Disassembly Listing for USB_Device_-_HID_-_Joystick
Generated From:
E:/Smart-Knob/pic16f1455_firmware/dist/LPCUSBDK_16F1455/production/pic16f1455_firmware.production.elf
Nov 2, 2022 2:00:01 AM

---  E:/Smart-Knob/pic16f1455_firmware/main.c  ----------------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #define _XTAL_FREQ 48000000
22:            #include "include/system.h"
23:            
24:            #include "include/usb/usb.h"
25:            #include "include/usb/usb_device_hid.h"
26:            
27:            #include "include/app_device_joystick.h"
28:            #include "include/app_led_usb_status.h"
29:            
30:            #include "include/spi.h"
31:            
32:            MAIN_RETURN main(void)
33:            {
34:                
35:                TRIS_MOSI_SDI_PIN = 1;TRIS_MISO_SDO_PIN = 0;
0903  0021     MOVLB 0x1
0904  148E     BSF TRISC, 0x1
0905  110E     BCF TRISC, 0x2
36:                //SYSTEM_Initialize(SYSTEM_STATE_USB_START);
37:                __delay_ms(200);
0906  300D     MOVLW 0xD
0907  0021     MOVLB 0x1
0908  00EF     MOVWF 0xEF
0909  302D     MOVLW 0x2D
090A  00EE     MOVWF 0xEE
090B  30D7     MOVLW 0xD7
090C  0B89     DECFSZ WREG, F
090D  290C     GOTO 0x10C
090E  0BEE     DECFSZ 0xEE, F
090F  290C     GOTO 0x10C
0910  0BEF     DECFSZ 0xEF, F
0911  290C     GOTO 0x10C
0912  3200     BRA 0x913
38:                
39:                SlaveinitSPI();
0913  3197     MOVLP 0x17
0914  274E     CALL 0x74E
0915  3189     MOVLP 0x9
40:                
41:                USBDeviceInit();
0916  3186     MOVLP 0x6
0917  26DB     CALL 0x6DB
0918  3189     MOVLP 0x9
42:                USBDeviceAttach();
43:            
44:                TRISCbits.TRISC4 = 0;
0919  0021     MOVLB 0x1
091A  120E     BCF TRISC, 0x4
45:                
46:                while(1)
47:                {
48:                    LATCbits.LATC4 = 0;
091B  0022     MOVLB 0x2
091C  120E     BCF LATC, 0x4
49:                    spiTask();
091D  3181     MOVLP 0x1
091E  21AB     CALL 0x1AB
091F  3189     MOVLP 0x9
50:                    LATCbits.LATC4 = 1;
0920  0022     MOVLB 0x2
0921  160E     BSF LATC, 0x4
51:                    SYSTEM_Tasks();
52:                    #if defined(USB_POLLING)
53:                        // Interrupt or polling method.  If using polling, must call
54:                        // this function periodically.  This function will take care
55:                        // of processing and responding to SETUP transactions
56:                        // (such as during the enumeration process when you first
57:                        // plug in).  USB hosts require that USB devices should accept
58:                        // and process SETUP packets in a timely fashion.  Therefore,
59:                        // when using polling, this function should be called
60:                        // regularly (such as once every 1.8ms or faster** [see
61:                        // inline code comments in usb_device.c for explanation when
62:                        // "or faster" applies])  In most cases, the USBDeviceTasks()
63:                        // function does not take very long to execute (ex: <100
64:                        // instruction cycles) before it returns.
65:                        USBDeviceTasks();
0922  3182     MOVLP 0x2
0923  22F2     CALL 0x2F2
0924  3189     MOVLP 0x9
66:                    #endif
67:            
68:                    // If the USB device isn't configured yet, we can't really do anything
69:                    // else since we don't have a host to talk to.  So jump back to the
70:                    // top of the while loop. 
71:                    if( USBGetDeviceState() < CONFIGURED_STATE )
0925  3020     MOVLW 0x20
0926  0021     MOVLB 0x1
0927  0254     SUBWF USBDeviceState, W
0928  1803     BTFSC STATUS, 0x0
0929  292B     GOTO 0x12B
092A  292C     GOTO 0x12C
092B  292D     GOTO 0x12D
092C  291B     GOTO 0x11B
72:                    {
73:                        // Jump back to the top of the while loop. 
74:                        continue;
75:                    }
76:            
77:                    // If we are currently suspended, then we need to see if we need to
78:                    // issue a remote wakeup.  In either case, we shouldn't process any
79:                    // keyboard commands since we aren't currently communicating to the host
80:                    // thus just continue back to the start of the while loop. 
81:                    if( USBIsDeviceSuspended() == true )
092D  003D     MOVLB 0x1D
092E  1C8E     BTFSS UCON, 0x1
092F  2931     GOTO 0x131
0930  2932     GOTO 0x132
0931  2933     GOTO 0x133
0932  291B     GOTO 0x11B
82:                    {
83:                        // Jump back to the top of the while loop. 
84:                        continue;
85:                    }
86:            
87:                    //Application specific tasks
88:                    APP_DeviceJoystickTasks();
0933  3185     MOVLP 0x5
0934  2538     CALL 0x538
0935  3189     MOVLP 0x9
0936  291B     GOTO 0x11B
0937  3180     MOVLP 0x0
89:                    
90:                    
91:                    //endfor
92:            
93:                }//end while
94:            }//end main
95:            
96:            /*******************************************************************************
97:             End of File
98:            */
99:            
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_events.c  --------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #include "include/system.h"
22:            
23:            #include "include/usb/usb.h"
24:            #include "include/usb/usb_device_hid.h"
25:            
26:            #include "include/app_device_joystick.h"
27:            #include "include/app_led_usb_status.h"
28:            
29:            /*******************************************************************
30:             * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
31:             *                        USB_EVENT event, void *pdata, uint16_t size)
32:             *
33:             * PreCondition:    None
34:             *
35:             * Input:           USB_EVENT event - the type of event
36:             *                  void *pdata - pointer to the event data
37:             *                  uint16_t size - size of the event data
38:             *
39:             * Output:          None
40:             *
41:             * Side Effects:    None
42:             *
43:             * Overview:        This function is called from the USB stack to
44:             *                  notify a user application that a USB event
45:             *                  occured.  This callback is in interrupt context
46:             *                  when the USB_INTERRUPT option is selected.
47:             *
48:             * Note:            None
49:             *******************************************************************/
50:            bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
51:            {
52:                switch( (int) event )
09B4  29D1     GOTO 0x1D1
53:                {
54:                    case EVENT_TRANSFER:
55:                        break;
56:            
57:                    case EVENT_SOF:
58:                        /* We are using the SOF as a timer to time the LED indicator.  Call
59:                         * the LED update function here. */
60:                        APP_LEDUpdateUSBStatus();
09B5  318A     MOVLP 0xA
09B6  22F5     CALL 0x2F5
09B7  3189     MOVLP 0x9
61:                        break;
09B8  29F9     GOTO 0x1F9
62:            
63:                    case EVENT_SUSPEND:
64:                        /* Update the LED status for the suspend event. */
65:                        APP_LEDUpdateUSBStatus();
09B9  318A     MOVLP 0xA
09BA  22F5     CALL 0x2F5
09BB  3189     MOVLP 0x9
66:            
67:                        //Call the hardware platform specific handler for suspend events for
68:                        //possible further action (like optionally going reconfiguring the application
69:                        //for lower power states and going to sleep during the suspend event).  This
70:                        //would normally be done in USB compliant bus powered applications, although
71:                        //no further processing is needed for purely self powered applications that
72:                        //don't consume power from the host.
73:                        SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND);
09BC  3001     MOVLW 0x1
09BD  3197     MOVLP 0x17
09BE  279C     CALL 0x79C
09BF  3189     MOVLP 0x9
74:                        break;
09C0  29F9     GOTO 0x1F9
75:            
76:                    case EVENT_RESUME:
77:                        /* Update the LED status for the resume event. */
78:                        APP_LEDUpdateUSBStatus();
09C1  318A     MOVLP 0xA
09C2  22F5     CALL 0x2F5
09C3  3189     MOVLP 0x9
79:            
80:                        //Call the hardware platform specific resume from suspend handler (ex: to
81:                        //restore I/O pins to higher power states if they were changed during the 
82:                        //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
83:                        //of the suspend condition.
84:                        SYSTEM_Initialize(SYSTEM_STATE_USB_RESUME);
09C4  3002     MOVLW 0x2
09C5  3197     MOVLP 0x17
09C6  279C     CALL 0x79C
09C7  3189     MOVLP 0x9
85:                        break;
09C8  29F9     GOTO 0x1F9
86:            
87:                    case EVENT_CONFIGURED:
88:                        /* When the device is configured, we can (re)initialize the demo
89:                         * code. */
90:                        APP_DeviceJoystickInitialize();
09C9  3188     MOVLP 0x8
09CA  2080     CALL 0x80
09CB  3189     MOVLP 0x9
91:                        break;
09CC  29F9     GOTO 0x1F9
92:            
93:                    case EVENT_SET_DESCRIPTOR:
94:                        break;
95:            
96:                    case EVENT_EP0_REQUEST:
97:                        /* We have received a non-standard USB request.  The HID driver
98:                         * needs to check to see if the request was for it. */
99:                        USBCheckHIDRequest();
09CD  3184     MOVLP 0x4
09CE  2421     CALL 0x421
09CF  3189     MOVLP 0x9
100:                       break;
09D0  29F9     GOTO 0x1F9
101:           
102:                   case EVENT_BUS_ERROR:
103:                       break;
104:           
105:                   case EVENT_TRANSFER_TERMINATED:
106:                       break;
107:           
108:                   default:
109:                       break;
110:               }
09D1  0021     MOVLB 0x1
09D2  085A     MOVF 0xDA, W
09D3  3A00     XORLW 0x0
09D4  1903     BTFSC STATUS, 0x2
09D5  29DA     GOTO 0x1DA
09D6  3A7F     XORLW 0x7F
09D7  1903     BTFSC STATUS, 0x2
09D8  29F4     GOTO 0x1F4
09D9  29F9     GOTO 0x1F9
09DA  0859     MOVF __pcstackBANK1, W
09DB  3A01     XORLW 0x1
09DC  1903     BTFSC STATUS, 0x2
09DD  29C9     GOTO 0x1C9
09DE  3A03     XORLW 0x3
09DF  1903     BTFSC STATUS, 0x2
09E0  29F9     GOTO 0x1F9
09E1  3A01     XORLW 0x1
09E2  1903     BTFSC STATUS, 0x2
09E3  29CD     GOTO 0x1CD
09E4  3A06     XORLW 0x6
09E5  1903     BTFSC STATUS, 0x2
09E6  29F9     GOTO 0x1F9
09E7  3A77     XORLW 0x77
09E8  1903     BTFSC STATUS, 0x2
09E9  29F9     GOTO 0x1F9
09EA  3A01     XORLW 0x1
09EB  1903     BTFSC STATUS, 0x2
09EC  29B5     GOTO 0x1B5
09ED  3A07     XORLW 0x7
09EE  1903     BTFSC STATUS, 0x2
09EF  29C1     GOTO 0x1C1
09F0  3A01     XORLW 0x1
09F1  1903     BTFSC STATUS, 0x2
09F2  29B9     GOTO 0x1B9
09F3  29F9     GOTO 0x1F9
09F4  0859     MOVF __pcstackBANK1, W
09F5  3AFF     XORLW 0xFF
09F6  1903     BTFSC STATUS, 0x2
09F7  29F9     GOTO 0x1F9
09F8  29F9     GOTO 0x1F9
111:               return true;
112:           }
09F9  0008     RETURN
113:           
114:           
115:           /*******************************************************************************
116:            End of File
117:           */
118:           
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device_hid.c  ----------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Human Interface Device (HID) Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device_hid.c
30:            
31:              Summary:
32:                USB Device Human Interface Device (HID) Layer interface API.
33:            
34:              Description:
35:                USB Device Human Interface Device (HID) Layer interface API.
36:            *******************************************************************************/
37:            
38:            
39:            // *****************************************************************************
40:            // *****************************************************************************
41:            // Section: Included Files
42:            // *****************************************************************************
43:            // *****************************************************************************
44:            #include "include/usb/usb_config.h"
45:            #include "include/usb/usb.h"
46:            #include "include/usb/usb_device_hid.h"
47:            
48:            #if defined(__XC8)
49:                #define PACKED
50:                #define ALIGNED
51:            #else
52:                #define PACKED __attribute__((packed))
53:                #define ALIGNED __attribute__((aligned))
54:            #endif
55:            
56:            // *****************************************************************************
57:            // *****************************************************************************
58:            // Section: File Scope or Global Constants
59:            // *****************************************************************************
60:            // *****************************************************************************
61:            
62:            // *****************************************************************************
63:            // *****************************************************************************
64:            // Section: File Scope Data Types
65:            // *****************************************************************************
66:            // *****************************************************************************
67:            typedef struct PACKED
68:            {
69:                unsigned :8;
70:                unsigned :8;
71:                uint8_t reportId;
72:                uint8_t duration;
73:            } USB_SETUP_SET_IDLE_RATE;
74:            
75:            typedef struct PACKED
76:            {
77:                unsigned :8;
78:                unsigned :8;
79:                uint8_t protocol;
80:            } USB_SETUP_SET_PROTOCOL;
81:            
82:            // *****************************************************************************
83:            // *****************************************************************************
84:            // Section: Variables
85:            // *****************************************************************************
86:            // *****************************************************************************
87:            static uint8_t idle_rate;
88:            static uint8_t active_protocol;   // [0] Boot Protocol [1] Report Protocol
89:            
90:            extern const struct{uint8_t report[HAPTIC_RPT_SIZE];}HAPTIC_rpt;
91:            extern const struct{uint8_t report[LED_RPT_SIZE];}LED_rpt;
92:            extern const struct{uint8_t report[DISPLAY_RPT_SIZE];}DISPLAY_rpt;
93:            
94:            // *****************************************************************************
95:            // *****************************************************************************
96:            // Section: Prototypes
97:            // *****************************************************************************
98:            // *****************************************************************************
99:            #if defined USER_GET_REPORT_HANDLER
100:               void USER_GET_REPORT_HANDLER(void);
101:           #endif
102:           
103:           #if defined USER_SET_REPORT_HANDLER
104:               extern void USER_SET_REPORT_HANDLER(void);
105:           #endif
106:           
107:           // *****************************************************************************
108:           // *****************************************************************************
109:           // Section: Macros or Functions
110:           // *****************************************************************************
111:           // *****************************************************************************
112:           
113:           //To implement a set idle rate callback function in the application,
114:           //Make sure "#define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportID, newIdleRate)    USBHIDCBSetIdleRateHandler(reportID, newIdleRate)"
115:           //is placed in your usb_config.h file, and then in your application .c file,
116:           //add the void USBHIDCBSetIdleRateHandler(reportID, newIdleRate) function
117:           //implementation that saves the new idle rate and report ID info, so that it
118:           //gets used later when sending subsequent HID input report packets to the host.
119:           #ifndef USB_DEVICE_HID_IDLE_RATE_CALLBACK
120:               #define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportId, idleRate)
121:           #else
122:               extern void USB_DEVICE_HID_IDLE_RATE_CALLBACK(uint8_t reportId, uint8_t idleRate);
123:           #endif
124:           
125:           /********************************************************************
126:           	Function:
127:           		void USBCheckHIDRequest(void)
128:           
129:            	Summary:
130:            		This routine handles HID specific request that happen on EP0.
131:                   This function should be called from the USBCBCheckOtherReq() call back
132:                   function whenever implementing a HID device.
133:           
134:            	Description:
135:            		This routine handles HID specific request that happen on EP0.  These
136:                   include, but are not limited to, requests for the HID report
137:                   descriptors.  This function should be called from the
138:                   USBCBCheckOtherReq() call back function whenever using an HID device.
139:           
140:                   Typical Usage:
141:                   <code>
142:                   void USBCBCheckOtherReq(void)
143:                   {
144:                       //Since the stack didn't handle the request I need to check
145:                       //  my class drivers to see if it is for them
146:                       USBCheckHIDRequest();
147:                   }
148:                   </code>
149:           
150:           	PreCondition:
151:           		None
152:           
153:           	Parameters:
154:           		None
155:           
156:           	Return Values:
157:           		None
158:           
159:           	Remarks:
160:           		None
161:           
162:            *******************************************************************/
163:           void USBCheckHIDRequest(void)
164:           {
165:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
0421  0020     MOVLB 0x0
0422  0860     MOVF SetupPkt, W
0423  391F     ANDLW 0x1F
0424  3A01     XORLW 0x1
0425  1903     BTFSC STATUS, 0x2
0426  2C28     GOTO 0x428
0427  2C29     GOTO 0x429
0428  2C2A     GOTO 0x42A
0429  2D37     GOTO 0x537
166:               if(SetupPkt.bIntfID != HID_INTF_HAP_ID && SetupPkt.bIntfID != HID_INTF_LED_ID && SetupPkt.bIntfID != HID_INTF_DSP_ID ) return;
042A  0864     MOVF 0x64, W
042B  1903     BTFSC STATUS, 0x2
042C  2C2E     GOTO 0x42E
042D  2C2F     GOTO 0x42F
042E  2C3B     GOTO 0x43B
042F  0364     DECF 0x64, W
0430  1903     BTFSC STATUS, 0x2
0431  2C33     GOTO 0x433
0432  2C34     GOTO 0x434
0433  2C3B     GOTO 0x43B
0434  3002     MOVLW 0x2
0435  0664     XORWF 0x64, W
0436  1903     BTFSC STATUS, 0x2
0437  2C39     GOTO 0x439
0438  2C3A     GOTO 0x43A
0439  2C3B     GOTO 0x43B
043A  2D37     GOTO 0x537
167:           
168:               /*
169:                * There are two standard requests that hid.c may support.
170:                * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
171:                * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
172:                */
173:               if(SetupPkt.bRequest == USB_REQUEST_GET_DESCRIPTOR)
043B  3006     MOVLW 0x6
043C  0661     XORWF 0x61, W
043D  1D03     BTFSS STATUS, 0x2
043E  2C40     GOTO 0x440
043F  2C41     GOTO 0x441
0440  2CDD     GOTO 0x4DD
0441  2CCA     GOTO 0x4CA
174:               {
175:                   switch(SetupPkt.bDescriptorType)
176:                   {
177:                       case DSC_HID: //HID Descriptor
178:                           if(USBActiveConfiguration == 1)
0442  0021     MOVLB 0x1
0443  0358     DECF USBActiveConfiguration, W
0444  1D03     BTFSS STATUS, 0x2
0445  2C47     GOTO 0x447
0446  2C48     GOTO 0x448
0447  2CDD     GOTO 0x4DD
179:                           {
180:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
0448  0020     MOVLB 0x0
0449  0864     MOVF 0x64, W
044A  0465     IORWF 0x65, W
044B  1D03     BTFSS STATUS, 0x2
044C  2C4E     GOTO 0x44E
044D  2C4F     GOTO 0x44F
044E  2C5C     GOTO 0x45C
181:                                   USBEP0SendROMPtr(
044F  3012     MOVLW 0x12
0450  0021     MOVLB 0x1
0451  00B8     MOVWF inPipes
0452  3090     MOVLW 0x90
0453  00B9     MOVWF 0xB9
0454  3009     MOVLW 0x9
0455  00BB     MOVWF 0xBB
0456  3000     MOVLW 0x0
0457  00BC     MOVWF 0xBC
0458  30C0     MOVLW 0xC0
0459  00F0     MOVWF 0xF0
045A  0870     MOVF 0xF0, W
045B  00BA     MOVWF 0xBA
182:                                       (const uint8_t*)&configDescriptor1 + 18,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
183:                                       sizeof(USB_HID_DSC)+3,
184:                                       USB_EP0_INCLUDE_ZERO);
185:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
045C  0020     MOVLB 0x0
045D  0364     DECF 0x64, W
045E  0465     IORWF 0x65, W
045F  1D03     BTFSS STATUS, 0x2
0460  2C62     GOTO 0x462
0461  2C63     GOTO 0x463
0462  2C70     GOTO 0x470
186:                                   USBEP0SendROMPtr(
0463  3032     MOVLW 0x32
0464  0021     MOVLB 0x1
0465  00B8     MOVWF inPipes
0466  3090     MOVLW 0x90
0467  00B9     MOVWF 0xB9
0468  3009     MOVLW 0x9
0469  00BB     MOVWF 0xBB
046A  3000     MOVLW 0x0
046B  00BC     MOVWF 0xBC
046C  30C0     MOVLW 0xC0
046D  00F0     MOVWF 0xF0
046E  0870     MOVF 0xF0, W
046F  00BA     MOVWF 0xBA
187:                                       (const uint8_t*)&configDescriptor1 + 50,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
188:                                       sizeof(USB_HID_DSC)+3,
189:                                       USB_EP0_INCLUDE_ZERO);
190:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
0470  3002     MOVLW 0x2
0471  0020     MOVLB 0x0
0472  0664     XORWF 0x64, W
0473  0465     IORWF 0x65, W
0474  1D03     BTFSS STATUS, 0x2
0475  2C77     GOTO 0x477
0476  2C78     GOTO 0x478
0477  2CDD     GOTO 0x4DD
191:                                   USBEP0SendROMPtr(
0478  3052     MOVLW 0x52
0479  0021     MOVLB 0x1
047A  00B8     MOVWF inPipes
047B  3090     MOVLW 0x90
047C  00B9     MOVWF 0xB9
047D  3009     MOVLW 0x9
047E  00BB     MOVWF 0xBB
047F  3000     MOVLW 0x0
0480  00BC     MOVWF 0xBC
0481  30C0     MOVLW 0xC0
0482  00F0     MOVWF 0xF0
0483  0870     MOVF 0xF0, W
0484  00BA     MOVWF 0xBA
0485  2CDD     GOTO 0x4DD
192:                                       (const uint8_t*)&configDescriptor1 + 82,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
193:                                       sizeof(USB_HID_DSC)+3,
194:                                       USB_EP0_INCLUDE_ZERO);
195:                           }
196:                           break;
197:                       case DSC_RPT:  //Report Descriptor
198:                           if(USBActiveConfiguration == 1)
0486  0021     MOVLB 0x1
0487  0358     DECF USBActiveConfiguration, W
0488  1D03     BTFSS STATUS, 0x2
0489  2C8B     GOTO 0x48B
048A  2C8C     GOTO 0x48C
048B  2CDD     GOTO 0x4DD
199:                           {
200:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
048C  0020     MOVLB 0x0
048D  0864     MOVF 0x64, W
048E  0465     IORWF 0x65, W
048F  1D03     BTFSS STATUS, 0x2
0490  2C92     GOTO 0x492
0491  2C93     GOTO 0x493
0492  2CA0     GOTO 0x4A0
201:                                   USBEP0SendROMPtr(
0493  3069     MOVLW 0x69
0494  0021     MOVLB 0x1
0495  00B8     MOVWF inPipes
0496  3090     MOVLW 0x90
0497  00B9     MOVWF 0xB9
0498  3057     MOVLW 0x57
0499  00BB     MOVWF 0xBB
049A  3000     MOVLW 0x0
049B  00BC     MOVWF 0xBC
049C  30C0     MOVLW 0xC0
049D  00F0     MOVWF 0xF0
049E  0870     MOVF 0xF0, W
049F  00BA     MOVWF 0xBA
202:                                       (const uint8_t*)&HAPTIC_rpt,
203:                                       HAPTIC_RPT_SIZE,     //See usbcfg.h
204:                                       USB_EP0_INCLUDE_ZERO);
205:                               
206:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
04A0  0020     MOVLB 0x0
04A1  0364     DECF 0x64, W
04A2  0465     IORWF 0x65, W
04A3  1D03     BTFSS STATUS, 0x2
04A4  2CA6     GOTO 0x4A6
04A5  2CA7     GOTO 0x4A7
04A6  2CB4     GOTO 0x4B4
207:                                   USBEP0SendROMPtr(
04A7  3000     MOVLW 0x0
04A8  0021     MOVLB 0x1
04A9  00B8     MOVWF inPipes
04AA  3098     MOVLW 0x98
04AB  00B9     MOVWF 0xB9
04AC  301C     MOVLW 0x1C
04AD  00BB     MOVWF 0xBB
04AE  3000     MOVLW 0x0
04AF  00BC     MOVWF 0xBC
04B0  30C0     MOVLW 0xC0
04B1  00F0     MOVWF 0xF0
04B2  0870     MOVF 0xF0, W
04B3  00BA     MOVWF 0xBA
208:                                       (const uint8_t*)&LED_rpt,
209:                                       LED_RPT_SIZE,     //See usbcfg.h
210:                                       USB_EP0_INCLUDE_ZERO);
211:                               
212:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
04B4  3002     MOVLW 0x2
04B5  0020     MOVLB 0x0
04B6  0664     XORWF 0x64, W
04B7  0465     IORWF 0x65, W
04B8  1D03     BTFSS STATUS, 0x2
04B9  2CBB     GOTO 0x4BB
04BA  2CBC     GOTO 0x4BC
04BB  2CDD     GOTO 0x4DD
213:                                   USBEP0SendROMPtr(
04BC  3038     MOVLW 0x38
04BD  0021     MOVLB 0x1
04BE  00B8     MOVWF inPipes
04BF  3098     MOVLW 0x98
04C0  00B9     MOVWF 0xB9
04C1  301C     MOVLW 0x1C
04C2  00BB     MOVWF 0xBB
04C3  3000     MOVLW 0x0
04C4  00BC     MOVWF 0xBC
04C5  30C0     MOVLW 0xC0
04C6  00F0     MOVWF 0xF0
04C7  0870     MOVF 0xF0, W
04C8  00BA     MOVWF 0xBA
04C9  2CDD     GOTO 0x4DD
214:                                       (const uint8_t*)&DISPLAY_rpt,
215:                                       LED_RPT_SIZE,     //See usbcfg.h
216:                                       USB_EP0_INCLUDE_ZERO);
217:                           }
218:                           break;
219:                       case DSC_PHY:  //Physical Descriptor
220:           				//Note: The below placeholder code is commented out.  HID Physical Descriptors are optional and are not used
221:           				//in many types of HID applications.  If an application does not have a physical descriptor,
222:           				//then the device should return STALL in response to this request (stack will do this automatically
223:           				//if no-one claims ownership of the control transfer).
224:           				//If an application does implement a physical descriptor, then make sure to declare
225:           				//hid_phy01 (rom structure containing the descriptor data), and hid_phy01 (the size of the descriptors in uint8_ts),
226:           				//and then uncomment the below code.
227:                           //if(USBActiveConfiguration == 1)
228:                           //{
229:                           //    USBEP0SendROMPtr((const uint8_t*)&hid_phy01, sizeof(hid_phy01), USB_EP0_INCLUDE_ZERO);
230:                           //}
231:                           break;
232:                   }//end switch(SetupPkt.bDescriptorType)
04CA  0863     MOVF i, W
04CB  00F0     MOVWF 0xF0
04CC  01F1     CLRF 0xF1
04CD  0871     MOVF 0xF1, W
04CE  3A00     XORLW 0x0
04CF  1903     BTFSC STATUS, 0x2
04D0  2CD2     GOTO 0x4D2
04D1  2CDD     GOTO 0x4DD
04D2  0870     MOVF 0xF0, W
04D3  3A21     XORLW 0x21
04D4  1903     BTFSC STATUS, 0x2
04D5  2C42     GOTO 0x442
04D6  3A03     XORLW 0x3
04D7  1903     BTFSC STATUS, 0x2
04D8  2C86     GOTO 0x486
04D9  3A01     XORLW 0x1
04DA  1903     BTFSC STATUS, 0x2
04DB  2CDD     GOTO 0x4DD
04DC  2CDD     GOTO 0x4DD
233:               }//end if(SetupPkt.bRequest == GET_DSC)
234:           
235:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD)
04DD  0020     MOVLB 0x0
04DE  0E60     SWAPF SetupPkt, W
04DF  0C89     RRF WREG, F
04E0  3903     ANDLW 0x3
04E1  3A01     XORLW 0x1
04E2  1903     BTFSC STATUS, 0x2
04E3  2CE5     GOTO 0x4E5
04E4  2CE6     GOTO 0x4E6
04E5  2D1B     GOTO 0x51B
04E6  2D37     GOTO 0x537
236:               {
237:                   return;
238:               }
239:           
240:               switch(SetupPkt.bRequest)
241:               {
242:                   case GET_REPORT:
243:                       #if defined USER_GET_REPORT_HANDLER
244:                           USER_GET_REPORT_HANDLER();
245:                       #endif
246:                       break;
247:                   case SET_REPORT:
248:                       #if defined USER_SET_REPORT_HANDLER
249:                           USER_SET_REPORT_HANDLER();
250:                       #endif
251:                       break;
252:                   case GET_IDLE:
253:                       USBEP0SendRAMPtr(
04E7  30D6     MOVLW 0xD6
04E8  0021     MOVLB 0x1
04E9  00B8     MOVWF inPipes
04EA  3000     MOVLW 0x0
04EB  00B9     MOVWF 0xB9
04EC  3001     MOVLW 0x1
04ED  00BB     MOVWF 0xBB
04EE  3000     MOVLW 0x0
04EF  00BC     MOVWF 0xBC
04F0  30C1     MOVLW 0xC1
04F1  00F0     MOVWF 0xF0
04F2  0870     MOVF 0xF0, W
04F3  00BA     MOVWF 0xBA
254:                           (uint8_t*)&idle_rate,
255:                           1,
256:                           USB_EP0_INCLUDE_ZERO);
257:                       break;
04F4  2D37     GOTO 0x537
258:                   case SET_IDLE:
259:                       USBEP0Transmit(USB_EP0_NO_DATA);
04F5  3080     MOVLW 0x80
04F6  00F0     MOVWF 0xF0
04F7  0870     MOVF 0xF0, W
04F8  0021     MOVLB 0x1
04F9  00BA     MOVWF 0xBA
260:                       idle_rate = SetupPkt.W_Value.byte.HB;
04FA  0020     MOVLB 0x0
04FB  0863     MOVF 0x63, W
04FC  00F0     MOVWF __pcstackCOMMON
04FD  0870     MOVF __pcstackCOMMON, W
04FE  0021     MOVLB 0x1
04FF  00D6     MOVWF idle_rate
261:                       USB_DEVICE_HID_IDLE_RATE_CALLBACK(SetupPkt.W_Value.byte.LB, idle_rate);
262:                       break;
0500  2D37     GOTO 0x537
263:                   case GET_PROTOCOL:
264:                       USBEP0SendRAMPtr(
0501  30D5     MOVLW 0xD5
0502  0021     MOVLB 0x1
0503  00B8     MOVWF inPipes
0504  3000     MOVLW 0x0
0505  00B9     MOVWF 0xB9
0506  3001     MOVLW 0x1
0507  00BB     MOVWF 0xBB
0508  3000     MOVLW 0x0
0509  00BC     MOVWF 0xBC
050A  3081     MOVLW 0x81
050B  00F0     MOVWF 0xF0
050C  0870     MOVF 0xF0, W
050D  00BA     MOVWF 0xBA
265:                           (uint8_t*)&active_protocol,
266:                           1,
267:                           USB_EP0_NO_OPTIONS);
268:                       break;
050E  2D37     GOTO 0x537
269:                   case SET_PROTOCOL:
270:                       USBEP0Transmit(USB_EP0_NO_DATA);
050F  3080     MOVLW 0x80
0510  00F0     MOVWF 0xF0
0511  0870     MOVF 0xF0, W
0512  0021     MOVLB 0x1
0513  00BA     MOVWF 0xBA
271:                       active_protocol = SetupPkt.W_Value.byte.LB;
0514  0020     MOVLB 0x0
0515  0862     MOVF 0x62, W
0516  00F0     MOVWF __pcstackCOMMON
0517  0870     MOVF __pcstackCOMMON, W
0518  0021     MOVLB 0x1
0519  00D5     MOVWF active_protocol
272:                       break;
051A  2D37     GOTO 0x537
273:               }//end switch(SetupPkt.bRequest)
051B  0861     MOVF pUEP, W
051C  00F0     MOVWF 0xF0
051D  01F1     CLRF 0xF1
051E  0871     MOVF 0xF1, W
051F  3A00     XORLW 0x0
0520  1903     BTFSC STATUS, 0x2
0521  2D23     GOTO 0x523
0522  2D37     GOTO 0x537
0523  0870     MOVF 0xF0, W
0524  3A01     XORLW 0x1
0525  1903     BTFSC STATUS, 0x2
0526  2D37     GOTO 0x537
0527  3A03     XORLW 0x3
0528  1903     BTFSC STATUS, 0x2
0529  2CE7     GOTO 0x4E7
052A  3A01     XORLW 0x1
052B  1903     BTFSC STATUS, 0x2
052C  2D01     GOTO 0x501
052D  3A0A     XORLW 0xA
052E  1903     BTFSC STATUS, 0x2
052F  2D37     GOTO 0x537
0530  3A03     XORLW 0x3
0531  1903     BTFSC STATUS, 0x2
0532  2CF5     GOTO 0x4F5
0533  3A01     XORLW 0x1
0534  1903     BTFSC STATUS, 0x2
0535  2D0F     GOTO 0x50F
0536  2D37     GOTO 0x537
274:           
275:           }//end USBCheckHIDRequest
0537  0008     RETURN
276:           
277:           /********************************************************************
278:               Function:
279:                   USB_HANDLE HIDTxPacket(uint8_t ep, uint8_t* data, uint16_t len)
280:           
281:               Summary:
282:                   Sends the specified data out the specified endpoint
283:           
284:               Description:
285:                   This function sends the specified data out the specified
286:                   endpoint and returns a handle to the transfer information.
287:           
288:                   Typical Usage:
289:                   <code>
290:                   //make sure that the last transfer isn't busy by checking the handle
291:                   if(!HIDTxHandleBusy(USBInHandle))
292:                   {
293:                       //Send the data contained in the ToSendDataBuffer[] array out on
294:                       //  endpoint HID_EP
295:                       USBInHandle = HIDTxPacket(HID_EP,(uint8_t*)&ToSendDataBuffer[0],sizeof(ToSendDataBuffer));
296:                   }
297:                   </code>
298:           
299:               PreCondition:
300:                   None
301:           
302:               Parameters:
303:                   uint8_t ep    - the endpoint you want to send the data out of
304:                   uint8_t* data - pointer to the data that you wish to send
305:                   uint16_t len   - the length of the data that you wish to send
306:           
307:               Return Values:
308:                   USB_HANDLE - a handle for the transfer.  This information
309:                   should be kept to track the status of the transfer
310:           
311:               Remarks:
312:                   None
313:           
314:            *******************************************************************/
315:            // Implemented as a macro. See usb_function_hid.h
316:           
317:           /********************************************************************
318:               Function:
319:                   USB_HANDLE HIDRxPacket(uint8_t ep, uint8_t* data, uint16_t len)
320:           
321:               Summary:
322:                   Receives the specified data out the specified endpoint
323:           
324:               Description:
325:                   Receives the specified data out the specified endpoint.
326:           
327:                   Typical Usage:
328:                   <code>
329:                   //Read 64-uint8_ts from endpoint HID_EP, into the ReceivedDataBuffer array.
330:                   //  Make sure to save the return handle so that we can check it later
331:                   //  to determine when the transfer is complete.
332:                   USBOutHandle = HIDRxPacket(HID_EP,(uint8_t*)&ReceivedDataBuffer,64);
333:                   </code>
334:           
335:               PreCondition:
336:                   None
337:           
338:               Parameters:
339:                   uint8_t ep    - the endpoint you want to receive the data into
340:                   uint8_t* data - pointer to where the data will go when it arrives
341:                   uint16_t len   - the length of the data that you wish to receive
342:           
343:               Return Values:
344:                   USB_HANDLE - a handle for the transfer.  This information
345:                   should be kept to track the status of the transfer
346:           
347:               Remarks:
348:                   None
349:           
350:            *******************************************************************/
351:             // Implemented as a macro. See usb_function_hid.h
352:           
353:           /*******************************************************************************
354:            End of File
355:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device.c  --------------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <xc.h>
46:            
47:            #include <stdint.h>
48:            #include <stddef.h>
49:            #include <string.h>
50:            
51:            #include "include/usb/usb_config.h"
52:            
53:            #include "include/usb/usb.h"
54:            #include "include/usb/usb_ch9.h"
55:            #include "include/usb/usb_device.h"
56:            #include "include/usb/usb_device_local.h"
57:            
58:            #ifndef uintptr_t
59:                #if  defined(__XC8__) || defined(__XC16__)
60:                    #define uintptr_t uint16_t
61:                #elif defined (__XC32__)
62:                    #define uintptr_t uint32_t
63:                #endif
64:            #endif
65:            
66:            #if defined(USB_USE_MSD)
67:                #include "usb_device_msd.h"
68:            #endif
69:            
70:            // *****************************************************************************
71:            // *****************************************************************************
72:            // Section: File Scope or Global Constants
73:            // *****************************************************************************
74:            // *****************************************************************************
75:            #if !defined(USE_USB_BUS_SENSE_IO)
76:                //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                //been properly defined elsewhere in the project.
79:                #undef USB_BUS_SENSE
80:                #define USB_BUS_SENSE 1
81:            #endif
82:            
83:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                #define _DTS_CHECKING_ENABLED 0
85:            #else
86:                #define _DTS_CHECKING_ENABLED _DTSEN
87:            #endif
88:            
89:            #if !defined(self_power)
90:                //Assume the application is always bus powered, unless self_power has been
91:                //defined elsewhere in the project
92:                #define self_power 0    //0 = bus powered
93:            #endif
94:            
95:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                //Assume the application only implements one configuration descriptor,
97:                //unless otherwise specified elsewhere in the project
98:                #define USB_MAX_NUM_CONFIG_DSC      1
99:            #endif
100:           
101:           #if defined(__XC8)
102:               //Suppress expected/harmless compiler warning message about unused RAM variables
103:               //and certain function pointer usage.
104:               //Certain variables and function pointers are not used if you don't use all
105:               //of the USB stack APIs.  However, these variables should not be
106:               //removed (since they are still used/needed in some applications, and this
107:               //is a common file shared by many projects, some of which rely on the "unused"
108:               //variables/function pointers).
109:               #pragma warning disable 1090
110:               #if __XC8_VERSION > 1300
111:                   #pragma warning disable 1471
112:               #endif
113:           #endif
114:           
115:           // *****************************************************************************
116:           // *****************************************************************************
117:           // Section: File Scope Data Types
118:           // *****************************************************************************
119:           // *****************************************************************************
120:           typedef union
121:           {
122:               uint8_t Val;
123:               struct __PACKED
124:               {
125:                   unsigned b0:1;
126:                   unsigned b1:1;
127:                   unsigned b2:1;
128:                   unsigned b3:1;
129:                   unsigned b4:1;
130:                   unsigned b5:1;
131:                   unsigned b6:1;
132:                   unsigned b7:1;
133:               } bits;
134:           } uint8_t_VAL, uint8_t_BITS;
135:           
136:           // *****************************************************************************
137:           // *****************************************************************************
138:           // Section: Variables
139:           // *****************************************************************************
140:           // *****************************************************************************
141:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:           USB_VOLATILE uint8_t USBActiveConfiguration;
143:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:           USB_VOLATILE uint8_t shortPacketStatus;
149:           USB_VOLATILE uint8_t controlTransferState;
150:           USB_VOLATILE IN_PIPE inPipes[1];
151:           USB_VOLATILE OUT_PIPE outPipes[1];
152:           USB_VOLATILE uint8_t *pDst;
153:           USB_VOLATILE bool RemoteWakeup;
154:           USB_VOLATILE bool USBBusIsSuspended;
155:           USB_VOLATILE USTAT_FIELDS USTATcopy;
156:           USB_VOLATILE uint8_t endpoint_number;
157:           USB_VOLATILE bool BothEP0OutUOWNsSet;
158:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:           volatile bool USBDeferStatusStagePacket;
162:           volatile bool USBStatusStageEnabledFlag1;
163:           volatile bool USBStatusStageEnabledFlag2;
164:           volatile bool USBDeferINDataStagePackets;
165:           volatile bool USBDeferOUTDataStagePackets;
166:           USB_VOLATILE uint32_t USB1msTickCount;
167:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:           
169:           /** USB FIXED LOCATION VARIABLES ***********************************/
170:           #if defined(COMPILER_MPLAB_C18)
171:               #pragma udata USB_BDT=USB_BDT_ADDRESS
172:           #endif
173:           
174:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:           
176:           /********************************************************************
177:            * EP0 Buffer Space
178:            *******************************************************************/
179:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:           
182:           /********************************************************************
183:            * non-EP0 Buffer Space
184:            *******************************************************************/
185:           #if defined(USB_USE_MSD)
186:               //Check if the MSD application specific USB endpoint buffer placement address
187:               //macros have already been defined or not (ex: in a processor specific header)
188:               //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:               //must be at a certain address range on certain microcontrollers).
190:               #if !defined(MSD_CBW_ADDR_TAG)
191:                   //Not previously defined.  Assume in this case all microcontroller RAM is
192:                   //USB module accessible, and therefore, no specific address tag value is needed.
193:                   #define MSD_CBW_ADDR_TAG
194:                   #define MSD_CSW_ADDR_TAG
195:               #endif
196:           	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:           	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:           
199:               #if defined(__18CXX) || defined(__XC8)
200:                   #if(__XC8_VERSION < 2000)
201:                   volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
202:                   #else
203:                       volatile char msd_buffer[512] __at(MSD_BUFFER_ADDRESS);
204:                   #endif
205:               #else
206:                   volatile char msd_buffer[512];
207:           	#endif
208:           #endif
209:           
210:           //Depricated in v2.2 - will be removed in a future revision
211:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
212:               //Device descriptor
213:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
214:           #else
215:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
216:           #endif
217:           
218:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
219:               //Array of configuration descriptors
220:               extern const uint8_t *const USB_CD_Ptr[];
221:           #else
222:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
223:           #endif
224:           
225:           extern const uint8_t *const USB_SD_Ptr[];
226:           
227:           
228:           // *****************************************************************************
229:           // *****************************************************************************
230:           // Section: Private and External Prototypes
231:           // *****************************************************************************
232:           // *****************************************************************************
233:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
234:           
235:           static void USBCtrlEPService(void);
236:           static void USBCtrlTrfSetupHandler(void);
237:           static void USBCtrlTrfInHandler(void);
238:           static void USBCheckStdRequest(void);
239:           static void USBStdGetDscHandler(void);
240:           static void USBCtrlEPServiceComplete(void);
241:           static void USBCtrlTrfTxService(void);
242:           static void USBCtrlTrfRxService(void);
243:           static void USBStdSetCfgHandler(void);
244:           static void USBStdGetStatusHandler(void);
245:           static void USBStdFeatureReqHandler(void);
246:           static void USBCtrlTrfOutHandler(void);
247:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
248:           static void USBWakeFromSuspend(void);
249:           static void USBSuspend(void);
250:           static void USBStallHandler(void);
251:           
252:           // *****************************************************************************
253:           // *****************************************************************************
254:           // Section: Macros or Functions
255:           // *****************************************************************************
256:           // *****************************************************************************
257:           
258:           /**************************************************************************
259:               Function:
260:                   void USBDeviceInit(void)
261:           
262:               Description:
263:                   This function initializes the device stack it in the default state. The
264:                   USB module will be completely reset including all of the internal
265:                   variables, registers, and interrupt flags.
266:           
267:               Precondition:
268:                   This function must be called before any of the other USB Device
269:                   functions can be called, including USBDeviceTasks().
270:           
271:               Parameters:
272:                   None
273:           
274:               Return Values:
275:                   None
276:           
277:               Remarks:
278:                   None
279:           
280:             ***************************************************************************/
281:           void USBDeviceInit(void)
282:           {
283:               uint8_t i;
284:           
285:               USBDisableInterrupts();
06DB  0021     MOVLB 0x1
06DC  1112     BCF PIE2, 0x2
286:           
287:               //Make sure that if a GPIO output driver exists on VBUS, that it is
288:               //tri-stated to avoid potential contention with the host
289:               USB_HAL_VBUSTristate();
290:           
291:               // Clear all USB error flags
292:               USBClearInterruptRegister(U1EIR);
06DD  003D     MOVLB 0x1D
06DE  0193     CLRF UEIR
293:           
294:               // Clears all USB interrupts
295:               USBClearInterruptRegister(U1IR);
06DF  0190     CLRF UIR
296:           
297:               //Clear all of the endpoint control registers
298:               U1EP0 = 0;
06E0  0198     CLRF UEP0
299:           
300:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
06E1  300E     MOVLW 0xE
06E2  00F2     MOVWF 0xEF2
06E3  3099     MOVLW 0x99
06E4  00F1     MOVWF 0xEF1
06E5  01F3     CLRF 0xEF3
06E6  0871     MOVF 0xEF1, W
06E7  0086     MOVWF FSR1L
06E8  0872     MOVF 0xEF2, W
06E9  0087     MOVWF FSR1H
06EA  0181     CLRF INDF1
06EB  3001     MOVLW 0x1
06EC  07F1     ADDWF 0xEF1, F
06ED  3000     MOVLW 0x0
06EE  3DF2     ADDWFC 0xEF2, F
06EF  3001     MOVLW 0x1
06F0  00F0     MOVWF 0xEF0
06F1  0870     MOVF 0xEF0, W
06F2  07F3     ADDWF 0xEF3, F
06F3  3003     MOVLW 0x3
06F4  0273     SUBWF 0xEF3, W
06F5  1C03     BTFSS STATUS, 0x0
06F6  2EF8     GOTO 0x6F8
06F7  2EF9     GOTO 0x6F9
06F8  2EE6     GOTO 0x6E6
301:           
302:               SetConfigurationOptions();
06F9  3016     MOVLW 0x16
06FA  003D     MOVLB 0x1D
06FB  0091     MOVWF UCFG
06FC  309F     MOVLW 0x9F
06FD  0097     MOVWF UEIE
06FE  307B     MOVLW 0x7B
06FF  0092     MOVWF UIE
303:           
304:               //power up the module (if not already powered)
305:               USBPowerModule();
306:           
307:               //set the address of the BDT (if applicable)
308:               USBSetBDTAddress(BDT);
309:           
310:               //Clear all of the BDT entries
311:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
0700  01F4     CLRF 0xEF4
312:               {
313:                   BDT[i].Val = 0x00;
0701  0874     MOVF 0xEF4, W
0702  00F0     MOVWF 0xEF0
0703  3001     MOVLW 0x1
0704  35F0     LSLF 0xEF0, F
0705  3EFF     ADDLW 0xFF
0706  1D03     BTFSS STATUS, 0x2
0707  2F04     GOTO 0x704
0708  3570     LSLF 0xEF0, W
0709  3E20     ADDLW 0x20
070A  0086     MOVWF FSR1L
070B  0187     CLRF FSR1H
070C  3000     MOVLW 0x0
070D  3FC0     MOVWI 0[FSR1]
070E  3000     MOVLW 0x0
070F  3FC1     MOVWI 1[FSR1]
0710  3FC2     MOVWI 2[FSR1]
0711  3FC3     MOVWI 3[FSR1]
314:               }
0712  3001     MOVLW 0x1
0713  00F0     MOVWF 0xEF0
0714  0870     MOVF 0xEF0, W
0715  07F4     ADDWF 0xEF4, F
0716  3010     MOVLW 0x10
0717  0274     SUBWF 0xEF4, W
0718  1C03     BTFSS STATUS, 0x0
0719  2F1B     GOTO 0x71B
071A  2F1C     GOTO 0x71C
071B  2F01     GOTO 0x701
315:           
316:               // Assert reset request to all of the Ping Pong buffer pointers
317:               USBPingPongBufferReset = 1;
071C  003D     MOVLB 0x1D
071D  170E     BSF UCON, 0x6
318:           
319:               // Reset to default address
320:               U1ADDR = 0x00;
071E  0196     CLRF UADDR
321:           
322:               // Make sure packet processing is enabled
323:               USBPacketDisable = 0;
071F  120E     BCF UCON, 0x4
324:           
325:               //Stop trying to reset ping pong buffer pointers
326:               USBPingPongBufferReset = 0;
0720  130E     BCF UCON, 0x6
327:           
328:               // Flush any pending transactions
329:               do
330:               {
331:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0721  30F7     MOVLW 0xF7
0722  00F0     MOVWF 0xEF0
0723  0870     MOVF 0xEF0, W
0724  0590     ANDWF UIR, F
332:                   //Initialize USB stack software state variables
333:                   inPipes[0].info.Val = 0;
0725  0021     MOVLB 0x1
0726  01BA     CLRF 0xBA
334:                   outPipes[0].info.Val = 0;
0727  0022     MOVLB 0x2
0728  01A2     CLRF 0x122
335:                   outPipes[0].wCount.Val = 0;
0729  01A3     CLRF 0x123
072A  01A4     CLRF 0x124
336:               }while(USBTransactionCompleteIF == 1);
072B  003D     MOVLB 0x1D
072C  1990     BTFSC UIR, 0x3
072D  2F2F     GOTO 0x72F
072E  2F30     GOTO 0x730
072F  2F21     GOTO 0x721
337:           
338:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
339:               //try and arm a status stage, even before the first control transfer starts.
340:               USBStatusStageEnabledFlag1 = true;
0730  3001     MOVLW 0x1
0731  00F0     MOVWF 0xEF0
0732  0870     MOVF 0xEF0, W
0733  0021     MOVLB 0x1
0734  00C9     MOVWF USBStatusStageEnabledFlag1
341:               USBStatusStageEnabledFlag2 = true;
0735  3001     MOVLW 0x1
0736  00F0     MOVWF 0xF0
0737  0870     MOVF 0xF0, W
0738  00C8     MOVWF USBStatusStageEnabledFlag2
342:               //Initialize other flags
343:               USBDeferINDataStagePackets = false;
0739  01C7     CLRF USBDeferINDataStagePackets
344:               USBDeferOUTDataStagePackets = false;
073A  01C6     CLRF USBDeferOUTDataStagePackets
345:               USBBusIsSuspended = false;
073B  01CE     CLRF USBBusIsSuspended
346:           
347:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
348:               //pointers to NULL, so they don't get used inadvertently.
349:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
073C  01F4     CLRF 0xF4
350:               {
351:                   pBDTEntryIn[i] = 0u;
073D  3574     LSLF 0xF4, W
073E  3EB0     ADDLW 0xB0
073F  0086     MOVWF FSR1L
0740  0187     CLRF FSR1H
0741  3000     MOVLW 0x0
0742  3FC0     MOVWI 0[FSR1]
0743  3FC1     MOVWI 1[FSR1]
352:                   pBDTEntryOut[i] = 0u;
0744  3574     LSLF 0xF4, W
0745  3EA0     ADDLW 0xA0
0746  0086     MOVWF FSR1L
0747  3001     MOVLW 0x1
0748  0087     MOVWF FSR1H
0749  3000     MOVLW 0x0
074A  3FC0     MOVWI 0[FSR1]
074B  3FC1     MOVWI 1[FSR1]
353:                   ep_data_in[i].Val = 0u;
074C  0874     MOVF 0xF4, W
074D  3EB0     ADDLW 0xB0
074E  0086     MOVWF FSR1L
074F  3001     MOVLW 0x1
0750  0087     MOVWF FSR1H
0751  0181     CLRF INDF1
354:                   ep_data_out[i].Val = 0u;
0752  0874     MOVF 0xF4, W
0753  3EAC     ADDLW 0xAC
0754  0086     MOVWF FSR1L
0755  3001     MOVLW 0x1
0756  0087     MOVWF FSR1H
0757  0181     CLRF INDF1
355:               }
0758  3001     MOVLW 0x1
0759  00F0     MOVWF 0xF0
075A  0870     MOVF 0xF0, W
075B  07F4     ADDWF 0xF4, F
075C  3004     MOVLW 0x4
075D  0274     SUBWF 0xF4, W
075E  1C03     BTFSS STATUS, 0x0
075F  2F61     GOTO 0x761
0760  2F62     GOTO 0x762
0761  2F3D     GOTO 0x73D
356:           
357:               //Get ready for the first packet
358:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0762  3028     MOVLW 0x28
0763  0021     MOVLB 0x1
0764  00B0     MOVWF pBDTEntryIn
0765  3000     MOVLW 0x0
0766  00B1     MOVWF 0xB1
359:               // Initialize EP0 as a Ctrl EP
360:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;
0767  3016     MOVLW 0x16
0768  003D     MOVLB 0x1D
0769  0098     MOVWF UEP0
361:           	//Prepare for the first SETUP on EP0 OUT
362:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
076A  3000     MOVLW 0x0
076B  0020     MOVLB 0x0
076C  00A3     MOVWF 0x23
076D  3060     MOVLW 0x60
076E  00A2     MOVWF 0x22
363:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
076F  3008     MOVLW 0x8
0770  00A1     MOVWF 0x21
364:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
0771  3004     MOVLW 0x4
0772  00F0     MOVWF __pcstackCOMMON
0773  0870     MOVF __pcstackCOMMON, W
0774  00A0     MOVWF BDT
365:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
0775  17A0     BSF BDT, 0x7
366:           
367:               // Clear active configuration
368:               USBActiveConfiguration = 0;
0776  0021     MOVLB 0x1
0777  01D8     CLRF USBActiveConfiguration
369:           
370:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
0778  3000     MOVLW 0x0
0779  0023     MOVLB 0x3
077A  00AB     MOVWF _spiTask
077B  3000     MOVLW 0x0
077C  00AA     MOVWF 0x1AA
077D  3000     MOVLW 0x0
077E  00A9     MOVWF 0x1A9
077F  3000     MOVLW 0x0
0780  00A8     MOVWF USB1msTickCount
371:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
0781  0021     MOVLB 0x1
0782  01C5     CLRF USBTicksSinceSuspendEnd
372:           
373:               //Indicate that we are now in the detached state
374:               USBDeviceState = DETACHED_STATE;
0783  01D4     CLRF USBDeviceState
375:           }
0784  0008     RETURN
376:           
377:           
378:           
379:           /**************************************************************************
380:             Function:
381:                   void USBDeviceTasks(void)
382:           
383:             Summary:
384:               This function is the main state machine/transaction handler of the USB
385:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
386:               (usb_config.h user option) the USBDeviceTasks() function should be called
387:               periodically to receive and transmit packets through the stack. This
388:               function also takes care of control transfers associated with the USB
389:               enumeration process, and detecting various USB events (such as suspend).
390:               This function should be called at least once every 1.8ms during the USB
391:               enumeration process. After the enumeration process is complete (which can
392:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
393:               USBDeviceTasks() handler may be called the faster of: either once
394:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
395:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
396:               a minimum rate of either the frequency that USBTransferOnePacket() gets
397:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
398:               near the top of usb_device.c for more details about minimum timing
399:               requirements when calling USBDeviceTasks().
400:           
401:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
402:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
403:               mode, the USBDeviceTasks() handler only needs to execute when a USB
404:               interrupt occurs, and therefore only needs to be called from the interrupt
405:               context.
406:           
407:             Description:
408:               This function is the main state machine/transaction handler of the USB
409:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
410:               (usb_config.h user option) the USBDeviceTasks() function should be called
411:               periodically to receive and transmit packets through the stack. This
412:               function also takes care of control transfers associated with the USB
413:               enumeration process, and detecting various USB events (such as suspend).
414:               This function should be called at least once every 1.8ms during the USB
415:               enumeration process. After the enumeration process is complete (which can
416:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
417:               USBDeviceTasks() handler may be called the faster of: either once
418:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
419:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
420:               a minimum rate of either the frequency that USBTransferOnePacket() gets
421:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
422:               near the top of usb_device.c for more details about minimum timing
423:               requirements when calling USBDeviceTasks().
424:           
425:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
426:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
427:               mode, the USBDeviceTasks() handler only needs to execute when a USB
428:               interrupt occurs, and therefore only needs to be called from the interrupt
429:               context.
430:           
431:               Typical usage:
432:               <code>
433:               void main(void)
434:               {
435:                   USBDeviceInit();
436:                   while(1)
437:                   {
438:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
439:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
440:                          (USBIsDeviceSuspended() == true))
441:                       {
442:                           //Either the device is not configured or we are suspended,
443:                           // so we don't want to execute any USB related application code
444:                           continue;   //go back to the top of the while loop
445:                       }
446:                       else
447:                       {
448:                           //Otherwise we are free to run USB and non-USB related user
449:                           //application code.
450:                           UserApplication();
451:                       }
452:                   }
453:               }
454:               </code>
455:           
456:             Precondition:
457:               Make sure the USBDeviceInit() function has been called prior to calling
458:               USBDeviceTasks() for the first time.
459:             Remarks:
460:               USBDeviceTasks() does not need to be called while in the USB suspend mode,
461:               if the user application firmware in the USBCBSuspend() callback function
462:               enables the ACTVIF USB interrupt source and put the microcontroller into
463:               sleep mode.  If the application firmware decides not to sleep the
464:               microcontroller core during USB suspend (ex: continues running at full
465:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
466:               function must still be called periodically, at a rate frequent enough to
467:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
468:               a worst case primary oscillator and PLL start up time of less than 5ms, then
469:               USBDeviceTasks() should be called once every 5ms in this scenario.
470:           
471:               When the USB cable is detached, or the USB host is not actively powering
472:               the VBUS line to +5V nominal, the application firmware does not always have
473:               to call USBDeviceTasks() frequently, as no USB activity will be taking
474:               place.  However, if USBDeviceTasks() is not called regularly, some
475:               alternative means of promptly detecting when VBUS is powered (indicating
476:               host attachment), or not powered (host powered down or USB cable unplugged)
477:               is still needed.  For self or dual self/bus powered USB applications, see
478:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional
479:               considerations.
480:               ***************************************************************************/
481:           void USBDeviceTasks(void)
482:           {
483:               uint8_t i;
484:           
485:               #ifdef USB_SUPPORT_OTG
486:                   //SRP Time Out Check
487:                   if (USBOTGSRPIsReady())
488:                   {
489:                       if (USBT1MSECIF && USBT1MSECIE)
490:                       {
491:                           if (USBOTGGetSRPTimeOutFlag())
492:                           {
493:                               if (USBOTGIsSRPTimeOutExpired())
494:                               {
495:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
496:                               }
497:                           }
498:           
499:                           //Clear Interrupt Flag
500:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
501:                       }
502:                   }
503:               #endif
504:           
505:               #if defined(USB_POLLING)
506:               //If the interrupt option is selected then the customer is required
507:               //  to notify the stack when the device is attached or removed from the
508:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
509:               if (USB_BUS_SENSE != 1)
510:               {
511:                    // Disable module & detach from bus
512:                    U1CON = 0;
513:           
514:                    // Mask all USB interrupts
515:                    U1IE = 0;
516:           
517:                    //Move to the detached state
518:                    USBDeviceState = DETACHED_STATE;
519:           
520:                    #ifdef  USB_SUPPORT_OTG
521:                        //Disable D+ Pullup
522:                        U1OTGCONbits.DPPULUP = 0;
523:           
524:                        //Disable HNP
525:                        USBOTGDisableHnp();
526:           
527:                        //Deactivate HNP
528:                        USBOTGDeactivateHnp();
529:           
530:                        //If ID Pin Changed State
531:                        if (USBIDIF && USBIDIE)
532:                        {
533:                            //Re-detect & Initialize
534:                             USBOTGInitialize();
535:           
536:                             //Clear ID Interrupt Flag
537:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
538:                        }
539:                    #endif
540:           
541:                    #if defined __C30__ || defined __XC16__
542:                        //USBClearInterruptFlag(U1OTGIR, 3);
543:                    #endif
544:                       //return so that we don't go through the rest of
545:                       //the state machine
546:                    USBClearUSBInterrupt();
547:                    return;
548:               }
549:           
550:           	#ifdef USB_SUPPORT_OTG
551:               //If Session Is Started Then
552:               else
553:           	{
554:                   //If SRP Is Ready
555:                   if (USBOTGSRPIsReady())
556:                   {
557:                       //Clear SRPReady
558:                       USBOTGClearSRPReady();
559:           
560:                       //Clear SRP Timeout Flag
561:                       USBOTGClearSRPTimeOutFlag();
562:           
563:                       //Indicate Session Started
564:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
565:                   }
566:               }
567:           	#endif	//#ifdef USB_SUPPORT_OTG
568:           
569:               //if we are in the detached state
570:               if(USBDeviceState == DETACHED_STATE)
02F2  0021     MOVLB 0x1
02F3  0854     MOVF USBDeviceState, W
02F4  1D03     BTFSS STATUS, 0x2
02F5  2AF7     GOTO 0x2F7
02F6  2AF8     GOTO 0x2F8
02F7  2B0A     GOTO 0x30A
571:               {
572:           	    //Initialize register to known value
573:                   U1CON = 0;
02F8  003D     MOVLB 0x1D
02F9  018E     CLRF UCON
574:           
575:                   // Mask all USB interrupts
576:                   U1IE = 0;
02FA  0192     CLRF UIE
577:           
578:                   //Enable/set things like: pull ups, full/low-speed mode,
579:                   //set the ping pong mode, and set internal transceiver
580:                   SetConfigurationOptions();
02FB  3016     MOVLW 0x16
02FC  0091     MOVWF UCFG
02FD  309F     MOVLW 0x9F
02FE  0097     MOVWF UEIE
02FF  307B     MOVLW 0x7B
0300  0092     MOVWF UIE
581:           
582:                   // Enable module & attach to bus
583:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
0301  2B03     GOTO 0x303
0302  158E     BSF UCON, 0x3
0303  1D8E     BTFSS UCON, 0x3
0304  2B06     GOTO 0x306
0305  2B07     GOTO 0x307
0306  2B02     GOTO 0x302
584:           
585:                   //moved to the attached state
586:                   USBDeviceState = ATTACHED_STATE;
0307  0021     MOVLB 0x1
0308  01D4     CLRF USBDeviceState
0309  0AD4     INCF USBDeviceState, F
587:           
588:                   #ifdef  USB_SUPPORT_OTG
589:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
590:                   #endif
591:               }
592:           	#endif  //#if defined(USB_POLLING)
593:           
594:               if(USBDeviceState == ATTACHED_STATE)
030A  0354     DECF USBDeviceState, W
030B  1D03     BTFSS STATUS, 0x2
030C  2B0E     GOTO 0x30E
030D  2B0F     GOTO 0x30F
030E  2B1D     GOTO 0x31D
595:               {
596:                   /*
597:                    * After enabling the USB module, it takes some time for the
598:                    * voltage on the D+ or D- line to rise high enough to get out
599:                    * of the SE0 condition. The USB Reset interrupt should not be
600:                    * unmasked until the SE0 condition is cleared. This helps
601:                    * prevent the firmware from misinterpreting this unique event
602:                    * as a USB bus reset from the USB host.
603:                    */
604:           
605:                   if(!USBSE0Event)
030F  003D     MOVLB 0x1D
0310  1A8E     BTFSC UCON, 0x5
0311  2B13     GOTO 0x313
0312  2B14     GOTO 0x314
0313  2B1D     GOTO 0x31D
606:                   {
607:                       //We recently attached, make sure we are in a clean state
608:                       #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
609:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
610:                                           //during attach de-bounce interval
611:                       #else
612:                           USBClearInterruptRegister(U1IR);
0314  0190     CLRF UIR
613:                       #endif
614:           
615:                       #if defined(USB_POLLING)
616:                           U1IE=0;                        // Mask all USB interrupts
0315  0192     CLRF UIE
617:                       #endif
618:                       USBResetIE = 1;             // Unmask RESET interrupt
0316  1412     BSF UIE, 0x0
619:                       USBIdleIE = 1;             // Unmask IDLE interrupt
0317  1612     BSF UIE, 0x4
620:                       USBDeviceState = POWERED_STATE;
0318  3002     MOVLW 0x2
0319  0021     MOVLB 0x1
031A  00EB     MOVWF 0xEB
031B  086B     MOVF 0xEB, W
031C  00D4     MOVWF USBDeviceState
621:                   }
622:               }
623:           
624:               #ifdef  USB_SUPPORT_OTG
625:                   //If ID Pin Changed State
626:                   if (USBIDIF && USBIDIE)
627:                   {
628:                       //Re-detect & Initialize
629:                       USBOTGInitialize();
630:           
631:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
632:                   }
633:               #endif
634:           
635:               /*
636:                * Task A: Service USB Activity Interrupt
637:                */
638:               if(USBActivityIF && USBActivityIE)
031D  003D     MOVLB 0x1D
031E  1D10     BTFSS UIR, 0x2
031F  2B21     GOTO 0x321
0320  2B22     GOTO 0x322
0321  2B2F     GOTO 0x32F
0322  1D12     BTFSS UIE, 0x2
0323  2B25     GOTO 0x325
0324  2B26     GOTO 0x326
0325  2B2F     GOTO 0x32F
639:               {
640:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0326  30FB     MOVLW 0xFB
0327  0021     MOVLB 0x1
0328  00EB     MOVWF 0xEB
0329  086B     MOVF 0xEB, W
032A  003D     MOVLB 0x1D
032B  0590     ANDWF UIR, F
641:                   #if defined(USB_SUPPORT_OTG)
642:                       U1OTGIR = 0x10;
643:                   #else
644:                       USBWakeFromSuspend();
032C  3197     MOVLP 0x17
032D  27BD     CALL 0x7BD
032E  3182     MOVLP 0x2
645:                   #endif
646:               }
647:           
648:               /*
649:                * Pointless to continue servicing if the device is in suspend mode.
650:                */
651:               if(USBSuspendControl==1)
032F  003D     MOVLB 0x1D
0330  1C8E     BTFSS UCON, 0x1
0331  2B33     GOTO 0x333
0332  2B34     GOTO 0x334
0333  2B37     GOTO 0x337
652:               {
653:                   USBClearUSBInterrupt();
0334  0020     MOVLB 0x0
0335  1112     BCF PIR2, 0x2
654:                   return;
0336  2C20     GOTO 0x420
655:               }
656:           
657:               /*
658:                * Task B: Service USB Bus Reset Interrupt.
659:                * When bus reset is received during suspend, ACTVIF will be set first,
660:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
661:                * This is why URSTIF is checked after ACTVIF.
662:                *
663:                * The USB reset flag is masked when the USB state is in
664:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
665:                * cause a USB reset event during these two states.
666:                */
667:               if(USBResetIF && USBResetIE)
0337  1C10     BTFSS start, 0x0
0338  2B3A     GOTO 0x33A
0339  2B3B     GOTO 0x33B
033A  2B4C     GOTO 0x34C
033B  1C12     BTFSS PIR2, 0x0
033C  2B3E     GOTO 0x33E
033D  2B3F     GOTO 0x33F
033E  2B4C     GOTO 0x34C
668:               {
669:                   USBDeviceInit();
033F  3186     MOVLP 0x6
0340  26DB     CALL 0x6DB
0341  3182     MOVLP 0x2
670:           
671:                   //Re-enable the interrupts since the USBDeviceInit() function will
672:                   //  disable them.  This will do nothing in a polling setup
673:                   USBUnmaskInterrupts();
674:           
675:                   USBDeviceState = DEFAULT_STATE;
0342  3004     MOVLW 0x4
0343  0021     MOVLB 0x1
0344  00EB     MOVWF 0xEB
0345  086B     MOVF 0xEB, W
0346  00D4     MOVWF USBDeviceState
676:           
677:                   #ifdef USB_SUPPORT_OTG
678:                        //Disable HNP
679:                        USBOTGDisableHnp();
680:           
681:                        //Deactivate HNP
682:                        USBOTGDeactivateHnp();
683:                   #endif
684:           
685:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
0347  30FE     MOVLW 0xFE
0348  00EB     MOVWF 0xEB
0349  086B     MOVF 0xEB, W
034A  003D     MOVLB 0x1D
034B  0590     ANDWF UIR, F
686:               }
687:           
688:               /*
689:                * Task C: Service other USB interrupts
690:                */
691:               if(USBIdleIF && USBIdleIE)
034C  1E10     BTFSS UIR, 0x4
034D  2B4F     GOTO 0x34F
034E  2B50     GOTO 0x350
034F  2B57     GOTO 0x357
0350  1E12     BTFSS UIE, 0x4
0351  2B53     GOTO 0x353
0352  2B54     GOTO 0x354
0353  2B57     GOTO 0x357
692:               {
693:                   #ifdef  USB_SUPPORT_OTG
694:                       //If Suspended, Try to switch to Host
695:                       USBOTGSelectRole(ROLE_HOST);
696:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
697:                   #else
698:                       USBSuspend();
0354  3197     MOVLP 0x17
0355  2763     CALL 0x763
0356  3182     MOVLP 0x2
699:                   #endif
700:               }
701:           
702:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
703:                   //Check if a 1ms interval has elapsed.
704:                   if(USBT1MSECIF)
705:                   {
706:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
707:                       USBIncrement1msInternalTimers();
708:                   }
709:               #endif
710:           
711:               //Start-of-Frame Interrupt
712:               if(USBSOFIF)
0357  003D     MOVLB 0x1D
0358  1F10     BTFSS UIR, 0x6
0359  2B5B     GOTO 0x35B
035A  2B5C     GOTO 0x35C
035B  2B89     GOTO 0x389
713:               {
714:                   //Call the user SOF event callback if enabled.
715:                   if(USBSOFIE)
035C  1F12     BTFSS UIE, 0x6
035D  2B5F     GOTO 0x35F
035E  2B60     GOTO 0x360
035F  2B70     GOTO 0x370
716:                   {
717:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
0360  3073     MOVLW 0x73
0361  0021     MOVLB 0x1
0362  00D9     MOVWF __pcstackBANK1
0363  3000     MOVLW 0x0
0364  00DA     MOVWF 0xDA
0365  3000     MOVLW 0x0
0366  00DB     MOVWF pdata
0367  3000     MOVLW 0x0
0368  00DC     MOVWF 0xDC
0369  3001     MOVLW 0x1
036A  00DD     MOVWF size
036B  3000     MOVLW 0x0
036C  00DE     MOVWF 0xDE
036D  3189     MOVLP 0x9
036E  21B4     CALL 0x1B4
036F  3182     MOVLP 0x2
718:                   }
719:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
0370  30BF     MOVLW 0xBF
0371  0021     MOVLB 0x1
0372  00EB     MOVWF 0xEB
0373  086B     MOVF 0xEB, W
0374  003D     MOVLB 0x1D
0375  0590     ANDWF UIR, F
720:           
721:                   #if defined(__XC8__) || defined(__C18__)
722:                       USBIncrement1msInternalTimers();
0376  3197     MOVLP 0x17
0377  277F     CALL 0x77F
0378  3182     MOVLP 0x2
723:                   #endif
724:           
725:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
726:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
727:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
728:                           #warning "Double click this message.  See inline code comments."
729:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
730:                           //not strictly needed in all applications (ex: those that never call
731:                           //USBDeferStatusStage() and don't use host to device (OUT) control
732:                           //transfers with data stage).
733:                           //However, if this feature is enabled and used in a low speed application,
734:                           //it is required for the application code to periodically call the
735:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
736:                       #endif
737:           
738:                       //Decrement our status stage counter.
739:                       if(USBStatusStageTimeoutCounter != 0u)
0379  0021     MOVLB 0x1
037A  084B     MOVF USBStatusStageTimeoutCounter, W
037B  1903     BTFSC STATUS, 0x2
037C  2B7E     GOTO 0x37E
037D  2B7F     GOTO 0x37F
037E  2B81     GOTO 0x381
740:                       {
741:                           USBStatusStageTimeoutCounter--;
037F  3001     MOVLW 0x1
0380  02CB     SUBWF USBStatusStageTimeoutCounter, F
742:                       }
743:                       //Check if too much time has elapsed since progress was made in
744:                       //processing the control transfer, without arming the status stage.
745:                       //If so, auto-arm the status stage to ensure that the control
746:                       //transfer can [eventually] complete, within the timing limits
747:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
748:                       if(USBStatusStageTimeoutCounter == 0)
0381  084B     MOVF USBStatusStageTimeoutCounter, W
0382  1D03     BTFSS STATUS, 0x2
0383  2B85     GOTO 0x385
0384  2B86     GOTO 0x386
0385  2B89     GOTO 0x389
749:                       {
750:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
0386  318B     MOVLP 0xB
0387  23C5     CALL 0x3C5
0388  3182     MOVLP 0x2
751:                       }
752:                   #endif
753:               }
754:           
755:               if(USBStallIF && USBStallIE)
0389  003D     MOVLB 0x1D
038A  1E90     BTFSS UIR, 0x5
038B  2B8D     GOTO 0x38D
038C  2B8E     GOTO 0x38E
038D  2B95     GOTO 0x395
038E  1E92     BTFSS UIE, 0x5
038F  2B91     GOTO 0x391
0390  2B92     GOTO 0x392
0391  2B95     GOTO 0x395
756:               {
757:                   USBStallHandler();
0392  3188     MOVLP 0x8
0393  20AA     CALL 0xAA
0394  3182     MOVLP 0x2
758:               }
759:           
760:               if(USBErrorIF && USBErrorIE)
0395  003D     MOVLB 0x1D
0396  1C90     BTFSS UIR, 0x1
0397  2B99     GOTO 0x399
0398  2B9A     GOTO 0x39A
0399  2BB0     GOTO 0x3B0
039A  1C92     BTFSS UIE, 0x1
039B  2B9D     GOTO 0x39D
039C  2B9E     GOTO 0x39E
039D  2BB0     GOTO 0x3B0
761:               {
762:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
039E  30FF     MOVLW 0xFF
039F  0021     MOVLB 0x1
03A0  00D9     MOVWF __pcstackBANK1
03A1  307F     MOVLW 0x7F
03A2  00DA     MOVWF 0xDA
03A3  3000     MOVLW 0x0
03A4  00DB     MOVWF pdata
03A5  3000     MOVLW 0x0
03A6  00DC     MOVWF 0xDC
03A7  3001     MOVLW 0x1
03A8  00DD     MOVWF size
03A9  3000     MOVLW 0x0
03AA  00DE     MOVWF 0xDE
03AB  3189     MOVLP 0x9
03AC  21B4     CALL 0x1B4
03AD  3182     MOVLP 0x2
763:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
03AE  003D     MOVLB 0x1D
03AF  0193     CLRF UEIR
764:           
765:                   //On PIC18, clearing the source of the error will automatically clear
766:                   //  the interrupt flag.  On other devices the interrupt flag must be
767:                   //  manually cleared.
768:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
769:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
770:                   #endif
771:               }
772:           
773:               /*
774:                * Pointless to continue servicing if the host has not sent a bus reset.
775:                * Once bus reset is received, the device transitions into the DEFAULT
776:                * state and is ready for communication.
777:                */
778:               if(USBDeviceState < DEFAULT_STATE)
03B0  3004     MOVLW 0x4
03B1  0021     MOVLB 0x1
03B2  0254     SUBWF USBDeviceState, W
03B3  1803     BTFSC STATUS, 0x0
03B4  2BB6     GOTO 0x3B6
03B5  2BB7     GOTO 0x3B7
03B6  2BBA     GOTO 0x3BA
779:               {
780:                   USBClearUSBInterrupt();
03B7  0020     MOVLB 0x0
03B8  1112     BCF PIR2, 0x2
781:                   return;
03B9  2C20     GOTO 0x420
782:               }
783:           
784:               /*
785:                * Task D: Servicing USB Transaction Complete Interrupt
786:                */
787:               if(USBTransactionCompleteIE)
03BA  003D     MOVLB 0x1D
03BB  1D92     BTFSS UIE, 0x3
03BC  2BBE     GOTO 0x3BE
03BD  2BBF     GOTO 0x3BF
03BE  2C1E     GOTO 0x41E
788:               {
789:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
03BF  0021     MOVLB 0x1
03C0  01ED     CLRF i
790:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
791:                       if(USBTransactionCompleteIF)
03C1  003D     MOVLB 0x1D
03C2  1D90     BTFSS UIR, 0x3
03C3  2BC5     GOTO 0x3C5
03C4  2BC6     GOTO 0x3C6
03C5  2C1E     GOTO 0x41E
792:                       {
793:                           //Save and extract USTAT register info.  Will use this info later.
794:                           USTATcopy.Val = U1STAT;
03C6  080F     MOVF USTAT, W
03C7  0021     MOVLB 0x1
03C8  00EB     MOVWF 0xEB
03C9  086B     MOVF 0xEB, W
03CA  00D7     MOVWF USTATcopy
795:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
03CB  0C57     RRF USTATcopy, W
03CC  00EB     MOVWF 0xEB
03CD  0CEB     RRF 0xEB, F
03CE  0C6B     RRF 0xEB, W
03CF  390F     ANDLW 0xF
03D0  00EC     MOVWF 0xEC
03D1  086C     MOVF 0xEC, W
03D2  00CD     MOVWF endpoint_number
796:           
797:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
03D3  30F7     MOVLW 0xF7
03D4  00EB     MOVWF 0xEB
03D5  086B     MOVF 0xEB, W
03D6  003D     MOVLB 0x1D
03D7  0590     ANDWF UIR, F
798:           
799:                           //Keep track of the hardware ping pong state for endpoints other
800:                           //than EP0, if ping pong buffering is enabled.
801:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
802:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
03D8  0021     MOVLB 0x1
03D9  1957     BTFSC USTATcopy, 0x2
03DA  2BDC     GOTO 0x3DC
03DB  2BDD     GOTO 0x3DD
03DC  2BED     GOTO 0x3ED
803:                           {
804:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
03DD  084D     MOVF endpoint_number, W
03DE  3EAC     ADDLW 0xAC
03DF  0086     MOVWF FSR1L
03E0  3001     MOVLW 0x1
03E1  0087     MOVWF FSR1H
03E2  0801     MOVF INDF1, W
03E3  3901     ANDLW 0x1
03E4  00EB     MOVWF 0xEB
03E5  3001     MOVLW 0x1
03E6  06EB     XORWF 0xEB, F
03E7  0801     MOVF INDF1, W
03E8  066B     XORWF 0xEB, W
03E9  39FE     ANDLW 0xFE
03EA  066B     XORWF 0xEB, W
03EB  0081     MOVWF INDF1
805:                           }
03EC  2BFC     GOTO 0x3FC
806:                           else
807:                           {
808:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
03ED  084D     MOVF endpoint_number, W
03EE  3EB0     ADDLW 0xB0
03EF  0086     MOVWF FSR1L
03F0  3001     MOVLW 0x1
03F1  0087     MOVWF FSR1H
03F2  0801     MOVF INDF1, W
03F3  3901     ANDLW 0x1
03F4  00EB     MOVWF 0xEB
03F5  3001     MOVLW 0x1
03F6  06EB     XORWF 0xEB, F
03F7  0801     MOVF INDF1, W
03F8  066B     XORWF 0xEB, W
03F9  39FE     ANDLW 0xFE
03FA  066B     XORWF 0xEB, W
03FB  0081     MOVWF INDF1
809:                           }
810:                           #endif
811:           
812:                           //USBCtrlEPService only services transactions over EP0.
813:                           //It ignores all other EP transactions.
814:                           if(endpoint_number == 0)
03FC  084D     MOVF endpoint_number, W
03FD  1D03     BTFSS STATUS, 0x2
03FE  2C00     GOTO 0x400
03FF  2C01     GOTO 0x401
0400  2C05     GOTO 0x405
815:                           {
816:                               USBCtrlEPService();
0401  318A     MOVLP 0xA
0402  2242     CALL 0x242
0403  3182     MOVLP 0x2
817:                           }
0404  2C13     GOTO 0x413
818:                           else
819:                           {
820:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
0405  3072     MOVLW 0x72
0406  00D9     MOVWF __pcstackBANK1
0407  3000     MOVLW 0x0
0408  00DA     MOVWF 0xDA
0409  30D7     MOVLW 0xD7
040A  00DB     MOVWF pdata
040B  3000     MOVLW 0x0
040C  00DC     MOVWF 0xDC
040D  3000     MOVLW 0x0
040E  00DD     MOVWF size
040F  00DE     MOVWF 0xDE
0410  3189     MOVLP 0x9
0411  21B4     CALL 0x1B4
0412  3182     MOVLP 0x2
821:                           }
822:                       }//end if(USBTransactionCompleteIF)
823:                       else
824:                       {
825:                           break;	//USTAT FIFO must be empty.
826:                       }
827:                   }//end for()
0413  3001     MOVLW 0x1
0414  0021     MOVLB 0x1
0415  00EB     MOVWF 0xEB
0416  086B     MOVF 0xEB, W
0417  07ED     ADDWF i, F
0418  3004     MOVLW 0x4
0419  026D     SUBWF i, W
041A  1C03     BTFSS STATUS, 0x0
041B  2C1D     GOTO 0x41D
041C  2C1E     GOTO 0x41E
041D  2BC1     GOTO 0x3C1
828:               }//end if(USBTransactionCompleteIE)
829:           
830:               USBClearUSBInterrupt();
041E  0020     MOVLB 0x0
041F  1112     BCF PIR2, 0x2
831:           }//end of USBDeviceTasks()
0420  0008     RETURN
832:           
833:           /*******************************************************************************
834:             Function:
835:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
836:           
837:             Summary:
838:               This function will enable the specified endpoint with the specified
839:               options
840:             Description:
841:               This function will enable the specified endpoint with the specified
842:               options.
843:           
844:               Typical Usage:
845:               <code>
846:               void USBCBInitEP(void)
847:               {
848:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
849:                   USBMSDInit();
850:               }
851:               </code>
852:           
853:               In the above example endpoint number MSD_DATA_IN_EP is being configured
854:               for both IN and OUT traffic with handshaking enabled. Also since
855:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
856:               explicitly disable SETUP packets on this endpoint.
857:             Conditions:
858:               None
859:             Input:
860:               uint8_t ep -       the endpoint to be configured
861:               uint8_t options -  optional settings for the endpoint. The options should
862:                               be ORed together to form a single options string. The
863:                               available optional settings for the endpoint. The
864:                               options should be ORed together to form a single options
865:                               string. The available options are the following\:
866:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
867:                                 NAK)
868:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
869:                                 NAK)
870:                               * USB_OUT_ENABLED enables the out direction
871:                               * USB_OUT_DISABLED disables the out direction
872:                               * USB_IN_ENABLED enables the in direction
873:                               * USB_IN_DISABLED disables the in direction
874:                               * USB_ALLOW_SETUP enables control transfers
875:                               * USB_DISALLOW_SETUP disables control transfers
876:                               * USB_STALL_ENDPOINT STALLs this endpoint
877:             Return:
878:               None
879:             Remarks:
880:               None
881:             *****************************************************************************/
882:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
085B  00FC     MOVWF s
883:           {
884:               unsigned char* p;
885:           
886:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and
887:               //starting DTS state in the BDT entry.
888:               if(options & USB_OUT_ENABLED)
085C  1D77     BTFSS tmp, 0x2
085D  285F     GOTO 0x5F
085E  2860     GOTO 0x60
085F  2865     GOTO 0x65
889:               {
890:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
0860  01F0     CLRF __pcstackCOMMON
0861  087C     MOVF s, W
0862  3189     MOVLP 0x9
0863  2171     CALL 0x171
0864  3188     MOVLP 0x8
891:               }
892:               if(options & USB_IN_ENABLED)
0865  1CF7     BTFSS tmp, 0x1
0866  2868     GOTO 0x68
0867  2869     GOTO 0x69
0868  286F     GOTO 0x6F
893:               {
894:                   USBConfigureEndpoint(ep, IN_TO_HOST);
0869  01F0     CLRF __pcstackCOMMON
086A  0AF0     INCF __pcstackCOMMON, F
086B  087C     MOVF s, W
086C  3189     MOVLP 0x9
086D  2171     CALL 0x171
086E  3188     MOVLP 0x8
895:               }
896:           
897:               //Update the relevant UEPx register to actually enable the endpoint with
898:               //the specified options (ex: handshaking enabled, control transfers allowed,
899:               //etc.)
900:               #if defined(__C32__)
901:                   p = (unsigned char*)(&U1EP0+(4*ep));
902:               #else
903:                   p = (unsigned char*)(&U1EP0+ep);
086F  087C     MOVF s, W
0870  3E98     ADDLW 0x98
0871  00F8     MOVWF d1
0872  01F9     CLRF d
0873  300E     MOVLW 0xE
0874  3DF9     ADDWFC d, F
0875  0878     MOVF d1, W
0876  00FA     MOVWF k
0877  0879     MOVF d, W
0878  00FB     MOVWF 0x7B
904:               #endif
905:               *p = options;
0879  087A     MOVF k, W
087A  0086     MOVWF FSR1
087B  087B     MOVF 0x7B, W
087C  0087     MOVWF FSR1H
087D  0877     MOVF tmp, W
087E  0081     MOVWF INDF1
906:           }
087F  0008     RETURN
907:           
908:           
909:           /*************************************************************************
910:             Function:
911:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
912:           
913:             Summary:
914:               Transfers a single packet (one transaction) of data on the USB bus.
915:           
916:             Description:
917:               The USBTransferOnePacket() function prepares a USB endpoint
918:               so that it may send data to the host (an IN transaction), or
919:               receive data from the host (an OUT transaction).  The
920:               USBTransferOnePacket() function can be used both to receive	and
921:               send data to the host.  This function is the primary API function
922:               provided by the USB stack firmware for sending or receiving application
923:               data over the USB port.
924:           
925:               The USBTransferOnePacket() is intended for use with all application
926:               endpoints.  It is not used for sending or receiving application data
927:               through endpoint 0 by using control transfers.  Separate API
928:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
929:               USBEP0SendROMPtr() are provided for this purpose.
930:           
931:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
932:               entry associated with an endpoint buffer, and sets the UOWN bit, which
933:               prepares the USB hardware to allow the transaction to complete.  The
934:               application firmware can use the USBHandleBusy() macro to check the
935:               status of the transaction, to see if the data has been successfully
936:               transmitted yet.
937:           
938:           
939:               Typical Usage
940:               <code>
941:               //make sure that the we are in the configured state
942:               if(USBGetDeviceState() == CONFIGURED_STATE)
943:               {
944:                   //make sure that the last transaction isn't busy by checking the handle
945:                   if(!USBHandleBusy(USBInHandle))
946:                   {
947:           	        //Write the new data that we wish to send to the host to the INPacket[] array
948:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
949:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
950:           	        //INPacket[2] = ... (fill in the rest of the packet data)
951:           
952:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
953:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
954:                   }
955:               }
956:               </code>
957:           
958:             Conditions:
959:               Before calling USBTransferOnePacket(), the following should be true.
960:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
961:               2.  A transaction is not already pending on the specified endpoint.  This
962:                   is done by checking the previous request using the USBHandleBusy()
963:                   macro (see the typical usage example).
964:               3.  The host has already sent a set configuration request and the
965:                   enumeration process is complete.
966:                   This can be checked by verifying that the USBGetDeviceState()
967:                   macro returns "CONFIGURED_STATE", prior to calling
968:                   USBTransferOnePacket().
969:           
970:             Input:
971:               uint8_t ep - The endpoint number that the data will be transmitted or
972:           	          received on
973:               uint8_t dir - The direction of the transfer
974:                          This value is either OUT_FROM_HOST or IN_TO_HOST
975:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
976:                            the data to be sent to the host.  For OUT transactions: pointer
977:                            to the RAM buffer that the received data should get written to.
978:              uint8_t len - Length of the data needing to be sent (for IN transactions).
979:                         For OUT transactions, the len parameter should normally be set
980:                         to the endpoint size specified in the endpoint descriptor.
981:           
982:             Return Values:
983:               USB_HANDLE - handle to the transfer.  The handle is a pointer to
984:                            the BDT entry associated with this transaction.  The
985:                            status of the transaction (ex: if it is complete or still
986:                            pending) can be checked using the USBHandleBusy() macro
987:                            and supplying the USB_HANDLE provided by
988:                            USBTransferOnePacket().
989:           
990:             Remarks:
991:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
992:               callback function, the set configuration is still being processed and the
993:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case,
994:               the USBTransferOnePacket() may still be called, but make sure that the
995:               endpoint has been enabled and initialized by the USBEnableEndpoint()
996:               function first.
997:           
998:             *************************************************************************/
999:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
0E33  00F8     MOVWF d1
1000:          {
1001:              volatile BDT_ENTRY* handle;
1002:          
1003:              //If the direction is IN
1004:              if(dir != 0)
0E34  0870     MOVF __pcstackCOMMON, W
0E35  1903     BTFSC STATUS, 0x2
0E36  2E38     GOTO 0x638
0E37  2E39     GOTO 0x639
0E38  2E42     GOTO 0x642
1005:              {
1006:                  //point to the IN BDT of the specified endpoint
1007:                  handle = pBDTEntryIn[ep];
0E39  3578     LSLF d1, W
0E3A  3EB0     ADDLW 0xB0
0E3B  0086     MOVWF FSR1
0E3C  0187     CLRF FSR1H
0E3D  3F40     MOVIW 0[FSR1]
0E3E  00F9     MOVWF d
0E3F  3F41     MOVIW 1[FSR1]
0E40  00FA     MOVWF k
1008:              }
0E41  2E4B     GOTO 0x64B
1009:              else
1010:              {
1011:                  //else point to the OUT BDT of the specified endpoint
1012:                  handle = pBDTEntryOut[ep];
0E42  3578     LSLF d1, W
0E43  3EA0     ADDLW 0xA0
0E44  0086     MOVWF FSR1
0E45  3001     MOVLW 0x1
0E46  0087     MOVWF FSR1H
0E47  3F40     MOVIW 0[FSR1]
0E48  00F9     MOVWF d
0E49  3F41     MOVIW 1[FSR1]
0E4A  00FA     MOVWF k
1013:              }
1014:          
1015:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1016:              //pBDTEntryOut[ep]) is initialized before using it.
1017:              if(handle == 0)
0E4B  0879     MOVF d, W
0E4C  047A     IORWF k, W
0E4D  1D03     BTFSS STATUS, 0x2
0E4E  2E50     GOTO 0x650
0E4F  2E51     GOTO 0x651
0E50  2E54     GOTO 0x654
1018:              {
1019:                  return 0;
0E51  01F0     CLRF __pcstackCOMMON
0E52  01F1     CLRF p
0E53  2EB9     GOTO 0x6B9
1020:              }
1021:          
1022:              //Toggle the DTS bit if required
1023:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1024:                  handle->STAT.Val ^= _DTSMASK;
1025:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1026:                  if(ep != 0)
1027:                  {
1028:                      handle->STAT.Val ^= _DTSMASK;
1029:                  }
1030:              #endif
1031:          
1032:              //Set the data pointer, data length, and enable the endpoint
1033:              handle->ADR = ConvertToPhysicalAddress(data);
0E54  30FF     MOVLW 0xFF
0E55  0571     ANDWF p, W
0E56  00F4     MOVWF n
0E57  307F     MOVLW 0x7F
0E58  0572     ANDWF led, W
0E59  00F5     MOVWF state
0E5A  0879     MOVF d, W
0E5B  0086     MOVWF FSR1
0E5C  087A     MOVF k, W
0E5D  0087     MOVWF FSR1H
0E5E  3142     ADDFSR 1, 2
0E5F  0874     MOVF n, W
0E60  3FC0     MOVWI 0[FSR1]
0E61  0875     MOVF state, W
0E62  3FC1     MOVWI 1[FSR1]
1034:              handle->CNT = len;
0E63  0879     MOVF d, W
0E64  3E01     ADDLW 0x1
0E65  00F4     MOVWF n
0E66  3000     MOVLW 0x0
0E67  3D7A     ADDWFC k, W
0E68  00F5     MOVWF state
0E69  0874     MOVF n, W
0E6A  0086     MOVWF FSR1
0E6B  0875     MOVF state, W
0E6C  0087     MOVWF FSR1H
0E6D  0873     MOVF i, W
0E6E  0081     MOVWF INDF1
1035:              handle->STAT.Val &= _DTSMASK;
0E6F  3040     MOVLW 0x40
0E70  00F4     MOVWF n
0E71  0879     MOVF d, W
0E72  0086     MOVWF FSR1
0E73  087A     MOVF k, W
0E74  0087     MOVWF FSR1H
0E75  0874     MOVF n, W
0E76  0581     ANDWF INDF1, F
1036:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
0E77  0879     MOVF d, W
0E78  0086     MOVWF FSR1
0E79  087A     MOVF k, W
0E7A  0087     MOVWF FSR1H
0E7B  1581     BSF INDF1, 0x3
1037:              handle->STAT.Val |= _USIE;
0E7C  0879     MOVF d, W
0E7D  0086     MOVWF FSR1
0E7E  087A     MOVF k, W
0E7F  0087     MOVWF FSR1H
0E80  1781     BSF INDF1, 0x7
1038:          
1039:              //Point to the next buffer for ping pong purposes.
1040:              if(dir != OUT_FROM_HOST)
0E81  0870     MOVF __pcstackCOMMON, W
0E82  1903     BTFSC STATUS, 0x2
0E83  2E85     GOTO 0x685
0E84  2E86     GOTO 0x686
0E85  2E9D     GOTO 0x69D
1041:              {
1042:                  //toggle over the to the next buffer for an IN endpoint
1043:                  pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
0E86  3578     LSLF d1, W
0E87  3EB0     ADDLW 0xB0
0E88  0086     MOVWF FSR1
0E89  0187     CLRF FSR1H
0E8A  3F40     MOVIW 0[FSR1]
0E8B  00F4     MOVWF n
0E8C  3F41     MOVIW 1[FSR1]
0E8D  00F5     MOVWF state
0E8E  3004     MOVLW 0x4
0E8F  0674     XORWF n, W
0E90  00F6     MOVWF handle
0E91  3000     MOVLW 0x0
0E92  0675     XORWF state, W
0E93  00F7     MOVWF tmp
0E94  3578     LSLF d1, W
0E95  3EB0     ADDLW 0xB0
0E96  0086     MOVWF FSR1
0E97  0187     CLRF FSR1H
0E98  0876     MOVF handle, W
0E99  3FC0     MOVWI 0[FSR1]
0E9A  0877     MOVF tmp, W
0E9B  3FC1     MOVWI 1[FSR1]
1044:              }
0E9C  2EB5     GOTO 0x6B5
1045:              else
1046:              {
1047:                  //toggle over the to the next buffer for an OUT endpoint
1048:                  pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
0E9D  3578     LSLF d1, W
0E9E  3EA0     ADDLW 0xA0
0E9F  0086     MOVWF FSR1
0EA0  3001     MOVLW 0x1
0EA1  0087     MOVWF FSR1H
0EA2  3F40     MOVIW 0[FSR1]
0EA3  00F4     MOVWF n
0EA4  3F41     MOVIW 1[FSR1]
0EA5  00F5     MOVWF state
0EA6  3004     MOVLW 0x4
0EA7  0674     XORWF n, W
0EA8  00F6     MOVWF handle
0EA9  3000     MOVLW 0x0
0EAA  0675     XORWF state, W
0EAB  00F7     MOVWF tmp
0EAC  3578     LSLF d1, W
0EAD  3EA0     ADDLW 0xA0
0EAE  0086     MOVWF FSR1
0EAF  3001     MOVLW 0x1
0EB0  0087     MOVWF FSR1H
0EB1  0876     MOVF handle, W
0EB2  3FC0     MOVWI 0[FSR1]
0EB3  0877     MOVF tmp, W
0EB4  3FC1     MOVWI 1[FSR1]
1049:              }
1050:              return (USB_HANDLE)handle;
0EB5  087A     MOVF k, W
0EB6  00F1     MOVWF p
0EB7  0879     MOVF d, W
0EB8  00F0     MOVWF __pcstackCOMMON
1051:          }
0EB9  0008     RETURN
1052:          
1053:          
1054:          /********************************************************************
1055:              Function:
1056:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1057:          
1058:              Summary:
1059:                   Configures the specified endpoint to send STALL to the host, the next
1060:                   time the host tries to access the endpoint.
1061:          
1062:              PreCondition:
1063:                  None
1064:          
1065:              Parameters:
1066:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1067:                  uint8_t dir - The direction of the endpoint to STALL, either
1068:                             IN_TO_HOST or OUT_FROM_HOST.
1069:          
1070:              Return Values:
1071:                  None
1072:          
1073:              Remarks:
1074:                  None
1075:          
1076:           *******************************************************************/
1077:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
1078:          {
1079:              BDT_ENTRY *p;
1080:          
1081:              if(ep == 0)
1082:              {
1083:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1084:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP
1085:                  //packet that will arrive.
1086:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1087:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1088:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1089:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1090:                  pBDTEntryIn[0]->STAT.Val = _BSTALL;
1091:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1092:          
1093:              }
1094:              else
1095:              {
1096:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1097:                  p->STAT.Val |= _BSTALL;
1098:                  p->STAT.Val |= _USIE;
1099:          
1100:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1101:                  //then stall that entry as well
1102:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1103:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1104:                  p->STAT.Val |= _BSTALL;
1105:                  p->STAT.Val |= _USIE;
1106:                  #endif
1107:              }
1108:          }
1109:          
1110:          /**************************************************************************
1111:              Function:
1112:                  void USBCancelIO(uint8_t endpoint)
1113:          
1114:              Description:
1115:                  This function cancels the transfers pending on the specified endpoint.
1116:                  This function can only be used after a SETUP packet is received and
1117:                  before that setup packet is handled.  This is the time period in which
1118:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1119:                  returns to the stack.
1120:          
1121:              Precondition:
1122:          
1123:              Parameters:
1124:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1125:          
1126:              Return Values:
1127:                  None
1128:          
1129:              Remarks:
1130:                  None
1131:          
1132:            **************************************************************************/
1133:          void USBCancelIO(uint8_t endpoint)
1134:          {
1135:              if(USBPacketDisable == 1)
1136:              {
1137:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1138:              	//to mess with the BDT right now.
1139:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1140:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1141:          
1142:              	//Need to do additional handling if ping-pong buffering is being used
1143:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1144:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1145:                  //(either due to SIE clearing it after a transaction, or the firmware
1146:                  //clearing it) makes hardware ping pong pointer advance.
1147:                  pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
1148:          
1149:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1150:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1151:                  #endif
1152:              }
1153:          }
1154:          
1155:          /**************************************************************************
1156:              Function:
1157:                  void USBDeviceDetach(void)
1158:          
1159:              Summary:
1160:                  This function configures the USB module to "soft detach" itself from
1161:                  the USB host.
1162:          
1163:              Description:
1164:                  This function configures the USB module to perform a "soft detach"
1165:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1166:                  lets the host know the device is present and attached.  This will make
1167:                  the host think that the device has been unplugged.  This is potentially
1168:                  useful, as it allows the USB device to force the host to re-enumerate
1169:                  the device (on the firmware has re-enabled the USB module/pull up, by
1170:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1171:          
1172:              Precondition:
1173:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1174:                  section if USB_POLLING mode option is being used (usb_config.h option).
1175:          
1176:                  Additionally, this function should only be called from the main() loop
1177:                  context.  Do not call this function from within an interrupt handler, as
1178:                  this function may modify global interrupt enable bits and settings.
1179:          
1180:              Parameters:
1181:                  None
1182:          
1183:              Return Values:
1184:                  None
1185:          
1186:              Remarks:
1187:                  If the application firmware calls USBDeviceDetach(), it is strongly
1188:                  recommended that the firmware wait at least >= 80ms before calling
1189:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1190:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1191:                  hosts may interpret this as an unexpected "glitch" rather than as a
1192:                  physical removal/re-attachment of the USB device.  In this case the host
1193:                  may simply ignore the event without re-enumerating the device.  To
1194:                  ensure that the host properly detects and processes the device soft
1195:                  detach/re-attach, it is recommended to make sure the device remains
1196:                  detached long enough to mimic a real human controlled USB
1197:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1198:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1199:          
1200:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1201:                  or take long to execute.  It is the application firmwares
1202:                  responsibility for adding the 80+ms delay, when using these API
1203:                  functions.
1204:          
1205:                  Note: The Windows plug and play event handler processing is fairly
1206:                  slow, especially in certain versions of Windows, and for certain USB
1207:                  device classes.  It has been observed that some device classes need to
1208:                  provide even more USB detach dwell interval (before calling
1209:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1210:                  If the USB device is a CDC class device, it is recommended to wait
1211:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1212:                  to provide the plug and play event handler enough time to finish
1213:                  processing the removal event, before the re-attach occurs.
1214:          
1215:                  If the application is using the USB_POLLING mode option, then the
1216:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.
1217:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO"
1218:                  and "#define USB_BUS_SENSE" options in the
1219:                  HardwareProfile  [platform name].h file.
1220:          
1221:                  When using the USB_POLLING mode option, and the
1222:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then
1223:                  the USB stack assumes that it should always enable the USB module at
1224:                  pretty much all times.  Basically, anytime the application firmware
1225:                  calls USBDeviceTasks(), the firmware will automatically enable the USB
1226:                  module.  This mode would typically be selected if the application was
1227:                  designed to be a purely bus powered device.  In this case, the
1228:                  application is powered from the +5V VBUS supply from the USB port, so
1229:                  it is correct and sensible in this type of application to power up and
1230:                  turn on the USB module, at anytime that the microcontroller is
1231:                  powered (which implies the USB cable is attached and the host is also
1232:                  powered).
1233:          
1234:                  In a self powered application, the USB stack is designed with the
1235:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO"
1236:                  option in the HardwareProfile  [platform name].h file.  When this
1237:                  option is defined, then the USBDeviceTasks() function will automatically
1238:                  check the I/O pin port value of the designated pin (based on the
1239:                  #define USB_BUS_SENSE option in the HardwareProfile  [platform name].h
1240:                  file), every time the application calls USBDeviceTasks().  If the
1241:                  USBDeviceTasks() function is executed and finds that the pin defined by
1242:                  the #define USB_BUS_SENSE is in a logic low state, then it will
1243:                  automatically disable the USB module and tri-state the D+ and D- pins.
1244:                  If however the USBDeviceTasks() function is executed and finds the pin
1245:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it
1246:                  will automatically enable the USB module, if it has not already been
1247:                  enabled.
1248:          
1249:            **************************************************************************/
1250:          #if defined(USB_INTERRUPT)
1251:          void USBDeviceDetach(void)
1252:          {
1253:              //If the interrupt option is selected then the customer is required
1254:              //  to notify the stack when the device is attached or removed from the
1255:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1256:          #ifdef USB_SUPPORT_OTG
1257:              if (USB_BUS_SENSE != 1)
1258:          #endif
1259:              {
1260:                   // Disable module & detach from bus
1261:                   U1CON = 0;
1262:          
1263:                   // Mask all USB interrupts
1264:                   U1IE = 0;
1265:          
1266:                   //Move to the detached state
1267:                   USBDeviceState = DETACHED_STATE;
1268:          
1269:                   #ifdef  USB_SUPPORT_OTG
1270:                       //Disable D+ Pull-up
1271:                       U1OTGCONbits.DPPULUP = 0;
1272:          
1273:                       //Disable HNP
1274:                       USBOTGDisableHnp();
1275:          
1276:                       //Deactivate HNP
1277:                       USBOTGDeactivateHnp();
1278:          
1279:                       //If ID Pin Changed State
1280:                       if (USBIDIF && USBIDIE)
1281:                       {
1282:                           //Re-detect & Initialize
1283:                            USBOTGInitialize();
1284:          
1285:                            //Clear ID Interrupt Flag
1286:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1287:                       }
1288:                   #endif
1289:          
1290:                   #if defined __C30__ || defined __XC16__
1291:                       //USBClearInterruptFlag(U1OTGIR, 3);
1292:                   #endif
1293:                      //return so that we don't go through the rest of
1294:                      //the state machine
1295:                    return;
1296:              }
1297:          
1298:          #ifdef USB_SUPPORT_OTG
1299:              //If Session Is Started Then
1300:             else
1301:             {
1302:                  //If SRP Is Ready
1303:                  if (USBOTGSRPIsReady())
1304:                  {
1305:                      //Clear SRPReady
1306:                      USBOTGClearSRPReady();
1307:          
1308:                      //Clear SRP Timeout Flag
1309:                      USBOTGClearSRPTimeOutFlag();
1310:          
1311:                      //Indicate Session Started
1312:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1313:                  }
1314:              }
1315:          #endif
1316:          }
1317:          #endif  //#if defined(USB_INTERRUPT)
1318:          /**************************************************************************
1319:              Function:
1320:                  void USBDeviceAttach(void)
1321:          
1322:              Summary:
1323:                  Checks if VBUS is present, and that the USB module is not already
1324:                  initialized, and if so, enables the USB module so as to signal device
1325:                  attachment to the USB host.
1326:          
1327:              Description:
1328:                  This function indicates to the USB host that the USB device has been
1329:                  attached to the bus.  This function needs to be called in order for the
1330:                  device to start to enumerate on the bus.
1331:          
1332:              Precondition:
1333:                  Should only be called when USB_INTERRUPT is defined.  Also, should only
1334:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1335:                  from within an interrupt handler, as the USBDeviceAttach() function
1336:                  may modify global interrupt enable bits and settings.
1337:          
1338:                  For normal USB devices:
1339:                  Make sure that if the module was previously on, that it has been turned off
1340:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1341:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1342:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes
1343:                  reject this event, since no human could ever unplug and re-attach a USB device in a
1344:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind
1345:                  of glitch and ignore the event altogether.
1346:              Parameters:
1347:                  None
1348:          
1349:              Return Values:
1350:                  None
1351:          
1352:              Remarks:
1353:          		See also the USBDeviceDetach() API function documentation.
1354:          ****************************************************************************/
1355:          #if defined(USB_INTERRUPT)
1356:          void USBDeviceAttach(void)
1357:          {
1358:              //if we are in the detached state
1359:              if(USBDeviceState == DETACHED_STATE)
1360:              {
1361:                  if(USB_BUS_SENSE == 1)
1362:                  {
1363:              	    //Initialize registers to known states.
1364:                      U1CON = 0;
1365:          
1366:                      // Mask all USB interrupts
1367:                      U1IE = 0;
1368:          
1369:                      //Configure things like: pull ups, full/low-speed mode,
1370:                      //set the ping pong mode, and set internal transceiver
1371:                      SetConfigurationOptions();
1372:          
1373:                      USBEnableInterrupts();  //Modifies global interrupt settings
1374:          
1375:                      // Enable module & attach to bus
1376:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1377:          
1378:                      //moved to the attached state
1379:                      USBDeviceState = ATTACHED_STATE;
1380:          
1381:                      #ifdef  USB_SUPPORT_OTG
1382:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
1383:                      #endif
1384:                  }
1385:              }
1386:          }
1387:          #endif  //#if defined(USB_INTERRUPT)
1388:          
1389:          
1390:          /*******************************************************************************
1391:            Function: void USBCtrlEPAllowStatusStage(void);
1392:          
1393:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1394:                      (based on the controlTransferState) to allow the status stage packet
1395:                      of a control transfer to complete.  This function gets used
1396:                      internally by the USB stack itself, but it may also be called from
1397:                      the application firmware, IF the application firmware called
1398:                      the USBDeferStatusStage() function during the initial processing
1399:                      of the control transfer request.  In this case, the application
1400:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1401:                      completed processing and handling the data stage portion of the
1402:                      request.
1403:          
1404:                      If the application firmware has no need for delaying control
1405:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1406:                      application firmware should not call USBCtrlEPAllowStatusStage().
1407:          
1408:            Description:
1409:          
1410:            Conditions:
1411:              None
1412:          
1413:            Input:
1414:          
1415:            Return:
1416:          
1417:            Remarks:
1418:              None
1419:            *****************************************************************************/
1420:          void USBCtrlEPAllowStatusStage(void)
1421:          {
1422:              //Check and set two flags, prior to actually modifying any BDT entries.
1423:              //This double checking is necessary to make certain that
1424:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once
1425:              //in main loop context, while simultaneously getting an interrupt which
1426:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1427:              if(USBStatusStageEnabledFlag1 == false)
0BC5  0021     MOVLB 0x1
0BC6  0849     MOVF USBStatusStageEnabledFlag1, W
0BC7  1D03     BTFSS STATUS, 0x2
0BC8  2BCA     GOTO 0x3CA
0BC9  2BCB     GOTO 0x3CB
0BCA  2C36     GOTO 0x436
1428:              {
1429:                  USBStatusStageEnabledFlag1 = true;
0BCB  3001     MOVLW 0x1
0BCC  00F0     MOVWF 0xF0
0BCD  0870     MOVF 0xF0, W
0BCE  00C9     MOVWF USBStatusStageEnabledFlag1
1430:                  if(USBStatusStageEnabledFlag2 == false)
0BCF  0848     MOVF USBStatusStageEnabledFlag2, W
0BD0  1D03     BTFSS STATUS, 0x2
0BD1  2BD3     GOTO 0x3D3
0BD2  2BD4     GOTO 0x3D4
0BD3  2C36     GOTO 0x436
1431:                  {
1432:                      USBStatusStageEnabledFlag2 = true;
0BD4  3001     MOVLW 0x1
0BD5  00F0     MOVWF 0xF0
0BD6  0870     MOVF 0xF0, W
0BD7  00C8     MOVWF USBStatusStageEnabledFlag2
1433:          
1434:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1435:                      //stage), based on the type of control transfer currently pending.
1436:                      if(controlTransferState == CTRL_TRF_RX)
0BD8  3002     MOVLW 0x2
0BD9  0651     XORWF controlTransferState, W
0BDA  1D03     BTFSS STATUS, 0x2
0BDB  2BDD     GOTO 0x3DD
0BDC  2BDE     GOTO 0x3DE
0BDD  2BF0     GOTO 0x3F0
1437:                      {
1438:                          pBDTEntryIn[0]->CNT = 0;
0BDE  0830     MOVF pBDTEntryIn, W
0BDF  0086     MOVWF FSR1L
0BE0  0831     MOVF 0xB1, W
0BE1  0087     MOVWF FSR1H
0BE2  3141     ADDFSR 1, 1
0BE3  0181     CLRF INDF1
1439:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0BE4  0830     MOVF pBDTEntryIn, W
0BE5  0086     MOVWF FSR1L
0BE6  0831     MOVF 0xB1, W
0BE7  0087     MOVWF FSR1H
0BE8  3048     MOVLW 0x48
0BE9  0081     MOVWF INDF1
1440:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0BEA  0830     MOVF pBDTEntryIn, W
0BEB  0086     MOVWF FSR1L
0BEC  0831     MOVF 0xB1, W
0BED  0087     MOVWF FSR1H
0BEE  1781     BSF INDF1, 0x7
1441:                      }
0BEF  2C36     GOTO 0x436
1442:                      else if(controlTransferState == CTRL_TRF_TX)
0BF0  0351     DECF controlTransferState, W
0BF1  1D03     BTFSS STATUS, 0x2
0BF2  2BF4     GOTO 0x3F4
0BF3  2BF5     GOTO 0x3F5
0BF4  2C36     GOTO 0x436
1443:                      {
1444:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
0BF5  01CC     CLRF BothEP0OutUOWNsSet
1445:          
1446:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1447:                          //next SETUP packet.
1448:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1449:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
0BF6  3008     MOVLW 0x8
0BF7  00F0     MOVWF 0xF0
0BF8  0A53     INCF pBDTEntryEP0OutCurrent, W
0BF9  0086     MOVWF FSR1L
0BFA  0187     CLRF FSR1H
0BFB  0870     MOVF 0xF0, W
0BFC  0081     MOVWF INDF1
1450:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
0BFD  3060     MOVLW 0x60
0BFE  00F0     MOVWF 0xF0
0BFF  3000     MOVLW 0x0
0C00  00F1     MOVWF 0xF1
0C01  0853     MOVF pBDTEntryEP0OutCurrent, W
0C02  3E02     ADDLW 0x2
0C03  0086     MOVWF FSR1L
0C04  0187     CLRF FSR1H
0C05  0870     MOVF 0xF0, W
0C06  3FC0     MOVWI 0[FSR1]
0C07  0871     MOVF 0xF1, W
0C08  3FC1     MOVWI 1[FSR1]
1451:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
0C09  3004     MOVLW 0x4
0C0A  00F0     MOVWF 0xF0
0C0B  0853     MOVF pBDTEntryEP0OutCurrent, W
0C0C  0086     MOVWF FSR1L
0C0D  0187     CLRF FSR1H
0C0E  0870     MOVF 0xF0, W
0C0F  0081     MOVWF INDF1
1452:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0C10  0853     MOVF pBDTEntryEP0OutCurrent, W
0C11  0086     MOVWF FSR1L
0C12  0187     CLRF FSR1H
0C13  1781     BSF INDF1, 0x7
1453:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
0C14  01CC     CLRF BothEP0OutUOWNsSet
0C15  0ACC     INCF BothEP0OutUOWNsSet, F
1454:                          #endif
1455:          
1456:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1457:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0C16  0841     MOVF pBDTEntryEP0OutNext, W
0C17  3E01     ADDLW 0x1
0C18  00F0     MOVWF 0xF0
0C19  3000     MOVLW 0x0
0C1A  3D42     ADDWFC 0xC2, W
0C1B  00F1     MOVWF 0xF1
0C1C  0870     MOVF 0xF0, W
0C1D  0086     MOVWF FSR1L
0C1E  0871     MOVF 0xF1, W
0C1F  0087     MOVWF FSR1H
0C20  3008     MOVLW 0x8
0C21  0081     MOVWF INDF1
1458:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0C22  3060     MOVLW 0x60
0C23  00F0     MOVWF 0xF0
0C24  3000     MOVLW 0x0
0C25  00F1     MOVWF 0xF1
0C26  0841     MOVF pBDTEntryEP0OutNext, W
0C27  0086     MOVWF FSR1L
0C28  0842     MOVF 0xC2, W
0C29  0087     MOVWF FSR1H
0C2A  3142     ADDFSR 1, 2
0C2B  0870     MOVF 0xF0, W
0C2C  3FC0     MOVWI 0[FSR1]
0C2D  0871     MOVF 0xF1, W
0C2E  3FC1     MOVWI 1[FSR1]
1459:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
0C2F  0841     MOVF pBDTEntryEP0OutNext, W
0C30  0086     MOVWF FSR1L
0C31  0842     MOVF 0xC2, W
0C32  0087     MOVWF FSR1H
0C33  3080     MOVLW 0x80
0C34  0081     MOVWF INDF1
0C35  2C36     GOTO 0x436
1460:                      }
1461:                  }
1462:              }
1463:          }
0C36  0008     RETURN
1464:          
1465:          
1466:          /*******************************************************************************
1467:            Function: void USBCtrlEPAllowDataStage(void);
1468:          
1469:            Summary: This function allows the data stage of either a host-to-device or
1470:                      device-to-host control transfer (with data stage) to complete.
1471:                      This function is meant to be used in conjunction with either the
1472:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1473:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1474:                      then the firmware does not need to manually call
1475:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1476:                      instead.
1477:          
1478:            Description:
1479:          
1480:            Conditions: A control transfer (with data stage) should already be pending,
1481:                          if the firmware calls this function.  Additionally, the firmware
1482:                          should have called either USBDeferOUTDataStage() or
1483:                          USBDeferINDataStage() at the start of the control transfer, if
1484:                          the firmware will be calling this function manually.
1485:          
1486:            Input:
1487:          
1488:            Return:
1489:          
1490:            Remarks:
1491:            *****************************************************************************/
1492:          void USBCtrlEPAllowDataStage(void)
1493:          {
1494:              USBDeferINDataStagePackets = false;
0A96  0021     MOVLB 0x1
0A97  01C7     CLRF USBDeferINDataStagePackets
1495:              USBDeferOUTDataStagePackets = false;
0A98  01C6     CLRF USBDeferOUTDataStagePackets
1496:          
1497:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
0A99  3002     MOVLW 0x2
0A9A  0651     XORWF controlTransferState, W
0A9B  1D03     BTFSS STATUS, 0x2
0A9C  2A9E     GOTO 0x29E
0A9D  2A9F     GOTO 0x29F
0A9E  2AC4     GOTO 0x2C4
1498:              {
1499:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1500:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0A9F  0841     MOVF pBDTEntryEP0OutNext, W
0AA0  3E01     ADDLW 0x1
0AA1  00F3     MOVWF 0xF3
0AA2  3000     MOVLW 0x0
0AA3  3D42     ADDWFC 0xC2, W
0AA4  00F4     MOVWF 0xF4
0AA5  0873     MOVF 0xF3, W
0AA6  0086     MOVWF FSR1L
0AA7  0874     MOVF 0xF4, W
0AA8  0087     MOVWF FSR1H
0AA9  3008     MOVLW 0x8
0AAA  0081     MOVWF INDF1
1501:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0AAB  3068     MOVLW 0x68
0AAC  00F3     MOVWF 0xF3
0AAD  3000     MOVLW 0x0
0AAE  00F4     MOVWF 0xF4
0AAF  0841     MOVF pBDTEntryEP0OutNext, W
0AB0  0086     MOVWF FSR1L
0AB1  0842     MOVF 0xC2, W
0AB2  0087     MOVWF FSR1H
0AB3  3142     ADDFSR 1, 2
0AB4  0873     MOVF 0xF3, W
0AB5  3FC0     MOVWI 0[FSR1]
0AB6  0874     MOVF 0xF4, W
0AB7  3FC1     MOVWI 1[FSR1]
1502:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0AB8  0841     MOVF pBDTEntryEP0OutNext, W
0AB9  0086     MOVWF FSR1L
0ABA  0842     MOVF 0xC2, W
0ABB  0087     MOVWF FSR1H
0ABC  3048     MOVLW 0x48
0ABD  0081     MOVWF INDF1
1503:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0ABE  0841     MOVF pBDTEntryEP0OutNext, W
0ABF  0086     MOVWF FSR1L
0AC0  0842     MOVF 0xC2, W
0AC1  0087     MOVWF FSR1H
0AC2  1781     BSF INDF1, 0x7
1504:              }
0AC3  2AF4     GOTO 0x2F4
1505:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1506:              {
1507:                  //Error check the data stage byte count.  Make sure the user specified
1508:                  //value was no greater than the number of bytes the host requested.
1509:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
0AC4  083C     MOVF 0xBC, W
0AC5  0020     MOVLB 0x0
0AC6  0267     SUBWF 0x67, W
0AC7  1D03     BTFSS STATUS, 0x2
0AC8  2ACD     GOTO 0x2CD
0AC9  0021     MOVLB 0x1
0ACA  083B     MOVF 0xBB, W
0ACB  0020     MOVLB 0x0
0ACC  0266     SUBWF 0x66, W
0ACD  1803     BTFSC STATUS, 0x0
0ACE  2AD0     GOTO 0x2D0
0ACF  2AD1     GOTO 0x2D1
0AD0  2AD8     GOTO 0x2D8
1510:          		{
1511:          			inPipes[0].wCount.Val = SetupPkt.wLength;
0AD1  0867     MOVF 0x67, W
0AD2  0021     MOVLB 0x1
0AD3  00BC     MOVWF 0xBC
0AD4  0020     MOVLB 0x0
0AD5  0866     MOVF 0x66, W
0AD6  0021     MOVLB 0x1
0AD7  00BB     MOVWF 0xBB
1512:          		}
1513:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
0AD8  318C     MOVLP 0xC
0AD9  2437     CALL 0x437
0ADA  318A     MOVLP 0xA
1514:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1515:          
1516:          	    //Cnt should have been initialized by responsible request owner (ex: by
1517:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1518:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0ADB  3068     MOVLW 0x68
0ADC  00F3     MOVWF 0xF3
0ADD  3000     MOVLW 0x0
0ADE  00F4     MOVWF 0xF4
0ADF  0021     MOVLB 0x1
0AE0  0830     MOVF pBDTEntryIn, W
0AE1  0086     MOVWF FSR1L
0AE2  0831     MOVF 0xB1, W
0AE3  0087     MOVWF FSR1H
0AE4  3142     ADDFSR 1, 2
0AE5  0873     MOVF 0xF3, W
0AE6  3FC0     MOVWI 0[FSR1]
0AE7  0874     MOVF 0xF4, W
0AE8  3FC1     MOVWI 1[FSR1]
1519:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0AE9  0830     MOVF pBDTEntryIn, W
0AEA  0086     MOVWF FSR1L
0AEB  0831     MOVF 0xB1, W
0AEC  0087     MOVWF FSR1H
0AED  3048     MOVLW 0x48
0AEE  0081     MOVWF INDF1
1520:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
0AEF  0830     MOVF pBDTEntryIn, W
0AF0  0086     MOVWF FSR1L
0AF1  0831     MOVF 0xB1, W
0AF2  0087     MOVWF FSR1H
0AF3  1781     BSF INDF1, 0x7
1521:              }
1522:          }
0AF4  0008     RETURN
1523:          
1524:          
1525:          /******************************************************************************/
1526:          /** Internal Functions *********************************************************/
1527:          /******************************************************************************/
1528:          
1529:          /********************************************************************
1530:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1531:           *
1532:           * PreCondition:    None
1533:           *
1534:           * Input:           uint8_t EPNum - the endpoint to be configured
1535:           *                  uint8_t direction - the direction to be configured
1536:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1537:           *
1538:           * Output:          None
1539:           *
1540:           * Side Effects:    None
1541:           *
1542:           * Overview:        This function will configure the specified
1543:           *                  endpoint
1544:           *
1545:           * Note:            None
1546:           *******************************************************************/
1547:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
0971  00F5     MOVWF 0xF5
1548:          {
1549:              volatile BDT_ENTRY* handle;
1550:          
1551:              //Compute a pointer to the even BDT entry corresponding to the
1552:              //EPNum and direction values passed to this function.
1553:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
0972  3020     MOVLW 0x20
0973  00F1     MOVWF 0xF1
0974  0871     MOVF 0xF1, W
0975  00F6     MOVWF 0xF6
1554:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
0976  0870     MOVF 0xF0, W
0977  00F1     MOVWF 0xF1
0978  3001     MOVLW 0x1
0979  35F1     LSLF 0xF1, F
097A  0B89     DECFSZ WREG, F
097B  2979     GOTO 0x179
097C  0875     MOVF 0xF5, W
097D  00F2     MOVWF 0xF2
097E  3001     MOVLW 0x1
097F  35F2     LSLF 0xF2, F
0980  3EFF     ADDLW 0xFF
0981  1D03     BTFSS STATUS, 0x2
0982  297F     GOTO 0x17F
0983  3572     LSLF 0xF2, W
0984  0771     ADDWF 0xF1, W
0985  00F3     MOVWF 0xF3
0986  3001     MOVLW 0x1
0987  35F3     LSLF 0xF3, F
0988  3EFF     ADDLW 0xFF
0989  1D03     BTFSS STATUS, 0x2
098A  2987     GOTO 0x187
098B  3573     LSLF 0xF3, W
098C  00F4     MOVWF 0xF4
098D  0874     MOVF 0xF4, W
098E  07F6     ADDWF 0xF6, F
1555:          
1556:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler()
098F  0876     MOVF 0xF6, W
0990  0086     MOVWF FSR1L
0991  0187     CLRF FSR1H
0992  1381     BCF INDF1, 0x7
1557:              //already cleared the entire BDT table
1558:          
1559:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1560:              //for USBTransferOnePacket() API calls.
1561:              if(direction == OUT_FROM_HOST)
0993  0870     MOVF 0xF0, W
0994  1D03     BTFSS STATUS, 0x2
0995  2997     GOTO 0x197
0996  2998     GOTO 0x198
0997  29A2     GOTO 0x1A2
1562:              {
1563:                  pBDTEntryOut[EPNum] = handle;
0998  3575     LSLF 0xF5, W
0999  3EA0     ADDLW 0xA0
099A  0086     MOVWF FSR1L
099B  3001     MOVLW 0x1
099C  0087     MOVWF FSR1H
099D  0876     MOVF 0xF6, W
099E  3FC0     MOVWI 0[FSR1]
099F  3000     MOVLW 0x0
09A0  3FC1     MOVWI 1[FSR1]
1564:              }
09A1  29AA     GOTO 0x1AA
1565:              else
1566:              {
1567:                  pBDTEntryIn[EPNum] = handle;
09A2  3575     LSLF 0xF5, W
09A3  3EB0     ADDLW 0xB0
09A4  0086     MOVWF FSR1L
09A5  0187     CLRF FSR1H
09A6  0876     MOVF 0xF6, W
09A7  3FC0     MOVWI 0[FSR1]
09A8  3000     MOVLW 0x0
09A9  3FC1     MOVWI 1[FSR1]
1568:              }
1569:          
1570:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1571:                  handle->STAT.DTS = 0;
09AA  0876     MOVF 0xF6, W
09AB  0086     MOVWF FSR1L
09AC  0187     CLRF FSR1H
09AD  1301     BCF INDF1, 0x6
1572:                  (handle+1)->STAT.DTS = 1;
09AE  0876     MOVF 0xF6, W
09AF  3E04     ADDLW 0x4
09B0  0086     MOVWF FSR1L
09B1  0187     CLRF FSR1H
09B2  1701     BSF INDF1, 0x6
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1574:                  //Set DTS to one because the first thing we will do
1575:                  //when transmitting is toggle the bit
1576:                  handle->STAT.DTS = 1;
1577:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1578:                  if(EPNum != 0)
1579:                  {
1580:                      handle->STAT.DTS = 1;
1581:                  }
1582:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1583:                  if(EPNum != 0)
1584:                  {
1585:                      handle->STAT.DTS = 0;
1586:                      (handle+1)->STAT.DTS = 1;
1587:                  }
1588:              #endif
1589:          }
09B3  0008     RETURN
1590:          
1591:          
1592:          /******************************************************************************
1593:           * Function:        void USBCtrlEPServiceComplete(void)
1594:           *
1595:           * PreCondition:    None
1596:           *
1597:           * Input:           None
1598:           *
1599:           * Output:          None
1600:           *
1601:           * Side Effects:    None
1602:           *
1603:           * Overview:        This routine wrap up the remaining tasks in servicing
1604:           *                  a Setup Request. Its main task is to set the endpoint
1605:           *                  controls appropriately for a given situation. See code
1606:           *                  below.
1607:           *                  There are three main scenarios:
1608:           *                  a) There was no handler for the Request, in this case
1609:           *                     a STALL should be sent out.
1610:           *                  b) The host has requested a read control transfer,
1611:           *                     endpoints are required to be setup in a specific way.
1612:           *                  c) The host has requested a write control transfer, or
1613:           *                     a control data stage is not required, endpoints are
1614:           *                     required to be setup in a specific way.
1615:           *
1616:           *                  Packet processing is resumed by clearing PKTDIS bit.
1617:           *
1618:           * Note:            None
1619:           *****************************************************************************/
1620:          static void USBCtrlEPServiceComplete(void)
1621:          {
1622:              /*
1623:               * PKTDIS bit is set when a Setup Transaction is received.
1624:               * Clear to resume packet processing.
1625:               */
1626:              USBPacketDisable = 0;
0EBA  003D     MOVLB 0x1D
0EBB  120E     BCF UCON, 0x4
1627:          
1628:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1629:          	//control transfer is currently in progress.  We need to know the type of control
1630:          	//transfer that is currently pending, in order to know how to properly arm the
1631:          	//EP0 IN and EP0 OUT endpoints.
1632:              if(inPipes[0].info.bits.busy == 0)
0EBC  0021     MOVLB 0x1
0EBD  1BBA     BTFSC 0xBA, 0x7
0EBE  2EC0     GOTO 0x6C0
0EBF  2EC1     GOTO 0x6C1
0EC0  2F08     GOTO 0x708
1633:              {
1634:                  if(outPipes[0].info.bits.busy == 1)
0EC1  0022     MOVLB 0x2
0EC2  1FA2     BTFSS 0x122, 0x7
0EC3  2EC5     GOTO 0x6C5
0EC4  2EC6     GOTO 0x6C6
0EC5  2ED7     GOTO 0x6D7
1635:                  {
1636:                      controlTransferState = CTRL_TRF_RX;
0EC6  3002     MOVLW 0x2
0EC7  00F5     MOVWF 0x175
0EC8  0875     MOVF 0x175, W
0EC9  0021     MOVLB 0x1
0ECA  00D1     MOVWF controlTransferState
1637:                      /*
1638:                       * Control Write:
1639:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1640:                       */
1641:          
1642:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1643:                      //   function decided to defer the data stage (ex: because the intended
1644:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1645:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1646:                      //   once it is ready to begin receiving the data.
1647:                      if(USBDeferOUTDataStagePackets == false)
0ECB  0846     MOVF USBDeferOUTDataStagePackets, W
0ECC  1D03     BTFSS STATUS, 0x2
0ECD  2ECF     GOTO 0x6CF
0ECE  2ED0     GOTO 0x6D0
0ECF  2ED3     GOTO 0x6D3
1648:                      {
1649:                          USBCtrlEPAllowDataStage();
0ED0  318A     MOVLP 0xA
0ED1  2296     CALL 0x296
0ED2  318E     MOVLP 0xE
1650:                      }
1651:          
1652:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage()
1653:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1654:                      USBStatusStageEnabledFlag2 = false;
0ED3  0021     MOVLB 0x1
0ED4  01C8     CLRF USBStatusStageEnabledFlag2
1655:                      USBStatusStageEnabledFlag1 = false;
0ED5  01C9     CLRF USBStatusStageEnabledFlag1
1656:                  }
0ED6  2F55     GOTO 0x755
1657:                  else
1658:                  {
1659:                      /*
1660:                       * If no one knows how to service this request then stall.
1661:                       * Must also prepare EP0 to receive the next SETUP transaction.
1662:                       */
1663:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0ED7  0021     MOVLB 0x1
0ED8  0841     MOVF pBDTEntryEP0OutNext, W
0ED9  3E01     ADDLW 0x1
0EDA  00F5     MOVWF 0xF5
0EDB  3000     MOVLW 0x0
0EDC  3D42     ADDWFC 0xC2, W
0EDD  00F6     MOVWF 0xF6
0EDE  0875     MOVF 0xF5, W
0EDF  0086     MOVWF FSR1L
0EE0  0876     MOVF 0xF6, W
0EE1  0087     MOVWF FSR1H
0EE2  3008     MOVLW 0x8
0EE3  0081     MOVWF INDF1
1664:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0EE4  3060     MOVLW 0x60
0EE5  00F5     MOVWF 0xF5
0EE6  3000     MOVLW 0x0
0EE7  00F6     MOVWF 0xF6
0EE8  0841     MOVF pBDTEntryEP0OutNext, W
0EE9  0086     MOVWF FSR1L
0EEA  0842     MOVF 0xC2, W
0EEB  0087     MOVWF FSR1H
0EEC  3142     ADDFSR 1, 2
0EED  0875     MOVF 0xF5, W
0EEE  3FC0     MOVWI 0[FSR1]
0EEF  0876     MOVF 0xF6, W
0EF0  3FC1     MOVWI 1[FSR1]
1665:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0EF1  0841     MOVF pBDTEntryEP0OutNext, W
0EF2  0086     MOVWF FSR1L
0EF3  0842     MOVF 0xC2, W
0EF4  0087     MOVWF FSR1H
0EF5  300C     MOVLW 0xC
0EF6  0081     MOVWF INDF1
1666:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0EF7  0841     MOVF pBDTEntryEP0OutNext, W
0EF8  0086     MOVWF FSR1L
0EF9  0842     MOVF 0xC2, W
0EFA  0087     MOVWF FSR1H
0EFB  1781     BSF INDF1, 0x7
1667:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0EFC  0830     MOVF pBDTEntryIn, W
0EFD  0086     MOVWF FSR1L
0EFE  0831     MOVF 0xB1, W
0EFF  0087     MOVWF FSR1H
0F00  3004     MOVLW 0x4
0F01  0081     MOVWF INDF1
1668:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0F02  0830     MOVF pBDTEntryIn, W
0F03  0086     MOVWF FSR1L
0F04  0831     MOVF 0xB1, W
0F05  0087     MOVWF FSR1H
0F06  1781     BSF INDF1, 0x7
0F07  2F55     GOTO 0x755
1669:                  }
1670:              }
1671:              else    // A module has claimed ownership of the control transfer session.
1672:              {
1673:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0F08  0020     MOVLB 0x0
0F09  1FE0     BTFSS SetupPkt, 0x7
0F0A  2F0C     GOTO 0x70C
0F0B  2F0D     GOTO 0x70D
0F0C  2F24     GOTO 0x724
1674:          		{
1675:          			controlTransferState = CTRL_TRF_TX;
0F0D  0021     MOVLB 0x1
0F0E  01D1     CLRF controlTransferState
0F0F  0AD1     INCF controlTransferState, F
1676:          			/*
1677:          			 * Control Read:
1678:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1679:          			 *
1680:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1681:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1682:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1683:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1684:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1685:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1686:          			 *    is ready to begin sending the data, it should then call the
1687:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1688:          			 */
1689:          			if(USBDeferINDataStagePackets == false)
0F10  0847     MOVF USBDeferINDataStagePackets, W
0F11  1D03     BTFSS STATUS, 0x2
0F12  2F14     GOTO 0x714
0F13  2F15     GOTO 0x715
0F14  2F18     GOTO 0x718
1690:                      {
1691:                          USBCtrlEPAllowDataStage();
0F15  318A     MOVLP 0xA
0F16  2296     CALL 0x296
0F17  318E     MOVLP 0xE
1692:          			}
1693:          
1694:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1695:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1696:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1697:                      //    is ready.  If the class request handler does this, it needs to be careful to
1698:                      //    be written so that it can handle the early termination scenario.
1699:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1700:                      //    1.  The desired total number of bytes were sent to the host.
1701:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that
1702:                      //        started the control transfer) has been reached.
1703:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless
1704:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1705:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1706:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1707:                      //        option can take care of this for you.
1708:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1709:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1710:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1711:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this
1712:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1713:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1714:                      USBStatusStageEnabledFlag2 = false;
0F18  0021     MOVLB 0x1
0F19  01C8     CLRF USBStatusStageEnabledFlag2
1715:                      USBStatusStageEnabledFlag1 = false;
0F1A  01C9     CLRF USBStatusStageEnabledFlag1
1716:                      if(USBDeferStatusStagePacket == false)
0F1B  084A     MOVF USBDeferStatusStagePacket, W
0F1C  1D03     BTFSS STATUS, 0x2
0F1D  2F1F     GOTO 0x71F
0F1E  2F20     GOTO 0x720
0F1F  2F55     GOTO 0x755
1717:                      {
1718:                          USBCtrlEPAllowStatusStage();
0F20  318B     MOVLP 0xB
0F21  23C5     CALL 0x3C5
0F22  318E     MOVLP 0xE
0F23  2F55     GOTO 0x755
1719:                      }
1720:          		}
1721:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1722:          		{
1723:          			//This situation occurs for special types of control transfers,
1724:          			//such as that which occurs when the host sends a SET_ADDRESS
1725:          			//control transfer.  Ex:
1726:          			//
1727:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1728:          
1729:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1730:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1731:          			//an IN status stage.
1732:          
1733:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
0F24  3002     MOVLW 0x2
0F25  00F5     MOVWF 0xF5
0F26  0875     MOVF 0xF5, W
0F27  0021     MOVLB 0x1
0F28  00D1     MOVWF controlTransferState
1734:          
1735:          			//1. Prepare OUT EP to receive the next SETUP packet.
1736:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0F29  0841     MOVF pBDTEntryEP0OutNext, W
0F2A  3E01     ADDLW 0x1
0F2B  00F5     MOVWF 0xF5
0F2C  3000     MOVLW 0x0
0F2D  3D42     ADDWFC 0xC2, W
0F2E  00F6     MOVWF 0xF6
0F2F  0875     MOVF 0xF5, W
0F30  0086     MOVWF FSR1L
0F31  0876     MOVF 0xF6, W
0F32  0087     MOVWF FSR1H
0F33  3008     MOVLW 0x8
0F34  0081     MOVWF INDF1
1737:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0F35  3060     MOVLW 0x60
0F36  00F5     MOVWF 0xF5
0F37  3000     MOVLW 0x0
0F38  00F6     MOVWF 0xF6
0F39  0841     MOVF pBDTEntryEP0OutNext, W
0F3A  0086     MOVWF FSR1L
0F3B  0842     MOVF 0xC2, W
0F3C  0087     MOVWF FSR1H
0F3D  3142     ADDFSR 1, 2
0F3E  0875     MOVF 0xF5, W
0F3F  3FC0     MOVWI 0[FSR1]
0F40  0876     MOVF 0xF6, W
0F41  3FC1     MOVWI 1[FSR1]
1738:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0F42  0841     MOVF pBDTEntryEP0OutNext, W
0F43  0086     MOVWF FSR1L
0F44  0842     MOVF 0xC2, W
0F45  0087     MOVWF FSR1H
0F46  3004     MOVLW 0x4
0F47  0081     MOVWF INDF1
1739:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0F48  0841     MOVF pBDTEntryEP0OutNext, W
0F49  0086     MOVWF FSR1L
0F4A  0842     MOVF 0xC2, W
0F4B  0087     MOVWF FSR1H
0F4C  1781     BSF INDF1, 0x7
1740:          
1741:          			//2. Prepare for IN status stage of the control transfer
1742:                      USBStatusStageEnabledFlag2 = false;
0F4D  01C8     CLRF USBStatusStageEnabledFlag2
1743:                      USBStatusStageEnabledFlag1 = false;
0F4E  01C9     CLRF USBStatusStageEnabledFlag1
1744:          			if(USBDeferStatusStagePacket == false)
0F4F  084A     MOVF USBDeferStatusStagePacket, W
0F50  1D03     BTFSS STATUS, 0x2
0F51  2F53     GOTO 0x753
0F52  2F54     GOTO 0x754
0F53  2F55     GOTO 0x755
0F54  2F20     GOTO 0x720
1745:                      {
1746:                          USBCtrlEPAllowStatusStage();
1747:                      }
1748:          		}
1749:          
1750:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1751:          
1752:          }//end USBCtrlEPServiceComplete
0F55  0008     RETURN
1753:          
1754:          
1755:          /******************************************************************************
1756:           * Function:        void USBCtrlTrfTxService(void)
1757:           *
1758:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1759:           *
1760:           * Input:           None
1761:           *
1762:           * Output:          None
1763:           *
1764:           * Side Effects:    None
1765:           *
1766:           * Overview:        This routine is used for device to host control transfers
1767:           *					(IN transactions).  This function takes care of managing a
1768:           *                  transfer over multiple USB transactions.
1769:           *					This routine should be called from only two places.
1770:           *                  One from USBCtrlEPServiceComplete() and one from
1771:           *                  USBCtrlTrfInHandler().
1772:           *
1773:           * Note:
1774:           *****************************************************************************/
1775:          static void USBCtrlTrfTxService(void)
1776:          {
1777:              uint8_t byteToSend;
1778:          
1779:              //Figure out how many bytes of data to send in the next IN transaction.
1780:              //Assume a full size packet, unless otherwise determined below.
1781:              byteToSend = USB_EP0_BUFF_SIZE;
0C37  3008     MOVLW 0x8
0C38  00F0     MOVWF 0xF0
0C39  0870     MOVF 0xF0, W
0C3A  00F2     MOVWF 0xF2
1782:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
0C3B  3000     MOVLW 0x0
0C3C  0021     MOVLB 0x1
0C3D  023C     SUBWF 0xBC, W
0C3E  3008     MOVLW 0x8
0C3F  1903     BTFSC STATUS, 0x2
0C40  023B     SUBWF 0xBB, W
0C41  1803     BTFSC STATUS, 0x0
0C42  2C44     GOTO 0x444
0C43  2C45     GOTO 0x445
0C44  2C5A     GOTO 0x45A
1783:              {
1784:                  byteToSend = (uint8_t)(inPipes[0].wCount.Val);
0C45  083B     MOVF 0xBB, W
0C46  00F0     MOVWF 0xF0
0C47  0870     MOVF 0xF0, W
0C48  00F2     MOVWF 0xF2
1785:          
1786:                  //Keep track of whether or not we have sent a "short packet" yet.
1787:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1788:                  //after we have sent all of the intended data.  This makes sure the
1789:                  //hardware STALLs if the host erroneously tries to send more IN token
1790:                  //packets, requesting more data than intended in the control transfer.
1791:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
0C49  0852     MOVF shortPacketStatus, W
0C4A  1D03     BTFSS STATUS, 0x2
0C4B  2C4D     GOTO 0x44D
0C4C  2C4E     GOTO 0x44E
0C4D  2C51     GOTO 0x451
1792:                  {
1793:                      shortPacketStatus = SHORT_PKT_PENDING;
0C4E  01D2     CLRF shortPacketStatus
0C4F  0AD2     INCF shortPacketStatus, F
1794:                  }
0C50  2C5A     GOTO 0x45A
1795:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
0C51  0352     DECF shortPacketStatus, W
0C52  1D03     BTFSS STATUS, 0x2
0C53  2C55     GOTO 0x455
0C54  2C56     GOTO 0x456
0C55  2C5A     GOTO 0x45A
1796:                  {
1797:                      shortPacketStatus = SHORT_PKT_SENT;
0C56  3002     MOVLW 0x2
0C57  00F0     MOVWF 0xF0
0C58  0870     MOVF 0xF0, W
0C59  00D2     MOVWF shortPacketStatus
1798:                  }
1799:              }
1800:          
1801:              //Keep track of how many bytes remain to be sent in the transfer, by
1802:              //subtracting the number of bytes about to be sent from the total.
1803:              inPipes[0].wCount.Val -= byteToSend;
0C5A  0872     MOVF 0xF2, W
0C5B  00F0     MOVWF 0xF0
0C5C  01F1     CLRF 0xF1
0C5D  0870     MOVF 0xF0, W
0C5E  02BB     SUBWF 0xBB, F
0C5F  0871     MOVF 0xF1, W
0C60  3BBC     SUBWFB 0xBC, F
1804:          
1805:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1806:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1807:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1808:              pBDTEntryIn[0]->CNT = byteToSend;
0C61  0830     MOVF pBDTEntryIn, W
0C62  3E01     ADDLW 0x1
0C63  00F0     MOVWF 0xF0
0C64  3000     MOVLW 0x0
0C65  3D31     ADDWFC 0xB1, W
0C66  00F1     MOVWF 0xF1
0C67  0870     MOVF 0xF0, W
0C68  0086     MOVWF FSR1L
0C69  0871     MOVF 0xF1, W
0C6A  0087     MOVWF FSR1H
0C6B  0872     MOVF 0xF2, W
0C6C  0081     MOVWF INDF1
1809:          
1810:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1811:              //which we will send to the host.
1812:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
0C6D  3068     MOVLW 0x68
0C6E  00F0     MOVWF 0xF0
0C6F  0870     MOVF 0xF0, W
0C70  00D0     MOVWF pDst
1813:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
0C71  183A     BTFSC 0xBA, 0x0
0C72  2C74     GOTO 0x474
0C73  2C75     GOTO 0x475
0C74  2CA6     GOTO 0x4A6
0C75  2C8B     GOTO 0x48B
1814:              {
1815:                  while(byteToSend)
0C8B  0872     MOVF 0xF2, W
0C8C  1D03     BTFSS STATUS, 0x2
0C8D  2C8F     GOTO 0x48F
0C8E  2C90     GOTO 0x490
0C8F  2C76     GOTO 0x476
0C90  2CAB     GOTO 0x4AB
1816:                  {
1817:                      *pDst++ = *inPipes[0].pSrc.bRom++;
0C76  0838     MOVF inPipes, W
0C77  0084     MOVWF FSR0L
0C78  0839     MOVF 0xB9, W
0C79  0085     MOVWF FSR0H
0C7A  0800     MOVF INDF0, W
0C7B  00F0     MOVWF 0xF0
0C7C  0850     MOVF pDst, W
0C7D  0086     MOVWF FSR1L
0C7E  0187     CLRF FSR1H
0C7F  0870     MOVF 0xF0, W
0C80  0081     MOVWF INDF1
0C81  3001     MOVLW 0x1
0C82  07B8     ADDWF inPipes, F
0C83  3000     MOVLW 0x0
0C84  3DB9     ADDWFC 0xB9, F
0C85  3001     MOVLW 0x1
0C86  00F0     MOVWF 0xF0
0C87  0870     MOVF 0xF0, W
0C88  07D0     ADDWF pDst, F
1818:                      byteToSend--;
0C89  3001     MOVLW 0x1
0C8A  02F2     SUBWF 0xF2, F
1819:                  }//end while(byte_to_send.Val)
1820:              }
1821:              else  // RAM
1822:              {
1823:                  while(byteToSend)
0CA6  0872     MOVF 0xF2, W
0CA7  1D03     BTFSS STATUS, 0x2
0CA8  2CAA     GOTO 0x4AA
0CA9  2CAB     GOTO 0x4AB
0CAA  2C91     GOTO 0x491
1824:                  {
1825:                      *pDst++ = *inPipes[0].pSrc.bRam++;
0C91  0838     MOVF inPipes, W
0C92  0084     MOVWF FSR0L
0C93  0839     MOVF 0xB9, W
0C94  0085     MOVWF FSR0H
0C95  0800     MOVF INDF0, W
0C96  00F0     MOVWF 0xF0
0C97  0850     MOVF pDst, W
0C98  0086     MOVWF FSR1L
0C99  0187     CLRF FSR1H
0C9A  0870     MOVF 0xF0, W
0C9B  0081     MOVWF INDF1
0C9C  3001     MOVLW 0x1
0C9D  07B8     ADDWF inPipes, F
0C9E  3000     MOVLW 0x0
0C9F  3DB9     ADDWFC 0xB9, F
0CA0  3001     MOVLW 0x1
0CA1  00F0     MOVWF 0xF0
0CA2  0870     MOVF 0xF0, W
0CA3  07D0     ADDWF pDst, F
1826:                      byteToSend--;
0CA4  3001     MOVLW 0x1
0CA5  02F2     SUBWF 0xF2, F
0CA6  0872     MOVF 0xF2, W
0CA7  1D03     BTFSS STATUS, 0x2
0CA8  2CAA     GOTO 0x4AA
0CA9  2CAB     GOTO 0x4AB
0CAA  2C91     GOTO 0x491
1827:                  }//end while(byte_to_send.Val)
1828:              }//end if(usb_stat.ctrl_trf_mem == _const)
1829:          }//end USBCtrlTrfTxService
0CAB  0008     RETURN
1830:          
1831:          /******************************************************************************
1832:           * Function:        void USBCtrlTrfRxService(void)
1833:           *
1834:           * PreCondition:    pDst and wCount are setup properly.
1835:           *                  pSrc is always &CtrlTrfData
1836:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1837:           *                  wCount should be set to 0 at the start of each control
1838:           *                  transfer.
1839:           *
1840:           * Input:           None
1841:           *
1842:           * Output:          None
1843:           *
1844:           * Side Effects:    None
1845:           *
1846:           * Overview:        This routine is used for host to device control transfers
1847:           *					(uses OUT transactions).  This function receives the data that arrives
1848:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1849:           *					buffer.  Once the host has sent all the data it was intending
1850:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1851:           *					handler (unless it is NULL), so that it can be used by the
1852:           *					intended target firmware.
1853:           *
1854:           * Note:            None
1855:           *****************************************************************************/
1856:          static void USBCtrlTrfRxService(void)
1857:          {
1858:              uint8_t byteToRead;
1859:              uint8_t i;
1860:          
1861:              //Load byteToRead with the number of bytes the host just sent us in the
1862:              //last OUT transaction.
1863:              byteToRead = pBDTEntryEP0OutCurrent->CNT;
0F56  0021     MOVLB 0x1
0F57  0853     MOVF pBDTEntryEP0OutCurrent, W
0F58  0086     MOVWF FSR1L
0F59  0187     CLRF FSR1H
0F5A  3F41     MOVIW 1[FSR1]
0F5B  00F5     MOVWF 0xF5
1864:          
1865:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1866:              //of remaining bytes expected to be received from the host, in the control
1867:              //transfer.  First check to see if the host sent us more bytes than the
1868:              //application firmware was expecting to receive.
1869:              if(byteToRead > outPipes[0].wCount.Val)
0F5C  0875     MOVF 0xF5, W
0F5D  00F2     MOVWF 0xF2
0F5E  01F3     CLRF 0xF3
0F5F  0873     MOVF 0xF3, W
0F60  0022     MOVLB 0x2
0F61  0224     SUBWF 0x124, W
0F62  1D03     BTFSS STATUS, 0x2
0F63  2F66     GOTO 0x766
0F64  0872     MOVF 0x172, W
0F65  0223     SUBWF 0x123, W
0F66  1803     BTFSC STATUS, 0x0
0F67  2F69     GOTO 0x769
0F68  2F6A     GOTO 0x76A
0F69  2F6E     GOTO 0x76E
1870:              {
1871:                  byteToRead = (uint8_t)(outPipes[0].wCount.Val);
0F6A  0823     MOVF 0x123, W
0F6B  00F2     MOVWF 0x172
0F6C  0872     MOVF 0x172, W
0F6D  00F5     MOVWF 0x175
1872:              }
1873:              //Reduce the number of remaining bytes by the number we just received.
1874:              outPipes[0].wCount.Val -= byteToRead;
0F6E  0875     MOVF 0x175, W
0F6F  00F2     MOVWF 0x172
0F70  01F3     CLRF 0x173
0F71  0872     MOVF 0x172, W
0F72  02A3     SUBWF 0x123, F
0F73  0873     MOVF 0x173, W
0F74  3BA4     SUBWFB 0x124, F
1875:          
1876:              //Copy the OUT DATAx packet bytes that we just received from the host,
1877:              //into the user application buffer space.
1878:              for(i=0;i<byteToRead;i++)
0F75  01F4     CLRF 0x174
0F76  2F8A     GOTO 0x78A
1879:              {
1880:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
0F77  0874     MOVF 0x174, W
0F78  3E68     ADDLW 0x68
0F79  0086     MOVWF FSR1L
0F7A  0187     CLRF FSR1H
0F7B  0801     MOVF INDF1, W
0F7C  00F2     MOVWF 0x172
0F7D  0820     MOVF outPipes, W
0F7E  0086     MOVWF FSR1L
0F7F  0187     CLRF FSR1H
0F80  0872     MOVF 0x172, W
0F81  0081     MOVWF INDF1
0F82  3001     MOVLW 0x1
0F83  00F2     MOVWF 0x172
0F84  0872     MOVF 0x172, W
0F85  07A0     ADDWF outPipes, F
1881:              }//end while(byteToRead.Val)
0F86  3001     MOVLW 0x1
0F87  00F2     MOVWF 0x172
0F88  0872     MOVF 0x172, W
0F89  07F4     ADDWF 0x174, F
0F8A  0875     MOVF 0x175, W
0F8B  0274     SUBWF 0x174, W
0F8C  1C03     BTFSS STATUS, 0x0
0F8D  2F8F     GOTO 0x78F
0F8E  2F90     GOTO 0x790
0F8F  2F77     GOTO 0x777
1882:          
1883:              //If there is more data to receive, prepare EP0 OUT so that it can receive
1884:          	//the next packet in the sequence.
1885:              if(outPipes[0].wCount.Val > 0)
0F90  0823     MOVF 0x123, W
0F91  0424     IORWF 0x124, W
0F92  1903     BTFSC STATUS, 0x2
0F93  2F95     GOTO 0x795
0F94  2F96     GOTO 0x796
0F95  2FCF     GOTO 0x7CF
1886:              {
1887:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0F96  0021     MOVLB 0x1
0F97  0841     MOVF pBDTEntryEP0OutNext, W
0F98  3E01     ADDLW 0x1
0F99  00F2     MOVWF 0xF2
0F9A  3000     MOVLW 0x0
0F9B  3D42     ADDWFC 0xC2, W
0F9C  00F3     MOVWF 0xF3
0F9D  0872     MOVF 0xF2, W
0F9E  0086     MOVWF FSR1L
0F9F  0873     MOVF 0xF3, W
0FA0  0087     MOVWF FSR1H
0FA1  3008     MOVLW 0x8
0FA2  0081     MOVWF INDF1
1888:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0FA3  3068     MOVLW 0x68
0FA4  00F2     MOVWF 0xF2
0FA5  3000     MOVLW 0x0
0FA6  00F3     MOVWF 0xF3
0FA7  0841     MOVF pBDTEntryEP0OutNext, W
0FA8  0086     MOVWF FSR1L
0FA9  0842     MOVF 0xC2, W
0FAA  0087     MOVWF FSR1H
0FAB  3142     ADDFSR 1, 2
0FAC  0872     MOVF 0xF2, W
0FAD  3FC0     MOVWI 0[FSR1]
0FAE  0873     MOVF 0xF3, W
0FAF  3FC1     MOVWI 1[FSR1]
1889:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
0FB0  0853     MOVF pBDTEntryEP0OutCurrent, W
0FB1  0086     MOVWF FSR1L
0FB2  0187     CLRF FSR1H
0FB3  1B01     BTFSC INDF1, 0x6
0FB4  2FB6     GOTO 0x7B6
0FB5  2FB7     GOTO 0x7B7
0FB6  2FC3     GOTO 0x7C3
1890:                  {
1891:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0FB7  0841     MOVF pBDTEntryEP0OutNext, W
0FB8  0086     MOVWF FSR1L
0FB9  0842     MOVF 0xC2, W
0FBA  0087     MOVWF FSR1H
0FBB  3048     MOVLW 0x48
0FBC  0081     MOVWF INDF1
1892:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FBD  0841     MOVF pBDTEntryEP0OutNext, W
0FBE  0086     MOVWF FSR1L
0FBF  0842     MOVF 0xC2, W
0FC0  0087     MOVWF FSR1H
0FC1  1781     BSF INDF1, 0x7
1893:                  }
0FC2  2FFF     GOTO 0x7FF
1894:                  else
1895:                  {
1896:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0FC3  0841     MOVF pBDTEntryEP0OutNext, W
0FC4  0086     MOVWF FSR1L
0FC5  0842     MOVF 0xC2, W
0FC6  0087     MOVWF FSR1H
0FC7  3008     MOVLW 0x8
0FC8  0081     MOVWF INDF1
1897:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FC9  0841     MOVF pBDTEntryEP0OutNext, W
0FCA  0086     MOVWF FSR1L
0FCB  0842     MOVF 0xC2, W
0FCC  0087     MOVWF FSR1H
0FCD  1781     BSF INDF1, 0x7
0FCE  2FFF     GOTO 0x7FF
1898:                  }
1899:              }
1900:              else
1901:              {
1902:          	    //We have received all OUT packets that we were expecting to
1903:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1904:          		//the next SETUP transaction that may arrive.
1905:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0FCF  0021     MOVLB 0x1
0FD0  0841     MOVF pBDTEntryEP0OutNext, W
0FD1  3E01     ADDLW 0x1
0FD2  00F2     MOVWF 0xF2
0FD3  3000     MOVLW 0x0
0FD4  3D42     ADDWFC 0xC2, W
0FD5  00F3     MOVWF 0xF3
0FD6  0872     MOVF 0xF2, W
0FD7  0086     MOVWF FSR1L
0FD8  0873     MOVF 0xF3, W
0FD9  0087     MOVWF FSR1H
0FDA  3008     MOVLW 0x8
0FDB  0081     MOVWF INDF1
1906:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0FDC  3060     MOVLW 0x60
0FDD  00F2     MOVWF 0xF2
0FDE  3000     MOVLW 0x0
0FDF  00F3     MOVWF 0xF3
0FE0  0841     MOVF pBDTEntryEP0OutNext, W
0FE1  0086     MOVWF FSR1L
0FE2  0842     MOVF 0xC2, W
0FE3  0087     MOVWF FSR1H
0FE4  3142     ADDFSR 1, 2
0FE5  0872     MOVF 0xF2, W
0FE6  3FC0     MOVWI 0[FSR1]
0FE7  0873     MOVF 0xF3, W
0FE8  3FC1     MOVWI 1[FSR1]
1907:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1908:                  //control transfers.  However, set BSTALL in case the host tries to send
1909:                  //more data than it claims it was going to send.
1910:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0FE9  0841     MOVF pBDTEntryEP0OutNext, W
0FEA  0086     MOVWF FSR1L
0FEB  0842     MOVF 0xC2, W
0FEC  0087     MOVWF FSR1H
0FED  3004     MOVLW 0x4
0FEE  0081     MOVWF INDF1
1911:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FEF  0841     MOVF pBDTEntryEP0OutNext, W
0FF0  0086     MOVWF FSR1L
0FF1  0842     MOVF 0xC2, W
0FF2  0087     MOVWF FSR1H
0FF3  1781     BSF INDF1, 0x7
1912:          
1913:          		//All data bytes for the host to device control write (OUT) have now been
1914:          		//received successfully.
1915:          		//Go ahead and call the user specified callback function, to use/consume
1916:          		//the control transfer data (ex: if the "void (*function)" parameter
1917:          		//was non-NULL when USBEP0Receive() was called).
1918:                  if(outPipes[0].pFunc != NULL)
1919:                  {
1920:                      #if defined(__XC8)
1921:                          //Special pragmas to suppress an expected/harmless warning
1922:                          //message when building with the XC8 compiler
1923:                          #pragma warning push
1924:                          #pragma warning disable 1088
1925:                          outPipes[0].pFunc();    //Call the user's callback function
1926:                          #pragma warning pop
1927:                      #else
1928:                          outPipes[0].pFunc();    //Call the user's callback function
1929:                      #endif
1930:                  }
1931:                  outPipes[0].info.bits.busy = 0;
0FF4  0022     MOVLB 0x2
0FF5  13A2     BCF 0x122, 0x7
1932:          
1933:                  //Ready to arm status stage IN transaction now, if the application
1934:                  //firmware has completed processing the request.  If it is still busy
1935:                  //and needs more time to finish handling the request, then the user
1936:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1937:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1938:                  //this case, it is the application's firmware responsibility to call
1939:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1940:                  //Note: The application firmware must process the request and call
1941:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1942:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1943:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1944:                  //more details.
1945:                  if(USBDeferStatusStagePacket == false)
0FF6  0021     MOVLB 0x1
0FF7  084A     MOVF USBDeferStatusStagePacket, W
0FF8  1D03     BTFSS STATUS, 0x2
0FF9  2FFB     GOTO 0x7FB
0FFA  2FFC     GOTO 0x7FC
0FFB  2FFF     GOTO 0x7FF
1946:                  {
1947:                      USBCtrlEPAllowStatusStage();
0FFC  318B     MOVLP 0xB
0FFD  23C5     CALL 0x3C5
0FFE  318F     MOVLP 0xF
1948:                  }
1949:              }
1950:          
1951:          }//end USBCtrlTrfRxService
0FFF  0008     RETURN
1952:          
1953:          
1954:          /********************************************************************
1955:           * Function:        void USBStdSetCfgHandler(void)
1956:           *
1957:           * PreCondition:    None
1958:           *
1959:           * Input:           None
1960:           *
1961:           * Output:          None
1962:           *
1963:           * Side Effects:    None
1964:           *
1965:           * Overview:        This routine first disables all endpoints by
1966:           *                  clearing UEP registers. It then configures
1967:           *                  (initializes) endpoints by calling the callback
1968:           *                  function USBCBInitEP().
1969:           *
1970:           * Note:            None
1971:           *******************************************************************/
1972:          static void USBStdSetCfgHandler(void)
1973:          {
1974:              uint8_t i;
1975:          
1976:              // This will generate a zero length packet
1977:              inPipes[0].info.bits.busy = 1;
0DAD  0021     MOVLB 0x1
0DAE  17BA     BSF 0xBA, 0x7
1978:          
1979:              //Clear all of the endpoint control registers
1980:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0DAF  300E     MOVLW 0xE
0DB0  00E1     MOVWF pUEP
0DB1  3099     MOVLW 0x99
0DB2  00E0     MOVWF p
0DB3  01E2     CLRF i
0DB4  0860     MOVF p, W
0DB5  0086     MOVWF FSR1L
0DB6  0861     MOVF pUEP, W
0DB7  0087     MOVWF FSR1H
0DB8  0181     CLRF INDF1
0DB9  3001     MOVLW 0x1
0DBA  07E0     ADDWF p, F
0DBB  3000     MOVLW 0x0
0DBC  3DE1     ADDWFC pUEP, F
0DBD  3001     MOVLW 0x1
0DBE  00DF     MOVWF 0xDF
0DBF  085F     MOVF 0xDF, W
0DC0  07E2     ADDWF i, F
0DC1  3003     MOVLW 0x3
0DC2  0262     SUBWF i, W
0DC3  1C03     BTFSS STATUS, 0x0
0DC4  2DC6     GOTO 0x5C6
0DC5  2DC7     GOTO 0x5C7
0DC6  2DB4     GOTO 0x5B4
1981:          
1982:              //Clear all of the BDT entries
1983:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
0DC7  3020     MOVLW 0x20
0DC8  00F0     MOVWF 0xF0
0DC9  3000     MOVLW 0x0
0DCA  00F1     MOVWF 0xF1
0DCB  3000     MOVLW 0x0
0DCC  00F2     MOVWF 0xF2
0DCD  00F3     MOVWF 0xF3
0DCE  3040     MOVLW 0x40
0DCF  00F4     MOVWF 0xF4
0DD0  3000     MOVLW 0x0
0DD1  00F5     MOVWF 0xF5
0DD2  3186     MOVLP 0x6
0DD3  2611     CALL 0x611
0DD4  318D     MOVLP 0xD
1984:          
1985:              // Assert reset request to all of the Ping Pong buffer pointers
1986:              USBPingPongBufferReset = 1;
0DD5  003D     MOVLB 0x1D
0DD6  170E     BSF UCON, 0x6
1987:          
1988:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1989:          	//the EVEN buffer being the next one that will be used), since we are also
1990:          	//doing a hardware ping pong pointer reset above.
1991:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0DD7  0021     MOVLB 0x1
0DD8  01E3     CLRF i
1992:          	{
1993:          		ep_data_in[i].Val = 0u;
0DD9  0863     MOVF i, W
0DDA  3EB0     ADDLW 0xB0
0DDB  0086     MOVWF FSR1L
0DDC  3001     MOVLW 0x1
0DDD  0087     MOVWF FSR1H
0DDE  0181     CLRF INDF1
1994:                  ep_data_out[i].Val = 0u;
0DDF  0863     MOVF i, W
0DE0  3EAC     ADDLW 0xAC
0DE1  0086     MOVWF FSR1L
0DE2  3001     MOVLW 0x1
0DE3  0087     MOVWF FSR1H
0DE4  0181     CLRF INDF1
1995:          	}
0DE5  3001     MOVLW 0x1
0DE6  00DF     MOVWF 0xDF
0DE7  085F     MOVF 0xDF, W
0DE8  07E3     ADDWF i, F
0DE9  3004     MOVLW 0x4
0DEA  0263     SUBWF i, W
0DEB  1C03     BTFSS STATUS, 0x0
0DEC  2DEE     GOTO 0x5EE
0DED  2DEF     GOTO 0x5EF
0DEE  2DD9     GOTO 0x5D9
1996:          
1997:              //clear the alternate interface settings
1998:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0DEF  30BD     MOVLW 0xBD
0DF0  00F0     MOVWF 0xF0
0DF1  3001     MOVLW 0x1
0DF2  00F1     MOVWF 0xF1
0DF3  3000     MOVLW 0x0
0DF4  00F2     MOVWF 0xF2
0DF5  00F3     MOVWF 0xF3
0DF6  3003     MOVLW 0x3
0DF7  00F4     MOVWF 0xF4
0DF8  3000     MOVLW 0x0
0DF9  00F5     MOVWF 0xF5
0DFA  3186     MOVLP 0x6
0DFB  2611     CALL 0x611
0DFC  318D     MOVLP 0xD
1999:          
2000:              //Stop trying to reset ping pong buffer pointers
2001:              USBPingPongBufferReset = 0;
0DFD  003D     MOVLB 0x1D
0DFE  130E     BCF UCON, 0x6
2002:          
2003:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0DFF  3028     MOVLW 0x28
0E00  0021     MOVLB 0x1
0E01  00B0     MOVWF pBDTEntryIn
0E02  3000     MOVLW 0x0
0E03  00B1     MOVWF 0xB1
2004:          
2005:          	//Set the next out to the current out packet
2006:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0E04  3020     MOVLW 0x20
0E05  00DF     MOVWF 0xDF
0E06  085F     MOVF 0xDF, W
0E07  00D3     MOVWF pBDTEntryEP0OutCurrent
2007:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0E08  0853     MOVF pBDTEntryEP0OutCurrent, W
0E09  00C1     MOVWF pBDTEntryEP0OutNext
0E0A  39FF     ANDLW 0xFF
0E0B  1D03     BTFSS STATUS, 0x2
0E0C  3000     MOVLW 0x0
0E0D  00C2     MOVWF 0xC2
2008:          
2009:              //set the current configuration
2010:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0E0E  0020     MOVLB 0x0
0E0F  0862     MOVF 0x62, W
0E10  0021     MOVLB 0x1
0E11  00DF     MOVWF 0xDF
0E12  085F     MOVF 0xDF, W
0E13  00D8     MOVWF USBActiveConfiguration
2011:          
2012:              //if the configuration value == 0
2013:              if(USBActiveConfiguration == 0)
0E14  0858     MOVF USBActiveConfiguration, W
0E15  1D03     BTFSS STATUS, 0x2
0E16  2E18     GOTO 0x618
0E17  2E19     GOTO 0x619
0E18  2E1E     GOTO 0x61E
2014:              {
2015:                  //Go back to the addressed state
2016:                  USBDeviceState = ADDRESS_STATE;
0E19  3010     MOVLW 0x10
0E1A  00DF     MOVWF 0xDF
0E1B  085F     MOVF 0xDF, W
0E1C  00D4     MOVWF USBDeviceState
2017:              }
0E1D  2E32     GOTO 0x632
2018:              else
2019:              {
2020:                  //initialize the required endpoints
2021:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0E1E  3001     MOVLW 0x1
0E1F  00D9     MOVWF __pcstackBANK1
0E20  3000     MOVLW 0x0
0E21  00DA     MOVWF 0xDA
0E22  30D8     MOVLW 0xD8
0E23  00DB     MOVWF pdata
0E24  3000     MOVLW 0x0
0E25  00DC     MOVWF 0xDC
0E26  3001     MOVLW 0x1
0E27  00DD     MOVWF size
0E28  3000     MOVLW 0x0
0E29  00DE     MOVWF 0xDE
0E2A  3189     MOVLP 0x9
0E2B  21B4     CALL 0x1B4
0E2C  318D     MOVLP 0xD
2022:          
2023:                  //Otherwise go to the configured state.  Update the state variable last,
2024:                  //after performing all of the set configuration related initialization
2025:                  //tasks.
2026:                  USBDeviceState = CONFIGURED_STATE;
0E2D  3020     MOVLW 0x20
0E2E  0021     MOVLB 0x1
0E2F  00DF     MOVWF 0xDF
0E30  085F     MOVF 0xDF, W
0E31  00D4     MOVWF USBDeviceState
2027:              }//end if(SetupPkt.bConfigurationValue == 0)
2028:          }//end USBStdSetCfgHandler
0E32  0008     RETURN
2029:          
2030:          
2031:          /********************************************************************
2032:           * Function:        void USBStdGetDscHandler(void)
2033:           *
2034:           * PreCondition:    None
2035:           *
2036:           * Input:           None
2037:           *
2038:           * Output:          None
2039:           *
2040:           * Side Effects:    None
2041:           *
2042:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2043:           *                  request.
2044:           *
2045:           * Note:            None
2046:           *******************************************************************/
2047:          static void USBStdGetDscHandler(void)
2048:          {
2049:              if(SetupPkt.bmRequestType == 0x80)
0D28  3080     MOVLW 0x80
0D29  0020     MOVLB 0x0
0D2A  0660     XORWF SetupPkt, W
0D2B  1D03     BTFSS STATUS, 0x2
0D2C  2D2E     GOTO 0x52E
0D2D  2D2F     GOTO 0x52F
0D2E  2DAC     GOTO 0x5AC
2050:              {
2051:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0D2F  30C0     MOVLW 0xC0
0D30  00F0     MOVWF __pcstackCOMMON
0D31  0870     MOVF __pcstackCOMMON, W
0D32  0021     MOVLB 0x1
0D33  00BA     MOVWF 0xBA
2052:          
2053:                  switch(SetupPkt.bDescriptorType)
0D34  2D98     GOTO 0x598
2054:                  {
2055:                      case USB_DESCRIPTOR_DEVICE:
2056:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2057:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2058:                          #else
2059:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0D35  304E     MOVLW 0x4E
0D36  0021     MOVLB 0x1
0D37  00B8     MOVWF inPipes
0D38  3098     MOVLW 0x98
0D39  00B9     MOVWF 0xB9
2060:                          #endif
2061:                          inPipes[0].wCount.Val = sizeof(device_dsc);
0D3A  3012     MOVLW 0x12
0D3B  00BB     MOVWF 0xBB
0D3C  3000     MOVLW 0x0
0D3D  00BC     MOVWF 0xBC
2062:                          break;
0D3E  2DAC     GOTO 0x5AC
2063:                      case USB_DESCRIPTOR_CONFIGURATION:
2064:                          //First perform error case check, to make sure the host is requesting a
2065:                          //legal descriptor index.  If the request index is illegal, don't do
2066:                          //anything (so that the default STALL response will be sent).
2067:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0D3F  0862     MOVF i, W
0D40  1D03     BTFSS STATUS, 0x2
0D41  2D43     GOTO 0x543
0D42  2D44     GOTO 0x544
0D43  2D73     GOTO 0x573
2068:                          {
2069:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2070:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2071:                              #else
2072:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0D44  0862     MOVF i, W
0D45  00F0     MOVWF 0xF0
0D46  01F1     CLRF 0xF1
0D47  35F0     LSLF 0xF0, F
0D48  0DF1     RLF 0xF1, F
0D49  306A     MOVLW 0x6A
0D4A  0770     ADDWF 0xF0, W
0D4B  0084     MOVWF FSR0L
0D4C  3098     MOVLW 0x98
0D4D  3D71     ADDWFC 0xF1, W
0D4E  0085     MOVWF FSR0H
0D4F  3F00     MOVIW 0[FSR0]
0D50  0021     MOVLB 0x1
0D51  00B8     MOVWF inPipes
0D52  3F01     MOVIW 1[FSR0]
0D53  00B9     MOVWF 0xB9
2073:                              #endif
2074:          
2075:                              //This must be loaded using byte addressing.  The source pointer
2076:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2077:                              //  in an address error on the dereference.
2078:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0D54  0839     MOVF 0xB9, W
0D55  00F1     MOVWF 0xF1
0D56  0838     MOVF inPipes, W
0D57  00F0     MOVWF 0xF0
0D58  3002     MOVLW 0x2
0D59  0770     ADDWF 0xF0, W
0D5A  0084     MOVWF FSR0L
0D5B  0871     MOVF 0xF1, W
0D5C  1803     BTFSC STATUS, 0x0
0D5D  0A71     INCF 0xF1, W
0D5E  0085     MOVWF FSR0H
0D5F  0800     MOVF INDF0, W
0D60  00F2     MOVWF 0xF2
0D61  0872     MOVF 0xF2, W
0D62  00BB     MOVWF 0xBB
2079:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0D63  0839     MOVF 0xB9, W
0D64  00F1     MOVWF 0xF1
0D65  0838     MOVF inPipes, W
0D66  00F0     MOVWF 0xF0
0D67  3003     MOVLW 0x3
0D68  0770     ADDWF 0xF0, W
0D69  0084     MOVWF FSR0L
0D6A  0871     MOVF 0xF1, W
0D6B  1803     BTFSC STATUS, 0x0
0D6C  0A71     INCF 0xF1, W
0D6D  0085     MOVWF FSR0H
0D6E  0800     MOVF INDF0, W
0D6F  00F2     MOVWF 0xF2
0D70  0872     MOVF 0xF2, W
0D71  00BC     MOVWF 0xBC
2080:                          }
0D72  2DAC     GOTO 0x5AC
2081:          				else
2082:          				{
2083:          					inPipes[0].info.Val = 0;
0D73  0021     MOVLB 0x1
0D74  01BA     CLRF 0xBA
0D75  2DAC     GOTO 0x5AC
2084:          				}
2085:                          break;
2086:                      case USB_DESCRIPTOR_STRING:
2087:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2088:                          //  later it is now mandatory.  This should be defined in usb_config.h and should
2089:                          //  indicate the number of string descriptors.
2090:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0D76  3003     MOVLW 0x3
0D77  0262     SUBWF i, W
0D78  1803     BTFSC STATUS, 0x0
0D79  2D7B     GOTO 0x57B
0D7A  2D7C     GOTO 0x57C
0D7B  2D73     GOTO 0x573
2091:                          {
2092:                              //Get a pointer to the String descriptor requested
2093:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0D7C  0862     MOVF i, W
0D7D  00F0     MOVWF 0xF0
0D7E  01F1     CLRF 0xF1
0D7F  35F0     LSLF 0xF0, F
0D80  0DF1     RLF 0xF1, F
0D81  3060     MOVLW 0x60
0D82  0770     ADDWF 0xF0, W
0D83  0084     MOVWF FSR0L
0D84  3098     MOVLW 0x98
0D85  3D71     ADDWFC 0xF1, W
0D86  0085     MOVWF FSR0H
0D87  3F00     MOVIW 0[FSR0]
0D88  0021     MOVLB 0x1
0D89  00B8     MOVWF inPipes
0D8A  3F01     MOVIW 1[FSR0]
0D8B  00B9     MOVWF 0xB9
2094:                              // Set data count
2095:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
0D8C  0838     MOVF inPipes, W
0D8D  0084     MOVWF FSR0L
0D8E  0839     MOVF 0xB9, W
0D8F  0085     MOVWF FSR0H
0D90  0800     MOVF INDF0, W
0D91  00F0     MOVWF 0xF0
0D92  01F1     CLRF 0xF1
0D93  0870     MOVF 0xF0, W
0D94  00BB     MOVWF 0xBB
0D95  0871     MOVF 0xF1, W
0D96  00BC     MOVWF 0xBC
2096:                          }
0D97  2DAC     GOTO 0x5AC
2097:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2098:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2099:                          {
2100:                              //Get a pointer to the special MS OS string descriptor requested
2101:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2102:                              // Set data count
2103:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
2104:                          }
2105:                          #endif
2106:                          else
2107:                          {
2108:                              inPipes[0].info.Val = 0;
2109:                          }
2110:                          break;
2111:                      default:
2112:                          inPipes[0].info.Val = 0;
2113:                          break;
2114:                  }//end switch
0D98  0020     MOVLB 0x0
0D99  0863     MOVF 0x63, W
0D9A  00F0     MOVWF __pcstackCOMMON
0D9B  01F1     CLRF p
0D9C  0871     MOVF p, W
0D9D  3A00     XORLW 0x0
0D9E  1903     BTFSC STATUS, 0x2
0D9F  2DA1     GOTO 0x5A1
0DA0  2D73     GOTO 0x573
0DA1  0870     MOVF __pcstackCOMMON, W
0DA2  3A01     XORLW 0x1
0DA3  1903     BTFSC STATUS, 0x2
0DA4  2D35     GOTO 0x535
0DA5  3A03     XORLW 0x3
0DA6  1903     BTFSC STATUS, 0x2
0DA7  2D3F     GOTO 0x53F
0DA8  3A01     XORLW 0x1
0DA9  1903     BTFSC STATUS, 0x2
0DAA  2D76     GOTO 0x576
0DAB  2D73     GOTO 0x573
2115:              }//end if
2116:          }//end USBStdGetDscHandler
0DAC  0008     RETURN
2117:          
2118:          /********************************************************************
2119:           * Function:        void USBStdGetStatusHandler(void)
2120:           *
2121:           * PreCondition:    None
2122:           *
2123:           * Input:           None
2124:           *
2125:           * Output:          None
2126:           *
2127:           * Side Effects:    None
2128:           *
2129:           * Overview:        This routine handles the standard GET_STATUS request
2130:           *
2131:           * Note:            None
2132:           *******************************************************************/
2133:          static void USBStdGetStatusHandler(void)
2134:          {
2135:              CtrlTrfData[0] = 0;                 // Initialize content
0B58  0020     MOVLB 0x0
0B59  01E8     CLRF CtrlTrfData
2136:              CtrlTrfData[1] = 0;
0B5A  01E9     CLRF 0x69
2137:          
2138:              switch(SetupPkt.Recipient)
0B5B  2BA2     GOTO 0x3A2
2139:              {
2140:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2141:                      inPipes[0].info.bits.busy = 1;
0B5C  0021     MOVLB 0x1
0B5D  17BA     BSF 0xBA, 0x7
2142:                      /*
2143:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2144:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2145:                       */
2146:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2147:                      {
2148:                          CtrlTrfData[0]|=0x01;
2149:                      }
2150:          
2151:                      if(RemoteWakeup == true)
0B5E  034F     DECF RemoteWakeup, W
0B5F  1D03     BTFSS STATUS, 0x2
0B60  2B62     GOTO 0x362
0B61  2B63     GOTO 0x363
0B62  2BB6     GOTO 0x3B6
2152:                      {
2153:                          CtrlTrfData[0]|=0x02;
0B63  0020     MOVLB 0x0
0B64  14E8     BSF CtrlTrfData, 0x1
0B65  2BB6     GOTO 0x3B6
2154:                      }
2155:                      break;
2156:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2157:                      inPipes[0].info.bits.busy = 1;     // No data to update
0B66  0021     MOVLB 0x1
0B67  17BA     BSF 0xBA, 0x7
2158:                      break;
0B68  2BB6     GOTO 0x3B6
2159:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2160:                      inPipes[0].info.bits.busy = 1;
0B69  0021     MOVLB 0x1
0B6A  17BA     BSF 0xBA, 0x7
2161:                      /*
2162:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2163:                       */
2164:                      if(SetupPkt.EPNum != 0)
0B6B  0020     MOVLB 0x0
0B6C  0864     MOVF 0x64, W
0B6D  390F     ANDLW 0xF
0B6E  3A00     XORLW 0x0
0B6F  1903     BTFSC STATUS, 0x2
0B70  2B72     GOTO 0x372
0B71  2B73     GOTO 0x373
0B72  2BB6     GOTO 0x3B6
2165:                      {
2166:                          BDT_ENTRY *p;
2167:          
2168:                          if(SetupPkt.EPDir == 0)
0B73  1BE4     BTFSC 0x64, 0x7
0B74  2B76     GOTO 0x376
0B75  2B77     GOTO 0x377
0B76  2B83     GOTO 0x383
2169:                          {
2170:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0B77  0864     MOVF 0x64, W
0B78  390F     ANDLW 0xF
0B79  0709     ADDWF WREG, W
0B7A  3EA0     ADDLW 0xA0
0B7B  0086     MOVWF FSR1
0B7C  3001     MOVLW 0x1
0B7D  0087     MOVWF FSR1H
0B7E  3F40     MOVIW 0[FSR1]
0B7F  00F2     MOVWF led
0B80  3F41     MOVIW 1[FSR1]
0B81  00F3     MOVWF i
2171:                          }
0B82  2B8D     GOTO 0x38D
2172:                          else
2173:                          {
2174:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0B83  0864     MOVF 0x64, W
0B84  390F     ANDLW 0xF
0B85  0709     ADDWF WREG, W
0B86  3EB0     ADDLW 0xB0
0B87  0086     MOVWF FSR1
0B88  0187     CLRF FSR1H
0B89  3F40     MOVIW 0[FSR1]
0B8A  00F2     MOVWF led
0B8B  3F41     MOVIW 1[FSR1]
0B8C  00F3     MOVWF i
2175:                          }
2176:          
2177:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
0B8D  0872     MOVF led, W
0B8E  0086     MOVWF FSR1
0B8F  0873     MOVF i, W
0B90  0087     MOVWF FSR1H
0B91  1F81     BTFSS INDF1, 0x7
0B92  2B94     GOTO 0x394
0B93  2B95     GOTO 0x395
0B94  2BB6     GOTO 0x3B6
0B95  0872     MOVF led, W
0B96  0086     MOVWF FSR1
0B97  0873     MOVF i, W
0B98  0087     MOVWF FSR1H
0B99  1D01     BTFSS INDF1, 0x2
0B9A  2B9C     GOTO 0x39C
0B9B  2B9D     GOTO 0x39D
0B9C  2BB6     GOTO 0x3B6
2178:                          {
2179:                              CtrlTrfData[0]=0x01;    // Set bit0
0B9D  3001     MOVLW 0x1
0B9E  00F0     MOVWF __pcstackCOMMON
0B9F  0870     MOVF __pcstackCOMMON, W
0BA0  00E8     MOVWF CtrlTrfData
0BA1  2BB6     GOTO 0x3B6
2180:                          }
2181:                      }
2182:                      break;
2183:              }//end switch
0BA2  0860     MOVF SetupPkt, W
0BA3  391F     ANDLW 0x1F
0BA4  00F0     MOVWF __pcstackCOMMON
0BA5  01F1     CLRF p
0BA6  0871     MOVF p, W
0BA7  3A00     XORLW 0x0
0BA8  1903     BTFSC STATUS, 0x2
0BA9  2BAB     GOTO 0x3AB
0BAA  2BB6     GOTO 0x3B6
0BAB  0870     MOVF __pcstackCOMMON, W
0BAC  3A00     XORLW 0x0
0BAD  1903     BTFSC STATUS, 0x2
0BAE  2B5C     GOTO 0x35C
0BAF  3A01     XORLW 0x1
0BB0  1903     BTFSC STATUS, 0x2
0BB1  2B66     GOTO 0x366
0BB2  3A03     XORLW 0x3
0BB3  1903     BTFSC STATUS, 0x2
0BB4  2B69     GOTO 0x369
0BB5  2BB6     GOTO 0x3B6
2184:          
2185:              if(inPipes[0].info.bits.busy == 1)
0BB6  0021     MOVLB 0x1
0BB7  1FBA     BTFSS 0xBA, 0x7
0BB8  2BBA     GOTO 0x3BA
0BB9  2BBB     GOTO 0x3BB
0BBA  2BC4     GOTO 0x3C4
2186:              {
2187:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
0BBB  3068     MOVLW 0x68
0BBC  00B8     MOVWF inPipes
0BBD  3000     MOVLW 0x0
0BBE  00B9     MOVWF 0xB9
2188:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
0BBF  143A     BSF 0xBA, 0x0
2189:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
0BC0  3002     MOVLW 0x2
0BC1  00F0     MOVWF 0xF0
0BC2  0870     MOVF 0xF0, W
0BC3  00BB     MOVWF 0xBB
2190:              }//end if(...)
2191:          }//end USBStdGetStatusHandler
0BC4  0008     RETURN
2192:          
2193:          /********************************************************************
2194:           * Function:        void USBStallHandler(void)
2195:           *
2196:           * PreCondition:    None
2197:           *
2198:           * Input:           None
2199:           *
2200:           * Output:          None
2201:           *
2202:           * Side Effects:
2203:           *
2204:           * Overview:        This function handles the event of a STALL
2205:           *                  occurring on the bus
2206:           *
2207:           * Note:            None
2208:           *******************************************************************/
2209:          static void USBStallHandler(void)
2210:          {
2211:              /*
2212:               * Does not really have to do anything here,
2213:               * even for the control endpoint.
2214:               * All BDs of Endpoint 0 are owned by SIE right now,
2215:               * but once a Setup Transaction is received, the ownership
2216:               * for EP0_OUT will be returned to CPU.
2217:               * When the Setup Transaction is serviced, the ownership
2218:               * for EP0_IN will then be forced back to CPU by firmware.
2219:               */
2220:          
2221:              if(U1EP0bits.EPSTALL == 1)
08AA  003D     MOVLB 0x1D
08AB  1C18     BTFSS UEP0, 0x0
08AC  28AE     GOTO 0xAE
08AD  28AF     GOTO 0xAF
08AE  28D0     GOTO 0xD0
2222:              {
2223:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2224:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
08AF  0021     MOVLB 0x1
08B0  0853     MOVF pBDTEntryEP0OutCurrent, W
08B1  0086     MOVWF FSR1L
08B2  0187     CLRF FSR1H
08B3  3080     MOVLW 0x80
08B4  0601     XORWF INDF1, W
08B5  1D03     BTFSS STATUS, 0x2
08B6  28B8     GOTO 0xB8
08B7  28B9     GOTO 0xB9
08B8  28CE     GOTO 0xCE
08B9  0830     MOVF pBDTEntryIn, W
08BA  0086     MOVWF FSR1L
08BB  0831     MOVF 0xB1, W
08BC  0087     MOVWF FSR1H
08BD  3084     MOVLW 0x84
08BE  0601     XORWF INDF1, W
08BF  1D03     BTFSS STATUS, 0x2
08C0  28C2     GOTO 0xC2
08C1  28C3     GOTO 0xC3
08C2  28CE     GOTO 0xCE
2225:                  {
2226:                      // Set ep0Bo to stall also
2227:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
08C3  300C     MOVLW 0xC
08C4  00F0     MOVWF 0xF0
08C5  0853     MOVF pBDTEntryEP0OutCurrent, W
08C6  0086     MOVWF FSR1L
08C7  0187     CLRF FSR1H
08C8  0870     MOVF 0xF0, W
08C9  0081     MOVWF INDF1
2228:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
08CA  0853     MOVF pBDTEntryEP0OutCurrent, W
08CB  0086     MOVWF FSR1L
08CC  0187     CLRF FSR1H
08CD  1781     BSF INDF1, 0x7
2229:                  }//end if
2230:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
08CE  003D     MOVLB 0x1D
08CF  1018     BCF UEP0, 0x0
2231:              }//end if
2232:          
2233:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
08D0  30DF     MOVLW 0xDF
08D1  00F0     MOVWF 0xEF0
08D2  0870     MOVF 0xEF0, W
08D3  0590     ANDWF UIR, F
2234:          }
08D4  0008     RETURN
2235:          
2236:          /********************************************************************
2237:           * Function:        void USBSuspend(void)
2238:           *
2239:           * PreCondition:    None
2240:           *
2241:           * Input:           None
2242:           *
2243:           * Output:          None
2244:           *
2245:           * Side Effects:
2246:           *
2247:           * Overview:        This function handles if the host tries to
2248:           *                  suspend the device
2249:           *
2250:           * Note:            None
2251:           *******************************************************************/
2252:          static void USBSuspend(void)
2253:          {
2254:              /*
2255:               * NOTE: Do not clear UIRbits.ACTVIF here!
2256:               * Reason:
2257:               * ACTVIF is only generated once an IDLEIF has been generated.
2258:               * This is a 1:1 ratio interrupt generation.
2259:               * For every IDLEIF, there will be only one ACTVIF regardless of
2260:               * the number of subsequent bus transitions.
2261:               *
2262:               * If the ACTIF is cleared here, a problem could occur when:
2263:               * [       IDLE       ][bus activity ->
2264:               * <--- 3 ms ----->     ^
2265:               *                ^     ACTVIF=1
2266:               *                IDLEIF=1
2267:               *  #           #           #           #   (#=Program polling flags)
2268:               *                          ^
2269:               *                          This polling loop will see both
2270:               *                          IDLEIF=1 and ACTVIF=1.
2271:               *                          However, the program services IDLEIF first
2272:               *                          because ACTIVIE=0.
2273:               *                          If this routine clears the only ACTIVIF,
2274:               *                          then it can never get out of the suspend
2275:               *                          mode.
2276:               */
2277:              USBActivityIE = 1;                     // Enable bus activity interrupt
1763  003D     MOVLB 0x1D
1764  1512     BSF UIE, 0x2
2278:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1765  30EF     MOVLW 0xEF
1766  0021     MOVLB 0x1
1767  00DF     MOVWF 0xDF
1768  085F     MOVF 0xDF, W
1769  003D     MOVLB 0x1D
176A  0590     ANDWF UIR, F
2279:          
2280:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2281:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
176B  148E     BSF UCON, 0x1
2282:                                                          // mode, SIE clock inactive
2283:              #endif
2284:              USBBusIsSuspended = true;
176C  0021     MOVLB 0x1
176D  01CE     CLRF USBBusIsSuspended
176E  0ACE     INCF USBBusIsSuspended, F
2285:              USBTicksSinceSuspendEnd = 0;
176F  01C5     CLRF USBTicksSinceSuspendEnd
2286:          
2287:              /*
2288:               * At this point the PIC can go into sleep,idle, or
2289:               * switch to a slower clock, etc.  This should be done in the
2290:               * USBCBSuspend() if necessary.
2291:               */
2292:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
1770  3075     MOVLW 0x75
1771  00D9     MOVWF __pcstackBANK1
1772  3000     MOVLW 0x0
1773  00DA     MOVWF 0xDA
1774  3000     MOVLW 0x0
1775  00DB     MOVWF pdata
1776  3000     MOVLW 0x0
1777  00DC     MOVWF 0xDC
1778  3000     MOVLW 0x0
1779  00DD     MOVWF size
177A  00DE     MOVWF 0xDE
177B  3189     MOVLP 0x9
177C  21B4     CALL 0x1B4
177D  3197     MOVLP 0x17
2293:          }
177E  0008     RETURN
2294:          
2295:          /********************************************************************
2296:           * Function:        void USBWakeFromSuspend(void)
2297:           *
2298:           * PreCondition:    None
2299:           *
2300:           * Input:           None
2301:           *
2302:           * Output:          None
2303:           *
2304:           * Side Effects:    None
2305:           *
2306:           * Overview:
2307:           *
2308:           * Note:            None
2309:           *******************************************************************/
2310:          static void USBWakeFromSuspend(void)
2311:          {
2312:              USBBusIsSuspended = false;
17BD  0021     MOVLB 0x1
17BE  01CE     CLRF USBBusIsSuspended
2313:          
2314:              /*
2315:               * If using clock switching, the place to restore the original
2316:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2317:               */
2318:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
17BF  3074     MOVLW 0x74
17C0  00D9     MOVWF __pcstackBANK1
17C1  3000     MOVLW 0x0
17C2  00DA     MOVWF 0xDA
17C3  3000     MOVLW 0x0
17C4  00DB     MOVWF pdata
17C5  3000     MOVLW 0x0
17C6  00DC     MOVWF 0xDC
17C7  3000     MOVLW 0x0
17C8  00DD     MOVWF size
17C9  00DE     MOVWF 0xDE
17CA  3189     MOVLP 0x9
17CB  21B4     CALL 0x1B4
17CC  3197     MOVLP 0x17
2319:          
2320:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2321:                  //To avoid improperly clocking the USB module, make sure the oscillator
2322:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2323:                  //Make sure the correct oscillator settings are selected in the
2324:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2325:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
17CD  003D     MOVLB 0x1D
17CE  108E     BCF UCON, 0x1
2326:                                          // mode.
2327:              #endif
2328:          
2329:          
2330:              USBActivityIE = 0;
17CF  1112     BCF UIE, 0x2
2331:          
2332:              /********************************************************************
2333:              Bug Fix: Feb 26, 2007 v2.1
2334:              *********************************************************************
2335:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2336:              up from Suspend or while the USB module is suspended. A few clock cycles
2337:              are required to synchronize the internal hardware state machine before
2338:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2339:              before the internal hardware is synchronized may not have an effect on
2340:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2341:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2342:              module may not be immediately operational while waiting for the 96 MHz
2343:              PLL to lock.
2344:              ********************************************************************/
2345:          
2346:              // UIRbits.ACTVIF = 0;                      // Removed
2347:              #if defined(__18CXX) || defined(__XC8)
2348:              while(USBActivityIF)
17D0  2FD7     GOTO 0x7D7
17D7  1910     BTFSC UIR, 0x2
17D8  2FDA     GOTO 0x7DA
17D9  2FDB     GOTO 0x7DB
17DA  2FD1     GOTO 0x7D1
2349:              #endif
2350:              {
2351:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
17D1  30FB     MOVLW 0xFB
17D2  0021     MOVLB 0x1
17D3  00DF     MOVWF 0xDF
17D4  085F     MOVF 0xDF, W
17D5  003D     MOVLB 0x1D
17D6  0590     ANDWF UIR, F
2352:              }  // Added
2353:          
2354:              USBTicksSinceSuspendEnd = 0;
17DB  0021     MOVLB 0x1
17DC  01C5     CLRF USBTicksSinceSuspendEnd
2355:          
2356:          }//end USBWakeFromSuspend
17DD  0008     RETURN
2357:          
2358:          /********************************************************************
2359:           * Function:        void USBCtrlEPService(void)
2360:           *
2361:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2362:           *
2363:           * Input:           None
2364:           *
2365:           * Output:          None
2366:           *
2367:           * Side Effects:    None
2368:           *
2369:           * Overview:        USBCtrlEPService checks for three transaction
2370:           *                  types that it knows how to service and services
2371:           *                  them:
2372:           *                  1. EP0 SETUP
2373:           *                  2. EP0 OUT
2374:           *                  3. EP0 IN
2375:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2376:           *
2377:           * Note:            None
2378:           *******************************************************************/
2379:          static void USBCtrlEPService(void)
2380:          {
2381:              //If we get to here, that means a successful transaction has just occurred
2382:              //on EP0.  This means "progress" has occurred in the currently pending
2383:              //control transfer, so we should re-initialize our timeout counter.
2384:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2385:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
0A42  302D     MOVLW 0x2D
0A43  0021     MOVLB 0x1
0A44  00E9     MOVWF 0xE9
0A45  0869     MOVF 0xE9, W
0A46  00CB     MOVWF USBStatusStageTimeoutCounter
2386:              #endif
2387:          
2388:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2389:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
0A47  0857     MOVF USTATcopy, W
0A48  39FD     ANDLW 0xFD
0A49  1D03     BTFSS STATUS, 0x2
0A4A  2A4C     GOTO 0x24C
0A4B  2A4D     GOTO 0x24D
0A4C  2A89     GOTO 0x289
2390:              {
2391:          		//Point to the EP0 OUT buffer of the buffer that arrived
2392:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2393:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
0A4D  3657     LSRF USTATcopy, W
0A4E  393F     ANDLW 0x3F
0A4F  00E9     MOVWF 0xE9
0A50  3001     MOVLW 0x1
0A51  35E9     LSLF 0xE9, F
0A52  3EFF     ADDLW 0xFF
0A53  1D03     BTFSS STATUS, 0x2
0A54  2A51     GOTO 0x251
0A55  3569     LSLF 0xE9, W
0A56  3E20     ADDLW 0x20
0A57  00EA     MOVWF 0xEA
0A58  086A     MOVF 0xEA, W
0A59  00D3     MOVWF pBDTEntryEP0OutCurrent
2394:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2395:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2396:                  #else
2397:                      #error "unimplemented"
2398:                  #endif
2399:          
2400:          		//Set the next out to the current out packet
2401:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0A5A  0853     MOVF pBDTEntryEP0OutCurrent, W
0A5B  00C1     MOVWF pBDTEntryEP0OutNext
0A5C  39FF     ANDLW 0xFF
0A5D  1D03     BTFSS STATUS, 0x2
0A5E  3000     MOVLW 0x0
0A5F  00C2     MOVWF 0xC2
2402:          		//Toggle it to the next ping pong buffer (if applicable)
2403:                  pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
0A60  3004     MOVLW 0x4
0A61  0641     XORWF pBDTEntryEP0OutNext, W
0A62  00C1     MOVWF pBDTEntryEP0OutNext
0A63  3000     MOVLW 0x0
0A64  0642     XORWF 0xC2, W
0A65  00C2     MOVWF 0xC2
2404:          
2405:          		//If the current EP0 OUT buffer has a SETUP packet
2406:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
0A66  0853     MOVF pBDTEntryEP0OutCurrent, W
0A67  0086     MOVWF FSR1L
0A68  0187     CLRF FSR1H
0A69  0C01     RRF INDF1, W
0A6A  0C89     RRF WREG, F
0A6B  390F     ANDLW 0xF
0A6C  3A0D     XORLW 0xD
0A6D  1D03     BTFSS STATUS, 0x2
0A6E  2A70     GOTO 0x270
0A6F  2A71     GOTO 0x271
0A70  2A85     GOTO 0x285
2407:                  {
2408:          	        //The SETUP transaction data may have gone into the the CtrlTrfData
2409:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2410:          	        //before the transaction.  Therefore, we should copy the data to the
2411:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().
2412:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
0A71  0853     MOVF pBDTEntryEP0OutCurrent, W
0A72  3E02     ADDLW 0x2
0A73  0086     MOVWF FSR1L
0A74  0187     CLRF FSR1H
0A75  3F40     MOVIW 0[FSR1]
0A76  00F0     MOVWF 0xF0
0A77  3F41     MOVIW 1[FSR1]
0A78  00F1     MOVWF 0xF1
0A79  3008     MOVLW 0x8
0A7A  00F2     MOVWF 0xF2
0A7B  3000     MOVLW 0x0
0A7C  00F3     MOVWF 0xF3
0A7D  3060     MOVLW 0x60
0A7E  3188     MOVLP 0x8
0A7F  20D5     CALL 0xD5
0A80  318A     MOVLP 0xA
2413:          
2414:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2415:                      USBCtrlTrfSetupHandler();
0A81  3189     MOVLP 0x9
0A82  21FA     CALL 0x1FA
0A83  318A     MOVLP 0xA
2416:                  }
0A84  2A95     GOTO 0x295
2417:                  else
2418:                  {
2419:          			//Handle the DATA transfer
2420:                      USBCtrlTrfOutHandler();
0A85  3189     MOVLP 0x9
0A86  2139     CALL 0x139
0A87  318A     MOVLP 0xA
0A88  2A95     GOTO 0x295
2421:                  }
2422:              }
2423:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
0A89  30FD     MOVLW 0xFD
0A8A  0557     ANDWF USTATcopy, W
0A8B  00E9     MOVWF 0xE9
0A8C  3004     MOVLW 0x4
0A8D  0669     XORWF 0xE9, W
0A8E  1D03     BTFSS STATUS, 0x2
0A8F  2A91     GOTO 0x291
0A90  2A92     GOTO 0x292
0A91  2A95     GOTO 0x295
2424:              {
2425:          		//Otherwise the transmission was and EP0 IN
2426:          		//  so take care of the IN transfer
2427:                  USBCtrlTrfInHandler();
0A92  3187     MOVLP 0x7
0A93  2785     CALL 0x785
0A94  318A     MOVLP 0xA
2428:              }
2429:          
2430:          }//end USBCtrlEPService
0A95  0008     RETURN
2431:          
2432:          /********************************************************************
2433:           * Function:        void USBCtrlTrfSetupHandler(void)
2434:           *
2435:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2436:           *
2437:           * Input:           None
2438:           *
2439:           * Output:          None
2440:           *
2441:           * Side Effects:    None
2442:           *
2443:           * Overview:        This routine is a task dispatcher and has 3 stages.
2444:           *                  1. It initializes the control transfer state machine.
2445:           *                  2. It calls on each of the module that may know how to
2446:           *                     service the Setup Request from the host.
2447:           *                     Module Example: USBD, HID, CDC, MSD, ...
2448:           *                     A callback function, USBCBCheckOtherReq(),
2449:           *                     is required to call other module handlers.
2450:           *                  3. Once each of the modules has had a chance to check if
2451:           *                     it is responsible for servicing the request, stage 3
2452:           *                     then checks direction of the transfer to determine how
2453:           *                     to prepare EP0 for the control transfer.
2454:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2455:           *
2456:           * Note:            Microchip USB Firmware has three different states for
2457:           *                  the control transfer state machine:
2458:           *                  1. WAIT_SETUP
2459:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2460:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2461:           *                  Refer to firmware manual to find out how one state
2462:           *                  is transitioned to another.
2463:           *
2464:           *                  A Control Transfer is composed of many USB transactions.
2465:           *                  When transferring data over multiple transactions,
2466:           *                  it is important to keep track of data source, data
2467:           *                  destination, and data count. These three parameters are
2468:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2469:           *                  note if the data source is from const or RAM.
2470:           *
2471:           *******************************************************************/
2472:          static void USBCtrlTrfSetupHandler(void)
2473:          {
2474:              //--------------------------------------------------------------------------
2475:              //1. Re-initialize state tracking variables related to control transfers.
2476:              //--------------------------------------------------------------------------
2477:              shortPacketStatus = SHORT_PKT_NOT_USED;
09FA  0021     MOVLB 0x1
09FB  01D2     CLRF shortPacketStatus
2478:              USBDeferStatusStagePacket = false;
09FC  01CA     CLRF USBDeferStatusStagePacket
2479:              USBDeferINDataStagePackets = false;
09FD  01C7     CLRF USBDeferINDataStagePackets
2480:              USBDeferOUTDataStagePackets = false;
09FE  01C6     CLRF USBDeferOUTDataStagePackets
2481:              BothEP0OutUOWNsSet = false;
09FF  01CC     CLRF BothEP0OutUOWNsSet
2482:              controlTransferState = WAIT_SETUP;
0A00  01D1     CLRF controlTransferState
2483:          
2484:              //Abandon any previous control transfers that might have been using EP0.
2485:              //Ordinarily, nothing actually needs abandoning, since the previous control
2486:              //transfer would have completed successfully prior to the host sending the next
2487:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2488:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2489:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2490:              //by the class request handler that will be called next.
2491:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
0A01  307F     MOVLW 0x7F
0A02  00E8     MOVWF 0xE8
0A03  0830     MOVF pBDTEntryIn, W
0A04  0086     MOVWF FSR1L
0A05  0831     MOVF 0xB1, W
0A06  0087     MOVWF FSR1H
0A07  0868     MOVF 0xE8, W
0A08  0581     ANDWF INDF1, F
2492:          
2493:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0A09  3004     MOVLW 0x4
0A0A  0630     XORWF pBDTEntryIn, W
0A0B  00B0     MOVWF pBDTEntryIn
0A0C  3000     MOVLW 0x0
0A0D  0631     XORWF 0xB1, W
0A0E  00B1     MOVWF 0xB1
2494:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
0A0F  307F     MOVLW 0x7F
0A10  00E8     MOVWF 0xE8
0A11  0830     MOVF pBDTEntryIn, W
0A12  0086     MOVWF FSR1L
0A13  0831     MOVF 0xB1, W
0A14  0087     MOVWF FSR1H
0A15  0868     MOVF 0xE8, W
0A16  0581     ANDWF INDF1, F
2495:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0A17  3004     MOVLW 0x4
0A18  0630     XORWF pBDTEntryIn, W
0A19  00B0     MOVWF pBDTEntryIn
0A1A  3000     MOVLW 0x0
0A1B  0631     XORWF 0xB1, W
0A1C  00B1     MOVWF 0xB1
2496:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);
0A1D  307F     MOVLW 0x7F
0A1E  00E8     MOVWF 0xE8
0A1F  0841     MOVF pBDTEntryEP0OutNext, W
0A20  0086     MOVWF FSR1L
0A21  0842     MOVF 0xC2, W
0A22  0087     MOVWF FSR1H
0A23  0868     MOVF 0xE8, W
0A24  0581     ANDWF INDF1, F
2497:          
2498:              inPipes[0].info.Val = 0;
0A25  01BA     CLRF 0xBA
2499:              inPipes[0].wCount.Val = 0;
0A26  01BB     CLRF 0xBB
0A27  01BC     CLRF 0xBC
2500:              outPipes[0].info.Val = 0;
0A28  0022     MOVLB 0x2
0A29  01A2     CLRF 0x122
2501:              outPipes[0].wCount.Val = 0;
0A2A  01A3     CLRF 0x123
0A2B  01A4     CLRF 0x124
2502:          
2503:          
2504:              //--------------------------------------------------------------------------
2505:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2506:              //--------------------------------------------------------------------------
2507:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
0A2C  318C     MOVLP 0xC
0A2D  24AC     CALL 0x4AC
0A2E  3189     MOVLP 0x9
2508:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
0A2F  3003     MOVLW 0x3
0A30  0021     MOVLB 0x1
0A31  00D9     MOVWF __pcstackBANK1
0A32  3000     MOVLW 0x0
0A33  00DA     MOVWF 0xDA
0A34  3000     MOVLW 0x0
0A35  00DB     MOVWF pdata
0A36  3000     MOVLW 0x0
0A37  00DC     MOVWF 0xDC
0A38  3000     MOVLW 0x0
0A39  00DD     MOVWF size
0A3A  00DE     MOVWF 0xDE
0A3B  3189     MOVLP 0x9
0A3C  21B4     CALL 0x1B4
0A3D  3189     MOVLP 0x9
2509:          
2510:          
2511:              //--------------------------------------------------------------------------
2512:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in
2513:              //   progress.  If one of the above handlers (in step 2) knew how to process
2514:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2515:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2516:              //   USBCtrlEPServiceComplete() function know how and which endpoints to
2517:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2518:              //   process the request.  In this case, the default behavior will be to
2519:              //   perform protocol STALL on EP0.
2520:              //--------------------------------------------------------------------------
2521:              USBCtrlEPServiceComplete();
0A3E  318E     MOVLP 0xE
0A3F  26BA     CALL 0x6BA
0A40  3189     MOVLP 0x9
2522:          }//end USBCtrlTrfSetupHandler
0A41  0008     RETURN
2523:          
2524:          
2525:          /******************************************************************************
2526:           * Function:        void USBCtrlTrfOutHandler(void)
2527:           *
2528:           * PreCondition:    None
2529:           *
2530:           * Input:           None
2531:           *
2532:           * Output:          None
2533:           *
2534:           * Side Effects:    None
2535:           *
2536:           * Overview:        This routine handles an OUT transaction according to
2537:           *                  which control transfer state is currently active.
2538:           *
2539:           * Note:            Note that if the the control transfer was from
2540:           *                  host to device, the session owner should be notified
2541:           *                  at the end of each OUT transaction to service the
2542:           *                  received data.
2543:           *
2544:           *****************************************************************************/
2545:          static void USBCtrlTrfOutHandler(void)
2546:          {
2547:              if(controlTransferState == CTRL_TRF_RX)
0939  3002     MOVLW 0x2
093A  0021     MOVLB 0x1
093B  0651     XORWF controlTransferState, W
093C  1D03     BTFSS STATUS, 0x2
093D  293F     GOTO 0x13F
093E  2940     GOTO 0x140
093F  2944     GOTO 0x144
2548:              {
2549:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
0940  318F     MOVLP 0xF
0941  2756     CALL 0x756
0942  3189     MOVLP 0x9
2550:              }
0943  2970     GOTO 0x170
2551:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2552:              {
2553:                  //If the status stage is complete, this means we are done with the
2554:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2555:                  controlTransferState = WAIT_SETUP;
0944  01D1     CLRF controlTransferState
2556:          
2557:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2558:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2559:                  //and the last control transfer was of direction: device to host, see
2560:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2561:                  //to do anything to the BDT.
2562:                  if(BothEP0OutUOWNsSet == false)
0945  084C     MOVF BothEP0OutUOWNsSet, W
0946  1D03     BTFSS STATUS, 0x2
0947  2949     GOTO 0x149
0948  294A     GOTO 0x14A
0949  296F     GOTO 0x16F
2563:                  {
2564:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
094A  0841     MOVF pBDTEntryEP0OutNext, W
094B  3E01     ADDLW 0x1
094C  00F6     MOVWF 0xF6
094D  3000     MOVLW 0x0
094E  3D42     ADDWFC 0xC2, W
094F  00F7     MOVWF 0xF7
0950  0876     MOVF 0xF6, W
0951  0086     MOVWF FSR1L
0952  0877     MOVF 0xF7, W
0953  0087     MOVWF FSR1H
0954  3008     MOVLW 0x8
0955  0081     MOVWF INDF1
2565:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0956  3060     MOVLW 0x60
0957  00F6     MOVWF 0xF6
0958  3000     MOVLW 0x0
0959  00F7     MOVWF 0xF7
095A  0841     MOVF pBDTEntryEP0OutNext, W
095B  0086     MOVWF FSR1L
095C  0842     MOVF 0xC2, W
095D  0087     MOVWF FSR1H
095E  3142     ADDFSR 1, 2
095F  0876     MOVF 0xF6, W
0960  3FC0     MOVWI 0[FSR1]
0961  0877     MOVF 0xF7, W
0962  3FC1     MOVWI 1[FSR1]
2566:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0963  0841     MOVF pBDTEntryEP0OutNext, W
0964  0086     MOVWF FSR1L
0965  0842     MOVF 0xC2, W
0966  0087     MOVWF FSR1H
0967  300C     MOVLW 0xC
0968  0081     MOVWF INDF1
2567:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0969  0841     MOVF pBDTEntryEP0OutNext, W
096A  0086     MOVWF FSR1L
096B  0842     MOVF 0xC2, W
096C  0087     MOVWF FSR1H
096D  1781     BSF INDF1, 0x7
2568:                  }
096E  2970     GOTO 0x170
2569:                  else
2570:                  {
2571:                      BothEP0OutUOWNsSet = false;
096F  01CC     CLRF BothEP0OutUOWNsSet
2572:                  }
2573:              }
2574:          }
0970  0008     RETURN
2575:          
2576:          /******************************************************************************
2577:           * Function:        void USBCtrlTrfInHandler(void)
2578:           *
2579:           * PreCondition:    None
2580:           *
2581:           * Input:           None
2582:           *
2583:           * Output:          None
2584:           *
2585:           * Side Effects:    None
2586:           *
2587:           * Overview:        This routine handles an IN transaction according to
2588:           *                  which control transfer state is currently active.
2589:           *
2590:           * Note:            A Set Address Request must not change the actual address
2591:           *                  of the device until the completion of the control
2592:           *                  transfer. The end of the control transfer for Set Address
2593:           *                  Request is an IN transaction. Therefore it is necessary
2594:           *                  to service this unique situation when the condition is
2595:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2596:           *                  usb9.h and its function is to specifically service this
2597:           *                  event.
2598:           *****************************************************************************/
2599:          static void USBCtrlTrfInHandler(void)
2600:          {
2601:              uint8_t lastDTS;
2602:          
2603:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
0785  0021     MOVLB 0x1
0786  0830     MOVF pBDTEntryIn, W
0787  0086     MOVWF FSR1L
0788  0831     MOVF 0xB1, W
0789  0087     MOVWF FSR1H
078A  3000     MOVLW 0x0
078B  1B01     BTFSC INDF1, 0x6
078C  3001     MOVLW 0x1
078D  00F5     MOVWF 0xF5
2604:          
2605:              //switch to the next ping pong buffer
2606:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
078E  3004     MOVLW 0x4
078F  0630     XORWF pBDTEntryIn, W
0790  00B0     MOVWF pBDTEntryIn
0791  3000     MOVLW 0x0
0792  0631     XORWF 0xB1, W
0793  00B1     MOVWF 0xB1
2607:          
2608:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2609:              //now, since the IN status stage of the (set address) control transfer has
2610:              //evidently completed successfully.
2611:              if(USBDeviceState == ADR_PENDING_STATE)
0794  3008     MOVLW 0x8
0795  0654     XORWF USBDeviceState, W
0796  1D03     BTFSS STATUS, 0x2
0797  2F99     GOTO 0x799
0798  2F9A     GOTO 0x79A
0799  2FAF     GOTO 0x7AF
2612:              {
2613:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
079A  0020     MOVLB 0x0
079B  0862     MOVF 0x62, W
079C  397F     ANDLW 0x7F
079D  003D     MOVLB 0x1D
079E  0096     MOVWF UADDR
2614:                  if(U1ADDR != 0u)
079F  0816     MOVF UADDR, W
07A0  1903     BTFSC STATUS, 0x2
07A1  2FA3     GOTO 0x7A3
07A2  2FA4     GOTO 0x7A4
07A3  2FAA     GOTO 0x7AA
2615:                  {
2616:                      USBDeviceState=ADDRESS_STATE;
07A4  3010     MOVLW 0x10
07A5  00F3     MOVWF 0xEF3
07A6  0873     MOVF 0xEF3, W
07A7  0021     MOVLB 0x1
07A8  00D4     MOVWF USBDeviceState
2617:                  }
07A9  2FAF     GOTO 0x7AF
2618:                  else
2619:                  {
2620:                      USBDeviceState=DEFAULT_STATE;
07AA  3004     MOVLW 0x4
07AB  00F3     MOVWF 0xF3
07AC  0873     MOVF 0xF3, W
07AD  0021     MOVLB 0x1
07AE  00D4     MOVWF USBDeviceState
2621:                  }
2622:              }//end if
2623:          
2624:          
2625:              if(controlTransferState == CTRL_TRF_TX)
07AF  0351     DECF controlTransferState, W
07B0  1D03     BTFSS STATUS, 0x2
07B1  2FB3     GOTO 0x7B3
07B2  2FB4     GOTO 0x7B4
07B3  2FF4     GOTO 0x7F4
2626:              {
2627:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
07B4  3068     MOVLW 0x68
07B5  00F3     MOVWF 0xF3
07B6  3000     MOVLW 0x0
07B7  00F4     MOVWF 0xF4
07B8  0830     MOVF pBDTEntryIn, W
07B9  0086     MOVWF FSR1L
07BA  0831     MOVF 0xB1, W
07BB  0087     MOVWF FSR1H
07BC  3142     ADDFSR 1, 2
07BD  0873     MOVF 0xF3, W
07BE  3FC0     MOVWI 0[FSR1]
07BF  0874     MOVF 0xF4, W
07C0  3FC1     MOVWI 1[FSR1]
2628:                  USBCtrlTrfTxService();
07C1  318C     MOVLP 0xC
07C2  2437     CALL 0x437
07C3  3187     MOVLP 0x7
2629:          
2630:                  //Check if we have already sent a short packet.  If so, configure
2631:                  //the endpoint to STALL in response to any further IN tokens (in the
2632:                  //case that the host erroneously tries to receive more data than it
2633:                  //should).
2634:                  if(shortPacketStatus == SHORT_PKT_SENT)
07C4  3002     MOVLW 0x2
07C5  0021     MOVLB 0x1
07C6  0652     XORWF shortPacketStatus, W
07C7  1D03     BTFSS STATUS, 0x2
07C8  2FCA     GOTO 0x7CA
07C9  2FCB     GOTO 0x7CB
07CA  2FD7     GOTO 0x7D7
2635:                  {
2636:                      // If a short packet has been sent, don't want to send any more,
2637:                      // stall next time if host is still trying to read.
2638:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
07CB  0830     MOVF pBDTEntryIn, W
07CC  0086     MOVWF FSR1L
07CD  0831     MOVF 0xB1, W
07CE  0087     MOVWF FSR1H
07CF  3004     MOVLW 0x4
07D0  0081     MOVWF INDF1
2639:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
07D1  0830     MOVF pBDTEntryIn, W
07D2  0086     MOVWF FSR1L
07D3  0831     MOVF 0xB1, W
07D4  0087     MOVWF FSR1H
07D5  1781     BSF INDF1, 0x7
2640:                  }
07D6  2FFC     GOTO 0x7FC
2641:                  else
2642:                  {
2643:                      if(lastDTS == 0)
07D7  0875     MOVF 0xF5, W
07D8  1D03     BTFSS STATUS, 0x2
07D9  2FDB     GOTO 0x7DB
07DA  2FDC     GOTO 0x7DC
07DB  2FE8     GOTO 0x7E8
2644:                      {
2645:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
07DC  0830     MOVF pBDTEntryIn, W
07DD  0086     MOVWF FSR1L
07DE  0831     MOVF 0xB1, W
07DF  0087     MOVWF FSR1H
07E0  3048     MOVLW 0x48
07E1  0081     MOVWF INDF1
2646:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
07E2  0830     MOVF pBDTEntryIn, W
07E3  0086     MOVWF FSR1L
07E4  0831     MOVF 0xB1, W
07E5  0087     MOVWF FSR1H
07E6  1781     BSF INDF1, 0x7
2647:                      }
07E7  2FFC     GOTO 0x7FC
2648:                      else
2649:                      {
2650:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
07E8  0830     MOVF pBDTEntryIn, W
07E9  0086     MOVWF FSR1L
07EA  0831     MOVF 0xB1, W
07EB  0087     MOVWF FSR1H
07EC  3008     MOVLW 0x8
07ED  0081     MOVWF INDF1
2651:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
07EE  0830     MOVF pBDTEntryIn, W
07EF  0086     MOVWF FSR1L
07F0  0831     MOVF 0xB1, W
07F1  0087     MOVWF FSR1H
07F2  1781     BSF INDF1, 0x7
07F3  2FFC     GOTO 0x7FC
2652:                      }
2653:                  }//end if(...)else
2654:              }
2655:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2656:          	{
2657:                  //if someone is still expecting data from the control transfer
2658:                  //  then make sure to terminate that request and let them know that
2659:                  //  they are done
2660:                  if(outPipes[0].info.bits.busy == 1)
07F4  0022     MOVLB 0x2
07F5  1FA2     BTFSS 0x122, 0x7
07F6  2FF8     GOTO 0x7F8
07F7  2FF9     GOTO 0x7F9
07F8  2FFA     GOTO 0x7FA
2661:                  {
2662:                      if(outPipes[0].pFunc != NULL)
2663:                      {
2664:                          outPipes[0].pFunc();
2665:                      }
2666:                      outPipes[0].info.bits.busy = 0;
07F9  13A2     BCF 0x122, 0x7
2667:                  }
2668:          
2669:                  controlTransferState = WAIT_SETUP;
07FA  0021     MOVLB 0x1
07FB  01D1     CLRF controlTransferState
2670:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2671:                  //got processed by the USBCtrlTrfRxService() handler.
2672:          	}
2673:          
2674:          }
07FC  0008     RETURN
2675:          
2676:          
2677:          /********************************************************************
2678:           * Function:        void USBCheckStdRequest(void)
2679:           *
2680:           * PreCondition:    None
2681:           *
2682:           * Input:           None
2683:           *
2684:           * Output:          None
2685:           *
2686:           * Side Effects:    None
2687:           *
2688:           * Overview:        This routine checks the setup data packet to see
2689:           *                  if it knows how to handle it
2690:           *
2691:           * Note:            None
2692:           *******************************************************************/
2693:          static void USBCheckStdRequest(void)
2694:          {
2695:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0CAC  0020     MOVLB 0x0
0CAD  0E60     SWAPF SetupPkt, W
0CAE  0C89     RRF WREG, F
0CAF  3903     ANDLW 0x3
0CB0  3A00     XORLW 0x0
0CB1  1903     BTFSC STATUS, 0x2
0CB2  2CB4     GOTO 0x4B4
0CB3  2CB5     GOTO 0x4B5
0CB4  2CFB     GOTO 0x4FB
0CB5  2D27     GOTO 0x527
2696:          
2697:              switch(SetupPkt.bRequest)
2698:              {
2699:                  case USB_REQUEST_SET_ADDRESS:
2700:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
0CB6  17BA     BSF 0x3A, 0x7
2701:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
0CB7  3008     MOVLW 0x8
0CB8  00E6     MOVWF 0x66
0CB9  0866     MOVF 0x66, W
0CBA  00D4     MOVWF 0x54
2702:                      /* See USBCtrlTrfInHandler() for the next step */
2703:                      break;
0CBB  2D27     GOTO 0x527
2704:                  case USB_REQUEST_GET_DESCRIPTOR:
2705:                      USBStdGetDscHandler();
0CBC  318D     MOVLP 0xD
0CBD  2528     CALL 0x528
0CBE  318C     MOVLP 0xC
2706:                      break;
0CBF  2D27     GOTO 0x527
2707:                  case USB_REQUEST_SET_CONFIGURATION:
2708:                      USBStdSetCfgHandler();
0CC0  318D     MOVLP 0xD
0CC1  25AD     CALL 0x5AD
0CC2  318C     MOVLP 0xC
2709:                      break;
0CC3  2D27     GOTO 0x527
2710:                  case USB_REQUEST_GET_CONFIGURATION:
2711:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
0CC4  30D8     MOVLW 0xD8
0CC5  00B8     MOVWF 0x38
0CC6  3000     MOVLW 0x0
0CC7  00B9     MOVWF 0x39
2712:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0CC8  143A     BSF 0x3A, 0x0
2713:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0CC9  01BB     CLRF 0x3B
0CCA  0ABB     INCF 0x3B, F
2714:                      inPipes[0].info.bits.busy = 1;
0CCB  17BA     BSF 0x3A, 0x7
2715:                      break;
0CCC  2D27     GOTO 0x527
2716:                  case USB_REQUEST_GET_STATUS:
2717:                      USBStdGetStatusHandler();
0CCD  318B     MOVLP 0xB
0CCE  2358     CALL 0x358
0CCF  318C     MOVLP 0xC
2718:                      break;
0CD0  2D27     GOTO 0x527
2719:                  case USB_REQUEST_CLEAR_FEATURE:
2720:                  case USB_REQUEST_SET_FEATURE:
2721:                      USBStdFeatureReqHandler();
0CD1  3180     MOVLP 0x0
0CD2  2044     CALL 0x44
0CD3  318C     MOVLP 0xC
2722:                      break;
0CD4  2D27     GOTO 0x527
2723:                  case USB_REQUEST_GET_INTERFACE:
2724:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
0CD5  0020     MOVLB 0x0
0CD6  0864     MOVF 0x64, W
0CD7  3EBD     ADDLW 0xBD
0CD8  0021     MOVLB 0x1
0CD9  00B8     MOVWF inPipes
0CDA  3001     MOVLW 0x1
0CDB  00B9     MOVWF 0xB9
0CDC  2CC8     GOTO 0x4C8
2725:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2726:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2727:                      inPipes[0].info.bits.busy = 1;
2728:                      break;
2729:                  case USB_REQUEST_SET_INTERFACE:
2730:                      inPipes[0].info.bits.busy = 1;
0CDD  17BA     BSF 0xBA, 0x7
2731:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0CDE  0020     MOVLB 0x0
0CDF  0862     MOVF 0x62, W
0CE0  0021     MOVLB 0x1
0CE1  00E6     MOVWF 0xE6
0CE2  0020     MOVLB 0x0
0CE3  0864     MOVF 0x64, W
0CE4  3EBD     ADDLW 0xBD
0CE5  0086     MOVWF FSR1
0CE6  3001     MOVLW 0x1
0CE7  0087     MOVWF FSR1H
0CE8  0021     MOVLB 0x1
0CE9  0866     MOVF 0xE6, W
0CEA  0081     MOVWF INDF1
2732:                      break;
0CEB  2D27     GOTO 0x527
2733:                  case USB_REQUEST_SET_DESCRIPTOR:
2734:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
0CEC  3002     MOVLW 0x2
0CED  00D9     MOVWF __pcstackBANK1
0CEE  3000     MOVLW 0x0
0CEF  00DA     MOVWF 0xDA
0CF0  3000     MOVLW 0x0
0CF1  00DB     MOVWF pdata
0CF2  3000     MOVLW 0x0
0CF3  00DC     MOVWF 0xDC
0CF4  3000     MOVLW 0x0
0CF5  00DD     MOVWF size
0CF6  00DE     MOVWF 0xDE
0CF7  3189     MOVLP 0x9
0CF8  21B4     CALL 0x1B4
0CF9  318C     MOVLP 0xC
2735:                      break;
0CFA  2D27     GOTO 0x527
2736:                  case USB_REQUEST_SYNCH_FRAME:
2737:                  default:
2738:                      break;
2739:              }//end switch
0CFB  0861     MOVF pUEP, W
0CFC  0021     MOVLB 0x1
0CFD  00E6     MOVWF 0xE6
0CFE  01E7     CLRF 0xE7
0CFF  0867     MOVF 0xE7, W
0D00  3A00     XORLW 0x0
0D01  1903     BTFSC STATUS, 0x2
0D02  2D04     GOTO 0x504
0D03  2D27     GOTO 0x527
0D04  0866     MOVF 0xE6, W
0D05  3A00     XORLW 0x0
0D06  1903     BTFSC STATUS, 0x2
0D07  2CCD     GOTO 0x4CD
0D08  3A01     XORLW 0x1
0D09  1903     BTFSC STATUS, 0x2
0D0A  2CD1     GOTO 0x4D1
0D0B  3A02     XORLW 0x2
0D0C  1903     BTFSC STATUS, 0x2
0D0D  2CD1     GOTO 0x4D1
0D0E  3A06     XORLW 0x6
0D0F  1903     BTFSC STATUS, 0x2
0D10  2CB6     GOTO 0x4B6
0D11  3A03     XORLW 0x3
0D12  1903     BTFSC STATUS, 0x2
0D13  2CBC     GOTO 0x4BC
0D14  3A01     XORLW 0x1
0D15  1903     BTFSC STATUS, 0x2
0D16  2CEC     GOTO 0x4EC
0D17  3A0F     XORLW 0xF
0D18  1903     BTFSC STATUS, 0x2
0D19  2CC4     GOTO 0x4C4
0D1A  3A01     XORLW 0x1
0D1B  1903     BTFSC STATUS, 0x2
0D1C  2CC0     GOTO 0x4C0
0D1D  3A03     XORLW 0x3
0D1E  1903     BTFSC STATUS, 0x2
0D1F  2CD5     GOTO 0x4D5
0D20  3A01     XORLW 0x1
0D21  1903     BTFSC STATUS, 0x2
0D22  2CDD     GOTO 0x4DD
0D23  3A07     XORLW 0x7
0D24  1903     BTFSC STATUS, 0x2
0D25  2D27     GOTO 0x527
0D26  2D27     GOTO 0x527
2740:          }//end USBCheckStdRequest
0D27  0008     RETURN
2741:          
2742:          /********************************************************************
2743:           * Function:        void USBStdFeatureReqHandler(void)
2744:           *
2745:           * PreCondition:    None
2746:           *
2747:           * Input:           None
2748:           *
2749:           * Output:          Can alter BDT entries.  Can also modify USB stack
2750:           *                  Maintained variables.
2751:           *
2752:           * Side Effects:    None
2753:           *
2754:           * Overview:        This routine handles the standard SET & CLEAR
2755:           *                  FEATURES requests
2756:           *
2757:           * Note:            This is a private function, intended for internal
2758:           *                  use by the USB stack, when processing SET/CLEAR
2759:           *                  feature requests.
2760:           *******************************************************************/
2761:          static void USBStdFeatureReqHandler(void)
2762:          {
2763:              BDT_ENTRY *p;
2764:              EP_STATUS current_ep_data;
2765:              #if defined(__C32__)
2766:                  uint32_t* pUEP;
2767:              #else
2768:                  unsigned char* pUEP;
2769:              #endif
2770:          
2771:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2772:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
0044  0020     MOVLB 0x0
0045  0362     DECF 0x62, W
0046  1D03     BTFSS STATUS, 0x2
0047  2849     GOTO 0x49
0048  284A     GOTO 0x4A
0049  2860     GOTO 0x60
004A  0860     MOVF SetupPkt, W
004B  391F     ANDLW 0x1F
004C  3A00     XORLW 0x0
004D  1D03     BTFSS STATUS, 0x2
004E  2850     GOTO 0x50
004F  2851     GOTO 0x51
0050  2860     GOTO 0x60
2773:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2774:              {
2775:                  inPipes[0].info.bits.busy = 1;
0051  0021     MOVLB 0x1
0052  17BA     BSF 0xBA, 0x7
2776:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0053  3003     MOVLW 0x3
0054  0020     MOVLB 0x0
0055  0661     XORWF 0x61, W
0056  1D03     BTFSS STATUS, 0x2
0057  2859     GOTO 0x59
0058  285A     GOTO 0x5A
0059  285E     GOTO 0x5E
2777:                      RemoteWakeup = true;
005A  0021     MOVLB 0x1
005B  01CF     CLRF RemoteWakeup
005C  0ACF     INCF RemoteWakeup, F
005D  2860     GOTO 0x60
2778:                  else
2779:                      RemoteWakeup = false;
005E  0021     MOVLB 0x1
005F  01CF     CLRF RemoteWakeup
2780:              }//end if
2781:          
2782:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2783:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
0060  0020     MOVLB 0x0
0061  0862     MOVF 0x62, W
0062  1D03     BTFSS STATUS, 0x2
0063  2865     GOTO 0x65
0064  2866     GOTO 0x66
0065  29AA     GOTO 0x1AA
0066  0860     MOVF SetupPkt, W
0067  391F     ANDLW 0x1F
0068  3A02     XORLW 0x2
0069  1D03     BTFSS STATUS, 0x2
006A  286C     GOTO 0x6C
006B  286D     GOTO 0x6D
006C  29AA     GOTO 0x1AA
006D  0864     MOVF 0x64, W
006E  390F     ANDLW 0xF
006F  3A00     XORLW 0x0
0070  1903     BTFSC STATUS, 0x2
0071  2873     GOTO 0x73
0072  2874     GOTO 0x74
0073  29AA     GOTO 0x1AA
0074  0864     MOVF 0x64, W
0075  390F     ANDLW 0xF
0076  0021     MOVLB 0x1
0077  00DF     MOVWF 0xDF
0078  3004     MOVLW 0x4
0079  025F     SUBWF 0xDF, W
007A  1803     BTFSC STATUS, 0x0
007B  287D     GOTO 0x7D
007C  287E     GOTO 0x7E
007D  29AA     GOTO 0x1AA
007E  3020     MOVLW 0x20
007F  0654     XORWF USBDeviceState, W
0080  1D03     BTFSS STATUS, 0x2
0081  2883     GOTO 0x83
0082  2884     GOTO 0x84
0083  29AA     GOTO 0x1AA
2784:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2785:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2786:                 (USBDeviceState == CONFIGURED_STATE))
2787:              {
2788:          		//The request was valid.  Take control of the control transfer and
2789:          		//perform the host requested action.
2790:          		inPipes[0].info.bits.busy = 1;
0084  17BA     BSF 0xBA, 0x7
2791:          
2792:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2793:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0085  0020     MOVLB 0x0
0086  1BE4     BTFSC 0x64, 0x7
0087  2889     GOTO 0x89
0088  288A     GOTO 0x8A
0089  28A3     GOTO 0xA3
2794:                  {
2795:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
008A  0864     MOVF 0x64, W
008B  390F     ANDLW 0xF
008C  0709     ADDWF WREG, W
008D  3EA0     ADDLW 0xA0
008E  0086     MOVWF FSR1
008F  3001     MOVLW 0x1
0090  0087     MOVWF FSR1H
0091  3F40     MOVIW 0[FSR1]
0092  0021     MOVLB 0x1
0093  00E4     MOVWF p
0094  3F41     MOVIW 1[FSR1]
0095  00E5     MOVWF 0xE5
2796:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0096  0020     MOVLB 0x0
0097  0864     MOVF 0x64, W
0098  390F     ANDLW 0xF
0099  3EAC     ADDLW 0xAC
009A  0086     MOVWF FSR1
009B  3001     MOVLW 0x1
009C  0087     MOVWF FSR1H
009D  0801     MOVF INDF1, W
009E  0021     MOVLB 0x1
009F  00DF     MOVWF 0xDF
00A0  085F     MOVF 0xDF, W
00A1  00E3     MOVWF i
2797:                  }
00A2  28BA     GOTO 0xBA
2798:                  else
2799:                  {
2800:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00A3  0864     MOVF p, W
00A4  390F     ANDLW 0xF
00A5  0709     ADDWF WREG, W
00A6  3EB0     ADDLW 0xB0
00A7  0086     MOVWF FSR1L
00A8  0187     CLRF FSR1H
00A9  3F40     MOVIW 0[FSR1]
00AA  0021     MOVLB 0x1
00AB  00E4     MOVWF p
00AC  3F41     MOVIW 1[FSR1]
00AD  00E5     MOVWF 0xE5
2801:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
00AE  0020     MOVLB 0x0
00AF  0864     MOVF 0x64, W
00B0  390F     ANDLW 0xF
00B1  3EB0     ADDLW 0xB0
00B2  0086     MOVWF FSR1
00B3  3001     MOVLW 0x1
00B4  0087     MOVWF FSR1H
00B5  0801     MOVF INDF1, W
00B6  0021     MOVLB 0x1
00B7  00DF     MOVWF 0xDF
00B8  085F     MOVF 0xDF, W
00B9  00E3     MOVWF i
2802:                  }
2803:          
2804:                  //If ping pong buffering is enabled on the requested endpoint, need
2805:                  //to point to the one that is the active BDT entry which the SIE will
2806:                  //use for the next attempted transaction on that EP number.
2807:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2808:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00BA  1863     BTFSC i, 0x0
00BB  28BD     GOTO 0xBD
00BC  28BE     GOTO 0xBE
00BD  28C9     GOTO 0xC9
2809:                      {
2810:                          p = (BDT_ENTRY*)(((uintptr_t)(p)) & (~USB_NEXT_PING_PONG));
00BE  30FB     MOVLW 0xFB
00BF  00DF     MOVWF 0xDF
00C0  30FF     MOVLW 0xFF
00C1  00E0     MOVWF p
00C2  0864     MOVF p, W
00C3  055F     ANDWF 0xDF, W
00C4  00E4     MOVWF p
00C5  0865     MOVF 0xE5, W
00C6  0560     ANDWF p, W
00C7  00E5     MOVWF 0xE5
2811:                      }
00C8  28CF     GOTO 0xCF
2812:                      else //else must have been odd
2813:                      {
2814:                          p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
00C9  3004     MOVLW 0x4
00CA  0464     IORWF p, W
00CB  00E4     MOVWF p
00CC  3000     MOVLW 0x0
00CD  0465     IORWF 0xE5, W
00CE  00E5     MOVWF 0xE5
2815:                      }
2816:                  #endif
2817:          
2818:                  //Update the BDT pointers with the new, next entry based on the feature
2819:                  //  request
2820:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00CF  0020     MOVLB 0x0
00D0  1BE4     BTFSC 0x64, 0x7
00D1  28D3     GOTO 0xD3
00D2  28D4     GOTO 0xD4
00D3  28E1     GOTO 0xE1
2821:                  {
2822:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00D4  0864     MOVF 0x64, W
00D5  390F     ANDLW 0xF
00D6  0709     ADDWF WREG, W
00D7  3EA0     ADDLW 0xA0
00D8  0086     MOVWF FSR1
00D9  3001     MOVLW 0x1
00DA  0087     MOVWF FSR1H
00DB  0021     MOVLB 0x1
00DC  0864     MOVF p, W
00DD  3FC0     MOVWI 0[FSR1]
00DE  0865     MOVF 0xE5, W
00DF  3FC1     MOVWI 1[FSR1]
2823:                  }
00E0  28EC     GOTO 0xEC
2824:                  else
2825:                  {
2826:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00E1  0864     MOVF p, W
00E2  390F     ANDLW 0xF
00E3  0709     ADDWF WREG, W
00E4  3EB0     ADDLW 0xB0
00E5  0086     MOVWF FSR1L
00E6  0187     CLRF FSR1H
00E7  0021     MOVLB 0x1
00E8  0864     MOVF p, W
00E9  3FC0     MOVWI 0[FSR1]
00EA  0865     MOVF 0xE5, W
00EB  3FC1     MOVWI 1[FSR1]
2827:                  }
2828:          
2829:          		//Check if it was a SET_FEATURE endpoint halt request
2830:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00EC  3003     MOVLW 0x3
00ED  0020     MOVLB 0x0
00EE  0661     XORWF 0x61, W
00EF  1D03     BTFSS STATUS, 0x2
00F0  28F2     GOTO 0xF2
00F1  28F3     GOTO 0xF3
00F2  291C     GOTO 0x11C
2831:                  {
2832:                      if(p->STAT.UOWN == 1)
00F3  0021     MOVLB 0x1
00F4  0864     MOVF p, W
00F5  0086     MOVWF FSR1L
00F6  0865     MOVF 0xE5, W
00F7  0087     MOVWF FSR1H
00F8  1F81     BTFSS INDF1, 0x7
00F9  28FB     GOTO 0xFB
00FA  28FC     GOTO 0xFC
00FB  2910     GOTO 0x110
2833:                      {
2834:                          //Mark that we are terminating this transfer and that the user
2835:                          //  needs to be notified later
2836:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
00FC  0020     MOVLB 0x0
00FD  1BE4     BTFSC 0x64, 0x7
00FE  2900     GOTO 0x100
00FF  2901     GOTO 0x101
0100  2909     GOTO 0x109
2837:                          {
2838:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0101  0864     MOVF 0x64, W
0102  390F     ANDLW 0xF
0103  3EAC     ADDLW 0xAC
0104  0086     MOVWF FSR1
0105  3001     MOVLW 0x1
0106  0087     MOVWF FSR1H
0107  1481     BSF INDF1, 0x1
2839:                          }
0108  2910     GOTO 0x110
2840:                          else
2841:                          {
2842:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
0109  0864     MOVF 0x64, W
010A  390F     ANDLW 0xF
010B  3EB0     ADDLW 0xB0
010C  0086     MOVWF FSR1
010D  3001     MOVLW 0x1
010E  0087     MOVWF FSR1H
010F  1481     BSF INDF1, 0x1
2843:                          }
2844:                      }
2845:          
2846:          			//Then STALL the endpoint
2847:                      p->STAT.Val |= _BSTALL;
0110  0021     MOVLB 0x1
0111  0864     MOVF p, W
0112  0086     MOVWF FSR1L
0113  0865     MOVF 0xE5, W
0114  0087     MOVWF FSR1H
0115  1501     BSF INDF1, 0x2
2848:                      p->STAT.Val |= _USIE;
0116  0864     MOVF p, W
0117  0086     MOVWF FSR1L
0118  0865     MOVF 0xE5, W
0119  0087     MOVWF FSR1H
011A  1781     BSF INDF1, 0x7
2849:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
011B  29AA     GOTO 0x1AA
2850:                  else
2851:                  {
2852:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2853:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2854:                          //toggle over the to the non-active BDT
2855:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
011C  3004     MOVLW 0x4
011D  0021     MOVLB 0x1
011E  0664     XORWF p, W
011F  00E4     MOVWF p
0120  3000     MOVLW 0x0
0121  0665     XORWF 0xE5, W
0122  00E5     MOVWF 0xE5
2856:          
2857:                          if(p->STAT.UOWN == 1)
0123  0864     MOVF p, W
0124  0086     MOVWF FSR1L
0125  0865     MOVF 0xE5, W
0126  0087     MOVWF FSR1H
0127  1F81     BTFSS INDF1, 0x7
0128  292A     GOTO 0x12A
0129  292B     GOTO 0x12B
012A  2948     GOTO 0x148
2858:                          {
2859:                              //Clear UOWN and set DTS state so it will be correct the next time
2860:                              //the application firmware uses USBTransferOnePacket() on the EP.
2861:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
012B  307F     MOVLW 0x7F
012C  00DF     MOVWF 0xDF
012D  0864     MOVF p, W
012E  0086     MOVWF FSR1L
012F  0865     MOVF 0xE5, W
0130  0087     MOVWF FSR1H
0131  085F     MOVF 0xDF, W
0132  0581     ANDWF INDF1, F
2862:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
0133  0864     MOVF p, W
0134  0086     MOVWF FSR1L
0135  0865     MOVF 0xE5, W
0136  0087     MOVWF FSR1H
0137  1701     BSF INDF1, 0x6
2863:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0138  3005     MOVLW 0x5
0139  00D9     MOVWF __pcstackBANK1
013A  3000     MOVLW 0x0
013B  00DA     MOVWF 0xDA
013C  0865     MOVF 0xE5, W
013D  00DC     MOVWF 0xDC
013E  0864     MOVF p, W
013F  00DB     MOVWF pdata
0140  3002     MOVLW 0x2
0141  00DD     MOVWF size
0142  3000     MOVLW 0x0
0143  00DE     MOVWF 0xDE
0144  3189     MOVLP 0x9
0145  21B4     CALL 0x1B4
0146  3180     MOVLP 0x0
2864:                          }
0147  294D     GOTO 0x14D
2865:                          else
2866:                          {
2867:                              //UOWN already clear, but still need to set DTS to DATA1
2868:          					p->STAT.Val |= _DAT1;
0148  0864     MOVF p, W
0149  0086     MOVWF FSR1L
014A  0865     MOVF 0xE5, W
014B  0087     MOVWF FSR1H
014C  1701     BSF INDF1, 0x6
2869:                          }
2870:          
2871:                          //toggle back to the active BDT (the one the SIE is currently looking at
2872:                          //and will use for the next successful transaction to take place on the EP
2873:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
014D  3004     MOVLW 0x4
014E  0021     MOVLB 0x1
014F  0664     XORWF p, W
0150  00E4     MOVWF p
0151  3000     MOVLW 0x0
0152  0665     XORWF 0xE5, W
0153  00E5     MOVWF 0xE5
2874:          
2875:                          //Check if we are currently terminating, or have previously terminated
2876:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2877:                          //set DTS to the proper state, and call the application callback
2878:                          //function.
2879:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
0154  18E3     BTFSC i, 0x1
0155  2957     GOTO 0x157
0156  2958     GOTO 0x158
0157  2960     GOTO 0x160
0158  0864     MOVF p, W
0159  0086     MOVWF FSR1L
015A  0865     MOVF 0xE5, W
015B  0087     MOVWF FSR1H
015C  1F81     BTFSS INDF1, 0x7
015D  295F     GOTO 0x15F
015E  2960     GOTO 0x160
015F  298D     GOTO 0x18D
2880:                          {
2881:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0160  0020     MOVLB 0x0
0161  1BE4     BTFSC 0x64, 0x7
0162  2964     GOTO 0x164
0163  2965     GOTO 0x165
0164  296D     GOTO 0x16D
2882:                              {
2883:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0165  0864     MOVF 0x64, W
0166  390F     ANDLW 0xF
0167  3EAC     ADDLW 0xAC
0168  0086     MOVWF FSR1
0169  3001     MOVLW 0x1
016A  0087     MOVWF FSR1H
016B  1081     BCF INDF1, 0x1
2884:                              }
016C  2974     GOTO 0x174
2885:                              else
2886:                              {
2887:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
016D  0864     MOVF 0x64, W
016E  390F     ANDLW 0xF
016F  3EB0     ADDLW 0xB0
0170  0086     MOVWF FSR1
0171  3001     MOVLW 0x1
0172  0087     MOVWF FSR1H
0173  1081     BCF INDF1, 0x1
2888:                              }
2889:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2890:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
0174  303B     MOVLW 0x3B
0175  0021     MOVLB 0x1
0176  00DF     MOVWF 0xDF
0177  0864     MOVF p, W
0178  0086     MOVWF FSR1L
0179  0865     MOVF 0xE5, W
017A  0087     MOVWF FSR1H
017B  085F     MOVF 0xDF, W
017C  0581     ANDWF INDF1, F
2891:                              //Call the application event handler callback function, so it can
2892:          					//decide if the endpoint should get re-armed again or not.
2893:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
017D  3005     MOVLW 0x5
017E  00D9     MOVWF __pcstackBANK1
017F  3000     MOVLW 0x0
0180  00DA     MOVWF 0xDA
0181  0865     MOVF 0xE5, W
0182  00DC     MOVWF 0xDC
0183  0864     MOVF p, W
0184  00DB     MOVWF pdata
0185  3002     MOVLW 0x2
0186  00DD     MOVWF size
0187  3000     MOVLW 0x0
0188  00DE     MOVWF 0xDE
0189  3189     MOVLP 0x9
018A  21B4     CALL 0x1B4
018B  3180     MOVLP 0x0
2894:                          }
018C  2995     GOTO 0x195
2895:                          else
2896:                          {
2897:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2898:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
018D  303B     MOVLW 0x3B
018E  00DF     MOVWF 0xDF
018F  0864     MOVF p, W
0190  0086     MOVWF FSR1L
0191  0865     MOVF 0xE5, W
0192  0087     MOVWF FSR1H
0193  085F     MOVF 0xDF, W
0194  0581     ANDWF INDF1, F
2899:                          }
2900:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2901:                          //Check if we need to call the user transfer terminated event callback function.
2902:                          //We should call the callback, if the endpoint was previously terminated,
2903:                          //or the endpoint is currently armed, and the host is performing clear
2904:                          //endpoint halt, even though the endpoint wasn't stalled.
2905:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2906:                          {
2907:                              //We are going to call the user transfer terminated callback.
2908:                              //Clear the flag so we know we took care of it and don't need
2909:                              //to call it again later.
2910:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2911:                              {
2912:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2913:                              }
2914:                              else
2915:                              {
2916:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2917:                              }
2918:          
2919:                              //Clear UOWN and remove the STALL condition.
2920:                              //  In this case we also need to set the DTS bit to 1 so that
2921:                              //  it toggles to DATA0 the next time the application firmware
2922:                              //  calls USBTransferOnePacket() (or equivalent macro).
2923:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2924:                              p->STAT.Val |= _DAT1;
2925:                              //Let the application firmware know a transaction just
2926:                              //got terminated by the host, and that it is now free to
2927:                              //re-arm the endpoint or do other tasks if desired.
2928:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2929:                          }
2930:                          else
2931:                          {
2932:                              //Clear UOWN and remove the STALL condition.
2933:                              //  In this case we also need to set the DTS bit to 1 so that
2934:                              //  it toggles to DATA0 the next time the application firmware
2935:                              //  calls USBTransferOnePacket() (or equivalent macro).
2936:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2937:                              p->STAT.Val |= _DAT1;
2938:                          }
2939:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2940:          
2941:          			//Get a pointer to the appropriate UEPn register
2942:                      #if defined(__C32__)
2943:                          pUEP = (uint32_t*)(&U1EP0);
2944:                          pUEP += (SetupPkt.EPNum*4);
2945:                      #else
2946:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0195  0020     MOVLB 0x0
0196  0864     MOVF 0x64, W
0197  390F     ANDLW 0xF
0198  3E98     ADDLW 0x98
0199  0021     MOVLB 0x1
019A  00DF     MOVWF 0xDF
019B  01E0     CLRF p
019C  300E     MOVLW 0xE
019D  3DE0     ADDWFC p, F
019E  085F     MOVF 0xDF, W
019F  00E1     MOVWF pUEP
01A0  0860     MOVF p, W
01A1  00E2     MOVWF i
2947:                      #endif
2948:          
2949:          			//Clear the STALL bit in the UEP register
2950:                      *pUEP &= ~UEP_STALL;
01A2  30FE     MOVLW 0xFE
01A3  00DF     MOVWF 0xDF
01A4  0861     MOVF pUEP, W
01A5  0086     MOVWF FSR1L
01A6  0862     MOVF i, W
01A7  0087     MOVWF FSR1H
01A8  085F     MOVF 0xDF, W
01A9  0581     ANDWF INDF1, F
2951:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2952:              }//end if (lots of checks for set/clear endpoint halt)
2953:          }//end USBStdFeatureReqHandler
01AA  0008     RETURN
2954:          
2955:          
2956:          
2957:          
2958:          /**************************************************************************
2959:              Function:
2960:                  void USBIncrement1msInternalTimers(void)
2961:          
2962:              Description:
2963:                  This function increments internal 1ms time base counters, which are
2964:                  useful for application code (that can use a 1ms time base/counter), and
2965:                  for certain USB event timing specific purposes.
2966:          
2967:                  In USB full speed applications, the application code does not need to (and should
2968:                  not) explicitly call this function, as the USBDeviceTasks() function will
2969:                  automatically call this function whenever a 1ms time interval has elapsed
2970:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2971:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
2972:                  in USB_INTERRUPT mode).
2973:          
2974:                  In USB low speed applications, the application firmware is responsible for
2975:                  periodically calling this function at a ~1ms rate.  This can be done using
2976:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
2977:                  If the low speed application code does not call this function, the internal timers
2978:                  will not increment, and the USBGet1msTickCount() API function will not be available.
2979:                  Additionally, certain USB stack operations (like control transfer timeouts)
2980:                  may be unavailable.
2981:          
2982:              Precondition:
2983:                  This function should be called only after USBDeviceInit() has been
2984:                  called (at least once at the start of the application).  Ordinarily,
2985:                  application code should never call this function, unless it is a low speed
2986:                  USB device.
2987:          
2988:              Parameters:
2989:                  None
2990:          
2991:              Return Values:
2992:                  None
2993:          
2994:              Remarks:
2995:                  This function does not need to be called during USB suspend conditions, when
2996:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
2997:            ***************************************************************************/
2998:          void USBIncrement1msInternalTimers(void)
2999:          {
3000:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3001:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3002:              #endif
3003:          
3004:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3005:              //that needs a 1ms time base that is active during USB non-suspended operation.
3006:              USB1msTickCount++;
177F  3001     MOVLW 0x1
1780  0023     MOVLB 0x3
1781  07A8     ADDWF USB1msTickCount, F
1782  3000     MOVLW 0x0
1783  3DA9     ADDWFC 0x1A9, F
1784  3000     MOVLW 0x0
1785  3DAA     ADDWFC 0x1AA, F
1786  3000     MOVLW 0x0
1787  3DAB     ADDWFC _spiTask, F
3007:              if(USBIsBusSuspended() == false)
1788  0021     MOVLB 0x1
1789  084E     MOVF USBBusIsSuspended, W
178A  1D03     BTFSS STATUS, 0x2
178B  2F8D     GOTO 0x78D
178C  2F8E     GOTO 0x78E
178D  2F9B     GOTO 0x79B
3008:              {
3009:                  USBTicksSinceSuspendEnd++;
178E  3001     MOVLW 0x1
178F  00F0     MOVWF 0xF0
1790  0870     MOVF 0xF0, W
1791  07C5     ADDWF USBTicksSinceSuspendEnd, F
3010:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3011:                  if(USBTicksSinceSuspendEnd == 0)
1792  0845     MOVF USBTicksSinceSuspendEnd, W
1793  1D03     BTFSS STATUS, 0x2
1794  2F96     GOTO 0x796
1795  2F97     GOTO 0x797
1796  2F9B     GOTO 0x79B
3012:                  {
3013:                      USBTicksSinceSuspendEnd = 255;
1797  30FF     MOVLW 0xFF
1798  00F0     MOVWF 0xF0
1799  0870     MOVF 0xF0, W
179A  00C5     MOVWF USBTicksSinceSuspendEnd
3014:                  }
3015:              }
3016:          }
179B  0008     RETURN
3017:          
3018:          
3019:          
3020:          
3021:          /**************************************************************************
3022:              Function:
3023:                  uint32_t USBGet1msTickCount(void)
3024:          
3025:              Description:
3026:                  This function retrieves a 32-bit unsigned integer that normally increments by
3027:                  one every one millisecond.  The count value starts from zero when the
3028:                  USBDeviceInit() function is first called.  See the remarks section for
3029:                  details on special circumstances where the tick count will not increment.
3030:          
3031:              Precondition:
3032:                  This function should be called only after USBDeviceInit() has been
3033:                  called (at least once at the start of the application).
3034:          
3035:              Parameters:
3036:                  None
3037:          
3038:              Return Values:
3039:                  uint32_t representing the approximate millisecond count, since the time the
3040:                  USBDeviceInit() function was first called.
3041:          
3042:              Remarks:
3043:                  On 8-bit USB full speed devices, the internal counter is incremented on
3044:                  every SOF packet detected.  Therefore, it will not increment during suspend
3045:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3046:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3047:                  on 16-bit devices, the count continue to increment during USB suspend or
3048:                  detach events, so long as the application code has not put the microcontroller
3049:                  to sleep during these events, and the application firmware is regularly
3050:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3051:                  USB_INTERRUPT mode operation).
3052:          
3053:                  In USB low speed applications, the host does not broadcast SOF packets to
3054:                  the device, so the application firmware becomes responsible for calling
3055:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3056:                  timer interrupt handler), or else the returned value from this function will
3057:                  not increment.
3058:          
3059:                  Prior to calling USBDeviceInit() for the first time the returned value will
3060:                  be unpredictable.
3061:          
3062:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3063:                  code without risk of retrieving a partially updated 32-bit number.
3064:          
3065:                  However, this value only increments when the USBDeviceTasks() function is allowed
3066:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3067:                  function.  If however USB_POLLING mode is used, one must not block on this
3068:                  function without also calling USBDeviceTasks() continuously for the blocking
3069:                  duration (since the USB stack must still be allowed to execute, and the USB
3070:                  stack is also responsible for updating the tick counter internally).
3071:          
3072:                  If the application is operating in USB_POLLING mode, this function should
3073:                  only be called from the main loop context, and not from an interrupt handler,
3074:                  as the returned value could be incorrect, if the main loop context code was in
3075:                  the process of updating the internal count at the moment of the interrupt event.
3076:             ***************************************************************************/
3077:          uint32_t USBGet1msTickCount(void)
3078:          {
3079:              #if defined (USB_INTERRUPT)
3080:                  uint32_t localContextValue;
3081:          
3082:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3083:                  //value.  This ensures that the complete 32-bit value got read without
3084:                  //getting interrupted in between bytes.
3085:                  do
3086:                  {
3087:                      localContextValue = USB1msTickCount;
3088:                  }while(localContextValue != USB1msTickCount);
3089:          
3090:                  return localContextValue;
3091:          
3092:              #else
3093:                  return USB1msTickCount;
3094:              #endif
3095:          }
3096:          
3097:          
3098:          
3099:          
3100:          
3101:          
3102:          /** EOF USBDevice.c *****************************************************/
---  E:/Smart-Knob/pic16f1455_firmware/lib/system.c  ----------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #include "include/system.h"
21:            
22:            /** CONFIGURATION Bits **********************************************/
23:            // PIC16F1459 configuration bit settings:
24:            #if defined (USE_INTERNAL_OSC)	    // Define this in system.h if using the HFINTOSC for USB operation
25:                // CONFIG1
26:                #pragma config FOSC = INTOSC    // Oscillator Selection Bits (INTOSC oscillator: I/O function on CLKIN pin)
27:                #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
28:                #pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
29:                #pragma config MCLRE = OFF      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
30:                #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
31:                #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
32:                #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
33:                #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
34:                #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
35:            
36:                // CONFIG2
37:                #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
38:                #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
39:                #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
40:                #pragma config PLLMULT = 3x     // PLL Multipler Selection Bit (3x Output Frequency Selected)
41:                #pragma config PLLEN = ENABLED  // PLL Enable Bit (3x or 4x PLL Enabled)
42:                #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
43:                #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
44:                #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
45:                #pragma config LVP = OFF        // Low-Voltage Programming Enable (High-voltage on MCLR/VPP must be used for programming)
46:            #else
47:                // CONFIG1
48:            #pragma config FOSC = HS        // Oscillator Selection Bits (HS Oscillator, High-speed crystal/resonator connected between OSC1 and OSC2 pins)
49:            #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
50:            #pragma config PWRTE = ON       // Power-up Timer Enable (PWRT enabled)
51:            #pragma config MCLRE = ON       // MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
52:            #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
53:            #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
54:            #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
55:            #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
56:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
57:            
58:            // CONFIG2
59:            #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
60:            #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
61:            #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
62:            #pragma config PLLMULT = 4x     // PLL Multipler Selection Bit (4x Output Frequency Selected)
63:            #pragma config PLLEN = ENABLED/*********!!!!!!!!!!!!!!!
64:            
65:            
66:            
67:            !*/  // PLL Enable Bit (3x or 4x PLL Enabled)
68:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
69:            #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
70:            #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
71:            #pragma config LVP = ON         // Low-Voltage Programming Enable (Low-voltage programming enabled)
72:            #endif
73:            /*********************************************************************
74:            * Function: void SYSTEM_Initialize( SYSTEM_STATE state )
75:            *
76:            * Overview: Initializes the system.
77:            *
78:            * PreCondition: None
79:            *
80:            * Input:  SYSTEM_STATE - the state to initialize the system into
81:            *
82:            * Output: None
83:            *
84:            ********************************************************************/
85:            void SYSTEM_Initialize( SYSTEM_STATE state )
179C  00F5     MOVWF 0xF5
86:            {
87:                ANSELC = 0;
179D  0023     MOVLB 0x3
179E  018E     CLRF ANSELC
88:                switch(state)
179F  2FA9     GOTO 0x7A9
89:                {
90:                    case SYSTEM_STATE_USB_START:
91:                        #if defined(USE_INTERNAL_OSC)
92:                            //Make sure to turn on active clock tuning for USB full speed 
93:                            //operation from the INTOSC
94:                            OSCCON = 0xFC;  //HFINTOSC @ 16MHz, 3X PLL, PLL enabled
95:                            ACTCON = 0x90;  //Active clock tuning enabled for USB
96:                        #endif
97:                        LED_Enable(LED_USB_DEVICE_STATE);
17A0  3001     MOVLW 0x1
17A1  3188     MOVLP 0x8
17A2  2039     CALL 0x39
17A3  3197     MOVLP 0x17
98:                        //LED_Enable(LED_D3);
99:                        
100:                       BUTTON_Enable(BUTTON_USB_DEVICE_HID_JOYSTICK);
17A4  3001     MOVLW 0x1
17A5  3188     MOVLP 0x8
17A6  2005     CALL 0x5
17A7  3197     MOVLP 0x17
101:                       break;
17A8  2FBC     GOTO 0x7BC
102:                       
103:                   case SYSTEM_STATE_USB_SUSPEND: 
104:                       break;
105:                       
106:                   case SYSTEM_STATE_USB_RESUME:
107:                       break;
108:               }
17A9  0875     MOVF 0x1F5, W
17AA  00F3     MOVWF 0x1F3
17AB  01F4     CLRF 0x1F4
17AC  0874     MOVF 0x1F4, W
17AD  3A00     XORLW 0x0
17AE  1903     BTFSC STATUS, 0x2
17AF  2FB1     GOTO 0x7B1
17B0  2FBC     GOTO 0x7BC
17B1  0873     MOVF 0x1F3, W
17B2  3A00     XORLW 0x0
17B3  1903     BTFSC STATUS, 0x2
17B4  2FA0     GOTO 0x7A0
17B5  3A01     XORLW 0x1
17B6  1903     BTFSC STATUS, 0x2
17B7  2FBC     GOTO 0x7BC
17B8  3A03     XORLW 0x3
17B9  1903     BTFSC STATUS, 0x2
17BA  2FBC     GOTO 0x7BC
17BB  2FBC     GOTO 0x7BC
109:           }
17BC  0008     RETURN
110:           
111:           #if(__XC8_VERSION < 2000)
112:               #define INTERRUPT interrupt
113:           #else
114:               #define INTERRUPT __interrupt()
115:           #endif			
116:           			
117:           void INTERRUPT SYS_InterruptHigh(void)
0004  147E     BSF 0x1FE, 0x0
0005  3180     MOVLP 0x0
118:           {
119:               #if defined(USB_INTERRUPT)
120:                   USBDeviceTasks();
121:               #endif
122:           }
0006  107E     BCF 0x1FE, 0x0
---  E:/Smart-Knob/pic16f1455_firmware/lib/spi.c  -------------------------------------------------------
1:             #include <xc.h>
2:             #include "include/spi.h"
3:             
4:             #include "include/app_device_joystick.h"
5:             
6:             #define SPI_FREQ 6
7:             #if SPI_FREQ == 6
8:                 #define SPI_MODE MASTER_OSC_SPADD
9:             #else
10:                #define SPI_MODE MASTER_OSC_DIV4
11:            #endif
12:            
13:            #define writeByteNOread asm("MOVIW FSR1++");/*load next byte*/   \
14:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
15:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
16:                asm("BRA -2");                         /*else go back*/         \
17:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
18:                
19:            #define writeByteRead asm("MOVIW FSR1++");/*load next byte*/   \
20:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
21:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
22:                asm("BRA -2");                         /*else go back*/         \
23:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
24:                asm("MOVWI FSR0++");/*save received byte*/
25:                
26:            #if SPI_FREQ == 6
27:                #define WAIT_ADDITIONAL NOP();NOP();NOP();NOP();  NOP();NOP();NOP();NOP(); 
28:            #else
29:                #define WIAT_ADDITIONAL
30:            #endif
31:            
32:            
33:            
34:            #define writeByteNOreadFAST asm("MOVIW FSR1++");/*load next byte*/  \
35:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
36:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
37:                WAIT_ADDITIONAL                                                 \
38:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
39:                
40:            #define writeByteReadFAST asm("MOVIW FSR1++");/*load next byte*/  \
41:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
42:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
43:                WAIT_ADDITIONAL                                                 \
44:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
45:                asm("MOVWI FSR0++");/*save received byte*/
46:                
47:            
48:            #define writeByteOnlyRead asm("BTFSS SSP1STAT, 0x0"); /*if ready continue*/   \
49:                            asm("BRA -2");              /*else go back*/                  \
50:                            asm("MOVF SSP1BUF,W");      /*read the received byte into W*/ \
51:                            asm("MOVWI FSR0++");        /*save received byte*/  
52:            
53:                //TO DO OUT VECTOR
54:            #define REP8(x) x x x x x x x x
55:            
56:            #define strgf(x) str_H(x)
57:            #define str_H(X) #X
58:            #define MOVLW_ADR(X) asm(strgf(M_CONC(MOVLW 0x, X)));
59:            
60:            
61:            #define _XTAL_FREQ 48000000
62:            
63:            
64:            
65:            uint8_t garbage;
66:            
67:            uint8_t luminosity;//first control byte to receive
68:            uint8_t errors_ctr2_to_PIC;//second control byte to send
69:            
70:            uint8_t pkt_requests;//bitmask for each packet type
71:            uint8_t ctrl2_from_PIC;//second ctrl byte
72:            
73:            void spiTask(void){
74:                pkt_requests = 0;
01AB  0021     MOVLB 0x1
01AC  01C3     CLRF pkt_requests
75:                if(!HIDTxHandleBusy(last_HAP_IN)){
01AD  083F     MOVF last_HAP_IN, W
01AE  0440     IORWF 0xC0, W
01AF  1903     BTFSC STATUS, 0x2
01B0  29B2     GOTO 0x1B2
01B1  29B3     GOTO 0x1B3
01B2  29BB     GOTO 0x1BB
01B3  083F     MOVF last_HAP_IN, W
01B4  0086     MOVWF FSR1L
01B5  0840     MOVF 0xC0, W
01B6  0087     MOVWF FSR1H
01B7  1B81     BTFSC INDF1, 0x7
01B8  29BA     GOTO 0x1BA
01B9  29BB     GOTO 0x1BB
01BA  29BD     GOTO 0x1BD
76:                    //rady to send another to PC
77:                    pkt_requests = REQUEST_HAPTIC_IN;
01BB  01C3     CLRF pkt_requests
01BC  0AC3     INCF pkt_requests, F
78:                }
79:                //in case we have received a start command 
80:                //from previous unserviced transaction
81:                garbage = SSPBUF;
01BD  0024     MOVLB 0x4
01BE  0811     MOVF SSP1BUF, W
01BF  00F0     MOVWF 0x270
01C0  0870     MOVF 0x270, W
01C1  0022     MOVLB 0x2
01C2  00A9     MOVWF garbage
82:                SSPOV = 0;
01C3  0024     MOVLB 0x4
01C4  1315     BCF SSP1CON1, 0x6
83:                //wait for a new byte, only for 3 microseconds
84:                
85:                if(BF) goto AFARA;
01C5  1C14     BTFSS SSP1STAT, 0x0
01C6  29C8     GOTO 0x1C8
01C7  29C9     GOTO 0x1C9
01C8  29CA     GOTO 0x1CA
01C9  2A10     GOTO 0x210
86:                if(BF) goto AFARA;
01CA  1C14     BTFSS SSP1STAT, 0x0
01CB  29CD     GOTO 0x1CD
01CC  29CE     GOTO 0x1CE
01CD  29CF     GOTO 0x1CF
01CE  2A10     GOTO 0x210
87:                if(BF) goto AFARA;
01CF  1C14     BTFSS SSP1STAT, 0x0
01D0  29D2     GOTO 0x1D2
01D1  29D3     GOTO 0x1D3
01D2  29D4     GOTO 0x1D4
01D3  2A10     GOTO 0x210
88:                if(BF) goto AFARA;
01D4  1C14     BTFSS SSP1STAT, 0x0
01D5  29D7     GOTO 0x1D7
01D6  29D8     GOTO 0x1D8
01D7  29D9     GOTO 0x1D9
01D8  2A10     GOTO 0x210
89:                if(BF) goto AFARA;
01D9  1C14     BTFSS SSP1STAT, 0x0
01DA  29DC     GOTO 0x1DC
01DB  29DD     GOTO 0x1DD
01DC  29DE     GOTO 0x1DE
01DD  2A10     GOTO 0x210
90:                if(BF) goto AFARA;
01DE  1C14     BTFSS SSP1STAT, 0x0
01DF  29E1     GOTO 0x1E1
01E0  29E2     GOTO 0x1E2
01E1  29E3     GOTO 0x1E3
01E2  2A10     GOTO 0x210
91:                if(BF) goto AFARA;
01E3  1C14     BTFSS SSP1STAT, 0x0
01E4  29E6     GOTO 0x1E6
01E5  29E7     GOTO 0x1E7
01E6  29E8     GOTO 0x1E8
01E7  2A10     GOTO 0x210
92:                if(BF) goto AFARA;
01E8  1C14     BTFSS SSP1STAT, 0x0
01E9  29EB     GOTO 0x1EB
01EA  29EC     GOTO 0x1EC
01EB  29ED     GOTO 0x1ED
01EC  2A10     GOTO 0x210
93:                if(BF) goto AFARA;
01ED  1C14     BTFSS SSP1STAT, 0x0
01EE  29F0     GOTO 0x1F0
01EF  29F1     GOTO 0x1F1
01F0  29F2     GOTO 0x1F2
01F1  2A10     GOTO 0x210
94:                if(BF) goto AFARA;
01F2  1C14     BTFSS SSP1STAT, 0x0
01F3  29F5     GOTO 0x1F5
01F4  29F6     GOTO 0x1F6
01F5  29F7     GOTO 0x1F7
01F6  2A10     GOTO 0x210
95:                if(BF) goto AFARA;
01F7  1C14     BTFSS SSP1STAT, 0x0
01F8  29FA     GOTO 0x1FA
01F9  29FB     GOTO 0x1FB
01FA  29FC     GOTO 0x1FC
01FB  2A10     GOTO 0x210
96:                if(BF) goto AFARA;
01FC  1C14     BTFSS SSP1STAT, 0x0
01FD  29FF     GOTO 0x1FF
01FE  2A00     GOTO 0x200
01FF  2A01     GOTO 0x201
0200  2A10     GOTO 0x210
97:                if(BF) goto AFARA;
0201  1C14     BTFSS SSP1STAT, 0x0
0202  2A04     GOTO 0x204
0203  2A05     GOTO 0x205
0204  2A06     GOTO 0x206
0205  2A10     GOTO 0x210
98:                if(BF) goto AFARA;
0206  1C14     BTFSS SSP1STAT, 0x0
0207  2A09     GOTO 0x209
0208  2A0A     GOTO 0x20A
0209  2A0B     GOTO 0x20B
020A  2A10     GOTO 0x210
99:                if(BF) goto AFARA;
020B  1C14     BTFSS SSP1STAT, 0x0
020C  2A0E     GOTO 0x20E
020D  2A0F     GOTO 0x20F
020E  2A10     GOTO 0x210
020F  2A10     GOTO 0x210
100:               if(BF) goto AFARA;
101:               AFARA:               /*read the received byte into W*/
102:               
103:               ///we have waited for a "fresh" request
104:               if(BF && SSPBUF == BEGIN_TRANSFER){
0210  1C14     BTFSS SSP1STAT, 0x0
0211  2A13     GOTO 0x213
0212  2A14     GOTO 0x214
0213  2AED     GOTO 0x2ED
0214  3055     MOVLW 0x55
0215  0611     XORWF SSP1BUF, W
0216  1D03     BTFSS STATUS, 0x2
0217  2A19     GOTO 0x219
0218  2A1A     GOTO 0x21A
0219  2AED     GOTO 0x2ED
105:                   //if we have a request(we have received BEGIN_TRANSFER)
106:                   //service transfer
107:                   SSPBUF = ACK1;
021A  3076     MOVLW 0x76
021B  0091     MOVWF SSP1BUF
108:                   //in case we write exactly during a receive the WCOL will be set
109:                   
110:                   while(!BF);//wait for response
021C  1C14     BTFSS SSP1STAT, 0x0
021D  2A1F     GOTO 0x21F
021E  2A20     GOTO 0x220
021F  2A1C     GOTO 0x21C
111:                   if(SSPBUF == BEGIN_TRANSFER){
0220  3055     MOVLW 0x55
0221  0611     XORWF SSP1BUF, W
0222  1D03     BTFSS STATUS, 0x2
0223  2A25     GOTO 0x225
0224  2A26     GOTO 0x226
0225  2AF1     GOTO 0x2F1
112:                       //we haven't just missed the NodeMCU's interval
113:                       //it sends 0x00 to indicate it timed out
114:                       //else it sends another BEGIN_TRANSFER to read the ACK1
115:                       SSPBUF = pkt_requests;
0226  0021     MOVLB 0x1
0227  0843     MOVF pkt_requests, W
0228  0024     MOVLB 0x4
0229  0091     MOVWF SSP1BUF
116:                       //we surely don't have overflow; NodeMCU waits 1us
117:                       while(!BF);
022A  1C14     BTFSS SSP1STAT, 0x0
022B  2A2D     GOTO 0x22D
022C  2A2E     GOTO 0x22E
022D  2A2A     GOTO 0x22A
118:                       luminosity = SSPBUF;
022E  0811     MOVF SSP1BUF, W
022F  00F0     MOVWF 0x270
0230  0870     MOVF 0x270, W
0231  0022     MOVLB 0x2
0232  00A8     MOVWF luminosity
119:                       
120:                       SSPBUF = ctrl2_from_PIC;
0233  0024     MOVLB 0x4
0234  0191     CLRF SSP1BUF
121:                       //we surely don't have overflow; NodeMCU waits 1us
122:                       while(!BF);
0235  1C14     BTFSS SSP1STAT, 0x0
0236  2A38     GOTO 0x238
0237  2A39     GOTO 0x239
0238  2A35     GOTO 0x235
123:                       errors_ctr2_to_PIC = SSPBUF;
0239  0811     MOVF SSP1BUF, W
023A  00F0     MOVWF 0x270
023B  0870     MOVF 0x270, W
023C  0022     MOVLB 0x2
023D  00A7     MOVWF errors_ctr2_to_PIC
124:                       //we have transmitted and received control bytes
125:                       
126:                       if(pkt_requests & REQUEST_HAPTIC_IN){
023E  0021     MOVLB 0x1
023F  1C43     BTFSS pkt_requests, 0x0
0240  2A42     GOTO 0x242
0241  2A43     GOTO 0x243
0242  2AED     GOTO 0x2ED
127:                           hap_IN_pkt_sent=0;
0243  0022     MOVLB 0x2
0244  01AC     CLRF hap_IN_pkt_sent
128:                           
129:                           
130:                           
131:                           garbage = SSPBUF;
0245  0024     MOVLB 0x4
0246  0811     MOVF SSP1BUF, W
0247  00F0     MOVWF 0x270
0248  0870     MOVF 0x270, W
0249  0022     MOVLB 0x2
024A  00A9     MOVWF garbage
132:                           while(!BF);
024B  0024     MOVLB 0x4
024C  1C14     BTFSS SSP1STAT, 0x0
024D  2A4F     GOTO 0x24F
024E  2A50     GOTO 0x250
024F  2A4B     GOTO 0x24B
133:                           haptic_in[0]=SSPBUF;
0250  0811     MOVF SSP1BUF, W
0251  00F0     MOVWF 0x270
0252  0870     MOVF 0x270, W
0253  0021     MOVLB 0x1
0254  00A0     MOVWF haptic_in
134:                           while(!BF);
0255  0024     MOVLB 0x4
0256  1C14     BTFSS SSP1STAT, 0x0
0257  2A59     GOTO 0x259
0258  2A5A     GOTO 0x25A
0259  2A55     GOTO 0x255
135:                           haptic_in[1]=SSPBUF;
025A  0811     MOVF SSP1BUF, W
025B  00F0     MOVWF 0x270
025C  0870     MOVF 0x270, W
025D  0021     MOVLB 0x1
025E  00A1     MOVWF 0xA1
136:                           while(!BF);
025F  0024     MOVLB 0x4
0260  1C14     BTFSS SSP1STAT, 0x0
0261  2A63     GOTO 0x263
0262  2A64     GOTO 0x264
0263  2A5F     GOTO 0x25F
137:                           haptic_in[2]=SSPBUF;
0264  0811     MOVF SSP1BUF, W
0265  00F0     MOVWF 0x270
0266  0870     MOVF 0x270, W
0267  0021     MOVLB 0x1
0268  00A2     MOVWF 0xA2
138:                           while(!BF);
0269  0024     MOVLB 0x4
026A  1C14     BTFSS SSP1STAT, 0x0
026B  2A6D     GOTO 0x26D
026C  2A6E     GOTO 0x26E
026D  2A69     GOTO 0x269
139:                           haptic_in[3]=SSPBUF;
026E  0811     MOVF SSP1BUF, W
026F  00F0     MOVWF 0x270
0270  0870     MOVF 0x270, W
0271  0021     MOVLB 0x1
0272  00A3     MOVWF 0xA3
140:                           while(!BF);
0273  0024     MOVLB 0x4
0274  1C14     BTFSS SSP1STAT, 0x0
0275  2A77     GOTO 0x277
0276  2A78     GOTO 0x278
0277  2A73     GOTO 0x273
141:                           haptic_in[4]=SSPBUF;
0278  0811     MOVF SSP1BUF, W
0279  00F0     MOVWF 0x270
027A  0870     MOVF 0x270, W
027B  0021     MOVLB 0x1
027C  00A4     MOVWF 0xA4
142:                           while(!BF);
027D  0024     MOVLB 0x4
027E  1C14     BTFSS SSP1STAT, 0x0
027F  2A81     GOTO 0x281
0280  2A82     GOTO 0x282
0281  2A7D     GOTO 0x27D
143:                           haptic_in[5]=SSPBUF;
0282  0811     MOVF SSP1BUF, W
0283  00F0     MOVWF 0x270
0284  0870     MOVF 0x270, W
0285  0021     MOVLB 0x1
0286  00A5     MOVWF 0xA5
144:                           while(!BF);
0287  0024     MOVLB 0x4
0288  1C14     BTFSS SSP1STAT, 0x0
0289  2A8B     GOTO 0x28B
028A  2A8C     GOTO 0x28C
028B  2A87     GOTO 0x287
145:                           haptic_in[6]=SSPBUF;
028C  0811     MOVF SSP1BUF, W
028D  00F0     MOVWF 0x270
028E  0870     MOVF 0x270, W
028F  0021     MOVLB 0x1
0290  00A6     MOVWF 0xA6
146:                           while(!BF);
0291  0024     MOVLB 0x4
0292  1C14     BTFSS SSP1STAT, 0x0
0293  2A95     GOTO 0x295
0294  2A96     GOTO 0x296
0295  2A91     GOTO 0x291
147:                           haptic_in[7]=SSPBUF;
0296  0811     MOVF SSP1BUF, W
0297  00F0     MOVWF 0x270
0298  0870     MOVF 0x270, W
0299  0021     MOVLB 0x1
029A  00A7     MOVWF 0xA7
148:                           while(!BF);
029B  0024     MOVLB 0x4
029C  1C14     BTFSS SSP1STAT, 0x0
029D  2A9F     GOTO 0x29F
029E  2AA0     GOTO 0x2A0
029F  2A9B     GOTO 0x29B
149:                           haptic_in[8]=SSPBUF;
02A0  0811     MOVF SSP1BUF, W
02A1  00F0     MOVWF 0x270
02A2  0870     MOVF 0x270, W
02A3  0021     MOVLB 0x1
02A4  00A8     MOVWF 0xA8
150:                           while(!BF);
02A5  0024     MOVLB 0x4
02A6  1C14     BTFSS SSP1STAT, 0x0
02A7  2AA9     GOTO 0x2A9
02A8  2AAA     GOTO 0x2AA
02A9  2AA5     GOTO 0x2A5
151:                           haptic_in[9]=SSPBUF;
02AA  0811     MOVF SSP1BUF, W
02AB  00F0     MOVWF 0x270
02AC  0870     MOVF 0x270, W
02AD  0021     MOVLB 0x1
02AE  00A9     MOVWF 0xA9
152:                           while(!BF);
02AF  0024     MOVLB 0x4
02B0  1C14     BTFSS SSP1STAT, 0x0
02B1  2AB3     GOTO 0x2B3
02B2  2AB4     GOTO 0x2B4
02B3  2AAF     GOTO 0x2AF
153:                           haptic_in[10]=SSPBUF;
02B4  0811     MOVF SSP1BUF, W
02B5  00F0     MOVWF 0x270
02B6  0870     MOVF 0x270, W
02B7  0021     MOVLB 0x1
02B8  00AA     MOVWF 0xAA
154:                           while(!BF);
02B9  0024     MOVLB 0x4
02BA  1C14     BTFSS SSP1STAT, 0x0
02BB  2ABD     GOTO 0x2BD
02BC  2ABE     GOTO 0x2BE
02BD  2AB9     GOTO 0x2B9
155:                           haptic_in[11]=SSPBUF;
02BE  0811     MOVF SSP1BUF, W
02BF  00F0     MOVWF 0x270
02C0  0870     MOVF 0x270, W
02C1  0021     MOVLB 0x1
02C2  00AB     MOVWF 0xAB
156:                           while(!BF);
02C3  0024     MOVLB 0x4
02C4  1C14     BTFSS SSP1STAT, 0x0
02C5  2AC7     GOTO 0x2C7
02C6  2AC8     GOTO 0x2C8
02C7  2AC3     GOTO 0x2C3
157:                           haptic_in[12]=SSPBUF;
02C8  0811     MOVF SSP1BUF, W
02C9  00F0     MOVWF 0x270
02CA  0870     MOVF 0x270, W
02CB  0021     MOVLB 0x1
02CC  00AC     MOVWF 0xAC
158:                           while(!BF);
02CD  0024     MOVLB 0x4
02CE  1C14     BTFSS SSP1STAT, 0x0
02CF  2AD1     GOTO 0x2D1
02D0  2AD2     GOTO 0x2D2
02D1  2ACD     GOTO 0x2CD
159:                           haptic_in[13]=SSPBUF;
02D2  0811     MOVF SSP1BUF, W
02D3  00F0     MOVWF 0x270
02D4  0870     MOVF 0x270, W
02D5  0021     MOVLB 0x1
02D6  00AD     MOVWF 0xAD
160:                           while(!BF);
02D7  0024     MOVLB 0x4
02D8  1C14     BTFSS SSP1STAT, 0x0
02D9  2ADB     GOTO 0x2DB
02DA  2ADC     GOTO 0x2DC
02DB  2AD7     GOTO 0x2D7
161:                           haptic_in[14]=SSPBUF;
02DC  0811     MOVF SSP1BUF, W
02DD  00F0     MOVWF 0x270
02DE  0870     MOVF 0x270, W
02DF  0021     MOVLB 0x1
02E0  00AE     MOVWF 0xAE
162:                           while(!BF);
02E1  0024     MOVLB 0x4
02E2  1C14     BTFSS SSP1STAT, 0x0
02E3  2AE5     GOTO 0x2E5
02E4  2AE6     GOTO 0x2E6
02E5  2AE1     GOTO 0x2E1
163:                           haptic_in[15]=SSPBUF;
02E6  0811     MOVF SSP1BUF, W
02E7  00F0     MOVWF 0x270
02E8  0870     MOVF 0x270, W
02E9  0021     MOVLB 0x1
02EA  00AF     MOVWF 0xAF
164:                                   
165:                           //asm("BTFSS SSP1STAT, 0x0"); //if ready continue   
166:                           //asm("BRA -2");              //else go back             
167:                           //asm("MOVF SSP1BUF,W");      //read the received byte into W
168:                           SSPBUF = 0x00;
02EB  0024     MOVLB 0x4
02EC  0191     CLRF SSP1BUF
169:                       }
170:                       
171:                   }else{
172:                       //we don't need to send another 0x00
173:                       //since BUF is already 0(or at least not BEGIN_TRANSFERs)
174:                       return;
175:                   }
176:                       
177:                   
178:               }
179:               //make sure no ACK1 byte is left in BUF
180:               SSPBUF = 0x00;
02ED  0024     MOVLB 0x4
02EE  0191     CLRF SSP1BUF
181:               WCOL=0;
02EF  1395     BCF SSP1CON1, 0x7
182:               SSPOV=0;
02F0  1315     BCF SSP1CON1, 0x6
183:           }
02F1  0008     RETURN
184:           
185:           char v[8]="ABCDEFGH";
186:           
187:           void spwrh(){
188:               /*
189:                
190:                * 
191:                * 
192:                * MOVLW 0xD0
193:           0B9E  0086     MOVWF FSR1L
194:           0B9F  3021     MOVLW 0x21
195:           0BA0  0087     MOVWF FSR1H
196:           0BA1  3141     ADDFSR 1, 1--------------
197:           0BA2  0801     MOVF INDF1, W
198:           0BA3  0091     MOVWF SSP1BUF
199:           0BA4  1C14     BTFSS SSP1STAT, 0x0
200:           0BA5  2BA7     GOTO 0x3A7
201:           0BA6  2BA8     GOTO 0x3A8
202:           0BA7  2BA4     GOTO 0x3A4
203:                */
204:               ////TESTING RECEIVE ON DISPLAY AND SEND ON HAPTIC
205:               //preload address
206:               //address for DISPLAY
207:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_LO)     //asm("MOVLW 0xD0");
208:               asm("MOVWF FSR1L");
209:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_HI)     //asm("MOVLW 0x21");
210:               asm("MOVWF FSR1H");
211:               
212:               //address for HAPTIC_IN
213:               /*asm("MOVLW 0x30");
214:               asm("MOVWF FSR0L");
215:               asm("MOVLW 0x22");
216:               asm("MOVWF FSR0H");*/
217:               
218:               
219:               //go to bank 4, where the spbuf/stat is
220:               asm("MOVLB 4");
221:               
222:               REP8(REP8(writeByteNOread))
223:               
224:                
225:               /*SSPBUF = display_output[0];while(!BF);//7f=DEL
226:               SSPBUF = display_output[1];while(!BF);//7f=DEL
227:               SSPBUF = display_output[2];while(!BF);//7f=DEL
228:               SSPBUF = display_output[3];while(!BF);//7f=DEL
229:               SSPBUF = display_output[4];while(!BF);//7f=DEL
230:               SSPBUF = display_output[5];while(!BF);//7f=DEL
231:               SSPBUF = display_output[6];while(!BF);//7f=
232:               SSPBUF = display_output[7];while(!BF);//7f=DEL*/
233:               
234:           }
235:           int cnt_tr=0;
236:           
237:           void spiWrite(){
238:               if(cnt_tr<1000){ 
239:                  cnt_tr++;
240:                   return;
241:               }
242:               cnt_tr=0;
243:               CS_PIN = 0;
244:               //__delay_us(100);
245:               
246:               spwrh();
247:               //spwrh("ASDFQWER");
248:               //spwrh("POIUYTRE");
249:               //spwrh("PLMNJKOI");
250:               //spwrh("GHBNVFTY");
251:               //spwrh("12398754");
252:               //spwrh(",./;'[]-");
253:               //spwrh("GHtjhv/]");
254:               //spwrh("-=6`4f;z");
255:               
256:               SSPBUF = ' ';while(!BF);
257:               CS_PIN = 1;
258:           }
259:           
260:           void MasterinitSPI(){
261:               TRIS_CS_PIN = 0;TRIS_CLK_PIN = 0;
262:             
263:           #if SPI_FREQ == 6
264:               SSPADD = 1;
265:           #endif
266:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
267:               SSPCON = SPI_MODE | IDLE_LOW;//SSPM=0000:=;CKP=0
268:               
269:           }
270:           void SlaveinitSPI(){
271:               TRIS_CS_PIN = 1;TRIS_CLK_PIN = 1;
174E  0021     MOVLB 0x1
174F  158E     BSF TRISC, 0x3
1750  140E     BSF TRISC, 0x0
272:               //BOEN = 0;
273:               //ANSC0=0;ANSC1=0;ANSC2=0;ANSC3=0; moved to system.c
274:               
275:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
1751  3040     MOVLW 0x40
1752  0024     MOVLB 0x4
1753  0094     MOVWF SSP1STAT
276:               SSPCON = SLAVE_SS_EN | IDLE_LOW;//SSPM=0000:=;CKP=0
1754  3024     MOVLW 0x24
1755  0095     MOVWF SSP1CON1
277:           }
1756  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/leds.c  ------------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <include/leds.h>
24:            #include <stdbool.h>
25:            #include <xc.h>
26:            
27:            #define LED_D1_LAT LATCbits.LATC4
28:            #define LED_D2_LAT LATCbits.LATC1
29:            #define LED_D3_LAT LATCbits.LATC2
30:            //#define LED_D4_LAT LATCbits.LATC3
31:            
32:            #define LED_D1_TRIS TRISCbits.TRISC4
33:            #define LED_D2_TRIS TRISCbits.TRISC1
34:            #define LED_D3_TRIS TRISCbits.TRISC2
35:            //#define LED_D4_TRIS TRISCbits.TRISC3
36:            
37:            #define LED_ON  1
38:            #define LED_OFF 0
39:            
40:            #define PIN_INPUT  1
41:            #define PIN_OUTPUT 0
42:            
43:            /*********************************************************************
44:            * Function: void LED_On(LED led);
45:            *
46:            * Overview: Turns requested LED on
47:            *
48:            * PreCondition: LED configured via LED_Configure()
49:            *
50:            * Input: LED led - enumeration of the LEDs available in this
51:            *        demo.  They should be meaningful names and not the names of
52:            *        the LEDs on the silkscreen on the board (as the demo code may
53:            *        be ported to other boards).
54:            *         i.e. - LED_On(LED_CONNECTION_DETECTED);
55:            *
56:            * Output: none
57:            *
58:            ********************************************************************/
59:            void LED_On(LED led)
0817  00F2     MOVWF 0x272
60:            {
61:                switch(led)
0818  2822     GOTO 0x22
62:                {
63:                    case LED_D1:
64:                        LED_D1_LAT = LED_ON;
0819  0022     MOVLB 0x2
081A  160E     BSF LATC, 0x4
65:                        break;
081B  2838     GOTO 0x38
66:            
67:                    case LED_D2:
68:                        LED_D2_LAT = LED_ON;
081C  0022     MOVLB 0x2
081D  148E     BSF LATC, 0x1
69:                        break;
081E  2838     GOTO 0x38
70:            			
71:                    case LED_D3:
72:                        LED_D3_LAT = LED_ON;
081F  0022     MOVLB 0x2
0820  150E     BSF LATC, 0x2
73:                        break;
0821  2838     GOTO 0x38
74:            			
75:                    /*case LED_D4:
76:                        LED_D4_LAT = LED_ON;
77:                        break;*/
78:            
79:                    case LED_NONE:
80:                        break;
81:                }
0822  0872     MOVF 0x172, W
0823  00F0     MOVWF 0x170
0824  01F1     CLRF 0x171
0825  0871     MOVF 0x171, W
0826  3A00     XORLW 0x0
0827  1903     BTFSC STATUS, 0x2
0828  282A     GOTO 0x2A
0829  2838     GOTO 0x38
082A  0870     MOVF 0x170, W
082B  3A00     XORLW 0x0
082C  1903     BTFSC STATUS, 0x2
082D  2838     GOTO 0x38
082E  3A01     XORLW 0x1
082F  1903     BTFSC STATUS, 0x2
0830  2819     GOTO 0x19
0831  3A03     XORLW 0x3
0832  1903     BTFSC STATUS, 0x2
0833  281C     GOTO 0x1C
0834  3A01     XORLW 0x1
0835  1903     BTFSC STATUS, 0x2
0836  281F     GOTO 0x1F
0837  2838     GOTO 0x38
82:            }
0838  0008     RETURN
83:            
84:            /*********************************************************************
85:            * Function: void LED_Off(LED led);
86:            *
87:            * Overview: Turns requested LED off
88:            *
89:            * PreCondition: LED configured via LEDConfigure()
90:            *
91:            * Input: LED led - enumeration of the LEDs available in this
92:            *        demo.  They should be meaningful names and not the names of
93:            *        the LEDs on the silkscreen on the board (as the demo code may
94:            *        be ported to other boards).
95:            *         i.e. - LED_Off(LED_CONNECTION_DETECTED);
96:            *
97:            * Output: none
98:            *
99:            ********************************************************************/
100:           void LED_Off(LED led)
17DE  00F2     MOVWF 0x172
101:           {
102:               switch(led)
17DF  2FE9     GOTO 0x7E9
103:               {
104:                   case LED_D1:
105:                       LED_D1_LAT = LED_OFF;
17E0  0022     MOVLB 0x2
17E1  120E     BCF LATC, 0x4
106:                       break;
17E2  2FFF     GOTO 0x7FF
107:           
108:                   case LED_D2:
109:                       LED_D2_LAT = LED_OFF;
17E3  0022     MOVLB 0x2
17E4  108E     BCF LATC, 0x1
110:                       break;
17E5  2FFF     GOTO 0x7FF
111:           			
112:                   case LED_D3:
113:                       LED_D3_LAT = LED_OFF;
17E6  0022     MOVLB 0x2
17E7  110E     BCF LATC, 0x2
114:                       break;
17E8  2FFF     GOTO 0x7FF
115:           			
116:                   /*case LED_D4:
117:                       LED_D4_LAT = LED_OFF;
118:                       break;*/
119:           
120:                   case LED_NONE:
121:                       break;
122:               }
17E9  0872     MOVF 0x172, W
17EA  00F0     MOVWF 0x170
17EB  01F1     CLRF 0x171
17EC  0871     MOVF 0x171, W
17ED  3A00     XORLW 0x0
17EE  1903     BTFSC STATUS, 0x2
17EF  2FF1     GOTO 0x7F1
17F0  2FFF     GOTO 0x7FF
17F1  0870     MOVF 0x170, W
17F2  3A00     XORLW 0x0
17F3  1903     BTFSC STATUS, 0x2
17F4  2FFF     GOTO 0x7FF
17F5  3A01     XORLW 0x1
17F6  1903     BTFSC STATUS, 0x2
17F7  2FE0     GOTO 0x7E0
17F8  3A03     XORLW 0x3
17F9  1903     BTFSC STATUS, 0x2
17FA  2FE3     GOTO 0x7E3
17FB  3A01     XORLW 0x1
17FC  1903     BTFSC STATUS, 0x2
17FD  2FE6     GOTO 0x7E6
17FE  2FFF     GOTO 0x7FF
123:           }
17FF  0008     RETURN
124:           
125:           /*********************************************************************
126:           * Function: void LED_Toggle(LED led);
127:           *
128:           * Overview: Toggles the state of the requested LED
129:           *
130:           * PreCondition: LED configured via LEDConfigure()
131:           *
132:           * Input: LED led - enumeration of the LEDs available in this
133:           *        demo.  They should be meaningful names and not the names of
134:           *        the LEDs on the silkscreen on the board (as the demo code may
135:           *        be ported to other boards).
136:           *         i.e. - LED_Toggle(LED_CONNECTION_DETECTED);
137:           *
138:           * Output: none
139:           *
140:           ********************************************************************/
141:           void LED_Toggle(LED led)
142:           {
143:               switch(led)
144:               {
145:                   case LED_D1:
146:                       LED_D1_LAT ^= 1;
147:                       break;
148:           
149:                   case LED_D2:
150:                       LED_D2_LAT ^= 1;
151:                       break;
152:           			
153:                   case LED_D3:
154:                       //LED_D3_LAT ^= 1;
155:                       break;
156:           			
157:                   /*case LED_D4:
158:                       LED_D4_LAT ^= 1;
159:                       break;*/
160:           
161:                   case LED_NONE:
162:                       break;
163:               }
164:           }
165:           
166:           /*********************************************************************
167:           * Function: bool LED_Get(LED led);
168:           *
169:           * Overview: Returns the current state of the requested LED
170:           *
171:           * PreCondition: LED configured via LEDConfigure()
172:           *
173:           * Input: LED led - enumeration of the LEDs available in this
174:           *        demo.  They should be meaningful names and not the names of
175:           *        the LEDs on the silkscreen on the board (as the demo code may
176:           *        be ported to other boards).
177:           *         i.e. - LED_Get(LED_CONNECTION_DETECTED);
178:           *
179:           * Output: true if on, false if off
180:           *
181:           ********************************************************************/
182:           bool LED_Get(LED led)
183:           {
184:               switch(led)
185:               {
186:                   case LED_D1:
187:                       return ( (LED_D1_LAT == LED_ON) ? true : false );
188:           
189:                   case LED_D2:
190:                       return ( (LED_D2_LAT == LED_ON) ? true : false );
191:           			
192:                   case LED_D3:
193:                       return ( (LED_D3_LAT == LED_ON) ? true : false );
194:           			
195:                   /*case LED_D4:
196:                       return ( (LED_D4_LAT == LED_ON) ? true : false );*/
197:           
198:                   case LED_NONE:
199:                       return false;
200:               }
201:               
202:               return false;
203:           }
204:           
205:           /*********************************************************************
206:           * Function: void LED_Enable(LED led);
207:           *
208:           * Overview: Configures the LED for use by the other LED API
209:           *
210:           * PreCondition: none
211:           *
212:           * Input: LED led - enumeration of the LEDs available in this
213:           *        demo.  They should be meaningful names and not the names of
214:           *        the LEDs on the silkscreen on the board (as the demo code may
215:           *        be ported to other boards).
216:           *
217:           * Output: none
218:           *
219:           ********************************************************************/
220:           void LED_Enable(LED led)
0839  00F2     MOVWF 0x172
221:           {
222:               switch(led)
083A  2844     GOTO 0x44
223:               {
224:                   case LED_D1:
225:                       LED_D1_TRIS = PIN_OUTPUT;
083B  0021     MOVLB 0x1
083C  120E     BCF TRISC, 0x4
226:                       break;
083D  285A     GOTO 0x5A
227:           
228:                   case LED_D2:
229:                       LED_D2_TRIS = PIN_OUTPUT;
083E  0021     MOVLB 0x1
083F  108E     BCF TRISC, 0x1
230:                       break;
0840  285A     GOTO 0x5A
231:           			
232:                   case LED_D3:
233:                       LED_D3_TRIS = PIN_OUTPUT;
0841  0021     MOVLB 0x1
0842  110E     BCF TRISC, 0x2
234:                       break;
0843  285A     GOTO 0x5A
235:           			
236:                   /*case LED_D4:
237:                       LED_D4_TRIS = PIN_OUTPUT;
238:                       break;*/
239:           
240:                   case LED_NONE:
241:                       break;
242:               }
0844  0872     MOVF 0xF2, W
0845  00F0     MOVWF 0xF0
0846  01F1     CLRF 0xF1
0847  0871     MOVF 0xF1, W
0848  3A00     XORLW 0x0
0849  1903     BTFSC STATUS, 0x2
084A  284C     GOTO 0x4C
084B  285A     GOTO 0x5A
084C  0870     MOVF 0xF0, W
084D  3A00     XORLW 0x0
084E  1903     BTFSC STATUS, 0x2
084F  285A     GOTO 0x5A
0850  3A01     XORLW 0x1
0851  1903     BTFSC STATUS, 0x2
0852  283B     GOTO 0x3B
0853  3A03     XORLW 0x3
0854  1903     BTFSC STATUS, 0x2
0855  283E     GOTO 0x3E
0856  3A01     XORLW 0x1
0857  1903     BTFSC STATUS, 0x2
0858  2841     GOTO 0x41
0859  285A     GOTO 0x5A
243:           }
085A  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/buttons.c  ---------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <xc.h>
24:            #include <stdbool.h>
25:            #include <include/buttons.h>
26:            
27:            /*** Button Definitions *********************************************/
28:            #define S1_PORT  PORTCbits.RC3
29:            
30:            #define BUTTON_PRESSED      0
31:            #define BUTTON_NOT_PRESSED  1
32:            
33:            #define PIN_INPUT           1
34:            #define PIN_OUTPUT          0
35:            
36:            #define PIN_DIGITAL         1
37:            #define PIN_ANALOG          0
38:            
39:            /*********************************************************************
40:            * Function: bool BUTTON_IsPressed(BUTTON button);
41:            *
42:            * Overview: Returns the current state of the requested button
43:            *
44:            * PreCondition: button configured via BUTTON_SetConfiguration()
45:            *
46:            * Input: BUTTON button - enumeration of the buttons available in
47:            *        this demo.  They should be meaningful names and not the names 
48:            *        of the buttons on the silkscreen on the board (as the demo 
49:            *        code may be ported to other boards).
50:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
51:            *
52:            * Output: TRUE if pressed; FALSE if not pressed.
53:            *
54:            ********************************************************************/
55:            bool BUTTON_IsPressed(BUTTON button)
56:            {
57:                ANSELC = 0;
58:                switch(button)
59:                {
60:                    case BUTTON_S1:
61:                        return ( (S1_PORT == BUTTON_PRESSED) ? true : false);
62:            
63:                    case BUTTON_NONE:
64:                        return false;
65:                }
66:                
67:                return false;
68:            }
69:            
70:            /*********************************************************************
71:            * Function: void BUTTON_Enable(BUTTON button);
72:            *
73:            * Overview: Returns the current state of the requested button
74:            *
75:            * PreCondition: button configured via BUTTON_SetConfiguration()
76:            *
77:            * Input: BUTTON button - enumeration of the buttons available in
78:            *        this demo.  They should be meaningful names and not the names
79:            *        of the buttons on the silkscreen on the board (as the demo
80:            *        code may be ported to other boards).
81:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
82:            *
83:            * Output: None
84:            *
85:            ********************************************************************/
86:            void BUTTON_Enable(BUTTON button)
0805  00F2     MOVWF 0xF2
87:            {
88:                switch(button)
0806  0872     MOVF 0xF2, W
0807  00F0     MOVWF 0xF0
0808  01F1     CLRF 0xF1
0809  0871     MOVF 0xF1, W
080A  3A00     XORLW 0x0
89:                {
90:                    case BUTTON_S1:
91:                        break;
92:            
93:                    case BUTTON_NONE:
94:                        break;
95:                }
080B  1903     BTFSC STATUS, 0x2
080C  280E     GOTO 0xE
080D  2816     GOTO 0x16
080E  0870     MOVF 0xF0, W
080F  3A00     XORLW 0x0
0810  1903     BTFSC STATUS, 0x2
0811  2816     GOTO 0x16
0812  3A01     XORLW 0x1
0813  1903     BTFSC STATUS, 0x2
0814  2816     GOTO 0x16
0815  2816     GOTO 0x16
96:            }
0816  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_led_usb_status.c  ----------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            // *****************************************************************************
21:            // *****************************************************************************
22:            // Section: Included Files
23:            // *****************************************************************************
24:            // *****************************************************************************
25:            #include "stdint.h"
26:            #include "include/system.h"
27:            #include "include/usb/usb_device.h"
28:            
29:            
30:            // *****************************************************************************
31:            // *****************************************************************************
32:            // Section: File Scope or Global Constants
33:            // *****************************************************************************
34:            // *****************************************************************************
35:            
36:            
37:            // *****************************************************************************
38:            // *****************************************************************************
39:            // Section: File Scope Data Types
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            
43:            
44:            // *****************************************************************************
45:            // *****************************************************************************
46:            // Section: Macros or Functions
47:            // *****************************************************************************
48:            // *****************************************************************************
49:            
50:            void APP_LEDUpdateUSBStatus(void)
51:            {
52:                static uint16_t ledCount = 0;
53:            
54:                if(USBIsDeviceSuspended() == true)
0AF5  003D     MOVLB 0x1D
0AF6  1C8E     BTFSS UCON, 0x1
0AF7  2AF9     GOTO 0x2F9
0AF8  2AFA     GOTO 0x2FA
0AF9  2B44     GOTO 0x344
55:                {
56:                    LED_Off(LED_USB_DEVICE_STATE);
0AFA  3001     MOVLW 0x1
0AFB  3197     MOVLP 0x17
0AFC  27DE     CALL 0x7DE
0AFD  318A     MOVLP 0xA
0AFE  2B57     GOTO 0x357
57:                    return;
58:                }
59:            
60:                switch(USBGetDeviceState())
61:                {         
62:                    case CONFIGURED_STATE:
63:                        /* We are configured.  Blink fast.
64:                         * On for 75ms, off for 75ms, then reset/repeat. */
65:                        if(ledCount == 1)
0AFF  033D     DECF 0xEBD, W
0B00  043E     IORWF 0xEBE, W
0B01  1D03     BTFSS STATUS, 0x2
0B02  2B04     GOTO 0x304
0B03  2B05     GOTO 0x305
0B04  2B0A     GOTO 0x30A
66:                        {
67:                            LED_On(LED_USB_DEVICE_STATE);
0B05  3001     MOVLW 0x1
0B06  3188     MOVLP 0x8
0B07  2017     CALL 0x17
0B08  318A     MOVLP 0xA
68:                        }
0B09  2B52     GOTO 0x352
69:                        else if(ledCount == 75)
0B0A  304B     MOVLW 0x4B
0B0B  063D     XORWF 0xEBD, W
0B0C  043E     IORWF 0xEBE, W
0B0D  1D03     BTFSS STATUS, 0x2
0B0E  2B10     GOTO 0x310
0B0F  2B11     GOTO 0x311
0B10  2B16     GOTO 0x316
70:                        {
71:                            LED_Off(LED_USB_DEVICE_STATE);
0B11  3001     MOVLW 0x1
0B12  3197     MOVLP 0x17
0B13  27DE     CALL 0x7DE
0B14  318A     MOVLP 0xA
72:                        }
0B15  2B52     GOTO 0x352
73:                        else if(ledCount > 150)
0B16  3000     MOVLW 0x0
0B17  023E     SUBWF 0xEBE, W
0B18  3097     MOVLW 0x97
0B19  1903     BTFSC STATUS, 0x2
0B1A  023D     SUBWF 0xEBD, W
0B1B  1C03     BTFSS STATUS, 0x0
0B1C  2B1E     GOTO 0x31E
0B1D  2B1F     GOTO 0x31F
0B1E  2B22     GOTO 0x322
74:                        {
75:                            ledCount = 0;
0B1F  01BD     CLRF 0xEBD
0B20  01BE     CLRF 0xEBE
0B21  2B52     GOTO 0x352
76:                        }
77:                        break;
0B22  2B52     GOTO 0x352
78:            
79:                    default:
80:                        /* We aren't configured yet, but we aren't suspended so let's blink with
81:                         * a slow pulse. On for 50ms, then off for 950ms, then reset/repeat. */
82:                        if(ledCount == 1)
0B23  033D     DECF 0xEBD, W
0B24  043E     IORWF 0xEBE, W
0B25  1D03     BTFSS STATUS, 0x2
0B26  2B28     GOTO 0x328
0B27  2B29     GOTO 0x329
0B28  2B2E     GOTO 0x32E
83:                        {
84:                            LED_On(LED_USB_DEVICE_STATE);
0B29  3001     MOVLW 0x1
0B2A  3188     MOVLP 0x8
0B2B  2017     CALL 0x17
0B2C  318A     MOVLP 0xA
85:                        }
0B2D  2B52     GOTO 0x352
86:                        else if(ledCount == 50)
0B2E  3032     MOVLW 0x32
0B2F  063D     XORWF 0xEBD, W
0B30  043E     IORWF 0xEBE, W
0B31  1D03     BTFSS STATUS, 0x2
0B32  2B34     GOTO 0x334
0B33  2B35     GOTO 0x335
0B34  2B3A     GOTO 0x33A
87:                        {
88:                            LED_Off(LED_USB_DEVICE_STATE);
0B35  3001     MOVLW 0x1
0B36  3197     MOVLP 0x17
0B37  27DE     CALL 0x7DE
0B38  318A     MOVLP 0xA
89:                        }
0B39  2B52     GOTO 0x352
90:                        else if(ledCount > 950)
0B3A  3003     MOVLW 0x3
0B3B  023E     SUBWF 0xEBE, W
0B3C  30B7     MOVLW 0xB7
0B3D  1903     BTFSC STATUS, 0x2
0B3E  023D     SUBWF 0xEBD, W
0B3F  1C03     BTFSS STATUS, 0x0
0B40  2B42     GOTO 0x342
0B41  2B43     GOTO 0x343
0B42  2B52     GOTO 0x352
0B43  2B1F     GOTO 0x31F
91:                        {
92:                            ledCount = 0;
93:                        }
94:                        break;
95:                }
0B44  0021     MOVLB 0x1
0B45  0854     MOVF USBDeviceState, W
0B46  00F3     MOVWF 0xF3
0B47  01F4     CLRF 0xF4
0B48  0874     MOVF 0xF4, W
0B49  3A00     XORLW 0x0
0B4A  1903     BTFSC STATUS, 0x2
0B4B  2B4D     GOTO 0x34D
0B4C  2B23     GOTO 0x323
0B4D  0873     MOVF 0xF3, W
0B4E  3A20     XORLW 0x20
0B4F  1903     BTFSC STATUS, 0x2
0B50  2AFF     GOTO 0x2FF
0B51  2B23     GOTO 0x323
96:            
97:                /* Increment the millisecond counter. */
98:                ledCount++;
0B52  3001     MOVLW 0x1
0B53  0021     MOVLB 0x1
0B54  07BD     ADDWF ledCount, F
0B55  3000     MOVLW 0x0
0B56  3DBE     ADDWFC 0xBE, F
99:            }
0B57  0008     RETURN
100:           
101:           /*******************************************************************************
102:            End of File
103:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_device_joystick.c  ---------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #ifndef USBJOYSTICK_C
21:            #define USBJOYSTICK_C
22:            
23:            /** INCLUDES *******************************************************/
24:            #include "include/app_device_joystick.h"
25:            
26:            #include "include/system.h"
27:            
28:            #include "include/app_led_usb_status.h"
29:            #include "include/spi.h"
30:            
31:            #include "stdint.h"
32:            
33:            /** DECLARATIONS ***************************************************/
34:            
35:            USB_VOLATILE USB_HANDLE last_HAP_IN = 0;
36:            USB_VOLATILE USB_HANDLE last_HAP_OUT = 0;
37:            USB_VOLATILE USB_HANDLE last_LED_OUT = 0;
38:            USB_VOLATILE USB_HANDLE last_DSP_OUT = 0;
39:            
40:            
41:            /*********************************************************************
42:            * Function: void APP_DeviceJoystickInitialize(void);
43:            *
44:            * Overview: Initializes the demo code
45:            *
46:            * PreCondition: None
47:            *
48:            * Input: None
49:            *
50:            * Output: None
51:            *
52:            ********************************************************************/
53:            
54:            uint8_t display_pkt_ready,LED_pkt_ready,hap_IN_pkt_sent,hap_OUT_pkt_ready;
55:            
56:            void APP_DeviceJoystickInitialize(void)
57:            {  
58:                //initialize the variable holding the handle for the last
59:                // transmission
60:                last_HAP_IN = 0;
0880  0021     MOVLB 0x1
0881  01BF     CLRF last_HAP_IN
0882  01C0     CLRF 0xC0
61:                last_HAP_OUT = 0;
0883  0023     MOVLB 0x3
0884  01BA     CLRF last_HAP_OUT
0885  01BB     CLRF 0x1BB
62:                last_LED_OUT = 0;
0886  01B8     CLRF last_LED_OUT
0887  01B9     CLRF 0x1B9
63:                last_DSP_OUT = 0;
0888  01B6     CLRF last_DSP_OUT
0889  01B7     CLRF 0x1B7
64:            
65:                
66:                display_pkt_ready=0;
088A  0021     MOVLB 0x1
088B  01C4     CLRF display_pkt_ready
67:                LED_pkt_ready=0;
088C  0022     MOVLB 0x2
088D  01AD     CLRF LED_pkt_ready
68:                hap_IN_pkt_sent=1;
088E  01AC     CLRF hap_IN_pkt_sent
088F  0AAC     INCF hap_IN_pkt_sent, F
69:                hap_OUT_pkt_ready=0;
0890  01AB     CLRF hap_OUT_pkt_ready
70:            
71:                //enable the HID endpoint
72:                USBEnableEndpoint(HAPTIC_EP,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
0891  301E     MOVLW 0x1E
0892  00FD     MOVWF 0x17D
0893  087D     MOVF 0x17D, W
0894  00F7     MOVWF 0x177
0895  3001     MOVLW 0x1
0896  3188     MOVLP 0x8
0897  205B     CALL 0x5B
0898  3188     MOVLP 0x8
73:                USBEnableEndpoint(LEDS_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
0899  301E     MOVLW 0x1E
089A  00FD     MOVWF 0x17D
089B  087D     MOVF 0x17D, W
089C  00F7     MOVWF 0x177
089D  3002     MOVLW 0x2
089E  3188     MOVLP 0x8
089F  205B     CALL 0x5B
08A0  3188     MOVLP 0x8
74:                USBEnableEndpoint(DISPLAY_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
08A1  301E     MOVLW 0x1E
08A2  00FD     MOVWF 0x17D
08A3  087D     MOVF 0x17D, W
08A4  00F7     MOVWF 0x177
08A5  3003     MOVLW 0x3
08A6  3188     MOVLP 0x8
08A7  205B     CALL 0x5B
08A8  3188     MOVLP 0x8
75:            }//end UserInit
08A9  0008     RETURN
76:            
77:            /*********************************************************************
78:            * Function: void APP_DeviceJoystickTasks(void);
79:            *
80:            * Overview: Keeps the demo running.
81:            *
82:            * PreCondition: The demo should have been initialized and started via
83:            *   the APP_DeviceJoystickInitialize() and APP_DeviceJoystickStart() demos
84:            *   respectively.
85:            *
86:            * Input: None
87:            *
88:            * Output: None
89:            *
90:            ********************************************************************/
91:            
92:            uint8_t cntr=0;
93:            
94:            void APP_DeviceJoystickTasks(void)
95:            {  
96:                /* If the USB device isn't configured yet, we can't really do anything
97:                 * else since we don't have a host to talk to.  So jump back to the
98:                 * top of the while loop. */
99:                if( USBGetDeviceState() < CONFIGURED_STATE )
0538  3020     MOVLW 0x20
0539  0021     MOVLB 0x1
053A  0254     SUBWF USBDeviceState, W
053B  1803     BTFSC STATUS, 0x0
053C  2D3E     GOTO 0x53E
053D  2D3F     GOTO 0x53F
053E  2D40     GOTO 0x540
053F  2E10     GOTO 0x610
100:               {
101:                   /* Jump back to the top of the while loop. */
102:                   return;
103:               }
104:           
105:               /* If we are currently suspended, then we need to see if we need to
106:                * issue a remote wakeup.  In either case, we shouldn't process any
107:                * keyboard commands since we aren't currently communicating to the host
108:                * thus just continue back to the start of the while loop. */
109:               if( USBIsDeviceSuspended() == true )
0540  003D     MOVLB 0x1D
0541  1C8E     BTFSS UCON, 0x1
0542  2D44     GOTO 0x544
0543  2D45     GOTO 0x545
0544  2D46     GOTO 0x546
0545  2E10     GOTO 0x610
110:               {
111:                   /* Jump back to the top of the while loop. */
112:                   return;
113:               }
114:           
115:               //If the last transmission is complete
116:               if(!HIDTxHandleBusy(last_HAP_IN) && (hap_IN_pkt_sent == 0))
0546  0021     MOVLB 0x1
0547  083F     MOVF last_HAP_IN, W
0548  0440     IORWF 0xC0, W
0549  1903     BTFSC STATUS, 0x2
054A  2D4C     GOTO 0x54C
054B  2D4D     GOTO 0x54D
054C  2D55     GOTO 0x555
054D  083F     MOVF last_HAP_IN, W
054E  0086     MOVWF FSR1L
054F  0840     MOVF 0xC0, W
0550  0087     MOVWF FSR1H
0551  1B81     BTFSC INDF1, 0x7
0552  2D54     GOTO 0x554
0553  2D55     GOTO 0x555
0554  2D98     GOTO 0x598
0555  0022     MOVLB 0x2
0556  082C     MOVF hap_IN_pkt_sent, W
0557  1D03     BTFSS STATUS, 0x2
0558  2D5A     GOTO 0x55A
0559  2D5B     GOTO 0x55B
055A  2D98     GOTO 0x598
117:               {
118:                   
119:                       
120:                   haptic_in[0] = display_output[0];
055B  30B0     MOVLW 0xB0
055C  0086     MOVWF FSR1L
055D  3021     MOVLW 0x21
055E  0087     MOVWF FSR1H
055F  0801     MOVF INDF1, W
0560  00FB     MOVWF 0x17B
0561  087B     MOVF 0x17B, W
0562  0021     MOVLB 0x1
0563  00A0     MOVWF haptic_in
121:                   haptic_in[1] = display_output[1];
0564  30B0     MOVLW 0xB0
0565  0086     MOVWF FSR1L
0566  3021     MOVLW 0x21
0567  0087     MOVWF FSR1H
0568  3141     ADDFSR 1, 1
0569  0801     MOVF INDF1, W
056A  00FB     MOVWF 0xFB
056B  087B     MOVF 0xFB, W
056C  00A1     MOVWF 0xA1
122:                   haptic_in[2] = TESTB;
056D  01A2     CLRF 0xA2
123:                   haptic_in[3] = SSPCON1;
056E  0024     MOVLB 0x4
056F  0815     MOVF SSP1CON1, W
0570  00FB     MOVWF 0x27B
0571  087B     MOVF 0x27B, W
0572  0021     MOVLB 0x1
0573  00A3     MOVWF 0xA3
124:                   haptic_in[4] = SSPSTAT;
0574  0024     MOVLB 0x4
0575  0814     MOVF SSP1STAT, W
0576  00FB     MOVWF 0x27B
0577  087B     MOVF 0x27B, W
0578  0021     MOVLB 0x1
0579  00A4     MOVWF 0xA4
125:                   haptic_in[5] = display_output[63];
057A  30EF     MOVLW 0xEF
057B  0086     MOVWF FSR1L
057C  3021     MOVLW 0x21
057D  0087     MOVWF FSR1H
057E  0801     MOVF INDF1, W
057F  00FB     MOVWF 0xFB
0580  087B     MOVF 0xFB, W
0581  00A5     MOVWF 0xA5
126:                   hap_IN_pkt_sent = 1;
0582  0022     MOVLB 0x2
0583  01AC     CLRF hap_IN_pkt_sent
0584  0AAC     INCF hap_IN_pkt_sent, F
127:                       //Send the 8 byte packet over USB to the host.
128:                   last_HAP_IN = HIDTxPacket(HAPTIC_EP, (uint8_t*)&haptic_in, sizeof(haptic_in));
0585  01F0     CLRF 0x170
0586  0AF0     INCF 0x170, F
0587  30A0     MOVLW 0xA0
0588  00F1     MOVWF 0x171
0589  3000     MOVLW 0x0
058A  00F2     MOVWF 0x172
058B  3010     MOVLW 0x10
058C  00FB     MOVWF 0x17B
058D  087B     MOVF 0x17B, W
058E  00F3     MOVWF 0x173
058F  3001     MOVLW 0x1
0590  318E     MOVLP 0xE
0591  2633     CALL 0x633
0592  3185     MOVLP 0x5
0593  0871     MOVF 0x171, W
0594  0021     MOVLB 0x1
0595  00C0     MOVWF 0xC0
0596  0870     MOVF 0xF0, W
0597  00BF     MOVWF last_HAP_IN
129:                   
130:               }
131:               
132:               if(!HIDRxHandleBusy(last_HAP_OUT) && hap_OUT_pkt_ready){
0598  0023     MOVLB 0x3
0599  083A     MOVF last_HAP_OUT, W
059A  043B     IORWF 0x1BB, W
059B  1903     BTFSC STATUS, 0x2
059C  2D9E     GOTO 0x59E
059D  2D9F     GOTO 0x59F
059E  2DA7     GOTO 0x5A7
059F  083A     MOVF last_HAP_OUT, W
05A0  0086     MOVWF FSR1L
05A1  083B     MOVF 0x1BB, W
05A2  0087     MOVWF FSR1H
05A3  1B81     BTFSC INDF1, 0x7
05A4  2DA6     GOTO 0x5A6
05A5  2DA7     GOTO 0x5A7
05A6  2DC0     GOTO 0x5C0
05A7  0022     MOVLB 0x2
05A8  082B     MOVF hap_OUT_pkt_ready, W
05A9  1903     BTFSC STATUS, 0x2
05AA  2DAC     GOTO 0x5AC
05AB  2DAD     GOTO 0x5AD
05AC  2DC0     GOTO 0x5C0
133:                   hap_OUT_pkt_ready = 0;
05AD  01AB     CLRF hap_OUT_pkt_ready
134:                   last_HAP_OUT = HIDRxPacket(HAPTIC_EP, (uint8_t*)&haptic_out, sizeof(haptic_out));
05AE  01F0     CLRF 0x170
05AF  3030     MOVLW 0x30
05B0  00F1     MOVWF 0x171
05B1  3001     MOVLW 0x1
05B2  00F2     MOVWF 0x172
05B3  3040     MOVLW 0x40
05B4  00FB     MOVWF 0x17B
05B5  087B     MOVF 0x17B, W
05B6  00F3     MOVWF 0x173
05B7  3001     MOVLW 0x1
05B8  318E     MOVLP 0xE
05B9  2633     CALL 0x633
05BA  3185     MOVLP 0x5
05BB  0871     MOVF 0x171, W
05BC  0023     MOVLB 0x3
05BD  00BB     MOVWF 0x1BB
05BE  0870     MOVF 0x1F0, W
05BF  00BA     MOVWF last_HAP_OUT
135:               }
136:               if(!HIDRxHandleBusy(last_DSP_OUT) && display_pkt_ready){
05C0  0023     MOVLB 0x3
05C1  0836     MOVF last_DSP_OUT, W
05C2  0437     IORWF 0x1B7, W
05C3  1903     BTFSC STATUS, 0x2
05C4  2DC6     GOTO 0x5C6
05C5  2DC7     GOTO 0x5C7
05C6  2DCF     GOTO 0x5CF
05C7  0836     MOVF last_DSP_OUT, W
05C8  0086     MOVWF FSR1L
05C9  0837     MOVF 0x1B7, W
05CA  0087     MOVWF FSR1H
05CB  1B81     BTFSC INDF1, 0x7
05CC  2DCE     GOTO 0x5CE
05CD  2DCF     GOTO 0x5CF
05CE  2DE8     GOTO 0x5E8
05CF  0021     MOVLB 0x1
05D0  0844     MOVF display_pkt_ready, W
05D1  1903     BTFSC STATUS, 0x2
05D2  2DD4     GOTO 0x5D4
05D3  2DD5     GOTO 0x5D5
05D4  2DE8     GOTO 0x5E8
137:                   display_pkt_ready = 0;
05D5  01C4     CLRF display_pkt_ready
138:                   last_DSP_OUT = HIDRxPacket(DISPLAY_EP, (uint8_t*)&display_output, sizeof(display_output));
05D6  01F0     CLRF 0xF0
05D7  30B0     MOVLW 0xB0
05D8  00F1     MOVWF 0xF1
05D9  3021     MOVLW 0x21
05DA  00F2     MOVWF 0xF2
05DB  3040     MOVLW 0x40
05DC  00FB     MOVWF 0xFB
05DD  087B     MOVF 0xFB, W
05DE  00F3     MOVWF 0xF3
05DF  3003     MOVLW 0x3
05E0  318E     MOVLP 0xE
05E1  2633     CALL 0x633
05E2  3185     MOVLP 0x5
05E3  0871     MOVF 0xF1, W
05E4  0023     MOVLB 0x3
05E5  00B7     MOVWF 0x1B7
05E6  0870     MOVF 0x1F0, W
05E7  00B6     MOVWF last_DSP_OUT
139:               }
140:               if(!HIDRxHandleBusy(last_LED_OUT) && LED_pkt_ready){
05E8  0023     MOVLB 0x3
05E9  0838     MOVF last_LED_OUT, W
05EA  0439     IORWF 0x1B9, W
05EB  1903     BTFSC STATUS, 0x2
05EC  2DEE     GOTO 0x5EE
05ED  2DEF     GOTO 0x5EF
05EE  2DF7     GOTO 0x5F7
05EF  0838     MOVF last_LED_OUT, W
05F0  0086     MOVWF FSR1L
05F1  0839     MOVF 0x1B9, W
05F2  0087     MOVWF FSR1H
05F3  1B81     BTFSC INDF1, 0x7
05F4  2DF6     GOTO 0x5F6
05F5  2DF7     GOTO 0x5F7
05F6  2E10     GOTO 0x610
05F7  0022     MOVLB 0x2
05F8  082D     MOVF LED_pkt_ready, W
05F9  1903     BTFSC STATUS, 0x2
05FA  2DFC     GOTO 0x5FC
05FB  2DFD     GOTO 0x5FD
05FC  2E10     GOTO 0x610
141:                   LED_pkt_ready = 0;
05FD  01AD     CLRF LED_pkt_ready
142:                   last_LED_OUT = HIDRxPacket(LEDS_EP, (uint8_t*)&leds_output, sizeof(leds_output));
05FE  01F0     CLRF 0x170
05FF  3030     MOVLW 0x30
0600  00F1     MOVWF 0x171
0601  3021     MOVLW 0x21
0602  00F2     MOVWF 0x172
0603  3031     MOVLW 0x31
0604  00FB     MOVWF 0x17B
0605  087B     MOVF 0x17B, W
0606  00F3     MOVWF 0x173
0607  3002     MOVLW 0x2
0608  318E     MOVLP 0xE
0609  2633     CALL 0x633
060A  3185     MOVLP 0x5
060B  0871     MOVF 0x171, W
060C  0023     MOVLB 0x3
060D  00B9     MOVWF 0x1B9
060E  0870     MOVF 0x1F0, W
060F  00B8     MOVWF last_LED_OUT
143:               }
144:               
145:           }//end ProcessIO
0610  0008     RETURN
146:           
147:           #endif
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memset.c  ---------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
0611  0871     MOVF 0x1F1, W
0612  00FD     MOVWF 0x1FD
0613  0870     MOVF 0x1F0, W
0614  00FC     MOVWF 0x1FC
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
0615  0874     MOVF 0x1F4, W
0616  0475     IORWF 0x1F5, W
0617  1D03     BTFSS STATUS, 0x2
0618  2E1A     GOTO 0x61A
0619  2E1B     GOTO 0x61B
061A  2E1C     GOTO 0x61C
061B  2EDA     GOTO 0x6DA
14:            	s[0] = (unsigned char)c;
061C  087C     MOVF 0x1FC, W
061D  0086     MOVWF FSR1L
061E  087D     MOVF 0x1FD, W
061F  0087     MOVWF FSR1H
0620  0872     MOVF 0x1F2, W
0621  0081     MOVWF INDF1
15:            	s[n-1] = (unsigned char)c;
0622  0874     MOVF 0x1F4, W
0623  077C     ADDWF 0x1FC, W
0624  00F6     MOVWF 0x1F6
0625  0875     MOVF 0x1F5, W
0626  3D7D     ADDWFC 0x1FD, W
0627  00F7     MOVWF 0x1F7
0628  0876     MOVF 0x1F6, W
0629  3EFF     ADDLW 0xFF
062A  00F8     MOVWF 0x1F8
062B  30FF     MOVLW 0xFF
062C  3D77     ADDWFC 0x1F7, W
062D  00F9     MOVWF 0x1F9
062E  0878     MOVF 0x1F8, W
062F  0086     MOVWF FSR1L
0630  0879     MOVF 0x1F9, W
0631  0087     MOVWF FSR1H
0632  0872     MOVF 0x1F2, W
0633  0081     MOVWF INDF1
16:            	if (n <= 2) return dest;
0634  3000     MOVLW 0x0
0635  0275     SUBWF 0x1F5, W
0636  3003     MOVLW 0x3
0637  1903     BTFSC STATUS, 0x2
0638  0274     SUBWF 0x1F4, W
0639  1803     BTFSC STATUS, 0x0
063A  2E3C     GOTO 0x63C
063B  2E3D     GOTO 0x63D
063C  2E3E     GOTO 0x63E
063D  2EDA     GOTO 0x6DA
17:            	s[1] = (unsigned char)c;
063E  087C     MOVF 0x1FC, W
063F  3E01     ADDLW 0x1
0640  00F6     MOVWF 0x1F6
0641  3000     MOVLW 0x0
0642  3D7D     ADDWFC 0x1FD, W
0643  00F7     MOVWF 0x1F7
0644  0876     MOVF 0x1F6, W
0645  0086     MOVWF FSR1L
0646  0877     MOVF 0x1F7, W
0647  0087     MOVWF FSR1H
0648  0872     MOVF 0x1F2, W
0649  0081     MOVWF INDF1
18:            	s[2] = (unsigned char)c;
064A  087C     MOVF 0x1FC, W
064B  3E02     ADDLW 0x2
064C  00F6     MOVWF 0x1F6
064D  3000     MOVLW 0x0
064E  3D7D     ADDWFC 0x1FD, W
064F  00F7     MOVWF 0x1F7
0650  0876     MOVF 0x1F6, W
0651  0086     MOVWF FSR1L
0652  0877     MOVF 0x1F7, W
0653  0087     MOVWF FSR1H
0654  0872     MOVF 0x1F2, W
0655  0081     MOVWF INDF1
19:            	s[n-2] = (unsigned char)c;
0656  0874     MOVF 0x1F4, W
0657  077C     ADDWF 0x1FC, W
0658  00F6     MOVWF 0x1F6
0659  0875     MOVF 0x1F5, W
065A  3D7D     ADDWFC 0x1FD, W
065B  00F7     MOVWF 0x1F7
065C  0876     MOVF 0x1F6, W
065D  3EFE     ADDLW 0xFE
065E  00F8     MOVWF 0x1F8
065F  30FF     MOVLW 0xFF
0660  3D77     ADDWFC 0x1F7, W
0661  00F9     MOVWF 0x1F9
0662  0878     MOVF 0x1F8, W
0663  0086     MOVWF FSR1L
0664  0879     MOVF 0x1F9, W
0665  0087     MOVWF FSR1H
0666  0872     MOVF 0x1F2, W
0667  0081     MOVWF INDF1
20:            	s[n-3] = (unsigned char)c;
0668  0874     MOVF 0x1F4, W
0669  077C     ADDWF 0x1FC, W
066A  00F6     MOVWF 0x1F6
066B  0875     MOVF 0x1F5, W
066C  3D7D     ADDWFC 0x1FD, W
066D  00F7     MOVWF 0x1F7
066E  0876     MOVF 0x1F6, W
066F  3EFD     ADDLW 0xFD
0670  00F8     MOVWF 0x1F8
0671  30FF     MOVLW 0xFF
0672  3D77     ADDWFC 0x1F7, W
0673  00F9     MOVWF 0x1F9
0674  0878     MOVF 0x1F8, W
0675  0086     MOVWF FSR1L
0676  0879     MOVF 0x1F9, W
0677  0087     MOVWF FSR1H
0678  0872     MOVF 0x1F2, W
0679  0081     MOVWF INDF1
21:            	if (n <= 6) return dest;
067A  3000     MOVLW 0x0
067B  0275     SUBWF 0x1F5, W
067C  3007     MOVLW 0x7
067D  1903     BTFSC STATUS, 0x2
067E  0274     SUBWF 0x1F4, W
067F  1803     BTFSC STATUS, 0x0
0680  2E82     GOTO 0x682
0681  2E83     GOTO 0x683
0682  2E84     GOTO 0x684
0683  2EDA     GOTO 0x6DA
22:            	s[3] = (unsigned char)c;
0684  087C     MOVF 0x1FC, W
0685  3E03     ADDLW 0x3
0686  00F6     MOVWF 0x1F6
0687  3000     MOVLW 0x0
0688  3D7D     ADDWFC 0x1FD, W
0689  00F7     MOVWF 0x1F7
068A  0876     MOVF 0x1F6, W
068B  0086     MOVWF FSR1L
068C  0877     MOVF 0x1F7, W
068D  0087     MOVWF FSR1H
068E  0872     MOVF 0x1F2, W
068F  0081     MOVWF INDF1
23:            	s[n-4] = (unsigned char)c;
0690  0874     MOVF 0x1F4, W
0691  077C     ADDWF 0x1FC, W
0692  00F6     MOVWF 0x1F6
0693  0875     MOVF 0x1F5, W
0694  3D7D     ADDWFC 0x1FD, W
0695  00F7     MOVWF 0x1F7
0696  0876     MOVF 0x1F6, W
0697  3EFC     ADDLW 0xFC
0698  00F8     MOVWF 0x1F8
0699  30FF     MOVLW 0xFF
069A  3D77     ADDWFC 0x1F7, W
069B  00F9     MOVWF 0x1F9
069C  0878     MOVF 0x1F8, W
069D  0086     MOVWF FSR1L
069E  0879     MOVF 0x1F9, W
069F  0087     MOVWF FSR1H
06A0  0872     MOVF 0x1F2, W
06A1  0081     MOVWF INDF1
24:            	if (n <= 8) return dest;
06A2  3000     MOVLW 0x0
06A3  0275     SUBWF 0x1F5, W
06A4  3009     MOVLW 0x9
06A5  1903     BTFSC STATUS, 0x2
06A6  0274     SUBWF 0x1F4, W
06A7  1803     BTFSC STATUS, 0x0
06A8  2EAA     GOTO 0x6AA
06A9  2EAB     GOTO 0x6AB
06AA  2EAC     GOTO 0x6AC
06AB  2EDA     GOTO 0x6DA
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
06AC  097C     COMF 0x1FC, W
06AD  00F6     MOVWF 0x1F6
06AE  097D     COMF 0x1FD, W
06AF  00F7     MOVWF 0x1F7
06B0  0AF6     INCF 0x1F6, F
06B1  1903     BTFSC STATUS, 0x2
06B2  0AF7     INCF 0x1F7, F
06B3  3003     MOVLW 0x3
06B4  0576     ANDWF 0x1F6, W
06B5  00FA     MOVWF 0x1FA
06B6  3000     MOVLW 0x0
06B7  0577     ANDWF 0x1F7, W
06B8  00FB     MOVWF 0x1FB
32:            	s += k;
06B9  087A     MOVF 0x1FA, W
06BA  07FC     ADDWF 0x1FC, F
06BB  087B     MOVF 0x1FB, W
06BC  3DFD     ADDWFC 0x1FD, F
33:            	n -= k;
06BD  087A     MOVF 0x1FA, W
06BE  02F4     SUBWF 0x1F4, F
06BF  087B     MOVF 0x1FB, W
06C0  3BF5     SUBWFB 0x1F5, F
34:            	n &= (size_t)-4;
06C1  30FC     MOVLW 0xFC
06C2  05F4     ANDWF 0x1F4, F
06C3  30FF     MOVLW 0xFF
06C4  05F5     ANDWF 0x1F5, F
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
06C5  2ED4     GOTO 0x6D4
06C6  087C     MOVF 0x1FC, W
06C7  0086     MOVWF FSR1L
06C8  087D     MOVF 0x1FD, W
06C9  0087     MOVWF FSR1H
06CA  0872     MOVF 0x1F2, W
06CB  0081     MOVWF INDF1
06CC  3001     MOVLW 0x1
06CD  02F4     SUBWF 0x1F4, F
06CE  3000     MOVLW 0x0
06CF  3BF5     SUBWFB 0x1F5, F
06D0  3001     MOVLW 0x1
06D1  07FC     ADDWF 0x1FC, F
06D2  3000     MOVLW 0x0
06D3  3DFD     ADDWFC 0x1FD, F
06D4  0874     MOVF 0x1F4, W
06D5  0475     IORWF 0x1F5, W
06D6  1D03     BTFSS STATUS, 0x2
06D7  2ED9     GOTO 0x6D9
06D8  2EDA     GOTO 0x6DA
06D9  2EC6     GOTO 0x6C6
87:            #endif
88:            
89:            	return dest;
90:            }
06DA  0008     RETURN
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memcpy.c  ---------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
08D5  00F8     MOVWF 0x1F8
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
08D6  0871     MOVF 0x1F1, W
08D7  00F6     MOVWF 0x1F6
08D8  0870     MOVF 0x1F0, W
08D9  00F5     MOVWF 0x1F5
12:            	d = d1;
08DA  0878     MOVF 0x1F8, W
08DB  00F4     MOVWF 0x1F4
08DC  0874     MOVF 0x1F4, W
08DD  00F9     MOVWF 0x1F9
13:            	while(n--) {
08DE  28F6     GOTO 0xF6
08F6  3001     MOVLW 0x1
08F7  02F2     SUBWF 0x1F2, F
08F8  3000     MOVLW 0x0
08F9  3BF3     SUBWFB 0x1F3, F
08FA  0A72     INCF 0x1F2, W
08FB  1D03     BTFSS STATUS, 0x2
08FC  2901     GOTO 0x101
08FD  0A73     INCF 0x1F3, W
08FE  1D03     BTFSS STATUS, 0x2
08FF  2901     GOTO 0x101
0900  2902     GOTO 0x102
0901  28DF     GOTO 0xDF
14:            		tmp = *s++;
08DF  0875     MOVF 0x1F5, W
08E0  0086     MOVWF FSR1L
08E1  0876     MOVF 0x1F6, W
08E2  0087     MOVWF FSR1H
08E3  0801     MOVF INDF1, W
08E4  00F4     MOVWF 0x1F4
08E5  0874     MOVF 0x1F4, W
08E6  00F7     MOVWF 0x1F7
08E7  3001     MOVLW 0x1
08E8  07F5     ADDWF 0x1F5, F
08E9  3000     MOVLW 0x0
08EA  3DF6     ADDWFC 0x1F6, F
15:            		*d++ = tmp;
08EB  0877     MOVF 0x1F7, W
08EC  00F4     MOVWF 0x1F4
08ED  0879     MOVF 0x1F9, W
08EE  0086     MOVWF FSR1L
08EF  0187     CLRF FSR1H
08F0  0874     MOVF 0x1F4, W
08F1  0081     MOVWF INDF1
08F2  3001     MOVLW 0x1
08F3  00F4     MOVWF 0x1F4
08F4  0874     MOVF 0x1F4, W
08F5  07F9     ADDWF 0x1F9, F
08F6  3001     MOVLW 0x1
08F7  02F2     SUBWF 0x1F2, F
08F8  3000     MOVLW 0x0
08F9  3BF3     SUBWFB 0x1F3, F
08FA  0A72     INCF 0x1F2, W
08FB  1D03     BTFSS STATUS, 0x2
08FC  2901     GOTO 0x101
08FD  0A73     INCF 0x1F3, W
08FE  1D03     BTFSS STATUS, 0x2
08FF  2901     GOTO 0x101
0900  2902     GOTO 0x102
0901  28DF     GOTO 0xDF
16:            	}
17:            	return d1;
18:            }
0902  0008     RETURN
19:            
---  C:/Users/Dutu/AppData/Local/Temp/xcAs1oho.s  -------------------------------------------------------
000A  3046     MOVLW 0x46
000B  0084     MOVWF FSR0L
000C  3097     MOVLW 0x97
000D  0085     MOVWF FSR0H
000E  0023     MOVLB 0x3
000F  0012     MOVIW FSR0++
0010  00C0     MOVWF __pdataBANK3
0011  0012     MOVIW FSR0++
0012  00C1     MOVWF 0x1C1
0013  0012     MOVIW FSR0++
0014  00C2     MOVWF 0x1C2
0015  0012     MOVIW FSR0++
0016  00C3     MOVWF 0x1C3
0017  0012     MOVIW FSR0++
0018  00C4     MOVWF 0x1C4
0019  0012     MOVIW FSR0++
001A  00C5     MOVWF 0x1C5
001B  0012     MOVIW FSR0++
001C  00C6     MOVWF 0x1C6
001D  0012     MOVIW FSR0++
001E  00C7     MOVWF 0x1C7
1757  0064     CLRWDT
1758  0180     CLRF INDF0
1759  3101     ADDFSR 0, 1
175A  3001     MOVLW 0x1
175B  02FE     SUBWF 0x1FE, F
175C  3000     MOVLW 0x0
175D  3BFF     SUBWFB 0x1FF, F
175E  087F     MOVF 0x1FF, W
175F  047E     IORWF 0x1FE, W
1760  1D03     BTFSS STATUS, 0x2
1761  2F58     GOTO 0x758
1762  3400     RETLW 0x0
001F  30B0     MOVLW 0xB0
0020  0084     MOVWF FSR0L
0021  3000     MOVLW 0x0
0022  0085     MOVWF FSR0H
0023  3029     MOVLW 0x29
0024  00FE     MOVWF 0x1FE
0025  3000     MOVLW 0x0
0026  00FF     MOVWF 0x1FF
0027  3197     MOVLP 0x17
002A  3020     MOVLW 0x20
002B  0084     MOVWF FSR0L
002C  3001     MOVLW 0x1
002D  0085     MOVWF FSR0H
002E  3010     MOVLW 0x10
002F  00FE     MOVWF 0x1FE
0030  3000     MOVLW 0x0
0031  00FF     MOVWF 0x1FF
0032  3197     MOVLP 0x17
0035  30A0     MOVLW 0xA0
0036  0084     MOVWF FSR0L
0037  3001     MOVLW 0x1
0038  0085     MOVWF FSR0H
0039  3020     MOVLW 0x20
003A  00FE     MOVWF 0x1FE
003B  3000     MOVLW 0x0
003C  00FF     MOVWF 0x1FF
003D  3197     MOVLP 0x17
0040  107E     BCF 0x1FE, 0x0
0041  0020     MOVLB 0x0
0042  3189     MOVLP 0x9
