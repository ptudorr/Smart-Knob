Disassembly Listing for USB_Device_-_HID_-_Joystick
Generated From:
E:/Smart-Knob/pic16f1455_firmware/dist/LPCUSBDK_16F1455/production/pic16f1455_firmware.production.elf
Nov 5, 2022 1:27:05 AM

---  E:/Smart-Knob/pic16f1455_firmware/main.c  ----------------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #define _XTAL_FREQ 48000000
22:            #include "include/system.h"
23:            
24:            #include "include/usb/usb.h"
25:            #include "include/usb/usb_device_hid.h"
26:            
27:            #include "include/app_device_joystick.h"
28:            #include "include/app_led_usb_status.h"
29:            
30:            #include "include/spi.h"
31:            
32:            MAIN_RETURN main(void)
33:            {
34:                
35:                TRIS_MOSI_SDI_PIN = 1;TRIS_MISO_SDO_PIN = 0;
0824  0021     MOVLB 0x1
0825  148E     BSF TRISC, 0x1
0826  110E     BCF TRISC, 0x2
36:                //SYSTEM_Initialize(SYSTEM_STATE_USB_START);
37:                __delay_ms(200);
0827  300D     MOVLW 0xD
0828  0021     MOVLB 0x1
0829  00EF     MOVWF 0xEF
082A  302D     MOVLW 0x2D
082B  00EE     MOVWF 0xEE
082C  30D7     MOVLW 0xD7
082D  0B89     DECFSZ WREG, F
082E  282D     GOTO 0x2D
082F  0BEE     DECFSZ 0xEE, F
0830  282D     GOTO 0x2D
0831  0BEF     DECFSZ 0xEF, F
0832  282D     GOTO 0x2D
0833  3200     BRA 0x834
38:                
39:                SlaveinitSPI();
0834  3196     MOVLP 0x16
0835  2662     CALL 0x662
0836  3188     MOVLP 0x8
40:                
41:                USBDeviceInit();
0837  318F     MOVLP 0xF
0838  2756     CALL 0x756
0839  3188     MOVLP 0x8
42:                USBDeviceAttach();
43:            
44:                TRISCbits.TRISC4 = 0;
083A  0021     MOVLB 0x1
083B  120E     BCF TRISC, 0x4
45:                
46:                while(1)
47:                {
48:                    LATCbits.LATC4 = 0;
083C  0022     MOVLB 0x2
083D  120E     BCF LATC, 0x4
49:                    spiTask();
083E  3185     MOVLP 0x5
083F  252D     CALL 0x52D
0840  3188     MOVLP 0x8
50:                    LATCbits.LATC4 = 1;
0841  0022     MOVLB 0x2
0842  160E     BSF LATC, 0x4
51:                    SYSTEM_Tasks();
52:                    #if defined(USB_POLLING)
53:                        // Interrupt or polling method.  If using polling, must call
54:                        // this function periodically.  This function will take care
55:                        // of processing and responding to SETUP transactions
56:                        // (such as during the enumeration process when you first
57:                        // plug in).  USB hosts require that USB devices should accept
58:                        // and process SETUP packets in a timely fashion.  Therefore,
59:                        // when using polling, this function should be called
60:                        // regularly (such as once every 1.8ms or faster** [see
61:                        // inline code comments in usb_device.c for explanation when
62:                        // "or faster" applies])  In most cases, the USBDeviceTasks()
63:                        // function does not take very long to execute (ex: <100
64:                        // instruction cycles) before it returns.
65:                        USBDeviceTasks();
0843  3182     MOVLP 0x2
0844  22E7     CALL 0x2E7
0845  3188     MOVLP 0x8
66:                    #endif
67:            
68:                    // If the USB device isn't configured yet, we can't really do anything
69:                    // else since we don't have a host to talk to.  So jump back to the
70:                    // top of the while loop. 
71:                    if( USBGetDeviceState() < CONFIGURED_STATE )
0846  3020     MOVLW 0x20
0847  0021     MOVLB 0x1
0848  0255     SUBWF USBDeviceState, W
0849  1803     BTFSC STATUS, 0x0
084A  284C     GOTO 0x4C
084B  284D     GOTO 0x4D
084C  284E     GOTO 0x4E
084D  283C     GOTO 0x3C
72:                    {
73:                        // Jump back to the top of the while loop. 
74:                        continue;
75:                    }
76:            
77:                    // If we are currently suspended, then we need to see if we need to
78:                    // issue a remote wakeup.  In either case, we shouldn't process any
79:                    // keyboard commands since we aren't currently communicating to the host
80:                    // thus just continue back to the start of the while loop. 
81:                    if( USBIsDeviceSuspended() == true )
084E  003D     MOVLB 0x1D
084F  1C8E     BTFSS UCON, 0x1
0850  2852     GOTO 0x52
0851  2853     GOTO 0x53
0852  2854     GOTO 0x54
0853  283C     GOTO 0x3C
82:                    {
83:                        // Jump back to the top of the while loop. 
84:                        continue;
85:                    }
86:            
87:                    //Application specific tasks
88:                    APP_DeviceJoystickTasks();
0854  3186     MOVLP 0x6
0855  2619     CALL 0x619
0856  3188     MOVLP 0x8
0857  283C     GOTO 0x3C
0858  3180     MOVLP 0x0
89:                    
90:                    
91:                    //endfor
92:            
93:                }//end while
94:            }//end main
95:            
96:            /*******************************************************************************
97:             End of File
98:            */
99:            
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_events.c  --------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #include "include/system.h"
22:            
23:            #include "include/usb/usb.h"
24:            #include "include/usb/usb_device_hid.h"
25:            
26:            #include "include/app_device_joystick.h"
27:            #include "include/app_led_usb_status.h"
28:            
29:            /*******************************************************************
30:             * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
31:             *                        USB_EVENT event, void *pdata, uint16_t size)
32:             *
33:             * PreCondition:    None
34:             *
35:             * Input:           USB_EVENT event - the type of event
36:             *                  void *pdata - pointer to the event data
37:             *                  uint16_t size - size of the event data
38:             *
39:             * Output:          None
40:             *
41:             * Side Effects:    None
42:             *
43:             * Overview:        This function is called from the USB stack to
44:             *                  notify a user application that a USB event
45:             *                  occured.  This callback is in interrupt context
46:             *                  when the USB_INTERRUPT option is selected.
47:             *
48:             * Note:            None
49:             *******************************************************************/
50:            bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
51:            {
52:                switch( (int) event )
0892  28AF     GOTO 0xAF
53:                {
54:                    case EVENT_TRANSFER:
55:                        break;
56:            
57:                    case EVENT_SOF:
58:                        /* We are using the SOF as a timer to time the LED indicator.  Call
59:                         * the LED update function here. */
60:                        APP_LEDUpdateUSBStatus();
0893  3189     MOVLP 0x9
0894  21D3     CALL 0x1D3
0895  3188     MOVLP 0x8
61:                        break;
0896  28D7     GOTO 0xD7
62:            
63:                    case EVENT_SUSPEND:
64:                        /* Update the LED status for the suspend event. */
65:                        APP_LEDUpdateUSBStatus();
0897  3189     MOVLP 0x9
0898  21D3     CALL 0x1D3
0899  3188     MOVLP 0x8
66:            
67:                        //Call the hardware platform specific handler for suspend events for
68:                        //possible further action (like optionally going reconfiguring the application
69:                        //for lower power states and going to sleep during the suspend event).  This
70:                        //would normally be done in USB compliant bus powered applications, although
71:                        //no further processing is needed for purely self powered applications that
72:                        //don't consume power from the host.
73:                        SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND);
089A  3001     MOVLW 0x1
089B  3196     MOVLP 0x16
089C  26CF     CALL 0x6CF
089D  3188     MOVLP 0x8
74:                        break;
089E  28D7     GOTO 0xD7
75:            
76:                    case EVENT_RESUME:
77:                        /* Update the LED status for the resume event. */
78:                        APP_LEDUpdateUSBStatus();
089F  3189     MOVLP 0x9
08A0  21D3     CALL 0x1D3
08A1  3188     MOVLP 0x8
79:            
80:                        //Call the hardware platform specific resume from suspend handler (ex: to
81:                        //restore I/O pins to higher power states if they were changed during the 
82:                        //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
83:                        //of the suspend condition.
84:                        SYSTEM_Initialize(SYSTEM_STATE_USB_RESUME);
08A2  3002     MOVLW 0x2
08A3  3196     MOVLP 0x16
08A4  26CF     CALL 0x6CF
08A5  3188     MOVLP 0x8
85:                        break;
08A6  28D7     GOTO 0xD7
86:            
87:                    case EVENT_CONFIGURED:
88:                        /* When the device is configured, we can (re)initialize the demo
89:                         * code. */
90:                        APP_DeviceJoystickInitialize();
08A7  3197     MOVLP 0x17
08A8  27A5     CALL 0x7A5
08A9  3188     MOVLP 0x8
91:                        break;
08AA  28D7     GOTO 0xD7
92:            
93:                    case EVENT_SET_DESCRIPTOR:
94:                        break;
95:            
96:                    case EVENT_EP0_REQUEST:
97:                        /* We have received a non-standard USB request.  The HID driver
98:                         * needs to check to see if the request was for it. */
99:                        USBCheckHIDRequest();
08AB  3184     MOVLP 0x4
08AC  2416     CALL 0x416
08AD  3188     MOVLP 0x8
100:                       break;
08AE  28D7     GOTO 0xD7
101:           
102:                   case EVENT_BUS_ERROR:
103:                       break;
104:           
105:                   case EVENT_TRANSFER_TERMINATED:
106:                       break;
107:           
108:                   default:
109:                       break;
110:               }
08AF  0021     MOVLB 0x1
08B0  085A     MOVF 0xDA, W
08B1  3A00     XORLW 0x0
08B2  1903     BTFSC STATUS, 0x2
08B3  28B8     GOTO 0xB8
08B4  3A7F     XORLW 0x7F
08B5  1903     BTFSC STATUS, 0x2
08B6  28D2     GOTO 0xD2
08B7  28D7     GOTO 0xD7
08B8  0859     MOVF __pcstackBANK1, W
08B9  3A01     XORLW 0x1
08BA  1903     BTFSC STATUS, 0x2
08BB  28A7     GOTO 0xA7
08BC  3A03     XORLW 0x3
08BD  1903     BTFSC STATUS, 0x2
08BE  28D7     GOTO 0xD7
08BF  3A01     XORLW 0x1
08C0  1903     BTFSC STATUS, 0x2
08C1  28AB     GOTO 0xAB
08C2  3A06     XORLW 0x6
08C3  1903     BTFSC STATUS, 0x2
08C4  28D7     GOTO 0xD7
08C5  3A77     XORLW 0x77
08C6  1903     BTFSC STATUS, 0x2
08C7  28D7     GOTO 0xD7
08C8  3A01     XORLW 0x1
08C9  1903     BTFSC STATUS, 0x2
08CA  2893     GOTO 0x93
08CB  3A07     XORLW 0x7
08CC  1903     BTFSC STATUS, 0x2
08CD  289F     GOTO 0x9F
08CE  3A01     XORLW 0x1
08CF  1903     BTFSC STATUS, 0x2
08D0  2897     GOTO 0x97
08D1  28D7     GOTO 0xD7
08D2  0859     MOVF __pcstackBANK1, W
08D3  3AFF     XORLW 0xFF
08D4  1903     BTFSC STATUS, 0x2
08D5  28D7     GOTO 0xD7
08D6  28D7     GOTO 0xD7
111:               return true;
112:           }
08D7  0008     RETURN
113:           
114:           
115:           /*******************************************************************************
116:            End of File
117:           */
118:           
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device_hid.c  ----------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Human Interface Device (HID) Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device_hid.c
30:            
31:              Summary:
32:                USB Device Human Interface Device (HID) Layer interface API.
33:            
34:              Description:
35:                USB Device Human Interface Device (HID) Layer interface API.
36:            *******************************************************************************/
37:            
38:            
39:            // *****************************************************************************
40:            // *****************************************************************************
41:            // Section: Included Files
42:            // *****************************************************************************
43:            // *****************************************************************************
44:            #include "include/usb/usb_config.h"
45:            #include "include/usb/usb.h"
46:            #include "include/usb/usb_device_hid.h"
47:            
48:            #if defined(__XC8)
49:                #define PACKED
50:                #define ALIGNED
51:            #else
52:                #define PACKED __attribute__((packed))
53:                #define ALIGNED __attribute__((aligned))
54:            #endif
55:            
56:            // *****************************************************************************
57:            // *****************************************************************************
58:            // Section: File Scope or Global Constants
59:            // *****************************************************************************
60:            // *****************************************************************************
61:            
62:            // *****************************************************************************
63:            // *****************************************************************************
64:            // Section: File Scope Data Types
65:            // *****************************************************************************
66:            // *****************************************************************************
67:            typedef struct PACKED
68:            {
69:                unsigned :8;
70:                unsigned :8;
71:                uint8_t reportId;
72:                uint8_t duration;
73:            } USB_SETUP_SET_IDLE_RATE;
74:            
75:            typedef struct PACKED
76:            {
77:                unsigned :8;
78:                unsigned :8;
79:                uint8_t protocol;
80:            } USB_SETUP_SET_PROTOCOL;
81:            
82:            // *****************************************************************************
83:            // *****************************************************************************
84:            // Section: Variables
85:            // *****************************************************************************
86:            // *****************************************************************************
87:            static uint8_t idle_rate;
88:            static uint8_t active_protocol;   // [0] Boot Protocol [1] Report Protocol
89:            
90:            extern const struct{uint8_t report[HAPTIC_RPT_SIZE];}HAPTIC_rpt;
91:            extern const struct{uint8_t report[LED_RPT_SIZE];}LED_rpt;
92:            extern const struct{uint8_t report[DISPLAY_RPT_SIZE];}DISPLAY_rpt;
93:            
94:            // *****************************************************************************
95:            // *****************************************************************************
96:            // Section: Prototypes
97:            // *****************************************************************************
98:            // *****************************************************************************
99:            #if defined USER_GET_REPORT_HANDLER
100:               void USER_GET_REPORT_HANDLER(void);
101:           #endif
102:           
103:           #if defined USER_SET_REPORT_HANDLER
104:               extern void USER_SET_REPORT_HANDLER(void);
105:           #endif
106:           
107:           // *****************************************************************************
108:           // *****************************************************************************
109:           // Section: Macros or Functions
110:           // *****************************************************************************
111:           // *****************************************************************************
112:           
113:           //To implement a set idle rate callback function in the application,
114:           //Make sure "#define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportID, newIdleRate)    USBHIDCBSetIdleRateHandler(reportID, newIdleRate)"
115:           //is placed in your usb_config.h file, and then in your application .c file,
116:           //add the void USBHIDCBSetIdleRateHandler(reportID, newIdleRate) function
117:           //implementation that saves the new idle rate and report ID info, so that it
118:           //gets used later when sending subsequent HID input report packets to the host.
119:           #ifndef USB_DEVICE_HID_IDLE_RATE_CALLBACK
120:               #define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportId, idleRate)
121:           #else
122:               extern void USB_DEVICE_HID_IDLE_RATE_CALLBACK(uint8_t reportId, uint8_t idleRate);
123:           #endif
124:           
125:           /********************************************************************
126:           	Function:
127:           		void USBCheckHIDRequest(void)
128:           
129:            	Summary:
130:            		This routine handles HID specific request that happen on EP0.
131:                   This function should be called from the USBCBCheckOtherReq() call back
132:                   function whenever implementing a HID device.
133:           
134:            	Description:
135:            		This routine handles HID specific request that happen on EP0.  These
136:                   include, but are not limited to, requests for the HID report
137:                   descriptors.  This function should be called from the
138:                   USBCBCheckOtherReq() call back function whenever using an HID device.
139:           
140:                   Typical Usage:
141:                   <code>
142:                   void USBCBCheckOtherReq(void)
143:                   {
144:                       //Since the stack didn't handle the request I need to check
145:                       //  my class drivers to see if it is for them
146:                       USBCheckHIDRequest();
147:                   }
148:                   </code>
149:           
150:           	PreCondition:
151:           		None
152:           
153:           	Parameters:
154:           		None
155:           
156:           	Return Values:
157:           		None
158:           
159:           	Remarks:
160:           		None
161:           
162:            *******************************************************************/
163:           void USBCheckHIDRequest(void)
164:           {
165:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
0416  0020     MOVLB 0x0
0417  0860     MOVF SetupPkt, W
0418  391F     ANDLW 0x1F
0419  3A01     XORLW 0x1
041A  1903     BTFSC STATUS, 0x2
041B  2C1D     GOTO 0x41D
041C  2C1E     GOTO 0x41E
041D  2C1F     GOTO 0x41F
041E  2D2C     GOTO 0x52C
166:               if(SetupPkt.bIntfID != HID_INTF_HAP_ID && SetupPkt.bIntfID != HID_INTF_LED_ID && SetupPkt.bIntfID != HID_INTF_DSP_ID ) return;
041F  0864     MOVF 0x64, W
0420  1903     BTFSC STATUS, 0x2
0421  2C23     GOTO 0x423
0422  2C24     GOTO 0x424
0423  2C30     GOTO 0x430
0424  0364     DECF 0x64, W
0425  1903     BTFSC STATUS, 0x2
0426  2C28     GOTO 0x428
0427  2C29     GOTO 0x429
0428  2C30     GOTO 0x430
0429  3002     MOVLW 0x2
042A  0664     XORWF 0x64, W
042B  1903     BTFSC STATUS, 0x2
042C  2C2E     GOTO 0x42E
042D  2C2F     GOTO 0x42F
042E  2C30     GOTO 0x430
042F  2D2C     GOTO 0x52C
167:           
168:               /*
169:                * There are two standard requests that hid.c may support.
170:                * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
171:                * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
172:                */
173:               if(SetupPkt.bRequest == USB_REQUEST_GET_DESCRIPTOR)
0430  3006     MOVLW 0x6
0431  0661     XORWF 0x61, W
0432  1D03     BTFSS STATUS, 0x2
0433  2C35     GOTO 0x435
0434  2C36     GOTO 0x436
0435  2CD2     GOTO 0x4D2
0436  2CBF     GOTO 0x4BF
174:               {
175:                   switch(SetupPkt.bDescriptorType)
176:                   {
177:                       case DSC_HID: //HID Descriptor
178:                           if(USBActiveConfiguration == 1)
0437  0021     MOVLB 0x1
0438  0358     DECF USBActiveConfiguration, W
0439  1D03     BTFSS STATUS, 0x2
043A  2C3C     GOTO 0x43C
043B  2C3D     GOTO 0x43D
043C  2CD2     GOTO 0x4D2
179:                           {
180:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
043D  0020     MOVLB 0x0
043E  0864     MOVF 0x64, W
043F  0465     IORWF 0x65, W
0440  1D03     BTFSS STATUS, 0x2
0441  2C43     GOTO 0x443
0442  2C44     GOTO 0x444
0443  2C51     GOTO 0x451
181:                                   USBEP0SendROMPtr(
0444  3012     MOVLW 0x12
0445  0021     MOVLB 0x1
0446  00B8     MOVWF inPipes
0447  3090     MOVLW 0x90
0448  00B9     MOVWF 0xB9
0449  3009     MOVLW 0x9
044A  00BB     MOVWF 0xBB
044B  3000     MOVLW 0x0
044C  00BC     MOVWF 0xBC
044D  30C0     MOVLW 0xC0
044E  00F0     MOVWF 0xF0
044F  0870     MOVF 0xF0, W
0450  00BA     MOVWF 0xBA
182:                                       (const uint8_t*)&configDescriptor1 + 18,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
183:                                       sizeof(USB_HID_DSC)+3,
184:                                       USB_EP0_INCLUDE_ZERO);
185:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
0451  0020     MOVLB 0x0
0452  0364     DECF 0x64, W
0453  0465     IORWF 0x65, W
0454  1D03     BTFSS STATUS, 0x2
0455  2C57     GOTO 0x457
0456  2C58     GOTO 0x458
0457  2C65     GOTO 0x465
186:                                   USBEP0SendROMPtr(
0458  3032     MOVLW 0x32
0459  0021     MOVLB 0x1
045A  00B8     MOVWF inPipes
045B  3090     MOVLW 0x90
045C  00B9     MOVWF 0xB9
045D  3009     MOVLW 0x9
045E  00BB     MOVWF 0xBB
045F  3000     MOVLW 0x0
0460  00BC     MOVWF 0xBC
0461  30C0     MOVLW 0xC0
0462  00F0     MOVWF 0xF0
0463  0870     MOVF 0xF0, W
0464  00BA     MOVWF 0xBA
187:                                       (const uint8_t*)&configDescriptor1 + 50,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
188:                                       sizeof(USB_HID_DSC)+3,
189:                                       USB_EP0_INCLUDE_ZERO);
190:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
0465  3002     MOVLW 0x2
0466  0020     MOVLB 0x0
0467  0664     XORWF 0x64, W
0468  0465     IORWF 0x65, W
0469  1D03     BTFSS STATUS, 0x2
046A  2C6C     GOTO 0x46C
046B  2C6D     GOTO 0x46D
046C  2CD2     GOTO 0x4D2
191:                                   USBEP0SendROMPtr(
046D  3052     MOVLW 0x52
046E  0021     MOVLB 0x1
046F  00B8     MOVWF inPipes
0470  3090     MOVLW 0x90
0471  00B9     MOVWF 0xB9
0472  3009     MOVLW 0x9
0473  00BB     MOVWF 0xBB
0474  3000     MOVLW 0x0
0475  00BC     MOVWF 0xBC
0476  30C0     MOVLW 0xC0
0477  00F0     MOVWF 0xF0
0478  0870     MOVF 0xF0, W
0479  00BA     MOVWF 0xBA
047A  2CD2     GOTO 0x4D2
192:                                       (const uint8_t*)&configDescriptor1 + 82,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
193:                                       sizeof(USB_HID_DSC)+3,
194:                                       USB_EP0_INCLUDE_ZERO);
195:                           }
196:                           break;
197:                       case DSC_RPT:  //Report Descriptor
198:                           if(USBActiveConfiguration == 1)
047B  0021     MOVLB 0x1
047C  0358     DECF USBActiveConfiguration, W
047D  1D03     BTFSS STATUS, 0x2
047E  2C80     GOTO 0x480
047F  2C81     GOTO 0x481
0480  2CD2     GOTO 0x4D2
199:                           {
200:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
0481  0020     MOVLB 0x0
0482  0864     MOVF 0x64, W
0483  0465     IORWF 0x65, W
0484  1D03     BTFSS STATUS, 0x2
0485  2C87     GOTO 0x487
0486  2C88     GOTO 0x488
0487  2C95     GOTO 0x495
201:                                   USBEP0SendROMPtr(
0488  3069     MOVLW 0x69
0489  0021     MOVLB 0x1
048A  00B8     MOVWF inPipes
048B  3090     MOVLW 0x90
048C  00B9     MOVWF 0xB9
048D  3057     MOVLW 0x57
048E  00BB     MOVWF 0xBB
048F  3000     MOVLW 0x0
0490  00BC     MOVWF 0xBC
0491  30C0     MOVLW 0xC0
0492  00F0     MOVWF 0xF0
0493  0870     MOVF 0xF0, W
0494  00BA     MOVWF 0xBA
202:                                       (const uint8_t*)&HAPTIC_rpt,
203:                                       HAPTIC_RPT_SIZE,     //See usbcfg.h
204:                                       USB_EP0_INCLUDE_ZERO);
205:                               
206:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
0495  0020     MOVLB 0x0
0496  0364     DECF 0x64, W
0497  0465     IORWF 0x65, W
0498  1D03     BTFSS STATUS, 0x2
0499  2C9B     GOTO 0x49B
049A  2C9C     GOTO 0x49C
049B  2CA9     GOTO 0x4A9
207:                                   USBEP0SendROMPtr(
049C  3000     MOVLW 0x0
049D  0021     MOVLB 0x1
049E  00B8     MOVWF inPipes
049F  3098     MOVLW 0x98
04A0  00B9     MOVWF 0xB9
04A1  301C     MOVLW 0x1C
04A2  00BB     MOVWF 0xBB
04A3  3000     MOVLW 0x0
04A4  00BC     MOVWF 0xBC
04A5  30C0     MOVLW 0xC0
04A6  00F0     MOVWF 0xF0
04A7  0870     MOVF 0xF0, W
04A8  00BA     MOVWF 0xBA
208:                                       (const uint8_t*)&LED_rpt,
209:                                       LED_RPT_SIZE,     //See usbcfg.h
210:                                       USB_EP0_INCLUDE_ZERO);
211:                               
212:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
04A9  3002     MOVLW 0x2
04AA  0020     MOVLB 0x0
04AB  0664     XORWF 0x64, W
04AC  0465     IORWF 0x65, W
04AD  1D03     BTFSS STATUS, 0x2
04AE  2CB0     GOTO 0x4B0
04AF  2CB1     GOTO 0x4B1
04B0  2CD2     GOTO 0x4D2
213:                                   USBEP0SendROMPtr(
04B1  3038     MOVLW 0x38
04B2  0021     MOVLB 0x1
04B3  00B8     MOVWF inPipes
04B4  3098     MOVLW 0x98
04B5  00B9     MOVWF 0xB9
04B6  301C     MOVLW 0x1C
04B7  00BB     MOVWF 0xBB
04B8  3000     MOVLW 0x0
04B9  00BC     MOVWF 0xBC
04BA  30C0     MOVLW 0xC0
04BB  00F0     MOVWF 0xF0
04BC  0870     MOVF 0xF0, W
04BD  00BA     MOVWF 0xBA
04BE  2CD2     GOTO 0x4D2
214:                                       (const uint8_t*)&DISPLAY_rpt,
215:                                       LED_RPT_SIZE,     //See usbcfg.h
216:                                       USB_EP0_INCLUDE_ZERO);
217:                           }
218:                           break;
219:                       case DSC_PHY:  //Physical Descriptor
220:           				//Note: The below placeholder code is commented out.  HID Physical Descriptors are optional and are not used
221:           				//in many types of HID applications.  If an application does not have a physical descriptor,
222:           				//then the device should return STALL in response to this request (stack will do this automatically
223:           				//if no-one claims ownership of the control transfer).
224:           				//If an application does implement a physical descriptor, then make sure to declare
225:           				//hid_phy01 (rom structure containing the descriptor data), and hid_phy01 (the size of the descriptors in uint8_ts),
226:           				//and then uncomment the below code.
227:                           //if(USBActiveConfiguration == 1)
228:                           //{
229:                           //    USBEP0SendROMPtr((const uint8_t*)&hid_phy01, sizeof(hid_phy01), USB_EP0_INCLUDE_ZERO);
230:                           //}
231:                           break;
232:                   }//end switch(SetupPkt.bDescriptorType)
04BF  0863     MOVF i, W
04C0  00F0     MOVWF 0xF0
04C1  01F1     CLRF 0xF1
04C2  0871     MOVF 0xF1, W
04C3  3A00     XORLW 0x0
04C4  1903     BTFSC STATUS, 0x2
04C5  2CC7     GOTO 0x4C7
04C6  2CD2     GOTO 0x4D2
04C7  0870     MOVF 0xF0, W
04C8  3A21     XORLW 0x21
04C9  1903     BTFSC STATUS, 0x2
04CA  2C37     GOTO 0x437
04CB  3A03     XORLW 0x3
04CC  1903     BTFSC STATUS, 0x2
04CD  2C7B     GOTO 0x47B
04CE  3A01     XORLW 0x1
04CF  1903     BTFSC STATUS, 0x2
04D0  2CD2     GOTO 0x4D2
04D1  2CD2     GOTO 0x4D2
233:               }//end if(SetupPkt.bRequest == GET_DSC)
234:           
235:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD)
04D2  0020     MOVLB 0x0
04D3  0E60     SWAPF SetupPkt, W
04D4  0C89     RRF WREG, F
04D5  3903     ANDLW 0x3
04D6  3A01     XORLW 0x1
04D7  1903     BTFSC STATUS, 0x2
04D8  2CDA     GOTO 0x4DA
04D9  2CDB     GOTO 0x4DB
04DA  2D10     GOTO 0x510
04DB  2D2C     GOTO 0x52C
236:               {
237:                   return;
238:               }
239:           
240:               switch(SetupPkt.bRequest)
241:               {
242:                   case GET_REPORT:
243:                       #if defined USER_GET_REPORT_HANDLER
244:                           USER_GET_REPORT_HANDLER();
245:                       #endif
246:                       break;
247:                   case SET_REPORT:
248:                       #if defined USER_SET_REPORT_HANDLER
249:                           USER_SET_REPORT_HANDLER();
250:                       #endif
251:                       break;
252:                   case GET_IDLE:
253:                       USBEP0SendRAMPtr(
04DC  30D6     MOVLW 0xD6
04DD  0021     MOVLB 0x1
04DE  00B8     MOVWF inPipes
04DF  3000     MOVLW 0x0
04E0  00B9     MOVWF 0xB9
04E1  3001     MOVLW 0x1
04E2  00BB     MOVWF 0xBB
04E3  3000     MOVLW 0x0
04E4  00BC     MOVWF 0xBC
04E5  30C1     MOVLW 0xC1
04E6  00F0     MOVWF 0xF0
04E7  0870     MOVF 0xF0, W
04E8  00BA     MOVWF 0xBA
254:                           (uint8_t*)&idle_rate,
255:                           1,
256:                           USB_EP0_INCLUDE_ZERO);
257:                       break;
04E9  2D2C     GOTO 0x52C
258:                   case SET_IDLE:
259:                       USBEP0Transmit(USB_EP0_NO_DATA);
04EA  3080     MOVLW 0x80
04EB  00F0     MOVWF 0xF0
04EC  0870     MOVF 0xF0, W
04ED  0021     MOVLB 0x1
04EE  00BA     MOVWF 0xBA
260:                       idle_rate = SetupPkt.W_Value.byte.HB;
04EF  0020     MOVLB 0x0
04F0  0863     MOVF 0x63, W
04F1  00F0     MOVWF __pcstackCOMMON
04F2  0870     MOVF __pcstackCOMMON, W
04F3  0021     MOVLB 0x1
04F4  00D6     MOVWF idle_rate
261:                       USB_DEVICE_HID_IDLE_RATE_CALLBACK(SetupPkt.W_Value.byte.LB, idle_rate);
262:                       break;
04F5  2D2C     GOTO 0x52C
263:                   case GET_PROTOCOL:
264:                       USBEP0SendRAMPtr(
04F6  302F     MOVLW 0x2F
04F7  0021     MOVLB 0x1
04F8  00B8     MOVWF inPipes
04F9  3001     MOVLW 0x1
04FA  00B9     MOVWF 0xB9
04FB  3001     MOVLW 0x1
04FC  00BB     MOVWF 0xBB
04FD  3000     MOVLW 0x0
04FE  00BC     MOVWF 0xBC
04FF  3081     MOVLW 0x81
0500  00F0     MOVWF 0xF0
0501  0870     MOVF 0xF0, W
0502  00BA     MOVWF 0xBA
265:                           (uint8_t*)&active_protocol,
266:                           1,
267:                           USB_EP0_NO_OPTIONS);
268:                       break;
0503  2D2C     GOTO 0x52C
269:                   case SET_PROTOCOL:
270:                       USBEP0Transmit(USB_EP0_NO_DATA);
0504  3080     MOVLW 0x80
0505  00F0     MOVWF 0xF0
0506  0870     MOVF 0xF0, W
0507  0021     MOVLB 0x1
0508  00BA     MOVWF 0xBA
271:                       active_protocol = SetupPkt.W_Value.byte.LB;
0509  0020     MOVLB 0x0
050A  0862     MOVF 0x62, W
050B  00F0     MOVWF __pcstackCOMMON
050C  0870     MOVF __pcstackCOMMON, W
050D  0022     MOVLB 0x2
050E  00AF     MOVWF active_protocol
272:                       break;
050F  2D2C     GOTO 0x52C
273:               }//end switch(SetupPkt.bRequest)
0510  0861     MOVF 0x161, W
0511  00F0     MOVWF 0x170
0512  01F1     CLRF 0x171
0513  0871     MOVF 0x171, W
0514  3A00     XORLW 0x0
0515  1903     BTFSC STATUS, 0x2
0516  2D18     GOTO 0x518
0517  2D2C     GOTO 0x52C
0518  0870     MOVF 0x170, W
0519  3A01     XORLW 0x1
051A  1903     BTFSC STATUS, 0x2
051B  2D2C     GOTO 0x52C
051C  3A03     XORLW 0x3
051D  1903     BTFSC STATUS, 0x2
051E  2CDC     GOTO 0x4DC
051F  3A01     XORLW 0x1
0520  1903     BTFSC STATUS, 0x2
0521  2CF6     GOTO 0x4F6
0522  3A0A     XORLW 0xA
0523  1903     BTFSC STATUS, 0x2
0524  2D2C     GOTO 0x52C
0525  3A03     XORLW 0x3
0526  1903     BTFSC STATUS, 0x2
0527  2CEA     GOTO 0x4EA
0528  3A01     XORLW 0x1
0529  1903     BTFSC STATUS, 0x2
052A  2D04     GOTO 0x504
052B  2D2C     GOTO 0x52C
274:           
275:           }//end USBCheckHIDRequest
052C  0008     RETURN
276:           
277:           /********************************************************************
278:               Function:
279:                   USB_HANDLE HIDTxPacket(uint8_t ep, uint8_t* data, uint16_t len)
280:           
281:               Summary:
282:                   Sends the specified data out the specified endpoint
283:           
284:               Description:
285:                   This function sends the specified data out the specified
286:                   endpoint and returns a handle to the transfer information.
287:           
288:                   Typical Usage:
289:                   <code>
290:                   //make sure that the last transfer isn't busy by checking the handle
291:                   if(!HIDTxHandleBusy(USBInHandle))
292:                   {
293:                       //Send the data contained in the ToSendDataBuffer[] array out on
294:                       //  endpoint HID_EP
295:                       USBInHandle = HIDTxPacket(HID_EP,(uint8_t*)&ToSendDataBuffer[0],sizeof(ToSendDataBuffer));
296:                   }
297:                   </code>
298:           
299:               PreCondition:
300:                   None
301:           
302:               Parameters:
303:                   uint8_t ep    - the endpoint you want to send the data out of
304:                   uint8_t* data - pointer to the data that you wish to send
305:                   uint16_t len   - the length of the data that you wish to send
306:           
307:               Return Values:
308:                   USB_HANDLE - a handle for the transfer.  This information
309:                   should be kept to track the status of the transfer
310:           
311:               Remarks:
312:                   None
313:           
314:            *******************************************************************/
315:            // Implemented as a macro. See usb_function_hid.h
316:           
317:           /********************************************************************
318:               Function:
319:                   USB_HANDLE HIDRxPacket(uint8_t ep, uint8_t* data, uint16_t len)
320:           
321:               Summary:
322:                   Receives the specified data out the specified endpoint
323:           
324:               Description:
325:                   Receives the specified data out the specified endpoint.
326:           
327:                   Typical Usage:
328:                   <code>
329:                   //Read 64-uint8_ts from endpoint HID_EP, into the ReceivedDataBuffer array.
330:                   //  Make sure to save the return handle so that we can check it later
331:                   //  to determine when the transfer is complete.
332:                   USBOutHandle = HIDRxPacket(HID_EP,(uint8_t*)&ReceivedDataBuffer,64);
333:                   </code>
334:           
335:               PreCondition:
336:                   None
337:           
338:               Parameters:
339:                   uint8_t ep    - the endpoint you want to receive the data into
340:                   uint8_t* data - pointer to where the data will go when it arrives
341:                   uint16_t len   - the length of the data that you wish to receive
342:           
343:               Return Values:
344:                   USB_HANDLE - a handle for the transfer.  This information
345:                   should be kept to track the status of the transfer
346:           
347:               Remarks:
348:                   None
349:           
350:            *******************************************************************/
351:             // Implemented as a macro. See usb_function_hid.h
352:           
353:           /*******************************************************************************
354:            End of File
355:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device.c  --------------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <xc.h>
46:            
47:            #include <stdint.h>
48:            #include <stddef.h>
49:            #include <string.h>
50:            
51:            #include "include/usb/usb_config.h"
52:            
53:            #include "include/usb/usb.h"
54:            #include "include/usb/usb_ch9.h"
55:            #include "include/usb/usb_device.h"
56:            #include "include/usb/usb_device_local.h"
57:            
58:            #ifndef uintptr_t
59:                #if  defined(__XC8__) || defined(__XC16__)
60:                    #define uintptr_t uint16_t
61:                #elif defined (__XC32__)
62:                    #define uintptr_t uint32_t
63:                #endif
64:            #endif
65:            
66:            #if defined(USB_USE_MSD)
67:                #include "usb_device_msd.h"
68:            #endif
69:            
70:            // *****************************************************************************
71:            // *****************************************************************************
72:            // Section: File Scope or Global Constants
73:            // *****************************************************************************
74:            // *****************************************************************************
75:            #if !defined(USE_USB_BUS_SENSE_IO)
76:                //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                //been properly defined elsewhere in the project.
79:                #undef USB_BUS_SENSE
80:                #define USB_BUS_SENSE 1
81:            #endif
82:            
83:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                #define _DTS_CHECKING_ENABLED 0
85:            #else
86:                #define _DTS_CHECKING_ENABLED _DTSEN
87:            #endif
88:            
89:            #if !defined(self_power)
90:                //Assume the application is always bus powered, unless self_power has been
91:                //defined elsewhere in the project
92:                #define self_power 0    //0 = bus powered
93:            #endif
94:            
95:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                //Assume the application only implements one configuration descriptor,
97:                //unless otherwise specified elsewhere in the project
98:                #define USB_MAX_NUM_CONFIG_DSC      1
99:            #endif
100:           
101:           #if defined(__XC8)
102:               //Suppress expected/harmless compiler warning message about unused RAM variables
103:               //and certain function pointer usage.
104:               //Certain variables and function pointers are not used if you don't use all
105:               //of the USB stack APIs.  However, these variables should not be
106:               //removed (since they are still used/needed in some applications, and this
107:               //is a common file shared by many projects, some of which rely on the "unused"
108:               //variables/function pointers).
109:               #pragma warning disable 1090
110:               #if __XC8_VERSION > 1300
111:                   #pragma warning disable 1471
112:               #endif
113:           #endif
114:           
115:           // *****************************************************************************
116:           // *****************************************************************************
117:           // Section: File Scope Data Types
118:           // *****************************************************************************
119:           // *****************************************************************************
120:           typedef union
121:           {
122:               uint8_t Val;
123:               struct __PACKED
124:               {
125:                   unsigned b0:1;
126:                   unsigned b1:1;
127:                   unsigned b2:1;
128:                   unsigned b3:1;
129:                   unsigned b4:1;
130:                   unsigned b5:1;
131:                   unsigned b6:1;
132:                   unsigned b7:1;
133:               } bits;
134:           } uint8_t_VAL, uint8_t_BITS;
135:           
136:           // *****************************************************************************
137:           // *****************************************************************************
138:           // Section: Variables
139:           // *****************************************************************************
140:           // *****************************************************************************
141:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:           USB_VOLATILE uint8_t USBActiveConfiguration;
143:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:           USB_VOLATILE uint8_t shortPacketStatus;
149:           USB_VOLATILE uint8_t controlTransferState;
150:           USB_VOLATILE IN_PIPE inPipes[1];
151:           USB_VOLATILE OUT_PIPE outPipes[1];
152:           USB_VOLATILE uint8_t *pDst;
153:           USB_VOLATILE bool RemoteWakeup;
154:           USB_VOLATILE bool USBBusIsSuspended;
155:           USB_VOLATILE USTAT_FIELDS USTATcopy;
156:           USB_VOLATILE uint8_t endpoint_number;
157:           USB_VOLATILE bool BothEP0OutUOWNsSet;
158:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:           volatile bool USBDeferStatusStagePacket;
162:           volatile bool USBStatusStageEnabledFlag1;
163:           volatile bool USBStatusStageEnabledFlag2;
164:           volatile bool USBDeferINDataStagePackets;
165:           volatile bool USBDeferOUTDataStagePackets;
166:           USB_VOLATILE uint32_t USB1msTickCount;
167:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:           
169:           /** USB FIXED LOCATION VARIABLES ***********************************/
170:           #if defined(COMPILER_MPLAB_C18)
171:               #pragma udata USB_BDT=USB_BDT_ADDRESS
172:           #endif
173:           
174:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:           
176:           /********************************************************************
177:            * EP0 Buffer Space
178:            *******************************************************************/
179:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:           
182:           /********************************************************************
183:            * non-EP0 Buffer Space
184:            *******************************************************************/
185:           #if defined(USB_USE_MSD)
186:               //Check if the MSD application specific USB endpoint buffer placement address
187:               //macros have already been defined or not (ex: in a processor specific header)
188:               //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:               //must be at a certain address range on certain microcontrollers).
190:               #if !defined(MSD_CBW_ADDR_TAG)
191:                   //Not previously defined.  Assume in this case all microcontroller RAM is
192:                   //USB module accessible, and therefore, no specific address tag value is needed.
193:                   #define MSD_CBW_ADDR_TAG
194:                   #define MSD_CSW_ADDR_TAG
195:               #endif
196:           	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:           	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:           
199:               #if defined(__18CXX) || defined(__XC8)
200:                   #if(__XC8_VERSION < 2000)
201:                   volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
202:                   #else
203:                       volatile char msd_buffer[512] __at(MSD_BUFFER_ADDRESS);
204:                   #endif
205:               #else
206:                   volatile char msd_buffer[512];
207:           	#endif
208:           #endif
209:           
210:           //Depricated in v2.2 - will be removed in a future revision
211:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
212:               //Device descriptor
213:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
214:           #else
215:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
216:           #endif
217:           
218:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
219:               //Array of configuration descriptors
220:               extern const uint8_t *const USB_CD_Ptr[];
221:           #else
222:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
223:           #endif
224:           
225:           extern const uint8_t *const USB_SD_Ptr[];
226:           
227:           
228:           // *****************************************************************************
229:           // *****************************************************************************
230:           // Section: Private and External Prototypes
231:           // *****************************************************************************
232:           // *****************************************************************************
233:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
234:           
235:           static void USBCtrlEPService(void);
236:           static void USBCtrlTrfSetupHandler(void);
237:           static void USBCtrlTrfInHandler(void);
238:           static void USBCheckStdRequest(void);
239:           static void USBStdGetDscHandler(void);
240:           static void USBCtrlEPServiceComplete(void);
241:           static void USBCtrlTrfTxService(void);
242:           static void USBCtrlTrfRxService(void);
243:           static void USBStdSetCfgHandler(void);
244:           static void USBStdGetStatusHandler(void);
245:           static void USBStdFeatureReqHandler(void);
246:           static void USBCtrlTrfOutHandler(void);
247:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
248:           static void USBWakeFromSuspend(void);
249:           static void USBSuspend(void);
250:           static void USBStallHandler(void);
251:           
252:           // *****************************************************************************
253:           // *****************************************************************************
254:           // Section: Macros or Functions
255:           // *****************************************************************************
256:           // *****************************************************************************
257:           
258:           /**************************************************************************
259:               Function:
260:                   void USBDeviceInit(void)
261:           
262:               Description:
263:                   This function initializes the device stack it in the default state. The
264:                   USB module will be completely reset including all of the internal
265:                   variables, registers, and interrupt flags.
266:           
267:               Precondition:
268:                   This function must be called before any of the other USB Device
269:                   functions can be called, including USBDeviceTasks().
270:           
271:               Parameters:
272:                   None
273:           
274:               Return Values:
275:                   None
276:           
277:               Remarks:
278:                   None
279:           
280:             ***************************************************************************/
281:           void USBDeviceInit(void)
282:           {
283:               uint8_t i;
284:           
285:               USBDisableInterrupts();
0F56  0021     MOVLB 0x1
0F57  1112     BCF PIE2, 0x2
286:           
287:               //Make sure that if a GPIO output driver exists on VBUS, that it is
288:               //tri-stated to avoid potential contention with the host
289:               USB_HAL_VBUSTristate();
290:           
291:               // Clear all USB error flags
292:               USBClearInterruptRegister(U1EIR);
0F58  003D     MOVLB 0x1D
0F59  0193     CLRF UEIR
293:           
294:               // Clears all USB interrupts
295:               USBClearInterruptRegister(U1IR);
0F5A  0190     CLRF UIR
296:           
297:               //Clear all of the endpoint control registers
298:               U1EP0 = 0;
0F5B  0198     CLRF UEP0
299:           
300:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0F5C  300E     MOVLW 0xE
0F5D  00F2     MOVWF 0xEF2
0F5E  3099     MOVLW 0x99
0F5F  00F1     MOVWF 0xEF1
0F60  01F3     CLRF 0xEF3
0F61  0871     MOVF 0xEF1, W
0F62  0086     MOVWF FSR1L
0F63  0872     MOVF 0xEF2, W
0F64  0087     MOVWF FSR1H
0F65  0181     CLRF INDF1
0F66  3001     MOVLW 0x1
0F67  07F1     ADDWF 0xEF1, F
0F68  3000     MOVLW 0x0
0F69  3DF2     ADDWFC 0xEF2, F
0F6A  3001     MOVLW 0x1
0F6B  00F0     MOVWF 0xEF0
0F6C  0870     MOVF 0xEF0, W
0F6D  07F3     ADDWF 0xEF3, F
0F6E  3003     MOVLW 0x3
0F6F  0273     SUBWF 0xEF3, W
0F70  1C03     BTFSS STATUS, 0x0
0F71  2F73     GOTO 0x773
0F72  2F74     GOTO 0x774
0F73  2F61     GOTO 0x761
301:           
302:               SetConfigurationOptions();
0F74  3016     MOVLW 0x16
0F75  003D     MOVLB 0x1D
0F76  0091     MOVWF UCFG
0F77  309F     MOVLW 0x9F
0F78  0097     MOVWF UEIE
0F79  307B     MOVLW 0x7B
0F7A  0092     MOVWF UIE
303:           
304:               //power up the module (if not already powered)
305:               USBPowerModule();
306:           
307:               //set the address of the BDT (if applicable)
308:               USBSetBDTAddress(BDT);
309:           
310:               //Clear all of the BDT entries
311:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
0F7B  01F4     CLRF 0xEF4
312:               {
313:                   BDT[i].Val = 0x00;
0F7C  0874     MOVF 0xEF4, W
0F7D  00F0     MOVWF 0xEF0
0F7E  3001     MOVLW 0x1
0F7F  35F0     LSLF 0xEF0, F
0F80  3EFF     ADDLW 0xFF
0F81  1D03     BTFSS STATUS, 0x2
0F82  2F7F     GOTO 0x77F
0F83  3570     LSLF 0xEF0, W
0F84  3E20     ADDLW 0x20
0F85  0086     MOVWF FSR1L
0F86  0187     CLRF FSR1H
0F87  3000     MOVLW 0x0
0F88  3FC0     MOVWI 0[FSR1]
0F89  3000     MOVLW 0x0
0F8A  3FC1     MOVWI 1[FSR1]
0F8B  3FC2     MOVWI 2[FSR1]
0F8C  3FC3     MOVWI 3[FSR1]
314:               }
0F8D  3001     MOVLW 0x1
0F8E  00F0     MOVWF 0xEF0
0F8F  0870     MOVF 0xEF0, W
0F90  07F4     ADDWF 0xEF4, F
0F91  3010     MOVLW 0x10
0F92  0274     SUBWF 0xEF4, W
0F93  1C03     BTFSS STATUS, 0x0
0F94  2F96     GOTO 0x796
0F95  2F97     GOTO 0x797
0F96  2F7C     GOTO 0x77C
315:           
316:               // Assert reset request to all of the Ping Pong buffer pointers
317:               USBPingPongBufferReset = 1;
0F97  003D     MOVLB 0x1D
0F98  170E     BSF UCON, 0x6
318:           
319:               // Reset to default address
320:               U1ADDR = 0x00;
0F99  0196     CLRF UADDR
321:           
322:               // Make sure packet processing is enabled
323:               USBPacketDisable = 0;
0F9A  120E     BCF UCON, 0x4
324:           
325:               //Stop trying to reset ping pong buffer pointers
326:               USBPingPongBufferReset = 0;
0F9B  130E     BCF UCON, 0x6
327:           
328:               // Flush any pending transactions
329:               do
330:               {
331:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0F9C  30F7     MOVLW 0xF7
0F9D  00F0     MOVWF 0xEF0
0F9E  0870     MOVF 0xEF0, W
0F9F  0590     ANDWF UIR, F
332:                   //Initialize USB stack software state variables
333:                   inPipes[0].info.Val = 0;
0FA0  0021     MOVLB 0x1
0FA1  01BA     CLRF 0xBA
334:                   outPipes[0].info.Val = 0;
0FA2  0022     MOVLB 0x2
0FA3  01A2     CLRF 0x122
335:                   outPipes[0].wCount.Val = 0;
0FA4  01A3     CLRF 0x123
0FA5  01A4     CLRF 0x124
336:               }while(USBTransactionCompleteIF == 1);
0FA6  003D     MOVLB 0x1D
0FA7  1990     BTFSC UIR, 0x3
0FA8  2FAA     GOTO 0x7AA
0FA9  2FAB     GOTO 0x7AB
0FAA  2F9C     GOTO 0x79C
337:           
338:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
339:               //try and arm a status stage, even before the first control transfer starts.
340:               USBStatusStageEnabledFlag1 = true;
0FAB  3001     MOVLW 0x1
0FAC  00F0     MOVWF 0xEF0
0FAD  0870     MOVF 0xEF0, W
0FAE  0021     MOVLB 0x1
0FAF  00CA     MOVWF USBStatusStageEnabledFlag1
341:               USBStatusStageEnabledFlag2 = true;
0FB0  3001     MOVLW 0x1
0FB1  00F0     MOVWF 0xF0
0FB2  0870     MOVF 0xF0, W
0FB3  00C9     MOVWF USBStatusStageEnabledFlag2
342:               //Initialize other flags
343:               USBDeferINDataStagePackets = false;
0FB4  01C8     CLRF USBDeferINDataStagePackets
344:               USBDeferOUTDataStagePackets = false;
0FB5  01C7     CLRF USBDeferOUTDataStagePackets
345:               USBBusIsSuspended = false;
0FB6  01CF     CLRF USBBusIsSuspended
346:           
347:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
348:               //pointers to NULL, so they don't get used inadvertently.
349:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0FB7  01F4     CLRF 0xF4
350:               {
351:                   pBDTEntryIn[i] = 0u;
0FB8  3574     LSLF 0xF4, W
0FB9  3EB0     ADDLW 0xB0
0FBA  0086     MOVWF FSR1L
0FBB  0187     CLRF FSR1H
0FBC  3000     MOVLW 0x0
0FBD  3FC0     MOVWI 0[FSR1]
0FBE  3FC1     MOVWI 1[FSR1]
352:                   pBDTEntryOut[i] = 0u;
0FBF  3574     LSLF 0xF4, W
0FC0  3EA0     ADDLW 0xA0
0FC1  0086     MOVWF FSR1L
0FC2  3001     MOVLW 0x1
0FC3  0087     MOVWF FSR1H
0FC4  3000     MOVLW 0x0
0FC5  3FC0     MOVWI 0[FSR1]
0FC6  3FC1     MOVWI 1[FSR1]
353:                   ep_data_in[i].Val = 0u;
0FC7  0874     MOVF 0xF4, W
0FC8  3EB0     ADDLW 0xB0
0FC9  0086     MOVWF FSR1L
0FCA  3001     MOVLW 0x1
0FCB  0087     MOVWF FSR1H
0FCC  0181     CLRF INDF1
354:                   ep_data_out[i].Val = 0u;
0FCD  0874     MOVF 0xF4, W
0FCE  3EAC     ADDLW 0xAC
0FCF  0086     MOVWF FSR1L
0FD0  3001     MOVLW 0x1
0FD1  0087     MOVWF FSR1H
0FD2  0181     CLRF INDF1
355:               }
0FD3  3001     MOVLW 0x1
0FD4  00F0     MOVWF 0xF0
0FD5  0870     MOVF 0xF0, W
0FD6  07F4     ADDWF 0xF4, F
0FD7  3004     MOVLW 0x4
0FD8  0274     SUBWF 0xF4, W
0FD9  1C03     BTFSS STATUS, 0x0
0FDA  2FDC     GOTO 0x7DC
0FDB  2FDD     GOTO 0x7DD
0FDC  2FB8     GOTO 0x7B8
356:           
357:               //Get ready for the first packet
358:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0FDD  3028     MOVLW 0x28
0FDE  0021     MOVLB 0x1
0FDF  00B0     MOVWF pBDTEntryIn
0FE0  3000     MOVLW 0x0
0FE1  00B1     MOVWF 0xB1
359:               // Initialize EP0 as a Ctrl EP
360:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;
0FE2  3016     MOVLW 0x16
0FE3  003D     MOVLB 0x1D
0FE4  0098     MOVWF UEP0
361:           	//Prepare for the first SETUP on EP0 OUT
362:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0FE5  3000     MOVLW 0x0
0FE6  0020     MOVLB 0x0
0FE7  00A3     MOVWF 0x23
0FE8  3060     MOVLW 0x60
0FE9  00A2     MOVWF 0x22
363:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0FEA  3008     MOVLW 0x8
0FEB  00A1     MOVWF 0x21
364:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
0FEC  3004     MOVLW 0x4
0FED  00F0     MOVWF __pcstackCOMMON
0FEE  0870     MOVF __pcstackCOMMON, W
0FEF  00A0     MOVWF BDT
365:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
0FF0  17A0     BSF BDT, 0x7
366:           
367:               // Clear active configuration
368:               USBActiveConfiguration = 0;
0FF1  0021     MOVLB 0x1
0FF2  01D8     CLRF USBActiveConfiguration
369:           
370:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
0FF3  3000     MOVLW 0x0
0FF4  0023     MOVLB 0x3
0FF5  00AB     MOVWF 0x1AB
0FF6  3000     MOVLW 0x0
0FF7  00AA     MOVWF 0x1AA
0FF8  3000     MOVLW 0x0
0FF9  00A9     MOVWF 0x1A9
0FFA  3000     MOVLW 0x0
0FFB  00A8     MOVWF USB1msTickCount
371:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
0FFC  0021     MOVLB 0x1
0FFD  01C6     CLRF USBTicksSinceSuspendEnd
372:           
373:               //Indicate that we are now in the detached state
374:               USBDeviceState = DETACHED_STATE;
0FFE  01D5     CLRF USBDeviceState
375:           }
0FFF  0008     RETURN
376:           
377:           
378:           
379:           /**************************************************************************
380:             Function:
381:                   void USBDeviceTasks(void)
382:           
383:             Summary:
384:               This function is the main state machine/transaction handler of the USB
385:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
386:               (usb_config.h user option) the USBDeviceTasks() function should be called
387:               periodically to receive and transmit packets through the stack. This
388:               function also takes care of control transfers associated with the USB
389:               enumeration process, and detecting various USB events (such as suspend).
390:               This function should be called at least once every 1.8ms during the USB
391:               enumeration process. After the enumeration process is complete (which can
392:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
393:               USBDeviceTasks() handler may be called the faster of: either once
394:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
395:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
396:               a minimum rate of either the frequency that USBTransferOnePacket() gets
397:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
398:               near the top of usb_device.c for more details about minimum timing
399:               requirements when calling USBDeviceTasks().
400:           
401:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
402:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
403:               mode, the USBDeviceTasks() handler only needs to execute when a USB
404:               interrupt occurs, and therefore only needs to be called from the interrupt
405:               context.
406:           
407:             Description:
408:               This function is the main state machine/transaction handler of the USB
409:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
410:               (usb_config.h user option) the USBDeviceTasks() function should be called
411:               periodically to receive and transmit packets through the stack. This
412:               function also takes care of control transfers associated with the USB
413:               enumeration process, and detecting various USB events (such as suspend).
414:               This function should be called at least once every 1.8ms during the USB
415:               enumeration process. After the enumeration process is complete (which can
416:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
417:               USBDeviceTasks() handler may be called the faster of: either once
418:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
419:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
420:               a minimum rate of either the frequency that USBTransferOnePacket() gets
421:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
422:               near the top of usb_device.c for more details about minimum timing
423:               requirements when calling USBDeviceTasks().
424:           
425:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
426:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
427:               mode, the USBDeviceTasks() handler only needs to execute when a USB
428:               interrupt occurs, and therefore only needs to be called from the interrupt
429:               context.
430:           
431:               Typical usage:
432:               <code>
433:               void main(void)
434:               {
435:                   USBDeviceInit();
436:                   while(1)
437:                   {
438:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
439:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
440:                          (USBIsDeviceSuspended() == true))
441:                       {
442:                           //Either the device is not configured or we are suspended,
443:                           // so we don't want to execute any USB related application code
444:                           continue;   //go back to the top of the while loop
445:                       }
446:                       else
447:                       {
448:                           //Otherwise we are free to run USB and non-USB related user
449:                           //application code.
450:                           UserApplication();
451:                       }
452:                   }
453:               }
454:               </code>
455:           
456:             Precondition:
457:               Make sure the USBDeviceInit() function has been called prior to calling
458:               USBDeviceTasks() for the first time.
459:             Remarks:
460:               USBDeviceTasks() does not need to be called while in the USB suspend mode,
461:               if the user application firmware in the USBCBSuspend() callback function
462:               enables the ACTVIF USB interrupt source and put the microcontroller into
463:               sleep mode.  If the application firmware decides not to sleep the
464:               microcontroller core during USB suspend (ex: continues running at full
465:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
466:               function must still be called periodically, at a rate frequent enough to
467:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
468:               a worst case primary oscillator and PLL start up time of less than 5ms, then
469:               USBDeviceTasks() should be called once every 5ms in this scenario.
470:           
471:               When the USB cable is detached, or the USB host is not actively powering
472:               the VBUS line to +5V nominal, the application firmware does not always have
473:               to call USBDeviceTasks() frequently, as no USB activity will be taking
474:               place.  However, if USBDeviceTasks() is not called regularly, some
475:               alternative means of promptly detecting when VBUS is powered (indicating
476:               host attachment), or not powered (host powered down or USB cable unplugged)
477:               is still needed.  For self or dual self/bus powered USB applications, see
478:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional
479:               considerations.
480:               ***************************************************************************/
481:           void USBDeviceTasks(void)
482:           {
483:               uint8_t i;
484:           
485:               #ifdef USB_SUPPORT_OTG
486:                   //SRP Time Out Check
487:                   if (USBOTGSRPIsReady())
488:                   {
489:                       if (USBT1MSECIF && USBT1MSECIE)
490:                       {
491:                           if (USBOTGGetSRPTimeOutFlag())
492:                           {
493:                               if (USBOTGIsSRPTimeOutExpired())
494:                               {
495:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
496:                               }
497:                           }
498:           
499:                           //Clear Interrupt Flag
500:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
501:                       }
502:                   }
503:               #endif
504:           
505:               #if defined(USB_POLLING)
506:               //If the interrupt option is selected then the customer is required
507:               //  to notify the stack when the device is attached or removed from the
508:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
509:               if (USB_BUS_SENSE != 1)
510:               {
511:                    // Disable module & detach from bus
512:                    U1CON = 0;
513:           
514:                    // Mask all USB interrupts
515:                    U1IE = 0;
516:           
517:                    //Move to the detached state
518:                    USBDeviceState = DETACHED_STATE;
519:           
520:                    #ifdef  USB_SUPPORT_OTG
521:                        //Disable D+ Pullup
522:                        U1OTGCONbits.DPPULUP = 0;
523:           
524:                        //Disable HNP
525:                        USBOTGDisableHnp();
526:           
527:                        //Deactivate HNP
528:                        USBOTGDeactivateHnp();
529:           
530:                        //If ID Pin Changed State
531:                        if (USBIDIF && USBIDIE)
532:                        {
533:                            //Re-detect & Initialize
534:                             USBOTGInitialize();
535:           
536:                             //Clear ID Interrupt Flag
537:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
538:                        }
539:                    #endif
540:           
541:                    #if defined __C30__ || defined __XC16__
542:                        //USBClearInterruptFlag(U1OTGIR, 3);
543:                    #endif
544:                       //return so that we don't go through the rest of
545:                       //the state machine
546:                    USBClearUSBInterrupt();
547:                    return;
548:               }
549:           
550:           	#ifdef USB_SUPPORT_OTG
551:               //If Session Is Started Then
552:               else
553:           	{
554:                   //If SRP Is Ready
555:                   if (USBOTGSRPIsReady())
556:                   {
557:                       //Clear SRPReady
558:                       USBOTGClearSRPReady();
559:           
560:                       //Clear SRP Timeout Flag
561:                       USBOTGClearSRPTimeOutFlag();
562:           
563:                       //Indicate Session Started
564:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
565:                   }
566:               }
567:           	#endif	//#ifdef USB_SUPPORT_OTG
568:           
569:               //if we are in the detached state
570:               if(USBDeviceState == DETACHED_STATE)
02E7  0021     MOVLB 0x1
02E8  0855     MOVF USBDeviceState, W
02E9  1D03     BTFSS STATUS, 0x2
02EA  2AEC     GOTO 0x2EC
02EB  2AED     GOTO 0x2ED
02EC  2AFF     GOTO 0x2FF
571:               {
572:           	    //Initialize register to known value
573:                   U1CON = 0;
02ED  003D     MOVLB 0x1D
02EE  018E     CLRF UCON
574:           
575:                   // Mask all USB interrupts
576:                   U1IE = 0;
02EF  0192     CLRF UIE
577:           
578:                   //Enable/set things like: pull ups, full/low-speed mode,
579:                   //set the ping pong mode, and set internal transceiver
580:                   SetConfigurationOptions();
02F0  3016     MOVLW 0x16
02F1  0091     MOVWF UCFG
02F2  309F     MOVLW 0x9F
02F3  0097     MOVWF UEIE
02F4  307B     MOVLW 0x7B
02F5  0092     MOVWF UIE
581:           
582:                   // Enable module & attach to bus
583:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
02F6  2AF8     GOTO 0x2F8
02F7  158E     BSF UCON, 0x3
02F8  1D8E     BTFSS UCON, 0x3
02F9  2AFB     GOTO 0x2FB
02FA  2AFC     GOTO 0x2FC
02FB  2AF7     GOTO 0x2F7
584:           
585:                   //moved to the attached state
586:                   USBDeviceState = ATTACHED_STATE;
02FC  0021     MOVLB 0x1
02FD  01D5     CLRF USBDeviceState
02FE  0AD5     INCF USBDeviceState, F
587:           
588:                   #ifdef  USB_SUPPORT_OTG
589:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
590:                   #endif
591:               }
592:           	#endif  //#if defined(USB_POLLING)
593:           
594:               if(USBDeviceState == ATTACHED_STATE)
02FF  0355     DECF USBDeviceState, W
0300  1D03     BTFSS STATUS, 0x2
0301  2B03     GOTO 0x303
0302  2B04     GOTO 0x304
0303  2B12     GOTO 0x312
595:               {
596:                   /*
597:                    * After enabling the USB module, it takes some time for the
598:                    * voltage on the D+ or D- line to rise high enough to get out
599:                    * of the SE0 condition. The USB Reset interrupt should not be
600:                    * unmasked until the SE0 condition is cleared. This helps
601:                    * prevent the firmware from misinterpreting this unique event
602:                    * as a USB bus reset from the USB host.
603:                    */
604:           
605:                   if(!USBSE0Event)
0304  003D     MOVLB 0x1D
0305  1A8E     BTFSC UCON, 0x5
0306  2B08     GOTO 0x308
0307  2B09     GOTO 0x309
0308  2B12     GOTO 0x312
606:                   {
607:                       //We recently attached, make sure we are in a clean state
608:                       #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
609:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
610:                                           //during attach de-bounce interval
611:                       #else
612:                           USBClearInterruptRegister(U1IR);
0309  0190     CLRF UIR
613:                       #endif
614:           
615:                       #if defined(USB_POLLING)
616:                           U1IE=0;                        // Mask all USB interrupts
030A  0192     CLRF UIE
617:                       #endif
618:                       USBResetIE = 1;             // Unmask RESET interrupt
030B  1412     BSF UIE, 0x0
619:                       USBIdleIE = 1;             // Unmask IDLE interrupt
030C  1612     BSF UIE, 0x4
620:                       USBDeviceState = POWERED_STATE;
030D  3002     MOVLW 0x2
030E  0021     MOVLB 0x1
030F  00EB     MOVWF 0xEB
0310  086B     MOVF 0xEB, W
0311  00D5     MOVWF USBDeviceState
621:                   }
622:               }
623:           
624:               #ifdef  USB_SUPPORT_OTG
625:                   //If ID Pin Changed State
626:                   if (USBIDIF && USBIDIE)
627:                   {
628:                       //Re-detect & Initialize
629:                       USBOTGInitialize();
630:           
631:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
632:                   }
633:               #endif
634:           
635:               /*
636:                * Task A: Service USB Activity Interrupt
637:                */
638:               if(USBActivityIF && USBActivityIE)
0312  003D     MOVLB 0x1D
0313  1D10     BTFSS UIR, 0x2
0314  2B16     GOTO 0x316
0315  2B17     GOTO 0x317
0316  2B24     GOTO 0x324
0317  1D12     BTFSS UIE, 0x2
0318  2B1A     GOTO 0x31A
0319  2B1B     GOTO 0x31B
031A  2B24     GOTO 0x324
639:               {
640:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
031B  30FB     MOVLW 0xFB
031C  0021     MOVLB 0x1
031D  00EB     MOVWF 0xEB
031E  086B     MOVF 0xEB, W
031F  003D     MOVLB 0x1D
0320  0590     ANDWF UIR, F
641:                   #if defined(USB_SUPPORT_OTG)
642:                       U1OTGIR = 0x10;
643:                   #else
644:                       USBWakeFromSuspend();
0321  3196     MOVLP 0x16
0322  26F0     CALL 0x6F0
0323  3182     MOVLP 0x2
645:                   #endif
646:               }
647:           
648:               /*
649:                * Pointless to continue servicing if the device is in suspend mode.
650:                */
651:               if(USBSuspendControl==1)
0324  003D     MOVLB 0x1D
0325  1C8E     BTFSS UCON, 0x1
0326  2B28     GOTO 0x328
0327  2B29     GOTO 0x329
0328  2B2C     GOTO 0x32C
652:               {
653:                   USBClearUSBInterrupt();
0329  0020     MOVLB 0x0
032A  1112     BCF PIR2, 0x2
654:                   return;
032B  2C15     GOTO 0x415
655:               }
656:           
657:               /*
658:                * Task B: Service USB Bus Reset Interrupt.
659:                * When bus reset is received during suspend, ACTVIF will be set first,
660:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
661:                * This is why URSTIF is checked after ACTVIF.
662:                *
663:                * The USB reset flag is masked when the USB state is in
664:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
665:                * cause a USB reset event during these two states.
666:                */
667:               if(USBResetIF && USBResetIE)
032C  1C10     BTFSS start, 0x0
032D  2B2F     GOTO 0x32F
032E  2B30     GOTO 0x330
032F  2B41     GOTO 0x341
0330  1C12     BTFSS PIR2, 0x0
0331  2B33     GOTO 0x333
0332  2B34     GOTO 0x334
0333  2B41     GOTO 0x341
668:               {
669:                   USBDeviceInit();
0334  318F     MOVLP 0xF
0335  2756     CALL 0x756
0336  3182     MOVLP 0x2
670:           
671:                   //Re-enable the interrupts since the USBDeviceInit() function will
672:                   //  disable them.  This will do nothing in a polling setup
673:                   USBUnmaskInterrupts();
674:           
675:                   USBDeviceState = DEFAULT_STATE;
0337  3004     MOVLW 0x4
0338  0021     MOVLB 0x1
0339  00EB     MOVWF 0xEB
033A  086B     MOVF 0xEB, W
033B  00D5     MOVWF USBDeviceState
676:           
677:                   #ifdef USB_SUPPORT_OTG
678:                        //Disable HNP
679:                        USBOTGDisableHnp();
680:           
681:                        //Deactivate HNP
682:                        USBOTGDeactivateHnp();
683:                   #endif
684:           
685:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
033C  30FE     MOVLW 0xFE
033D  00EB     MOVWF 0xEB
033E  086B     MOVF 0xEB, W
033F  003D     MOVLB 0x1D
0340  0590     ANDWF UIR, F
686:               }
687:           
688:               /*
689:                * Task C: Service other USB interrupts
690:                */
691:               if(USBIdleIF && USBIdleIE)
0341  1E10     BTFSS UIR, 0x4
0342  2B44     GOTO 0x344
0343  2B45     GOTO 0x345
0344  2B4C     GOTO 0x34C
0345  1E12     BTFSS UIE, 0x4
0346  2B48     GOTO 0x348
0347  2B49     GOTO 0x349
0348  2B4C     GOTO 0x34C
692:               {
693:                   #ifdef  USB_SUPPORT_OTG
694:                       //If Suspended, Try to switch to Host
695:                       USBOTGSelectRole(ROLE_HOST);
696:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
697:                   #else
698:                       USBSuspend();
0349  3196     MOVLP 0x16
034A  2696     CALL 0x696
034B  3182     MOVLP 0x2
699:                   #endif
700:               }
701:           
702:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
703:                   //Check if a 1ms interval has elapsed.
704:                   if(USBT1MSECIF)
705:                   {
706:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
707:                       USBIncrement1msInternalTimers();
708:                   }
709:               #endif
710:           
711:               //Start-of-Frame Interrupt
712:               if(USBSOFIF)
034C  003D     MOVLB 0x1D
034D  1F10     BTFSS UIR, 0x6
034E  2B50     GOTO 0x350
034F  2B51     GOTO 0x351
0350  2B7E     GOTO 0x37E
713:               {
714:                   //Call the user SOF event callback if enabled.
715:                   if(USBSOFIE)
0351  1F12     BTFSS UIE, 0x6
0352  2B54     GOTO 0x354
0353  2B55     GOTO 0x355
0354  2B65     GOTO 0x365
716:                   {
717:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
0355  3073     MOVLW 0x73
0356  0021     MOVLB 0x1
0357  00D9     MOVWF __pcstackBANK1
0358  3000     MOVLW 0x0
0359  00DA     MOVWF 0xDA
035A  3000     MOVLW 0x0
035B  00DB     MOVWF pdata
035C  3000     MOVLW 0x0
035D  00DC     MOVWF 0xDC
035E  3001     MOVLW 0x1
035F  00DD     MOVWF size
0360  3000     MOVLW 0x0
0361  00DE     MOVWF 0xDE
0362  3188     MOVLP 0x8
0363  2092     CALL 0x92
0364  3182     MOVLP 0x2
718:                   }
719:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
0365  30BF     MOVLW 0xBF
0366  0021     MOVLB 0x1
0367  00EB     MOVWF 0xEB
0368  086B     MOVF 0xEB, W
0369  003D     MOVLB 0x1D
036A  0590     ANDWF UIR, F
720:           
721:                   #if defined(__XC8__) || defined(__C18__)
722:                       USBIncrement1msInternalTimers();
036B  3196     MOVLP 0x16
036C  26B2     CALL 0x6B2
036D  3182     MOVLP 0x2
723:                   #endif
724:           
725:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
726:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
727:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
728:                           #warning "Double click this message.  See inline code comments."
729:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
730:                           //not strictly needed in all applications (ex: those that never call
731:                           //USBDeferStatusStage() and don't use host to device (OUT) control
732:                           //transfers with data stage).
733:                           //However, if this feature is enabled and used in a low speed application,
734:                           //it is required for the application code to periodically call the
735:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
736:                       #endif
737:           
738:                       //Decrement our status stage counter.
739:                       if(USBStatusStageTimeoutCounter != 0u)
036E  0021     MOVLB 0x1
036F  084C     MOVF USBStatusStageTimeoutCounter, W
0370  1903     BTFSC STATUS, 0x2
0371  2B73     GOTO 0x373
0372  2B74     GOTO 0x374
0373  2B76     GOTO 0x376
740:                       {
741:                           USBStatusStageTimeoutCounter--;
0374  3001     MOVLW 0x1
0375  02CC     SUBWF USBStatusStageTimeoutCounter, F
742:                       }
743:                       //Check if too much time has elapsed since progress was made in
744:                       //processing the control transfer, without arming the status stage.
745:                       //If so, auto-arm the status stage to ensure that the control
746:                       //transfer can [eventually] complete, within the timing limits
747:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
748:                       if(USBStatusStageTimeoutCounter == 0)
0376  084C     MOVF USBStatusStageTimeoutCounter, W
0377  1D03     BTFSS STATUS, 0x2
0378  2B7A     GOTO 0x37A
0379  2B7B     GOTO 0x37B
037A  2B7E     GOTO 0x37E
749:                       {
750:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
037B  318A     MOVLP 0xA
037C  22A3     CALL 0x2A3
037D  3182     MOVLP 0x2
751:                       }
752:                   #endif
753:               }
754:           
755:               if(USBStallIF && USBStallIE)
037E  003D     MOVLB 0x1D
037F  1E90     BTFSS UIR, 0x5
0380  2B82     GOTO 0x382
0381  2B83     GOTO 0x383
0382  2B8A     GOTO 0x38A
0383  1E92     BTFSS UIE, 0x5
0384  2B86     GOTO 0x386
0385  2B87     GOTO 0x387
0386  2B8A     GOTO 0x38A
756:               {
757:                   USBStallHandler();
0387  3197     MOVLP 0x17
0388  277A     CALL 0x77A
0389  3182     MOVLP 0x2
758:               }
759:           
760:               if(USBErrorIF && USBErrorIE)
038A  003D     MOVLB 0x1D
038B  1C90     BTFSS UIR, 0x1
038C  2B8E     GOTO 0x38E
038D  2B8F     GOTO 0x38F
038E  2BA5     GOTO 0x3A5
038F  1C92     BTFSS UIE, 0x1
0390  2B92     GOTO 0x392
0391  2B93     GOTO 0x393
0392  2BA5     GOTO 0x3A5
761:               {
762:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
0393  30FF     MOVLW 0xFF
0394  0021     MOVLB 0x1
0395  00D9     MOVWF __pcstackBANK1
0396  307F     MOVLW 0x7F
0397  00DA     MOVWF 0xDA
0398  3000     MOVLW 0x0
0399  00DB     MOVWF pdata
039A  3000     MOVLW 0x0
039B  00DC     MOVWF 0xDC
039C  3001     MOVLW 0x1
039D  00DD     MOVWF size
039E  3000     MOVLW 0x0
039F  00DE     MOVWF 0xDE
03A0  3188     MOVLP 0x8
03A1  2092     CALL 0x92
03A2  3182     MOVLP 0x2
763:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
03A3  003D     MOVLB 0x1D
03A4  0193     CLRF UEIR
764:           
765:                   //On PIC18, clearing the source of the error will automatically clear
766:                   //  the interrupt flag.  On other devices the interrupt flag must be
767:                   //  manually cleared.
768:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
769:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
770:                   #endif
771:               }
772:           
773:               /*
774:                * Pointless to continue servicing if the host has not sent a bus reset.
775:                * Once bus reset is received, the device transitions into the DEFAULT
776:                * state and is ready for communication.
777:                */
778:               if(USBDeviceState < DEFAULT_STATE)
03A5  3004     MOVLW 0x4
03A6  0021     MOVLB 0x1
03A7  0255     SUBWF USBDeviceState, W
03A8  1803     BTFSC STATUS, 0x0
03A9  2BAB     GOTO 0x3AB
03AA  2BAC     GOTO 0x3AC
03AB  2BAF     GOTO 0x3AF
779:               {
780:                   USBClearUSBInterrupt();
03AC  0020     MOVLB 0x0
03AD  1112     BCF PIR2, 0x2
781:                   return;
03AE  2C15     GOTO 0x415
782:               }
783:           
784:               /*
785:                * Task D: Servicing USB Transaction Complete Interrupt
786:                */
787:               if(USBTransactionCompleteIE)
03AF  003D     MOVLB 0x1D
03B0  1D92     BTFSS UIE, 0x3
03B1  2BB3     GOTO 0x3B3
03B2  2BB4     GOTO 0x3B4
03B3  2C13     GOTO 0x413
788:               {
789:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
03B4  0021     MOVLB 0x1
03B5  01ED     CLRF i
790:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
791:                       if(USBTransactionCompleteIF)
03B6  003D     MOVLB 0x1D
03B7  1D90     BTFSS UIR, 0x3
03B8  2BBA     GOTO 0x3BA
03B9  2BBB     GOTO 0x3BB
03BA  2C13     GOTO 0x413
792:                       {
793:                           //Save and extract USTAT register info.  Will use this info later.
794:                           USTATcopy.Val = U1STAT;
03BB  080F     MOVF USTAT, W
03BC  0021     MOVLB 0x1
03BD  00EB     MOVWF 0xEB
03BE  086B     MOVF 0xEB, W
03BF  00D7     MOVWF USTATcopy
795:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
03C0  0C57     RRF USTATcopy, W
03C1  00EB     MOVWF 0xEB
03C2  0CEB     RRF 0xEB, F
03C3  0C6B     RRF 0xEB, W
03C4  390F     ANDLW 0xF
03C5  00EC     MOVWF 0xEC
03C6  086C     MOVF 0xEC, W
03C7  00CE     MOVWF endpoint_number
796:           
797:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
03C8  30F7     MOVLW 0xF7
03C9  00EB     MOVWF 0xEB
03CA  086B     MOVF 0xEB, W
03CB  003D     MOVLB 0x1D
03CC  0590     ANDWF UIR, F
798:           
799:                           //Keep track of the hardware ping pong state for endpoints other
800:                           //than EP0, if ping pong buffering is enabled.
801:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
802:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
03CD  0021     MOVLB 0x1
03CE  1957     BTFSC USTATcopy, 0x2
03CF  2BD1     GOTO 0x3D1
03D0  2BD2     GOTO 0x3D2
03D1  2BE2     GOTO 0x3E2
803:                           {
804:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
03D2  084E     MOVF endpoint_number, W
03D3  3EAC     ADDLW 0xAC
03D4  0086     MOVWF FSR1L
03D5  3001     MOVLW 0x1
03D6  0087     MOVWF FSR1H
03D7  0801     MOVF INDF1, W
03D8  3901     ANDLW 0x1
03D9  00EB     MOVWF 0xEB
03DA  3001     MOVLW 0x1
03DB  06EB     XORWF 0xEB, F
03DC  0801     MOVF INDF1, W
03DD  066B     XORWF 0xEB, W
03DE  39FE     ANDLW 0xFE
03DF  066B     XORWF 0xEB, W
03E0  0081     MOVWF INDF1
805:                           }
03E1  2BF1     GOTO 0x3F1
806:                           else
807:                           {
808:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
03E2  084E     MOVF endpoint_number, W
03E3  3EB0     ADDLW 0xB0
03E4  0086     MOVWF FSR1L
03E5  3001     MOVLW 0x1
03E6  0087     MOVWF FSR1H
03E7  0801     MOVF INDF1, W
03E8  3901     ANDLW 0x1
03E9  00EB     MOVWF 0xEB
03EA  3001     MOVLW 0x1
03EB  06EB     XORWF 0xEB, F
03EC  0801     MOVF INDF1, W
03ED  066B     XORWF 0xEB, W
03EE  39FE     ANDLW 0xFE
03EF  066B     XORWF 0xEB, W
03F0  0081     MOVWF INDF1
809:                           }
810:                           #endif
811:           
812:                           //USBCtrlEPService only services transactions over EP0.
813:                           //It ignores all other EP transactions.
814:                           if(endpoint_number == 0)
03F1  084E     MOVF endpoint_number, W
03F2  1D03     BTFSS STATUS, 0x2
03F3  2BF5     GOTO 0x3F5
03F4  2BF6     GOTO 0x3F6
03F5  2BFA     GOTO 0x3FA
815:                           {
816:                               USBCtrlEPService();
03F6  3189     MOVLP 0x9
03F7  2120     CALL 0x120
03F8  3182     MOVLP 0x2
817:                           }
03F9  2C08     GOTO 0x408
818:                           else
819:                           {
820:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
03FA  3072     MOVLW 0x72
03FB  00D9     MOVWF __pcstackBANK1
03FC  3000     MOVLW 0x0
03FD  00DA     MOVWF 0xDA
03FE  30D7     MOVLW 0xD7
03FF  00DB     MOVWF pdata
0400  3000     MOVLW 0x0
0401  00DC     MOVWF 0xDC
0402  3000     MOVLW 0x0
0403  00DD     MOVWF size
0404  00DE     MOVWF 0xDE
0405  3188     MOVLP 0x8
0406  2092     CALL 0x92
0407  3182     MOVLP 0x2
821:                           }
822:                       }//end if(USBTransactionCompleteIF)
823:                       else
824:                       {
825:                           break;	//USTAT FIFO must be empty.
826:                       }
827:                   }//end for()
0408  3001     MOVLW 0x1
0409  0021     MOVLB 0x1
040A  00EB     MOVWF 0xEB
040B  086B     MOVF 0xEB, W
040C  07ED     ADDWF i, F
040D  3004     MOVLW 0x4
040E  026D     SUBWF i, W
040F  1C03     BTFSS STATUS, 0x0
0410  2C12     GOTO 0x412
0411  2C13     GOTO 0x413
0412  2BB6     GOTO 0x3B6
828:               }//end if(USBTransactionCompleteIE)
829:           
830:               USBClearUSBInterrupt();
0413  0020     MOVLB 0x0
0414  1112     BCF PIR2, 0x2
831:           }//end of USBDeviceTasks()
0415  0008     RETURN
832:           
833:           /*******************************************************************************
834:             Function:
835:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
836:           
837:             Summary:
838:               This function will enable the specified endpoint with the specified
839:               options
840:             Description:
841:               This function will enable the specified endpoint with the specified
842:               options.
843:           
844:               Typical Usage:
845:               <code>
846:               void USBCBInitEP(void)
847:               {
848:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
849:                   USBMSDInit();
850:               }
851:               </code>
852:           
853:               In the above example endpoint number MSD_DATA_IN_EP is being configured
854:               for both IN and OUT traffic with handshaking enabled. Also since
855:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
856:               explicitly disable SETUP packets on this endpoint.
857:             Conditions:
858:               None
859:             Input:
860:               uint8_t ep -       the endpoint to be configured
861:               uint8_t options -  optional settings for the endpoint. The options should
862:                               be ORed together to form a single options string. The
863:                               available optional settings for the endpoint. The
864:                               options should be ORed together to form a single options
865:                               string. The available options are the following\:
866:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
867:                                 NAK)
868:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
869:                                 NAK)
870:                               * USB_OUT_ENABLED enables the out direction
871:                               * USB_OUT_DISABLED disables the out direction
872:                               * USB_IN_ENABLED enables the in direction
873:                               * USB_IN_DISABLED disables the in direction
874:                               * USB_ALLOW_SETUP enables control transfers
875:                               * USB_DISALLOW_SETUP disables control transfers
876:                               * USB_STALL_ENDPOINT STALLs this endpoint
877:             Return:
878:               None
879:             Remarks:
880:               None
881:             *****************************************************************************/
882:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
1755  00FC     MOVWF ep
883:           {
884:               unsigned char* p;
885:           
886:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and
887:               //starting DTS state in the BDT entry.
888:               if(options & USB_OUT_ENABLED)
1756  1D77     BTFSS tmp, 0x2
1757  2F59     GOTO 0x759
1758  2F5A     GOTO 0x75A
1759  2F5F     GOTO 0x75F
889:               {
890:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
175A  01F0     CLRF __pcstackCOMMON
175B  087C     MOVF ep, W
175C  3187     MOVLP 0x7
175D  27BC     CALL 0x7BC
175E  3197     MOVLP 0x17
891:               }
892:               if(options & USB_IN_ENABLED)
175F  1CF7     BTFSS tmp, 0x1
1760  2F62     GOTO 0x762
1761  2F63     GOTO 0x763
1762  2F69     GOTO 0x769
893:               {
894:                   USBConfigureEndpoint(ep, IN_TO_HOST);
1763  01F0     CLRF __pcstackCOMMON
1764  0AF0     INCF __pcstackCOMMON, F
1765  087C     MOVF ep, W
1766  3187     MOVLP 0x7
1767  27BC     CALL 0x7BC
1768  3197     MOVLP 0x17
895:               }
896:           
897:               //Update the relevant UEPx register to actually enable the endpoint with
898:               //the specified options (ex: handshaking enabled, control transfers allowed,
899:               //etc.)
900:               #if defined(__C32__)
901:                   p = (unsigned char*)(&U1EP0+(4*ep));
902:               #else
903:                   p = (unsigned char*)(&U1EP0+ep);
1769  087C     MOVF ep, W
176A  3E98     ADDLW 0x98
176B  00F8     MOVWF d1
176C  01F9     CLRF d
176D  300E     MOVLW 0xE
176E  3DF9     ADDWFC d, F
176F  0878     MOVF d1, W
1770  00FA     MOVWF p
1771  0879     MOVF d, W
1772  00FB     MOVWF 0x7B
904:               #endif
905:               *p = options;
1773  087A     MOVF p, W
1774  0086     MOVWF FSR1
1775  087B     MOVF 0x7B, W
1776  0087     MOVWF FSR1H
1777  0877     MOVF tmp, W
1778  0081     MOVWF INDF1
906:           }
1779  0008     RETURN
907:           
908:           
909:           /*************************************************************************
910:             Function:
911:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
912:           
913:             Summary:
914:               Transfers a single packet (one transaction) of data on the USB bus.
915:           
916:             Description:
917:               The USBTransferOnePacket() function prepares a USB endpoint
918:               so that it may send data to the host (an IN transaction), or
919:               receive data from the host (an OUT transaction).  The
920:               USBTransferOnePacket() function can be used both to receive	and
921:               send data to the host.  This function is the primary API function
922:               provided by the USB stack firmware for sending or receiving application
923:               data over the USB port.
924:           
925:               The USBTransferOnePacket() is intended for use with all application
926:               endpoints.  It is not used for sending or receiving application data
927:               through endpoint 0 by using control transfers.  Separate API
928:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
929:               USBEP0SendROMPtr() are provided for this purpose.
930:           
931:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
932:               entry associated with an endpoint buffer, and sets the UOWN bit, which
933:               prepares the USB hardware to allow the transaction to complete.  The
934:               application firmware can use the USBHandleBusy() macro to check the
935:               status of the transaction, to see if the data has been successfully
936:               transmitted yet.
937:           
938:           
939:               Typical Usage
940:               <code>
941:               //make sure that the we are in the configured state
942:               if(USBGetDeviceState() == CONFIGURED_STATE)
943:               {
944:                   //make sure that the last transaction isn't busy by checking the handle
945:                   if(!USBHandleBusy(USBInHandle))
946:                   {
947:           	        //Write the new data that we wish to send to the host to the INPacket[] array
948:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
949:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
950:           	        //INPacket[2] = ... (fill in the rest of the packet data)
951:           
952:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
953:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
954:                   }
955:               }
956:               </code>
957:           
958:             Conditions:
959:               Before calling USBTransferOnePacket(), the following should be true.
960:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
961:               2.  A transaction is not already pending on the specified endpoint.  This
962:                   is done by checking the previous request using the USBHandleBusy()
963:                   macro (see the typical usage example).
964:               3.  The host has already sent a set configuration request and the
965:                   enumeration process is complete.
966:                   This can be checked by verifying that the USBGetDeviceState()
967:                   macro returns "CONFIGURED_STATE", prior to calling
968:                   USBTransferOnePacket().
969:           
970:             Input:
971:               uint8_t ep - The endpoint number that the data will be transmitted or
972:           	          received on
973:               uint8_t dir - The direction of the transfer
974:                          This value is either OUT_FROM_HOST or IN_TO_HOST
975:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
976:                            the data to be sent to the host.  For OUT transactions: pointer
977:                            to the RAM buffer that the received data should get written to.
978:              uint8_t len - Length of the data needing to be sent (for IN transactions).
979:                         For OUT transactions, the len parameter should normally be set
980:                         to the endpoint size specified in the endpoint descriptor.
981:           
982:             Return Values:
983:               USB_HANDLE - handle to the transfer.  The handle is a pointer to
984:                            the BDT entry associated with this transaction.  The
985:                            status of the transaction (ex: if it is complete or still
986:                            pending) can be checked using the USBHandleBusy() macro
987:                            and supplying the USB_HANDLE provided by
988:                            USBTransferOnePacket().
989:           
990:             Remarks:
991:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
992:               callback function, the set configuration is still being processed and the
993:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case,
994:               the USBTransferOnePacket() may still be called, but make sure that the
995:               endpoint has been enabled and initialized by the USBEnableEndpoint()
996:               function first.
997:           
998:             *************************************************************************/
999:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
0D89  00F8     MOVWF d1
1000:          {
1001:              volatile BDT_ENTRY* handle;
1002:          
1003:              //If the direction is IN
1004:              if(dir != 0)
0D8A  0870     MOVF __pcstackCOMMON, W
0D8B  1903     BTFSC STATUS, 0x2
0D8C  2D8E     GOTO 0x58E
0D8D  2D8F     GOTO 0x58F
0D8E  2D98     GOTO 0x598
1005:              {
1006:                  //point to the IN BDT of the specified endpoint
1007:                  handle = pBDTEntryIn[ep];
0D8F  3578     LSLF d1, W
0D90  3EB0     ADDLW 0xB0
0D91  0086     MOVWF FSR1
0D92  0187     CLRF FSR1H
0D93  3F40     MOVIW 0[FSR1]
0D94  00F9     MOVWF d
0D95  3F41     MOVIW 1[FSR1]
0D96  00FA     MOVWF p
1008:              }
0D97  2DA1     GOTO 0x5A1
1009:              else
1010:              {
1011:                  //else point to the OUT BDT of the specified endpoint
1012:                  handle = pBDTEntryOut[ep];
0D98  3578     LSLF d1, W
0D99  3EA0     ADDLW 0xA0
0D9A  0086     MOVWF FSR1
0D9B  3001     MOVLW 0x1
0D9C  0087     MOVWF FSR1H
0D9D  3F40     MOVIW 0[FSR1]
0D9E  00F9     MOVWF d
0D9F  3F41     MOVIW 1[FSR1]
0DA0  00FA     MOVWF p
1013:              }
1014:          
1015:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1016:              //pBDTEntryOut[ep]) is initialized before using it.
1017:              if(handle == 0)
0DA1  0879     MOVF d, W
0DA2  047A     IORWF p, W
0DA3  1D03     BTFSS STATUS, 0x2
0DA4  2DA6     GOTO 0x5A6
0DA5  2DA7     GOTO 0x5A7
0DA6  2DAA     GOTO 0x5AA
1018:              {
1019:                  return 0;
0DA7  01F0     CLRF __pcstackCOMMON
0DA8  01F1     CLRF p
0DA9  2E0F     GOTO 0x60F
1020:              }
1021:          
1022:              //Toggle the DTS bit if required
1023:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1024:                  handle->STAT.Val ^= _DTSMASK;
1025:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1026:                  if(ep != 0)
1027:                  {
1028:                      handle->STAT.Val ^= _DTSMASK;
1029:                  }
1030:              #endif
1031:          
1032:              //Set the data pointer, data length, and enable the endpoint
1033:              handle->ADR = ConvertToPhysicalAddress(data);
0DAA  30FF     MOVLW 0xFF
0DAB  0571     ANDWF p, W
0DAC  00F4     MOVWF i
0DAD  307F     MOVLW 0x7F
0DAE  0572     ANDWF button, W
0DAF  00F5     MOVWF state
0DB0  0879     MOVF d, W
0DB1  0086     MOVWF FSR1
0DB2  087A     MOVF p, W
0DB3  0087     MOVWF FSR1H
0DB4  3142     ADDFSR 1, 2
0DB5  0874     MOVF i, W
0DB6  3FC0     MOVWI 0[FSR1]
0DB7  0875     MOVF state, W
0DB8  3FC1     MOVWI 1[FSR1]
1034:              handle->CNT = len;
0DB9  0879     MOVF d, W
0DBA  3E01     ADDLW 0x1
0DBB  00F4     MOVWF i
0DBC  3000     MOVLW 0x0
0DBD  3D7A     ADDWFC p, W
0DBE  00F5     MOVWF state
0DBF  0874     MOVF i, W
0DC0  0086     MOVWF FSR1
0DC1  0875     MOVF state, W
0DC2  0087     MOVWF FSR1H
0DC3  0873     MOVF i, W
0DC4  0081     MOVWF INDF1
1035:              handle->STAT.Val &= _DTSMASK;
0DC5  3040     MOVLW 0x40
0DC6  00F4     MOVWF i
0DC7  0879     MOVF d, W
0DC8  0086     MOVWF FSR1
0DC9  087A     MOVF p, W
0DCA  0087     MOVWF FSR1H
0DCB  0874     MOVF i, W
0DCC  0581     ANDWF INDF1, F
1036:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
0DCD  0879     MOVF d, W
0DCE  0086     MOVWF FSR1
0DCF  087A     MOVF p, W
0DD0  0087     MOVWF FSR1H
0DD1  1581     BSF INDF1, 0x3
1037:              handle->STAT.Val |= _USIE;
0DD2  0879     MOVF d, W
0DD3  0086     MOVWF FSR1
0DD4  087A     MOVF p, W
0DD5  0087     MOVWF FSR1H
0DD6  1781     BSF INDF1, 0x7
1038:          
1039:              //Point to the next buffer for ping pong purposes.
1040:              if(dir != OUT_FROM_HOST)
0DD7  0870     MOVF __pcstackCOMMON, W
0DD8  1903     BTFSC STATUS, 0x2
0DD9  2DDB     GOTO 0x5DB
0DDA  2DDC     GOTO 0x5DC
0DDB  2DF3     GOTO 0x5F3
1041:              {
1042:                  //toggle over the to the next buffer for an IN endpoint
1043:                  pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
0DDC  3578     LSLF d1, W
0DDD  3EB0     ADDLW 0xB0
0DDE  0086     MOVWF FSR1
0DDF  0187     CLRF FSR1H
0DE0  3F40     MOVIW 0[FSR1]
0DE1  00F4     MOVWF i
0DE2  3F41     MOVIW 1[FSR1]
0DE3  00F5     MOVWF state
0DE4  3004     MOVLW 0x4
0DE5  0674     XORWF i, W
0DE6  00F6     MOVWF handle
0DE7  3000     MOVLW 0x0
0DE8  0675     XORWF state, W
0DE9  00F7     MOVWF tmp
0DEA  3578     LSLF d1, W
0DEB  3EB0     ADDLW 0xB0
0DEC  0086     MOVWF FSR1
0DED  0187     CLRF FSR1H
0DEE  0876     MOVF handle, W
0DEF  3FC0     MOVWI 0[FSR1]
0DF0  0877     MOVF tmp, W
0DF1  3FC1     MOVWI 1[FSR1]
1044:              }
0DF2  2E0B     GOTO 0x60B
1045:              else
1046:              {
1047:                  //toggle over the to the next buffer for an OUT endpoint
1048:                  pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
0DF3  3578     LSLF d1, W
0DF4  3EA0     ADDLW 0xA0
0DF5  0086     MOVWF FSR1
0DF6  3001     MOVLW 0x1
0DF7  0087     MOVWF FSR1H
0DF8  3F40     MOVIW 0[FSR1]
0DF9  00F4     MOVWF i
0DFA  3F41     MOVIW 1[FSR1]
0DFB  00F5     MOVWF state
0DFC  3004     MOVLW 0x4
0DFD  0674     XORWF i, W
0DFE  00F6     MOVWF handle
0DFF  3000     MOVLW 0x0
0E00  0675     XORWF state, W
0E01  00F7     MOVWF tmp
0E02  3578     LSLF d1, W
0E03  3EA0     ADDLW 0xA0
0E04  0086     MOVWF FSR1
0E05  3001     MOVLW 0x1
0E06  0087     MOVWF FSR1H
0E07  0876     MOVF handle, W
0E08  3FC0     MOVWI 0[FSR1]
0E09  0877     MOVF tmp, W
0E0A  3FC1     MOVWI 1[FSR1]
1049:              }
1050:              return (USB_HANDLE)handle;
0E0B  087A     MOVF p, W
0E0C  00F1     MOVWF p
0E0D  0879     MOVF d, W
0E0E  00F0     MOVWF __pcstackCOMMON
1051:          }
0E0F  0008     RETURN
1052:          
1053:          
1054:          /********************************************************************
1055:              Function:
1056:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1057:          
1058:              Summary:
1059:                   Configures the specified endpoint to send STALL to the host, the next
1060:                   time the host tries to access the endpoint.
1061:          
1062:              PreCondition:
1063:                  None
1064:          
1065:              Parameters:
1066:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1067:                  uint8_t dir - The direction of the endpoint to STALL, either
1068:                             IN_TO_HOST or OUT_FROM_HOST.
1069:          
1070:              Return Values:
1071:                  None
1072:          
1073:              Remarks:
1074:                  None
1075:          
1076:           *******************************************************************/
1077:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
1078:          {
1079:              BDT_ENTRY *p;
1080:          
1081:              if(ep == 0)
1082:              {
1083:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1084:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP
1085:                  //packet that will arrive.
1086:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1087:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1088:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1089:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1090:                  pBDTEntryIn[0]->STAT.Val = _BSTALL;
1091:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1092:          
1093:              }
1094:              else
1095:              {
1096:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1097:                  p->STAT.Val |= _BSTALL;
1098:                  p->STAT.Val |= _USIE;
1099:          
1100:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1101:                  //then stall that entry as well
1102:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1103:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1104:                  p->STAT.Val |= _BSTALL;
1105:                  p->STAT.Val |= _USIE;
1106:                  #endif
1107:              }
1108:          }
1109:          
1110:          /**************************************************************************
1111:              Function:
1112:                  void USBCancelIO(uint8_t endpoint)
1113:          
1114:              Description:
1115:                  This function cancels the transfers pending on the specified endpoint.
1116:                  This function can only be used after a SETUP packet is received and
1117:                  before that setup packet is handled.  This is the time period in which
1118:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1119:                  returns to the stack.
1120:          
1121:              Precondition:
1122:          
1123:              Parameters:
1124:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1125:          
1126:              Return Values:
1127:                  None
1128:          
1129:              Remarks:
1130:                  None
1131:          
1132:            **************************************************************************/
1133:          void USBCancelIO(uint8_t endpoint)
1134:          {
1135:              if(USBPacketDisable == 1)
1136:              {
1137:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1138:              	//to mess with the BDT right now.
1139:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1140:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1141:          
1142:              	//Need to do additional handling if ping-pong buffering is being used
1143:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1144:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1145:                  //(either due to SIE clearing it after a transaction, or the firmware
1146:                  //clearing it) makes hardware ping pong pointer advance.
1147:                  pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
1148:          
1149:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1150:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1151:                  #endif
1152:              }
1153:          }
1154:          
1155:          /**************************************************************************
1156:              Function:
1157:                  void USBDeviceDetach(void)
1158:          
1159:              Summary:
1160:                  This function configures the USB module to "soft detach" itself from
1161:                  the USB host.
1162:          
1163:              Description:
1164:                  This function configures the USB module to perform a "soft detach"
1165:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1166:                  lets the host know the device is present and attached.  This will make
1167:                  the host think that the device has been unplugged.  This is potentially
1168:                  useful, as it allows the USB device to force the host to re-enumerate
1169:                  the device (on the firmware has re-enabled the USB module/pull up, by
1170:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1171:          
1172:              Precondition:
1173:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1174:                  section if USB_POLLING mode option is being used (usb_config.h option).
1175:          
1176:                  Additionally, this function should only be called from the main() loop
1177:                  context.  Do not call this function from within an interrupt handler, as
1178:                  this function may modify global interrupt enable bits and settings.
1179:          
1180:              Parameters:
1181:                  None
1182:          
1183:              Return Values:
1184:                  None
1185:          
1186:              Remarks:
1187:                  If the application firmware calls USBDeviceDetach(), it is strongly
1188:                  recommended that the firmware wait at least >= 80ms before calling
1189:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1190:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1191:                  hosts may interpret this as an unexpected "glitch" rather than as a
1192:                  physical removal/re-attachment of the USB device.  In this case the host
1193:                  may simply ignore the event without re-enumerating the device.  To
1194:                  ensure that the host properly detects and processes the device soft
1195:                  detach/re-attach, it is recommended to make sure the device remains
1196:                  detached long enough to mimic a real human controlled USB
1197:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1198:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1199:          
1200:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1201:                  or take long to execute.  It is the application firmwares
1202:                  responsibility for adding the 80+ms delay, when using these API
1203:                  functions.
1204:          
1205:                  Note: The Windows plug and play event handler processing is fairly
1206:                  slow, especially in certain versions of Windows, and for certain USB
1207:                  device classes.  It has been observed that some device classes need to
1208:                  provide even more USB detach dwell interval (before calling
1209:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1210:                  If the USB device is a CDC class device, it is recommended to wait
1211:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1212:                  to provide the plug and play event handler enough time to finish
1213:                  processing the removal event, before the re-attach occurs.
1214:          
1215:                  If the application is using the USB_POLLING mode option, then the
1216:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.
1217:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO"
1218:                  and "#define USB_BUS_SENSE" options in the
1219:                  HardwareProfile – [platform name].h file.
1220:          
1221:                  When using the USB_POLLING mode option, and the
1222:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then
1223:                  the USB stack assumes that it should always enable the USB module at
1224:                  pretty much all times.  Basically, anytime the application firmware
1225:                  calls USBDeviceTasks(), the firmware will automatically enable the USB
1226:                  module.  This mode would typically be selected if the application was
1227:                  designed to be a purely bus powered device.  In this case, the
1228:                  application is powered from the +5V VBUS supply from the USB port, so
1229:                  it is correct and sensible in this type of application to power up and
1230:                  turn on the USB module, at anytime that the microcontroller is
1231:                  powered (which implies the USB cable is attached and the host is also
1232:                  powered).
1233:          
1234:                  In a self powered application, the USB stack is designed with the
1235:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO"
1236:                  option in the HardwareProfile – [platform name].h file.  When this
1237:                  option is defined, then the USBDeviceTasks() function will automatically
1238:                  check the I/O pin port value of the designated pin (based on the
1239:                  #define USB_BUS_SENSE option in the HardwareProfile – [platform name].h
1240:                  file), every time the application calls USBDeviceTasks().  If the
1241:                  USBDeviceTasks() function is executed and finds that the pin defined by
1242:                  the #define USB_BUS_SENSE is in a logic low state, then it will
1243:                  automatically disable the USB module and tri-state the D+ and D- pins.
1244:                  If however the USBDeviceTasks() function is executed and finds the pin
1245:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it
1246:                  will automatically enable the USB module, if it has not already been
1247:                  enabled.
1248:          
1249:            **************************************************************************/
1250:          #if defined(USB_INTERRUPT)
1251:          void USBDeviceDetach(void)
1252:          {
1253:              //If the interrupt option is selected then the customer is required
1254:              //  to notify the stack when the device is attached or removed from the
1255:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1256:          #ifdef USB_SUPPORT_OTG
1257:              if (USB_BUS_SENSE != 1)
1258:          #endif
1259:              {
1260:                   // Disable module & detach from bus
1261:                   U1CON = 0;
1262:          
1263:                   // Mask all USB interrupts
1264:                   U1IE = 0;
1265:          
1266:                   //Move to the detached state
1267:                   USBDeviceState = DETACHED_STATE;
1268:          
1269:                   #ifdef  USB_SUPPORT_OTG
1270:                       //Disable D+ Pull-up
1271:                       U1OTGCONbits.DPPULUP = 0;
1272:          
1273:                       //Disable HNP
1274:                       USBOTGDisableHnp();
1275:          
1276:                       //Deactivate HNP
1277:                       USBOTGDeactivateHnp();
1278:          
1279:                       //If ID Pin Changed State
1280:                       if (USBIDIF && USBIDIE)
1281:                       {
1282:                           //Re-detect & Initialize
1283:                            USBOTGInitialize();
1284:          
1285:                            //Clear ID Interrupt Flag
1286:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1287:                       }
1288:                   #endif
1289:          
1290:                   #if defined __C30__ || defined __XC16__
1291:                       //USBClearInterruptFlag(U1OTGIR, 3);
1292:                   #endif
1293:                      //return so that we don't go through the rest of
1294:                      //the state machine
1295:                    return;
1296:              }
1297:          
1298:          #ifdef USB_SUPPORT_OTG
1299:              //If Session Is Started Then
1300:             else
1301:             {
1302:                  //If SRP Is Ready
1303:                  if (USBOTGSRPIsReady())
1304:                  {
1305:                      //Clear SRPReady
1306:                      USBOTGClearSRPReady();
1307:          
1308:                      //Clear SRP Timeout Flag
1309:                      USBOTGClearSRPTimeOutFlag();
1310:          
1311:                      //Indicate Session Started
1312:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1313:                  }
1314:              }
1315:          #endif
1316:          }
1317:          #endif  //#if defined(USB_INTERRUPT)
1318:          /**************************************************************************
1319:              Function:
1320:                  void USBDeviceAttach(void)
1321:          
1322:              Summary:
1323:                  Checks if VBUS is present, and that the USB module is not already
1324:                  initialized, and if so, enables the USB module so as to signal device
1325:                  attachment to the USB host.
1326:          
1327:              Description:
1328:                  This function indicates to the USB host that the USB device has been
1329:                  attached to the bus.  This function needs to be called in order for the
1330:                  device to start to enumerate on the bus.
1331:          
1332:              Precondition:
1333:                  Should only be called when USB_INTERRUPT is defined.  Also, should only
1334:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1335:                  from within an interrupt handler, as the USBDeviceAttach() function
1336:                  may modify global interrupt enable bits and settings.
1337:          
1338:                  For normal USB devices:
1339:                  Make sure that if the module was previously on, that it has been turned off
1340:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1341:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1342:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes
1343:                  reject this event, since no human could ever unplug and re-attach a USB device in a
1344:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind
1345:                  of glitch and ignore the event altogether.
1346:              Parameters:
1347:                  None
1348:          
1349:              Return Values:
1350:                  None
1351:          
1352:              Remarks:
1353:          		See also the USBDeviceDetach() API function documentation.
1354:          ****************************************************************************/
1355:          #if defined(USB_INTERRUPT)
1356:          void USBDeviceAttach(void)
1357:          {
1358:              //if we are in the detached state
1359:              if(USBDeviceState == DETACHED_STATE)
1360:              {
1361:                  if(USB_BUS_SENSE == 1)
1362:                  {
1363:              	    //Initialize registers to known states.
1364:                      U1CON = 0;
1365:          
1366:                      // Mask all USB interrupts
1367:                      U1IE = 0;
1368:          
1369:                      //Configure things like: pull ups, full/low-speed mode,
1370:                      //set the ping pong mode, and set internal transceiver
1371:                      SetConfigurationOptions();
1372:          
1373:                      USBEnableInterrupts();  //Modifies global interrupt settings
1374:          
1375:                      // Enable module & attach to bus
1376:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1377:          
1378:                      //moved to the attached state
1379:                      USBDeviceState = ATTACHED_STATE;
1380:          
1381:                      #ifdef  USB_SUPPORT_OTG
1382:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
1383:                      #endif
1384:                  }
1385:              }
1386:          }
1387:          #endif  //#if defined(USB_INTERRUPT)
1388:          
1389:          
1390:          /*******************************************************************************
1391:            Function: void USBCtrlEPAllowStatusStage(void);
1392:          
1393:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1394:                      (based on the controlTransferState) to allow the status stage packet
1395:                      of a control transfer to complete.  This function gets used
1396:                      internally by the USB stack itself, but it may also be called from
1397:                      the application firmware, IF the application firmware called
1398:                      the USBDeferStatusStage() function during the initial processing
1399:                      of the control transfer request.  In this case, the application
1400:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1401:                      completed processing and handling the data stage portion of the
1402:                      request.
1403:          
1404:                      If the application firmware has no need for delaying control
1405:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1406:                      application firmware should not call USBCtrlEPAllowStatusStage().
1407:          
1408:            Description:
1409:          
1410:            Conditions:
1411:              None
1412:          
1413:            Input:
1414:          
1415:            Return:
1416:          
1417:            Remarks:
1418:              None
1419:            *****************************************************************************/
1420:          void USBCtrlEPAllowStatusStage(void)
1421:          {
1422:              //Check and set two flags, prior to actually modifying any BDT entries.
1423:              //This double checking is necessary to make certain that
1424:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once
1425:              //in main loop context, while simultaneously getting an interrupt which
1426:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1427:              if(USBStatusStageEnabledFlag1 == false)
0AA3  0021     MOVLB 0x1
0AA4  084A     MOVF USBStatusStageEnabledFlag1, W
0AA5  1D03     BTFSS STATUS, 0x2
0AA6  2AA8     GOTO 0x2A8
0AA7  2AA9     GOTO 0x2A9
0AA8  2B14     GOTO 0x314
1428:              {
1429:                  USBStatusStageEnabledFlag1 = true;
0AA9  3001     MOVLW 0x1
0AAA  00F0     MOVWF 0xF0
0AAB  0870     MOVF 0xF0, W
0AAC  00CA     MOVWF USBStatusStageEnabledFlag1
1430:                  if(USBStatusStageEnabledFlag2 == false)
0AAD  0849     MOVF USBStatusStageEnabledFlag2, W
0AAE  1D03     BTFSS STATUS, 0x2
0AAF  2AB1     GOTO 0x2B1
0AB0  2AB2     GOTO 0x2B2
0AB1  2B14     GOTO 0x314
1431:                  {
1432:                      USBStatusStageEnabledFlag2 = true;
0AB2  3001     MOVLW 0x1
0AB3  00F0     MOVWF 0xF0
0AB4  0870     MOVF 0xF0, W
0AB5  00C9     MOVWF USBStatusStageEnabledFlag2
1433:          
1434:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1435:                      //stage), based on the type of control transfer currently pending.
1436:                      if(controlTransferState == CTRL_TRF_RX)
0AB6  3002     MOVLW 0x2
0AB7  0652     XORWF controlTransferState, W
0AB8  1D03     BTFSS STATUS, 0x2
0AB9  2ABB     GOTO 0x2BB
0ABA  2ABC     GOTO 0x2BC
0ABB  2ACE     GOTO 0x2CE
1437:                      {
1438:                          pBDTEntryIn[0]->CNT = 0;
0ABC  0830     MOVF pBDTEntryIn, W
0ABD  0086     MOVWF FSR1L
0ABE  0831     MOVF 0xB1, W
0ABF  0087     MOVWF FSR1H
0AC0  3141     ADDFSR 1, 1
0AC1  0181     CLRF INDF1
1439:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0AC2  0830     MOVF pBDTEntryIn, W
0AC3  0086     MOVWF FSR1L
0AC4  0831     MOVF 0xB1, W
0AC5  0087     MOVWF FSR1H
0AC6  3048     MOVLW 0x48
0AC7  0081     MOVWF INDF1
1440:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0AC8  0830     MOVF pBDTEntryIn, W
0AC9  0086     MOVWF FSR1L
0ACA  0831     MOVF 0xB1, W
0ACB  0087     MOVWF FSR1H
0ACC  1781     BSF INDF1, 0x7
1441:                      }
0ACD  2B14     GOTO 0x314
1442:                      else if(controlTransferState == CTRL_TRF_TX)
0ACE  0352     DECF controlTransferState, W
0ACF  1D03     BTFSS STATUS, 0x2
0AD0  2AD2     GOTO 0x2D2
0AD1  2AD3     GOTO 0x2D3
0AD2  2B14     GOTO 0x314
1443:                      {
1444:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
0AD3  01CD     CLRF BothEP0OutUOWNsSet
1445:          
1446:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1447:                          //next SETUP packet.
1448:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1449:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
0AD4  3008     MOVLW 0x8
0AD5  00F0     MOVWF 0xF0
0AD6  0A54     INCF pBDTEntryEP0OutCurrent, W
0AD7  0086     MOVWF FSR1L
0AD8  0187     CLRF FSR1H
0AD9  0870     MOVF 0xF0, W
0ADA  0081     MOVWF INDF1
1450:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
0ADB  3060     MOVLW 0x60
0ADC  00F0     MOVWF 0xF0
0ADD  3000     MOVLW 0x0
0ADE  00F1     MOVWF 0xF1
0ADF  0854     MOVF pBDTEntryEP0OutCurrent, W
0AE0  3E02     ADDLW 0x2
0AE1  0086     MOVWF FSR1L
0AE2  0187     CLRF FSR1H
0AE3  0870     MOVF 0xF0, W
0AE4  3FC0     MOVWI 0[FSR1]
0AE5  0871     MOVF 0xF1, W
0AE6  3FC1     MOVWI 1[FSR1]
1451:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
0AE7  3004     MOVLW 0x4
0AE8  00F0     MOVWF 0xF0
0AE9  0854     MOVF pBDTEntryEP0OutCurrent, W
0AEA  0086     MOVWF FSR1L
0AEB  0187     CLRF FSR1H
0AEC  0870     MOVF 0xF0, W
0AED  0081     MOVWF INDF1
1452:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0AEE  0854     MOVF pBDTEntryEP0OutCurrent, W
0AEF  0086     MOVWF FSR1L
0AF0  0187     CLRF FSR1H
0AF1  1781     BSF INDF1, 0x7
1453:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
0AF2  01CD     CLRF BothEP0OutUOWNsSet
0AF3  0ACD     INCF BothEP0OutUOWNsSet, F
1454:                          #endif
1455:          
1456:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1457:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0AF4  0843     MOVF pBDTEntryEP0OutNext, W
0AF5  3E01     ADDLW 0x1
0AF6  00F0     MOVWF 0xF0
0AF7  3000     MOVLW 0x0
0AF8  3D44     ADDWFC 0xC4, W
0AF9  00F1     MOVWF 0xF1
0AFA  0870     MOVF 0xF0, W
0AFB  0086     MOVWF FSR1L
0AFC  0871     MOVF 0xF1, W
0AFD  0087     MOVWF FSR1H
0AFE  3008     MOVLW 0x8
0AFF  0081     MOVWF INDF1
1458:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0B00  3060     MOVLW 0x60
0B01  00F0     MOVWF 0xF0
0B02  3000     MOVLW 0x0
0B03  00F1     MOVWF 0xF1
0B04  0843     MOVF pBDTEntryEP0OutNext, W
0B05  0086     MOVWF FSR1L
0B06  0844     MOVF 0xC4, W
0B07  0087     MOVWF FSR1H
0B08  3142     ADDFSR 1, 2
0B09  0870     MOVF 0xF0, W
0B0A  3FC0     MOVWI 0[FSR1]
0B0B  0871     MOVF 0xF1, W
0B0C  3FC1     MOVWI 1[FSR1]
1459:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
0B0D  0843     MOVF pBDTEntryEP0OutNext, W
0B0E  0086     MOVWF FSR1L
0B0F  0844     MOVF 0xC4, W
0B10  0087     MOVWF FSR1H
0B11  3080     MOVLW 0x80
0B12  0081     MOVWF INDF1
0B13  2B14     GOTO 0x314
1460:                      }
1461:                  }
1462:              }
1463:          }
0B14  0008     RETURN
1464:          
1465:          
1466:          /*******************************************************************************
1467:            Function: void USBCtrlEPAllowDataStage(void);
1468:          
1469:            Summary: This function allows the data stage of either a host-to-device or
1470:                      device-to-host control transfer (with data stage) to complete.
1471:                      This function is meant to be used in conjunction with either the
1472:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1473:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1474:                      then the firmware does not need to manually call
1475:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1476:                      instead.
1477:          
1478:            Description:
1479:          
1480:            Conditions: A control transfer (with data stage) should already be pending,
1481:                          if the firmware calls this function.  Additionally, the firmware
1482:                          should have called either USBDeferOUTDataStage() or
1483:                          USBDeferINDataStage() at the start of the control transfer, if
1484:                          the firmware will be calling this function manually.
1485:          
1486:            Input:
1487:          
1488:            Return:
1489:          
1490:            Remarks:
1491:            *****************************************************************************/
1492:          void USBCtrlEPAllowDataStage(void)
1493:          {
1494:              USBDeferINDataStagePackets = false;
0974  0021     MOVLB 0x1
0975  01C8     CLRF USBDeferINDataStagePackets
1495:              USBDeferOUTDataStagePackets = false;
0976  01C7     CLRF USBDeferOUTDataStagePackets
1496:          
1497:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
0977  3002     MOVLW 0x2
0978  0652     XORWF controlTransferState, W
0979  1D03     BTFSS STATUS, 0x2
097A  297C     GOTO 0x17C
097B  297D     GOTO 0x17D
097C  29A2     GOTO 0x1A2
1498:              {
1499:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1500:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
097D  0843     MOVF pBDTEntryEP0OutNext, W
097E  3E01     ADDLW 0x1
097F  00F3     MOVWF 0xF3
0980  3000     MOVLW 0x0
0981  3D44     ADDWFC 0xC4, W
0982  00F4     MOVWF 0xF4
0983  0873     MOVF 0xF3, W
0984  0086     MOVWF FSR1L
0985  0874     MOVF 0xF4, W
0986  0087     MOVWF FSR1H
0987  3008     MOVLW 0x8
0988  0081     MOVWF INDF1
1501:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0989  3068     MOVLW 0x68
098A  00F3     MOVWF 0xF3
098B  3000     MOVLW 0x0
098C  00F4     MOVWF 0xF4
098D  0843     MOVF pBDTEntryEP0OutNext, W
098E  0086     MOVWF FSR1L
098F  0844     MOVF 0xC4, W
0990  0087     MOVWF FSR1H
0991  3142     ADDFSR 1, 2
0992  0873     MOVF 0xF3, W
0993  3FC0     MOVWI 0[FSR1]
0994  0874     MOVF 0xF4, W
0995  3FC1     MOVWI 1[FSR1]
1502:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0996  0843     MOVF pBDTEntryEP0OutNext, W
0997  0086     MOVWF FSR1L
0998  0844     MOVF 0xC4, W
0999  0087     MOVWF FSR1H
099A  3048     MOVLW 0x48
099B  0081     MOVWF INDF1
1503:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
099C  0843     MOVF pBDTEntryEP0OutNext, W
099D  0086     MOVWF FSR1L
099E  0844     MOVF 0xC4, W
099F  0087     MOVWF FSR1H
09A0  1781     BSF INDF1, 0x7
1504:              }
09A1  29D2     GOTO 0x1D2
1505:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1506:              {
1507:                  //Error check the data stage byte count.  Make sure the user specified
1508:                  //value was no greater than the number of bytes the host requested.
1509:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
09A2  083C     MOVF 0xBC, W
09A3  0020     MOVLB 0x0
09A4  0267     SUBWF 0x67, W
09A5  1D03     BTFSS STATUS, 0x2
09A6  29AB     GOTO 0x1AB
09A7  0021     MOVLB 0x1
09A8  083B     MOVF 0xBB, W
09A9  0020     MOVLB 0x0
09AA  0266     SUBWF 0x66, W
09AB  1803     BTFSC STATUS, 0x0
09AC  29AE     GOTO 0x1AE
09AD  29AF     GOTO 0x1AF
09AE  29B6     GOTO 0x1B6
1510:          		{
1511:          			inPipes[0].wCount.Val = SetupPkt.wLength;
09AF  0867     MOVF 0x67, W
09B0  0021     MOVLB 0x1
09B1  00BC     MOVWF 0xBC
09B2  0020     MOVLB 0x0
09B3  0866     MOVF 0x66, W
09B4  0021     MOVLB 0x1
09B5  00BB     MOVWF 0xBB
1512:          		}
1513:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
09B6  318B     MOVLP 0xB
09B7  2315     CALL 0x315
09B8  3189     MOVLP 0x9
1514:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1515:          
1516:          	    //Cnt should have been initialized by responsible request owner (ex: by
1517:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1518:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
09B9  3068     MOVLW 0x68
09BA  00F3     MOVWF 0xF3
09BB  3000     MOVLW 0x0
09BC  00F4     MOVWF 0xF4
09BD  0021     MOVLB 0x1
09BE  0830     MOVF pBDTEntryIn, W
09BF  0086     MOVWF FSR1L
09C0  0831     MOVF 0xB1, W
09C1  0087     MOVWF FSR1H
09C2  3142     ADDFSR 1, 2
09C3  0873     MOVF 0xF3, W
09C4  3FC0     MOVWI 0[FSR1]
09C5  0874     MOVF 0xF4, W
09C6  3FC1     MOVWI 1[FSR1]
1519:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
09C7  0830     MOVF pBDTEntryIn, W
09C8  0086     MOVWF FSR1L
09C9  0831     MOVF 0xB1, W
09CA  0087     MOVWF FSR1H
09CB  3048     MOVLW 0x48
09CC  0081     MOVWF INDF1
1520:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
09CD  0830     MOVF pBDTEntryIn, W
09CE  0086     MOVWF FSR1L
09CF  0831     MOVF 0xB1, W
09D0  0087     MOVWF FSR1H
09D1  1781     BSF INDF1, 0x7
1521:              }
1522:          }
09D2  0008     RETURN
1523:          
1524:          
1525:          /******************************************************************************/
1526:          /** Internal Functions *********************************************************/
1527:          /******************************************************************************/
1528:          
1529:          /********************************************************************
1530:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1531:           *
1532:           * PreCondition:    None
1533:           *
1534:           * Input:           uint8_t EPNum - the endpoint to be configured
1535:           *                  uint8_t direction - the direction to be configured
1536:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1537:           *
1538:           * Output:          None
1539:           *
1540:           * Side Effects:    None
1541:           *
1542:           * Overview:        This function will configure the specified
1543:           *                  endpoint
1544:           *
1545:           * Note:            None
1546:           *******************************************************************/
1547:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
07BC  00F5     MOVWF 0xF5
1548:          {
1549:              volatile BDT_ENTRY* handle;
1550:          
1551:              //Compute a pointer to the even BDT entry corresponding to the
1552:              //EPNum and direction values passed to this function.
1553:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
07BD  3020     MOVLW 0x20
07BE  00F1     MOVWF 0xF1
07BF  0871     MOVF 0xF1, W
07C0  00F6     MOVWF 0xF6
1554:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
07C1  0870     MOVF 0xF0, W
07C2  00F1     MOVWF 0xF1
07C3  3001     MOVLW 0x1
07C4  35F1     LSLF 0xF1, F
07C5  0B89     DECFSZ WREG, F
07C6  2FC4     GOTO 0x7C4
07C7  0875     MOVF 0xF5, W
07C8  00F2     MOVWF 0xF2
07C9  3001     MOVLW 0x1
07CA  35F2     LSLF 0xF2, F
07CB  3EFF     ADDLW 0xFF
07CC  1D03     BTFSS STATUS, 0x2
07CD  2FCA     GOTO 0x7CA
07CE  3572     LSLF 0xF2, W
07CF  0771     ADDWF 0xF1, W
07D0  00F3     MOVWF 0xF3
07D1  3001     MOVLW 0x1
07D2  35F3     LSLF 0xF3, F
07D3  3EFF     ADDLW 0xFF
07D4  1D03     BTFSS STATUS, 0x2
07D5  2FD2     GOTO 0x7D2
07D6  3573     LSLF 0xF3, W
07D7  00F4     MOVWF 0xF4
07D8  0874     MOVF 0xF4, W
07D9  07F6     ADDWF 0xF6, F
1555:          
1556:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler()
07DA  0876     MOVF 0xF6, W
07DB  0086     MOVWF FSR1L
07DC  0187     CLRF FSR1H
07DD  1381     BCF INDF1, 0x7
1557:              //already cleared the entire BDT table
1558:          
1559:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1560:              //for USBTransferOnePacket() API calls.
1561:              if(direction == OUT_FROM_HOST)
07DE  0870     MOVF 0xF0, W
07DF  1D03     BTFSS STATUS, 0x2
07E0  2FE2     GOTO 0x7E2
07E1  2FE3     GOTO 0x7E3
07E2  2FED     GOTO 0x7ED
1562:              {
1563:                  pBDTEntryOut[EPNum] = handle;
07E3  3575     LSLF 0xF5, W
07E4  3EA0     ADDLW 0xA0
07E5  0086     MOVWF FSR1L
07E6  3001     MOVLW 0x1
07E7  0087     MOVWF FSR1H
07E8  0876     MOVF 0xF6, W
07E9  3FC0     MOVWI 0[FSR1]
07EA  3000     MOVLW 0x0
07EB  3FC1     MOVWI 1[FSR1]
1564:              }
07EC  2FF5     GOTO 0x7F5
1565:              else
1566:              {
1567:                  pBDTEntryIn[EPNum] = handle;
07ED  3575     LSLF 0xF5, W
07EE  3EB0     ADDLW 0xB0
07EF  0086     MOVWF FSR1L
07F0  0187     CLRF FSR1H
07F1  0876     MOVF 0xF6, W
07F2  3FC0     MOVWI 0[FSR1]
07F3  3000     MOVLW 0x0
07F4  3FC1     MOVWI 1[FSR1]
1568:              }
1569:          
1570:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1571:                  handle->STAT.DTS = 0;
07F5  0876     MOVF 0xF6, W
07F6  0086     MOVWF FSR1L
07F7  0187     CLRF FSR1H
07F8  1301     BCF INDF1, 0x6
1572:                  (handle+1)->STAT.DTS = 1;
07F9  0876     MOVF 0xF6, W
07FA  3E04     ADDLW 0x4
07FB  0086     MOVWF FSR1L
07FC  0187     CLRF FSR1H
07FD  1701     BSF INDF1, 0x6
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1574:                  //Set DTS to one because the first thing we will do
1575:                  //when transmitting is toggle the bit
1576:                  handle->STAT.DTS = 1;
1577:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1578:                  if(EPNum != 0)
1579:                  {
1580:                      handle->STAT.DTS = 1;
1581:                  }
1582:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1583:                  if(EPNum != 0)
1584:                  {
1585:                      handle->STAT.DTS = 0;
1586:                      (handle+1)->STAT.DTS = 1;
1587:                  }
1588:              #endif
1589:          }
07FE  0008     RETURN
1590:          
1591:          
1592:          /******************************************************************************
1593:           * Function:        void USBCtrlEPServiceComplete(void)
1594:           *
1595:           * PreCondition:    None
1596:           *
1597:           * Input:           None
1598:           *
1599:           * Output:          None
1600:           *
1601:           * Side Effects:    None
1602:           *
1603:           * Overview:        This routine wrap up the remaining tasks in servicing
1604:           *                  a Setup Request. Its main task is to set the endpoint
1605:           *                  controls appropriately for a given situation. See code
1606:           *                  below.
1607:           *                  There are three main scenarios:
1608:           *                  a) There was no handler for the Request, in this case
1609:           *                     a STALL should be sent out.
1610:           *                  b) The host has requested a read control transfer,
1611:           *                     endpoints are required to be setup in a specific way.
1612:           *                  c) The host has requested a write control transfer, or
1613:           *                     a control data stage is not required, endpoints are
1614:           *                     required to be setup in a specific way.
1615:           *
1616:           *                  Packet processing is resumed by clearing PKTDIS bit.
1617:           *
1618:           * Note:            None
1619:           *****************************************************************************/
1620:          static void USBCtrlEPServiceComplete(void)
1621:          {
1622:              /*
1623:               * PKTDIS bit is set when a Setup Transaction is received.
1624:               * Clear to resume packet processing.
1625:               */
1626:              USBPacketDisable = 0;
0E10  003D     MOVLB 0x1D
0E11  120E     BCF UCON, 0x4
1627:          
1628:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1629:          	//control transfer is currently in progress.  We need to know the type of control
1630:          	//transfer that is currently pending, in order to know how to properly arm the
1631:          	//EP0 IN and EP0 OUT endpoints.
1632:              if(inPipes[0].info.bits.busy == 0)
0E12  0021     MOVLB 0x1
0E13  1BBA     BTFSC 0xBA, 0x7
0E14  2E16     GOTO 0x616
0E15  2E17     GOTO 0x617
0E16  2E5E     GOTO 0x65E
1633:              {
1634:                  if(outPipes[0].info.bits.busy == 1)
0E17  0022     MOVLB 0x2
0E18  1FA2     BTFSS 0x122, 0x7
0E19  2E1B     GOTO 0x61B
0E1A  2E1C     GOTO 0x61C
0E1B  2E2D     GOTO 0x62D
1635:                  {
1636:                      controlTransferState = CTRL_TRF_RX;
0E1C  3002     MOVLW 0x2
0E1D  00F5     MOVWF 0x175
0E1E  0875     MOVF 0x175, W
0E1F  0021     MOVLB 0x1
0E20  00D2     MOVWF controlTransferState
1637:                      /*
1638:                       * Control Write:
1639:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1640:                       */
1641:          
1642:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1643:                      //   function decided to defer the data stage (ex: because the intended
1644:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1645:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1646:                      //   once it is ready to begin receiving the data.
1647:                      if(USBDeferOUTDataStagePackets == false)
0E21  0847     MOVF USBDeferOUTDataStagePackets, W
0E22  1D03     BTFSS STATUS, 0x2
0E23  2E25     GOTO 0x625
0E24  2E26     GOTO 0x626
0E25  2E29     GOTO 0x629
1648:                      {
1649:                          USBCtrlEPAllowDataStage();
0E26  3189     MOVLP 0x9
0E27  2174     CALL 0x174
0E28  318E     MOVLP 0xE
1650:                      }
1651:          
1652:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage()
1653:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1654:                      USBStatusStageEnabledFlag2 = false;
0E29  0021     MOVLB 0x1
0E2A  01C9     CLRF USBStatusStageEnabledFlag2
1655:                      USBStatusStageEnabledFlag1 = false;
0E2B  01CA     CLRF USBStatusStageEnabledFlag1
1656:                  }
0E2C  2EAB     GOTO 0x6AB
1657:                  else
1658:                  {
1659:                      /*
1660:                       * If no one knows how to service this request then stall.
1661:                       * Must also prepare EP0 to receive the next SETUP transaction.
1662:                       */
1663:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0E2D  0021     MOVLB 0x1
0E2E  0843     MOVF pBDTEntryEP0OutNext, W
0E2F  3E01     ADDLW 0x1
0E30  00F5     MOVWF 0xF5
0E31  3000     MOVLW 0x0
0E32  3D44     ADDWFC 0xC4, W
0E33  00F6     MOVWF 0xF6
0E34  0875     MOVF 0xF5, W
0E35  0086     MOVWF FSR1L
0E36  0876     MOVF 0xF6, W
0E37  0087     MOVWF FSR1H
0E38  3008     MOVLW 0x8
0E39  0081     MOVWF INDF1
1664:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0E3A  3060     MOVLW 0x60
0E3B  00F5     MOVWF 0xF5
0E3C  3000     MOVLW 0x0
0E3D  00F6     MOVWF 0xF6
0E3E  0843     MOVF pBDTEntryEP0OutNext, W
0E3F  0086     MOVWF FSR1L
0E40  0844     MOVF 0xC4, W
0E41  0087     MOVWF FSR1H
0E42  3142     ADDFSR 1, 2
0E43  0875     MOVF 0xF5, W
0E44  3FC0     MOVWI 0[FSR1]
0E45  0876     MOVF 0xF6, W
0E46  3FC1     MOVWI 1[FSR1]
1665:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0E47  0843     MOVF pBDTEntryEP0OutNext, W
0E48  0086     MOVWF FSR1L
0E49  0844     MOVF 0xC4, W
0E4A  0087     MOVWF FSR1H
0E4B  300C     MOVLW 0xC
0E4C  0081     MOVWF INDF1
1666:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0E4D  0843     MOVF pBDTEntryEP0OutNext, W
0E4E  0086     MOVWF FSR1L
0E4F  0844     MOVF 0xC4, W
0E50  0087     MOVWF FSR1H
0E51  1781     BSF INDF1, 0x7
1667:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0E52  0830     MOVF pBDTEntryIn, W
0E53  0086     MOVWF FSR1L
0E54  0831     MOVF 0xB1, W
0E55  0087     MOVWF FSR1H
0E56  3004     MOVLW 0x4
0E57  0081     MOVWF INDF1
1668:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0E58  0830     MOVF pBDTEntryIn, W
0E59  0086     MOVWF FSR1L
0E5A  0831     MOVF 0xB1, W
0E5B  0087     MOVWF FSR1H
0E5C  1781     BSF INDF1, 0x7
0E5D  2EAB     GOTO 0x6AB
1669:                  }
1670:              }
1671:              else    // A module has claimed ownership of the control transfer session.
1672:              {
1673:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0E5E  0020     MOVLB 0x0
0E5F  1FE0     BTFSS SetupPkt, 0x7
0E60  2E62     GOTO 0x662
0E61  2E63     GOTO 0x663
0E62  2E7A     GOTO 0x67A
1674:          		{
1675:          			controlTransferState = CTRL_TRF_TX;
0E63  0021     MOVLB 0x1
0E64  01D2     CLRF controlTransferState
0E65  0AD2     INCF controlTransferState, F
1676:          			/*
1677:          			 * Control Read:
1678:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1679:          			 *
1680:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1681:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1682:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1683:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1684:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1685:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1686:          			 *    is ready to begin sending the data, it should then call the
1687:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1688:          			 */
1689:          			if(USBDeferINDataStagePackets == false)
0E66  0848     MOVF USBDeferINDataStagePackets, W
0E67  1D03     BTFSS STATUS, 0x2
0E68  2E6A     GOTO 0x66A
0E69  2E6B     GOTO 0x66B
0E6A  2E6E     GOTO 0x66E
1690:                      {
1691:                          USBCtrlEPAllowDataStage();
0E6B  3189     MOVLP 0x9
0E6C  2174     CALL 0x174
0E6D  318E     MOVLP 0xE
1692:          			}
1693:          
1694:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1695:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1696:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1697:                      //    is ready.  If the class request handler does this, it needs to be careful to
1698:                      //    be written so that it can handle the early termination scenario.
1699:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1700:                      //    1.  The desired total number of bytes were sent to the host.
1701:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that
1702:                      //        started the control transfer) has been reached.
1703:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless
1704:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1705:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1706:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1707:                      //        option can take care of this for you.
1708:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1709:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1710:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1711:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this
1712:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1713:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1714:                      USBStatusStageEnabledFlag2 = false;
0E6E  0021     MOVLB 0x1
0E6F  01C9     CLRF USBStatusStageEnabledFlag2
1715:                      USBStatusStageEnabledFlag1 = false;
0E70  01CA     CLRF USBStatusStageEnabledFlag1
1716:                      if(USBDeferStatusStagePacket == false)
0E71  084B     MOVF USBDeferStatusStagePacket, W
0E72  1D03     BTFSS STATUS, 0x2
0E73  2E75     GOTO 0x675
0E74  2E76     GOTO 0x676
0E75  2EAB     GOTO 0x6AB
1717:                      {
1718:                          USBCtrlEPAllowStatusStage();
0E76  318A     MOVLP 0xA
0E77  22A3     CALL 0x2A3
0E78  318E     MOVLP 0xE
0E79  2EAB     GOTO 0x6AB
1719:                      }
1720:          		}
1721:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1722:          		{
1723:          			//This situation occurs for special types of control transfers,
1724:          			//such as that which occurs when the host sends a SET_ADDRESS
1725:          			//control transfer.  Ex:
1726:          			//
1727:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1728:          
1729:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1730:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1731:          			//an IN status stage.
1732:          
1733:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
0E7A  3002     MOVLW 0x2
0E7B  00F5     MOVWF 0xF5
0E7C  0875     MOVF 0xF5, W
0E7D  0021     MOVLB 0x1
0E7E  00D2     MOVWF controlTransferState
1734:          
1735:          			//1. Prepare OUT EP to receive the next SETUP packet.
1736:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0E7F  0843     MOVF pBDTEntryEP0OutNext, W
0E80  3E01     ADDLW 0x1
0E81  00F5     MOVWF 0xF5
0E82  3000     MOVLW 0x0
0E83  3D44     ADDWFC 0xC4, W
0E84  00F6     MOVWF 0xF6
0E85  0875     MOVF 0xF5, W
0E86  0086     MOVWF FSR1L
0E87  0876     MOVF 0xF6, W
0E88  0087     MOVWF FSR1H
0E89  3008     MOVLW 0x8
0E8A  0081     MOVWF INDF1
1737:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0E8B  3060     MOVLW 0x60
0E8C  00F5     MOVWF 0xF5
0E8D  3000     MOVLW 0x0
0E8E  00F6     MOVWF 0xF6
0E8F  0843     MOVF pBDTEntryEP0OutNext, W
0E90  0086     MOVWF FSR1L
0E91  0844     MOVF 0xC4, W
0E92  0087     MOVWF FSR1H
0E93  3142     ADDFSR 1, 2
0E94  0875     MOVF 0xF5, W
0E95  3FC0     MOVWI 0[FSR1]
0E96  0876     MOVF 0xF6, W
0E97  3FC1     MOVWI 1[FSR1]
1738:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0E98  0843     MOVF pBDTEntryEP0OutNext, W
0E99  0086     MOVWF FSR1L
0E9A  0844     MOVF 0xC4, W
0E9B  0087     MOVWF FSR1H
0E9C  3004     MOVLW 0x4
0E9D  0081     MOVWF INDF1
1739:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0E9E  0843     MOVF pBDTEntryEP0OutNext, W
0E9F  0086     MOVWF FSR1L
0EA0  0844     MOVF 0xC4, W
0EA1  0087     MOVWF FSR1H
0EA2  1781     BSF INDF1, 0x7
1740:          
1741:          			//2. Prepare for IN status stage of the control transfer
1742:                      USBStatusStageEnabledFlag2 = false;
0EA3  01C9     CLRF USBStatusStageEnabledFlag2
1743:                      USBStatusStageEnabledFlag1 = false;
0EA4  01CA     CLRF USBStatusStageEnabledFlag1
1744:          			if(USBDeferStatusStagePacket == false)
0EA5  084B     MOVF USBDeferStatusStagePacket, W
0EA6  1D03     BTFSS STATUS, 0x2
0EA7  2EA9     GOTO 0x6A9
0EA8  2EAA     GOTO 0x6AA
0EA9  2EAB     GOTO 0x6AB
0EAA  2E76     GOTO 0x676
1745:                      {
1746:                          USBCtrlEPAllowStatusStage();
1747:                      }
1748:          		}
1749:          
1750:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1751:          
1752:          }//end USBCtrlEPServiceComplete
0EAB  0008     RETURN
1753:          
1754:          
1755:          /******************************************************************************
1756:           * Function:        void USBCtrlTrfTxService(void)
1757:           *
1758:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1759:           *
1760:           * Input:           None
1761:           *
1762:           * Output:          None
1763:           *
1764:           * Side Effects:    None
1765:           *
1766:           * Overview:        This routine is used for device to host control transfers
1767:           *					(IN transactions).  This function takes care of managing a
1768:           *                  transfer over multiple USB transactions.
1769:           *					This routine should be called from only two places.
1770:           *                  One from USBCtrlEPServiceComplete() and one from
1771:           *                  USBCtrlTrfInHandler().
1772:           *
1773:           * Note:
1774:           *****************************************************************************/
1775:          static void USBCtrlTrfTxService(void)
1776:          {
1777:              uint8_t byteToSend;
1778:          
1779:              //Figure out how many bytes of data to send in the next IN transaction.
1780:              //Assume a full size packet, unless otherwise determined below.
1781:              byteToSend = USB_EP0_BUFF_SIZE;
0B15  3008     MOVLW 0x8
0B16  00F0     MOVWF 0xF0
0B17  0870     MOVF 0xF0, W
0B18  00F2     MOVWF 0xF2
1782:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
0B19  3000     MOVLW 0x0
0B1A  0021     MOVLB 0x1
0B1B  023C     SUBWF 0xBC, W
0B1C  3008     MOVLW 0x8
0B1D  1903     BTFSC STATUS, 0x2
0B1E  023B     SUBWF 0xBB, W
0B1F  1803     BTFSC STATUS, 0x0
0B20  2B22     GOTO 0x322
0B21  2B23     GOTO 0x323
0B22  2B38     GOTO 0x338
1783:              {
1784:                  byteToSend = (uint8_t)(inPipes[0].wCount.Val);
0B23  083B     MOVF 0xBB, W
0B24  00F0     MOVWF 0xF0
0B25  0870     MOVF 0xF0, W
0B26  00F2     MOVWF 0xF2
1785:          
1786:                  //Keep track of whether or not we have sent a "short packet" yet.
1787:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1788:                  //after we have sent all of the intended data.  This makes sure the
1789:                  //hardware STALLs if the host erroneously tries to send more IN token
1790:                  //packets, requesting more data than intended in the control transfer.
1791:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
0B27  0853     MOVF shortPacketStatus, W
0B28  1D03     BTFSS STATUS, 0x2
0B29  2B2B     GOTO 0x32B
0B2A  2B2C     GOTO 0x32C
0B2B  2B2F     GOTO 0x32F
1792:                  {
1793:                      shortPacketStatus = SHORT_PKT_PENDING;
0B2C  01D3     CLRF shortPacketStatus
0B2D  0AD3     INCF shortPacketStatus, F
1794:                  }
0B2E  2B38     GOTO 0x338
1795:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
0B2F  0353     DECF shortPacketStatus, W
0B30  1D03     BTFSS STATUS, 0x2
0B31  2B33     GOTO 0x333
0B32  2B34     GOTO 0x334
0B33  2B38     GOTO 0x338
1796:                  {
1797:                      shortPacketStatus = SHORT_PKT_SENT;
0B34  3002     MOVLW 0x2
0B35  00F0     MOVWF 0xF0
0B36  0870     MOVF 0xF0, W
0B37  00D3     MOVWF shortPacketStatus
1798:                  }
1799:              }
1800:          
1801:              //Keep track of how many bytes remain to be sent in the transfer, by
1802:              //subtracting the number of bytes about to be sent from the total.
1803:              inPipes[0].wCount.Val -= byteToSend;
0B38  0872     MOVF 0xF2, W
0B39  00F0     MOVWF 0xF0
0B3A  01F1     CLRF 0xF1
0B3B  0870     MOVF 0xF0, W
0B3C  02BB     SUBWF 0xBB, F
0B3D  0871     MOVF 0xF1, W
0B3E  3BBC     SUBWFB 0xBC, F
1804:          
1805:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1806:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1807:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1808:              pBDTEntryIn[0]->CNT = byteToSend;
0B3F  0830     MOVF pBDTEntryIn, W
0B40  3E01     ADDLW 0x1
0B41  00F0     MOVWF 0xF0
0B42  3000     MOVLW 0x0
0B43  3D31     ADDWFC 0xB1, W
0B44  00F1     MOVWF 0xF1
0B45  0870     MOVF 0xF0, W
0B46  0086     MOVWF FSR1L
0B47  0871     MOVF 0xF1, W
0B48  0087     MOVWF FSR1H
0B49  0872     MOVF 0xF2, W
0B4A  0081     MOVWF INDF1
1809:          
1810:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1811:              //which we will send to the host.
1812:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
0B4B  3068     MOVLW 0x68
0B4C  00F0     MOVWF 0xF0
0B4D  0870     MOVF 0xF0, W
0B4E  00D1     MOVWF pDst
1813:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
0B4F  183A     BTFSC 0xBA, 0x0
0B50  2B52     GOTO 0x352
0B51  2B53     GOTO 0x353
0B52  2B84     GOTO 0x384
0B53  2B69     GOTO 0x369
1814:              {
1815:                  while(byteToSend)
0B69  0872     MOVF 0xF2, W
0B6A  1D03     BTFSS STATUS, 0x2
0B6B  2B6D     GOTO 0x36D
0B6C  2B6E     GOTO 0x36E
0B6D  2B54     GOTO 0x354
0B6E  2B89     GOTO 0x389
1816:                  {
1817:                      *pDst++ = *inPipes[0].pSrc.bRom++;
0B54  0838     MOVF inPipes, W
0B55  0084     MOVWF FSR0L
0B56  0839     MOVF 0xB9, W
0B57  0085     MOVWF FSR0H
0B58  0800     MOVF INDF0, W
0B59  00F0     MOVWF 0xF0
0B5A  0851     MOVF pDst, W
0B5B  0086     MOVWF FSR1L
0B5C  0187     CLRF FSR1H
0B5D  0870     MOVF 0xF0, W
0B5E  0081     MOVWF INDF1
0B5F  3001     MOVLW 0x1
0B60  07B8     ADDWF inPipes, F
0B61  3000     MOVLW 0x0
0B62  3DB9     ADDWFC 0xB9, F
0B63  3001     MOVLW 0x1
0B64  00F0     MOVWF 0xF0
0B65  0870     MOVF 0xF0, W
0B66  07D1     ADDWF pDst, F
1818:                      byteToSend--;
0B67  3001     MOVLW 0x1
0B68  02F2     SUBWF 0xF2, F
1819:                  }//end while(byte_to_send.Val)
1820:              }
1821:              else  // RAM
1822:              {
1823:                  while(byteToSend)
0B84  0872     MOVF 0xF2, W
0B85  1D03     BTFSS STATUS, 0x2
0B86  2B88     GOTO 0x388
0B87  2B89     GOTO 0x389
0B88  2B6F     GOTO 0x36F
1824:                  {
1825:                      *pDst++ = *inPipes[0].pSrc.bRam++;
0B6F  0838     MOVF inPipes, W
0B70  0084     MOVWF FSR0L
0B71  0839     MOVF 0xB9, W
0B72  0085     MOVWF FSR0H
0B73  0800     MOVF INDF0, W
0B74  00F0     MOVWF 0xF0
0B75  0851     MOVF pDst, W
0B76  0086     MOVWF FSR1L
0B77  0187     CLRF FSR1H
0B78  0870     MOVF 0xF0, W
0B79  0081     MOVWF INDF1
0B7A  3001     MOVLW 0x1
0B7B  07B8     ADDWF inPipes, F
0B7C  3000     MOVLW 0x0
0B7D  3DB9     ADDWFC 0xB9, F
0B7E  3001     MOVLW 0x1
0B7F  00F0     MOVWF 0xF0
0B80  0870     MOVF 0xF0, W
0B81  07D1     ADDWF pDst, F
1826:                      byteToSend--;
0B82  3001     MOVLW 0x1
0B83  02F2     SUBWF 0xF2, F
0B84  0872     MOVF 0xF2, W
0B85  1D03     BTFSS STATUS, 0x2
0B86  2B88     GOTO 0x388
0B87  2B89     GOTO 0x389
0B88  2B6F     GOTO 0x36F
1827:                  }//end while(byte_to_send.Val)
1828:              }//end if(usb_stat.ctrl_trf_mem == _const)
1829:          }//end USBCtrlTrfTxService
0B89  0008     RETURN
1830:          
1831:          /******************************************************************************
1832:           * Function:        void USBCtrlTrfRxService(void)
1833:           *
1834:           * PreCondition:    pDst and wCount are setup properly.
1835:           *                  pSrc is always &CtrlTrfData
1836:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1837:           *                  wCount should be set to 0 at the start of each control
1838:           *                  transfer.
1839:           *
1840:           * Input:           None
1841:           *
1842:           * Output:          None
1843:           *
1844:           * Side Effects:    None
1845:           *
1846:           * Overview:        This routine is used for host to device control transfers
1847:           *					(uses OUT transactions).  This function receives the data that arrives
1848:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1849:           *					buffer.  Once the host has sent all the data it was intending
1850:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1851:           *					handler (unless it is NULL), so that it can be used by the
1852:           *					intended target firmware.
1853:           *
1854:           * Note:            None
1855:           *****************************************************************************/
1856:          static void USBCtrlTrfRxService(void)
1857:          {
1858:              uint8_t byteToRead;
1859:              uint8_t i;
1860:          
1861:              //Load byteToRead with the number of bytes the host just sent us in the
1862:              //last OUT transaction.
1863:              byteToRead = pBDTEntryEP0OutCurrent->CNT;
0EAC  0021     MOVLB 0x1
0EAD  0854     MOVF pBDTEntryEP0OutCurrent, W
0EAE  0086     MOVWF FSR1L
0EAF  0187     CLRF FSR1H
0EB0  3F41     MOVIW 1[FSR1]
0EB1  00F5     MOVWF 0xF5
1864:          
1865:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1866:              //of remaining bytes expected to be received from the host, in the control
1867:              //transfer.  First check to see if the host sent us more bytes than the
1868:              //application firmware was expecting to receive.
1869:              if(byteToRead > outPipes[0].wCount.Val)
0EB2  0875     MOVF 0xF5, W
0EB3  00F2     MOVWF 0xF2
0EB4  01F3     CLRF 0xF3
0EB5  0873     MOVF 0xF3, W
0EB6  0022     MOVLB 0x2
0EB7  0224     SUBWF 0x124, W
0EB8  1D03     BTFSS STATUS, 0x2
0EB9  2EBC     GOTO 0x6BC
0EBA  0872     MOVF 0x172, W
0EBB  0223     SUBWF 0x123, W
0EBC  1803     BTFSC STATUS, 0x0
0EBD  2EBF     GOTO 0x6BF
0EBE  2EC0     GOTO 0x6C0
0EBF  2EC4     GOTO 0x6C4
1870:              {
1871:                  byteToRead = (uint8_t)(outPipes[0].wCount.Val);
0EC0  0823     MOVF 0x123, W
0EC1  00F2     MOVWF 0x172
0EC2  0872     MOVF 0x172, W
0EC3  00F5     MOVWF 0x175
1872:              }
1873:              //Reduce the number of remaining bytes by the number we just received.
1874:              outPipes[0].wCount.Val -= byteToRead;
0EC4  0875     MOVF 0x175, W
0EC5  00F2     MOVWF 0x172
0EC6  01F3     CLRF 0x173
0EC7  0872     MOVF 0x172, W
0EC8  02A3     SUBWF 0x123, F
0EC9  0873     MOVF 0x173, W
0ECA  3BA4     SUBWFB 0x124, F
1875:          
1876:              //Copy the OUT DATAx packet bytes that we just received from the host,
1877:              //into the user application buffer space.
1878:              for(i=0;i<byteToRead;i++)
0ECB  01F4     CLRF 0x174
0ECC  2EE0     GOTO 0x6E0
1879:              {
1880:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
0ECD  0874     MOVF 0x174, W
0ECE  3E68     ADDLW 0x68
0ECF  0086     MOVWF FSR1L
0ED0  0187     CLRF FSR1H
0ED1  0801     MOVF INDF1, W
0ED2  00F2     MOVWF 0x172
0ED3  0820     MOVF outPipes, W
0ED4  0086     MOVWF FSR1L
0ED5  0187     CLRF FSR1H
0ED6  0872     MOVF 0x172, W
0ED7  0081     MOVWF INDF1
0ED8  3001     MOVLW 0x1
0ED9  00F2     MOVWF 0x172
0EDA  0872     MOVF 0x172, W
0EDB  07A0     ADDWF outPipes, F
1881:              }//end while(byteToRead.Val)
0EDC  3001     MOVLW 0x1
0EDD  00F2     MOVWF 0x172
0EDE  0872     MOVF 0x172, W
0EDF  07F4     ADDWF 0x174, F
0EE0  0875     MOVF 0x175, W
0EE1  0274     SUBWF 0x174, W
0EE2  1C03     BTFSS STATUS, 0x0
0EE3  2EE5     GOTO 0x6E5
0EE4  2EE6     GOTO 0x6E6
0EE5  2ECD     GOTO 0x6CD
1882:          
1883:              //If there is more data to receive, prepare EP0 OUT so that it can receive
1884:          	//the next packet in the sequence.
1885:              if(outPipes[0].wCount.Val > 0)
0EE6  0823     MOVF 0x123, W
0EE7  0424     IORWF 0x124, W
0EE8  1903     BTFSC STATUS, 0x2
0EE9  2EEB     GOTO 0x6EB
0EEA  2EEC     GOTO 0x6EC
0EEB  2F25     GOTO 0x725
1886:              {
1887:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0EEC  0021     MOVLB 0x1
0EED  0843     MOVF pBDTEntryEP0OutNext, W
0EEE  3E01     ADDLW 0x1
0EEF  00F2     MOVWF 0xF2
0EF0  3000     MOVLW 0x0
0EF1  3D44     ADDWFC 0xC4, W
0EF2  00F3     MOVWF 0xF3
0EF3  0872     MOVF 0xF2, W
0EF4  0086     MOVWF FSR1L
0EF5  0873     MOVF 0xF3, W
0EF6  0087     MOVWF FSR1H
0EF7  3008     MOVLW 0x8
0EF8  0081     MOVWF INDF1
1888:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0EF9  3068     MOVLW 0x68
0EFA  00F2     MOVWF 0xF2
0EFB  3000     MOVLW 0x0
0EFC  00F3     MOVWF 0xF3
0EFD  0843     MOVF pBDTEntryEP0OutNext, W
0EFE  0086     MOVWF FSR1L
0EFF  0844     MOVF 0xC4, W
0F00  0087     MOVWF FSR1H
0F01  3142     ADDFSR 1, 2
0F02  0872     MOVF 0xF2, W
0F03  3FC0     MOVWI 0[FSR1]
0F04  0873     MOVF 0xF3, W
0F05  3FC1     MOVWI 1[FSR1]
1889:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
0F06  0854     MOVF pBDTEntryEP0OutCurrent, W
0F07  0086     MOVWF FSR1L
0F08  0187     CLRF FSR1H
0F09  1B01     BTFSC INDF1, 0x6
0F0A  2F0C     GOTO 0x70C
0F0B  2F0D     GOTO 0x70D
0F0C  2F19     GOTO 0x719
1890:                  {
1891:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0F0D  0843     MOVF pBDTEntryEP0OutNext, W
0F0E  0086     MOVWF FSR1L
0F0F  0844     MOVF 0xC4, W
0F10  0087     MOVWF FSR1H
0F11  3048     MOVLW 0x48
0F12  0081     MOVWF INDF1
1892:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0F13  0843     MOVF pBDTEntryEP0OutNext, W
0F14  0086     MOVWF FSR1L
0F15  0844     MOVF 0xC4, W
0F16  0087     MOVWF FSR1H
0F17  1781     BSF INDF1, 0x7
1893:                  }
0F18  2F55     GOTO 0x755
1894:                  else
1895:                  {
1896:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0F19  0843     MOVF pBDTEntryEP0OutNext, W
0F1A  0086     MOVWF FSR1L
0F1B  0844     MOVF 0xC4, W
0F1C  0087     MOVWF FSR1H
0F1D  3008     MOVLW 0x8
0F1E  0081     MOVWF INDF1
1897:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0F1F  0843     MOVF pBDTEntryEP0OutNext, W
0F20  0086     MOVWF FSR1L
0F21  0844     MOVF 0xC4, W
0F22  0087     MOVWF FSR1H
0F23  1781     BSF INDF1, 0x7
0F24  2F55     GOTO 0x755
1898:                  }
1899:              }
1900:              else
1901:              {
1902:          	    //We have received all OUT packets that we were expecting to
1903:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1904:          		//the next SETUP transaction that may arrive.
1905:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0F25  0021     MOVLB 0x1
0F26  0843     MOVF pBDTEntryEP0OutNext, W
0F27  3E01     ADDLW 0x1
0F28  00F2     MOVWF 0xF2
0F29  3000     MOVLW 0x0
0F2A  3D44     ADDWFC 0xC4, W
0F2B  00F3     MOVWF 0xF3
0F2C  0872     MOVF 0xF2, W
0F2D  0086     MOVWF FSR1L
0F2E  0873     MOVF 0xF3, W
0F2F  0087     MOVWF FSR1H
0F30  3008     MOVLW 0x8
0F31  0081     MOVWF INDF1
1906:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0F32  3060     MOVLW 0x60
0F33  00F2     MOVWF 0xF2
0F34  3000     MOVLW 0x0
0F35  00F3     MOVWF 0xF3
0F36  0843     MOVF pBDTEntryEP0OutNext, W
0F37  0086     MOVWF FSR1L
0F38  0844     MOVF 0xC4, W
0F39  0087     MOVWF FSR1H
0F3A  3142     ADDFSR 1, 2
0F3B  0872     MOVF 0xF2, W
0F3C  3FC0     MOVWI 0[FSR1]
0F3D  0873     MOVF 0xF3, W
0F3E  3FC1     MOVWI 1[FSR1]
1907:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1908:                  //control transfers.  However, set BSTALL in case the host tries to send
1909:                  //more data than it claims it was going to send.
1910:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0F3F  0843     MOVF pBDTEntryEP0OutNext, W
0F40  0086     MOVWF FSR1L
0F41  0844     MOVF 0xC4, W
0F42  0087     MOVWF FSR1H
0F43  3004     MOVLW 0x4
0F44  0081     MOVWF INDF1
1911:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0F45  0843     MOVF pBDTEntryEP0OutNext, W
0F46  0086     MOVWF FSR1L
0F47  0844     MOVF 0xC4, W
0F48  0087     MOVWF FSR1H
0F49  1781     BSF INDF1, 0x7
1912:          
1913:          		//All data bytes for the host to device control write (OUT) have now been
1914:          		//received successfully.
1915:          		//Go ahead and call the user specified callback function, to use/consume
1916:          		//the control transfer data (ex: if the "void (*function)" parameter
1917:          		//was non-NULL when USBEP0Receive() was called).
1918:                  if(outPipes[0].pFunc != NULL)
1919:                  {
1920:                      #if defined(__XC8)
1921:                          //Special pragmas to suppress an expected/harmless warning
1922:                          //message when building with the XC8 compiler
1923:                          #pragma warning push
1924:                          #pragma warning disable 1088
1925:                          outPipes[0].pFunc();    //Call the user's callback function
1926:                          #pragma warning pop
1927:                      #else
1928:                          outPipes[0].pFunc();    //Call the user's callback function
1929:                      #endif
1930:                  }
1931:                  outPipes[0].info.bits.busy = 0;
0F4A  0022     MOVLB 0x2
0F4B  13A2     BCF 0x122, 0x7
1932:          
1933:                  //Ready to arm status stage IN transaction now, if the application
1934:                  //firmware has completed processing the request.  If it is still busy
1935:                  //and needs more time to finish handling the request, then the user
1936:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1937:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1938:                  //this case, it is the application's firmware responsibility to call
1939:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1940:                  //Note: The application firmware must process the request and call
1941:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1942:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1943:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1944:                  //more details.
1945:                  if(USBDeferStatusStagePacket == false)
0F4C  0021     MOVLB 0x1
0F4D  084B     MOVF USBDeferStatusStagePacket, W
0F4E  1D03     BTFSS STATUS, 0x2
0F4F  2F51     GOTO 0x751
0F50  2F52     GOTO 0x752
0F51  2F55     GOTO 0x755
1946:                  {
1947:                      USBCtrlEPAllowStatusStage();
0F52  318A     MOVLP 0xA
0F53  22A3     CALL 0x2A3
0F54  318E     MOVLP 0xE
1948:                  }
1949:              }
1950:          
1951:          }//end USBCtrlTrfRxService
0F55  0008     RETURN
1952:          
1953:          
1954:          /********************************************************************
1955:           * Function:        void USBStdSetCfgHandler(void)
1956:           *
1957:           * PreCondition:    None
1958:           *
1959:           * Input:           None
1960:           *
1961:           * Output:          None
1962:           *
1963:           * Side Effects:    None
1964:           *
1965:           * Overview:        This routine first disables all endpoints by
1966:           *                  clearing UEP registers. It then configures
1967:           *                  (initializes) endpoints by calling the callback
1968:           *                  function USBCBInitEP().
1969:           *
1970:           * Note:            None
1971:           *******************************************************************/
1972:          static void USBStdSetCfgHandler(void)
1973:          {
1974:              uint8_t i;
1975:          
1976:              // This will generate a zero length packet
1977:              inPipes[0].info.bits.busy = 1;
0D03  0021     MOVLB 0x1
0D04  17BA     BSF 0xBA, 0x7
1978:          
1979:              //Clear all of the endpoint control registers
1980:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0D05  300E     MOVLW 0xE
0D06  00E1     MOVWF pUEP
0D07  3099     MOVLW 0x99
0D08  00E0     MOVWF p
0D09  01E2     CLRF i
0D0A  0860     MOVF p, W
0D0B  0086     MOVWF FSR1L
0D0C  0861     MOVF pUEP, W
0D0D  0087     MOVWF FSR1H
0D0E  0181     CLRF INDF1
0D0F  3001     MOVLW 0x1
0D10  07E0     ADDWF p, F
0D11  3000     MOVLW 0x0
0D12  3DE1     ADDWFC pUEP, F
0D13  3001     MOVLW 0x1
0D14  00DF     MOVWF 0xDF
0D15  085F     MOVF 0xDF, W
0D16  07E2     ADDWF i, F
0D17  3003     MOVLW 0x3
0D18  0262     SUBWF i, W
0D19  1C03     BTFSS STATUS, 0x0
0D1A  2D1C     GOTO 0x51C
0D1B  2D1D     GOTO 0x51D
0D1C  2D0A     GOTO 0x50A
1981:          
1982:              //Clear all of the BDT entries
1983:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
0D1D  3020     MOVLW 0x20
0D1E  00F0     MOVWF 0xF0
0D1F  3000     MOVLW 0x0
0D20  00F1     MOVWF 0xF1
0D21  3000     MOVLW 0x0
0D22  00F2     MOVWF 0xF2
0D23  00F3     MOVWF 0xF3
0D24  3040     MOVLW 0x40
0D25  00F4     MOVWF 0xF4
0D26  3000     MOVLW 0x0
0D27  00F5     MOVWF 0xF5
0D28  3186     MOVLP 0x6
0D29  26F2     CALL 0x6F2
0D2A  318D     MOVLP 0xD
1984:          
1985:              // Assert reset request to all of the Ping Pong buffer pointers
1986:              USBPingPongBufferReset = 1;
0D2B  003D     MOVLB 0x1D
0D2C  170E     BSF UCON, 0x6
1987:          
1988:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1989:          	//the EVEN buffer being the next one that will be used), since we are also
1990:          	//doing a hardware ping pong pointer reset above.
1991:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0D2D  0021     MOVLB 0x1
0D2E  01E3     CLRF i
1992:          	{
1993:          		ep_data_in[i].Val = 0u;
0D2F  0863     MOVF i, W
0D30  3EB0     ADDLW 0xB0
0D31  0086     MOVWF FSR1L
0D32  3001     MOVLW 0x1
0D33  0087     MOVWF FSR1H
0D34  0181     CLRF INDF1
1994:                  ep_data_out[i].Val = 0u;
0D35  0863     MOVF i, W
0D36  3EAC     ADDLW 0xAC
0D37  0086     MOVWF FSR1L
0D38  3001     MOVLW 0x1
0D39  0087     MOVWF FSR1H
0D3A  0181     CLRF INDF1
1995:          	}
0D3B  3001     MOVLW 0x1
0D3C  00DF     MOVWF 0xDF
0D3D  085F     MOVF 0xDF, W
0D3E  07E3     ADDWF i, F
0D3F  3004     MOVLW 0x4
0D40  0263     SUBWF i, W
0D41  1C03     BTFSS STATUS, 0x0
0D42  2D44     GOTO 0x544
0D43  2D45     GOTO 0x545
0D44  2D2F     GOTO 0x52F
1996:          
1997:              //clear the alternate interface settings
1998:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0D45  30BB     MOVLW 0xBB
0D46  00F0     MOVWF 0xF0
0D47  3001     MOVLW 0x1
0D48  00F1     MOVWF 0xF1
0D49  3000     MOVLW 0x0
0D4A  00F2     MOVWF 0xF2
0D4B  00F3     MOVWF 0xF3
0D4C  3003     MOVLW 0x3
0D4D  00F4     MOVWF 0xF4
0D4E  3000     MOVLW 0x0
0D4F  00F5     MOVWF 0xF5
0D50  3186     MOVLP 0x6
0D51  26F2     CALL 0x6F2
0D52  318D     MOVLP 0xD
1999:          
2000:              //Stop trying to reset ping pong buffer pointers
2001:              USBPingPongBufferReset = 0;
0D53  003D     MOVLB 0x1D
0D54  130E     BCF UCON, 0x6
2002:          
2003:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0D55  3028     MOVLW 0x28
0D56  0021     MOVLB 0x1
0D57  00B0     MOVWF pBDTEntryIn
0D58  3000     MOVLW 0x0
0D59  00B1     MOVWF 0xB1
2004:          
2005:          	//Set the next out to the current out packet
2006:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0D5A  3020     MOVLW 0x20
0D5B  00DF     MOVWF 0xDF
0D5C  085F     MOVF 0xDF, W
0D5D  00D4     MOVWF pBDTEntryEP0OutCurrent
2007:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0D5E  0854     MOVF pBDTEntryEP0OutCurrent, W
0D5F  00C3     MOVWF pBDTEntryEP0OutNext
0D60  39FF     ANDLW 0xFF
0D61  1D03     BTFSS STATUS, 0x2
0D62  3000     MOVLW 0x0
0D63  00C4     MOVWF 0xC4
2008:          
2009:              //set the current configuration
2010:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0D64  0020     MOVLB 0x0
0D65  0862     MOVF 0x62, W
0D66  0021     MOVLB 0x1
0D67  00DF     MOVWF 0xDF
0D68  085F     MOVF 0xDF, W
0D69  00D8     MOVWF USBActiveConfiguration
2011:          
2012:              //if the configuration value == 0
2013:              if(USBActiveConfiguration == 0)
0D6A  0858     MOVF USBActiveConfiguration, W
0D6B  1D03     BTFSS STATUS, 0x2
0D6C  2D6E     GOTO 0x56E
0D6D  2D6F     GOTO 0x56F
0D6E  2D74     GOTO 0x574
2014:              {
2015:                  //Go back to the addressed state
2016:                  USBDeviceState = ADDRESS_STATE;
0D6F  3010     MOVLW 0x10
0D70  00DF     MOVWF 0xDF
0D71  085F     MOVF 0xDF, W
0D72  00D5     MOVWF USBDeviceState
2017:              }
0D73  2D88     GOTO 0x588
2018:              else
2019:              {
2020:                  //initialize the required endpoints
2021:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0D74  3001     MOVLW 0x1
0D75  00D9     MOVWF __pcstackBANK1
0D76  3000     MOVLW 0x0
0D77  00DA     MOVWF 0xDA
0D78  30D8     MOVLW 0xD8
0D79  00DB     MOVWF pdata
0D7A  3000     MOVLW 0x0
0D7B  00DC     MOVWF 0xDC
0D7C  3001     MOVLW 0x1
0D7D  00DD     MOVWF size
0D7E  3000     MOVLW 0x0
0D7F  00DE     MOVWF 0xDE
0D80  3188     MOVLP 0x8
0D81  2092     CALL 0x92
0D82  318D     MOVLP 0xD
2022:          
2023:                  //Otherwise go to the configured state.  Update the state variable last,
2024:                  //after performing all of the set configuration related initialization
2025:                  //tasks.
2026:                  USBDeviceState = CONFIGURED_STATE;
0D83  3020     MOVLW 0x20
0D84  0021     MOVLB 0x1
0D85  00DF     MOVWF 0xDF
0D86  085F     MOVF 0xDF, W
0D87  00D5     MOVWF USBDeviceState
2027:              }//end if(SetupPkt.bConfigurationValue == 0)
2028:          }//end USBStdSetCfgHandler
0D88  0008     RETURN
2029:          
2030:          
2031:          /********************************************************************
2032:           * Function:        void USBStdGetDscHandler(void)
2033:           *
2034:           * PreCondition:    None
2035:           *
2036:           * Input:           None
2037:           *
2038:           * Output:          None
2039:           *
2040:           * Side Effects:    None
2041:           *
2042:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2043:           *                  request.
2044:           *
2045:           * Note:            None
2046:           *******************************************************************/
2047:          static void USBStdGetDscHandler(void)
2048:          {
2049:              if(SetupPkt.bmRequestType == 0x80)
0C7E  3080     MOVLW 0x80
0C7F  0020     MOVLB 0x0
0C80  0660     XORWF SetupPkt, W
0C81  1D03     BTFSS STATUS, 0x2
0C82  2C84     GOTO 0x484
0C83  2C85     GOTO 0x485
0C84  2D02     GOTO 0x502
2050:              {
2051:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0C85  30C0     MOVLW 0xC0
0C86  00F0     MOVWF __pcstackCOMMON
0C87  0870     MOVF __pcstackCOMMON, W
0C88  0021     MOVLB 0x1
0C89  00BA     MOVWF 0xBA
2052:          
2053:                  switch(SetupPkt.bDescriptorType)
0C8A  2CEE     GOTO 0x4EE
2054:                  {
2055:                      case USB_DESCRIPTOR_DEVICE:
2056:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2057:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2058:                          #else
2059:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0C8B  304E     MOVLW 0x4E
0C8C  0021     MOVLB 0x1
0C8D  00B8     MOVWF inPipes
0C8E  3098     MOVLW 0x98
0C8F  00B9     MOVWF 0xB9
2060:                          #endif
2061:                          inPipes[0].wCount.Val = sizeof(device_dsc);
0C90  3012     MOVLW 0x12
0C91  00BB     MOVWF 0xBB
0C92  3000     MOVLW 0x0
0C93  00BC     MOVWF 0xBC
2062:                          break;
0C94  2D02     GOTO 0x502
2063:                      case USB_DESCRIPTOR_CONFIGURATION:
2064:                          //First perform error case check, to make sure the host is requesting a
2065:                          //legal descriptor index.  If the request index is illegal, don't do
2066:                          //anything (so that the default STALL response will be sent).
2067:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0C95  0862     MOVF i, W
0C96  1D03     BTFSS STATUS, 0x2
0C97  2C99     GOTO 0x499
0C98  2C9A     GOTO 0x49A
0C99  2CC9     GOTO 0x4C9
2068:                          {
2069:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2070:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2071:                              #else
2072:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0C9A  0862     MOVF i, W
0C9B  00F0     MOVWF 0xF0
0C9C  01F1     CLRF 0xF1
0C9D  35F0     LSLF 0xF0, F
0C9E  0DF1     RLF 0xF1, F
0C9F  306A     MOVLW 0x6A
0CA0  0770     ADDWF 0xF0, W
0CA1  0084     MOVWF FSR0L
0CA2  3098     MOVLW 0x98
0CA3  3D71     ADDWFC 0xF1, W
0CA4  0085     MOVWF FSR0H
0CA5  3F00     MOVIW 0[FSR0]
0CA6  0021     MOVLB 0x1
0CA7  00B8     MOVWF inPipes
0CA8  3F01     MOVIW 1[FSR0]
0CA9  00B9     MOVWF 0xB9
2073:                              #endif
2074:          
2075:                              //This must be loaded using byte addressing.  The source pointer
2076:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2077:                              //  in an address error on the dereference.
2078:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0CAA  0839     MOVF 0xB9, W
0CAB  00F1     MOVWF 0xF1
0CAC  0838     MOVF inPipes, W
0CAD  00F0     MOVWF 0xF0
0CAE  3002     MOVLW 0x2
0CAF  0770     ADDWF 0xF0, W
0CB0  0084     MOVWF FSR0L
0CB1  0871     MOVF 0xF1, W
0CB2  1803     BTFSC STATUS, 0x0
0CB3  0A71     INCF 0xF1, W
0CB4  0085     MOVWF FSR0H
0CB5  0800     MOVF INDF0, W
0CB6  00F2     MOVWF 0xF2
0CB7  0872     MOVF 0xF2, W
0CB8  00BB     MOVWF 0xBB
2079:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0CB9  0839     MOVF 0xB9, W
0CBA  00F1     MOVWF 0xF1
0CBB  0838     MOVF inPipes, W
0CBC  00F0     MOVWF 0xF0
0CBD  3003     MOVLW 0x3
0CBE  0770     ADDWF 0xF0, W
0CBF  0084     MOVWF FSR0L
0CC0  0871     MOVF 0xF1, W
0CC1  1803     BTFSC STATUS, 0x0
0CC2  0A71     INCF 0xF1, W
0CC3  0085     MOVWF FSR0H
0CC4  0800     MOVF INDF0, W
0CC5  00F2     MOVWF 0xF2
0CC6  0872     MOVF 0xF2, W
0CC7  00BC     MOVWF 0xBC
2080:                          }
0CC8  2D02     GOTO 0x502
2081:          				else
2082:          				{
2083:          					inPipes[0].info.Val = 0;
0CC9  0021     MOVLB 0x1
0CCA  01BA     CLRF 0xBA
0CCB  2D02     GOTO 0x502
2084:          				}
2085:                          break;
2086:                      case USB_DESCRIPTOR_STRING:
2087:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2088:                          //  later it is now mandatory.  This should be defined in usb_config.h and should
2089:                          //  indicate the number of string descriptors.
2090:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0CCC  3003     MOVLW 0x3
0CCD  0262     SUBWF i, W
0CCE  1803     BTFSC STATUS, 0x0
0CCF  2CD1     GOTO 0x4D1
0CD0  2CD2     GOTO 0x4D2
0CD1  2CC9     GOTO 0x4C9
2091:                          {
2092:                              //Get a pointer to the String descriptor requested
2093:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0CD2  0862     MOVF i, W
0CD3  00F0     MOVWF 0xF0
0CD4  01F1     CLRF 0xF1
0CD5  35F0     LSLF 0xF0, F
0CD6  0DF1     RLF 0xF1, F
0CD7  3060     MOVLW 0x60
0CD8  0770     ADDWF 0xF0, W
0CD9  0084     MOVWF FSR0L
0CDA  3098     MOVLW 0x98
0CDB  3D71     ADDWFC 0xF1, W
0CDC  0085     MOVWF FSR0H
0CDD  3F00     MOVIW 0[FSR0]
0CDE  0021     MOVLB 0x1
0CDF  00B8     MOVWF inPipes
0CE0  3F01     MOVIW 1[FSR0]
0CE1  00B9     MOVWF 0xB9
2094:                              // Set data count
2095:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
0CE2  0838     MOVF inPipes, W
0CE3  0084     MOVWF FSR0L
0CE4  0839     MOVF 0xB9, W
0CE5  0085     MOVWF FSR0H
0CE6  0800     MOVF INDF0, W
0CE7  00F0     MOVWF 0xF0
0CE8  01F1     CLRF 0xF1
0CE9  0870     MOVF 0xF0, W
0CEA  00BB     MOVWF 0xBB
0CEB  0871     MOVF 0xF1, W
0CEC  00BC     MOVWF 0xBC
2096:                          }
0CED  2D02     GOTO 0x502
2097:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2098:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2099:                          {
2100:                              //Get a pointer to the special MS OS string descriptor requested
2101:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2102:                              // Set data count
2103:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
2104:                          }
2105:                          #endif
2106:                          else
2107:                          {
2108:                              inPipes[0].info.Val = 0;
2109:                          }
2110:                          break;
2111:                      default:
2112:                          inPipes[0].info.Val = 0;
2113:                          break;
2114:                  }//end switch
0CEE  0020     MOVLB 0x0
0CEF  0863     MOVF 0x63, W
0CF0  00F0     MOVWF __pcstackCOMMON
0CF1  01F1     CLRF p
0CF2  0871     MOVF p, W
0CF3  3A00     XORLW 0x0
0CF4  1903     BTFSC STATUS, 0x2
0CF5  2CF7     GOTO 0x4F7
0CF6  2CC9     GOTO 0x4C9
0CF7  0870     MOVF __pcstackCOMMON, W
0CF8  3A01     XORLW 0x1
0CF9  1903     BTFSC STATUS, 0x2
0CFA  2C8B     GOTO 0x48B
0CFB  3A03     XORLW 0x3
0CFC  1903     BTFSC STATUS, 0x2
0CFD  2C95     GOTO 0x495
0CFE  3A01     XORLW 0x1
0CFF  1903     BTFSC STATUS, 0x2
0D00  2CCC     GOTO 0x4CC
0D01  2CC9     GOTO 0x4C9
2115:              }//end if
2116:          }//end USBStdGetDscHandler
0D02  0008     RETURN
2117:          
2118:          /********************************************************************
2119:           * Function:        void USBStdGetStatusHandler(void)
2120:           *
2121:           * PreCondition:    None
2122:           *
2123:           * Input:           None
2124:           *
2125:           * Output:          None
2126:           *
2127:           * Side Effects:    None
2128:           *
2129:           * Overview:        This routine handles the standard GET_STATUS request
2130:           *
2131:           * Note:            None
2132:           *******************************************************************/
2133:          static void USBStdGetStatusHandler(void)
2134:          {
2135:              CtrlTrfData[0] = 0;                 // Initialize content
0A36  0020     MOVLB 0x0
0A37  01E8     CLRF CtrlTrfData
2136:              CtrlTrfData[1] = 0;
0A38  01E9     CLRF 0x69
2137:          
2138:              switch(SetupPkt.Recipient)
0A39  2A80     GOTO 0x280
2139:              {
2140:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2141:                      inPipes[0].info.bits.busy = 1;
0A3A  0021     MOVLB 0x1
0A3B  17BA     BSF 0xBA, 0x7
2142:                      /*
2143:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2144:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2145:                       */
2146:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2147:                      {
2148:                          CtrlTrfData[0]|=0x01;
2149:                      }
2150:          
2151:                      if(RemoteWakeup == true)
0A3C  0350     DECF RemoteWakeup, W
0A3D  1D03     BTFSS STATUS, 0x2
0A3E  2A40     GOTO 0x240
0A3F  2A41     GOTO 0x241
0A40  2A94     GOTO 0x294
2152:                      {
2153:                          CtrlTrfData[0]|=0x02;
0A41  0020     MOVLB 0x0
0A42  14E8     BSF CtrlTrfData, 0x1
0A43  2A94     GOTO 0x294
2154:                      }
2155:                      break;
2156:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2157:                      inPipes[0].info.bits.busy = 1;     // No data to update
0A44  0021     MOVLB 0x1
0A45  17BA     BSF 0xBA, 0x7
2158:                      break;
0A46  2A94     GOTO 0x294
2159:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2160:                      inPipes[0].info.bits.busy = 1;
0A47  0021     MOVLB 0x1
0A48  17BA     BSF 0xBA, 0x7
2161:                      /*
2162:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2163:                       */
2164:                      if(SetupPkt.EPNum != 0)
0A49  0020     MOVLB 0x0
0A4A  0864     MOVF 0x64, W
0A4B  390F     ANDLW 0xF
0A4C  3A00     XORLW 0x0
0A4D  1903     BTFSC STATUS, 0x2
0A4E  2A50     GOTO 0x250
0A4F  2A51     GOTO 0x251
0A50  2A94     GOTO 0x294
2165:                      {
2166:                          BDT_ENTRY *p;
2167:          
2168:                          if(SetupPkt.EPDir == 0)
0A51  1BE4     BTFSC 0x64, 0x7
0A52  2A54     GOTO 0x254
0A53  2A55     GOTO 0x255
0A54  2A61     GOTO 0x261
2169:                          {
2170:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0A55  0864     MOVF 0x64, W
0A56  390F     ANDLW 0xF
0A57  0709     ADDWF WREG, W
0A58  3EA0     ADDLW 0xA0
0A59  0086     MOVWF FSR1
0A5A  3001     MOVLW 0x1
0A5B  0087     MOVWF FSR1H
0A5C  3F40     MOVIW 0[FSR1]
0A5D  00F2     MOVWF button
0A5E  3F41     MOVIW 1[FSR1]
0A5F  00F3     MOVWF i
2171:                          }
0A60  2A6B     GOTO 0x26B
2172:                          else
2173:                          {
2174:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0A61  0864     MOVF 0x64, W
0A62  390F     ANDLW 0xF
0A63  0709     ADDWF WREG, W
0A64  3EB0     ADDLW 0xB0
0A65  0086     MOVWF FSR1
0A66  0187     CLRF FSR1H
0A67  3F40     MOVIW 0[FSR1]
0A68  00F2     MOVWF button
0A69  3F41     MOVIW 1[FSR1]
0A6A  00F3     MOVWF i
2175:                          }
2176:          
2177:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
0A6B  0872     MOVF button, W
0A6C  0086     MOVWF FSR1
0A6D  0873     MOVF i, W
0A6E  0087     MOVWF FSR1H
0A6F  1F81     BTFSS INDF1, 0x7
0A70  2A72     GOTO 0x272
0A71  2A73     GOTO 0x273
0A72  2A94     GOTO 0x294
0A73  0872     MOVF button, W
0A74  0086     MOVWF FSR1
0A75  0873     MOVF i, W
0A76  0087     MOVWF FSR1H
0A77  1D01     BTFSS INDF1, 0x2
0A78  2A7A     GOTO 0x27A
0A79  2A7B     GOTO 0x27B
0A7A  2A94     GOTO 0x294
2178:                          {
2179:                              CtrlTrfData[0]=0x01;    // Set bit0
0A7B  3001     MOVLW 0x1
0A7C  00F0     MOVWF __pcstackCOMMON
0A7D  0870     MOVF __pcstackCOMMON, W
0A7E  00E8     MOVWF CtrlTrfData
0A7F  2A94     GOTO 0x294
2180:                          }
2181:                      }
2182:                      break;
2183:              }//end switch
0A80  0860     MOVF SetupPkt, W
0A81  391F     ANDLW 0x1F
0A82  00F0     MOVWF __pcstackCOMMON
0A83  01F1     CLRF p
0A84  0871     MOVF p, W
0A85  3A00     XORLW 0x0
0A86  1903     BTFSC STATUS, 0x2
0A87  2A89     GOTO 0x289
0A88  2A94     GOTO 0x294
0A89  0870     MOVF __pcstackCOMMON, W
0A8A  3A00     XORLW 0x0
0A8B  1903     BTFSC STATUS, 0x2
0A8C  2A3A     GOTO 0x23A
0A8D  3A01     XORLW 0x1
0A8E  1903     BTFSC STATUS, 0x2
0A8F  2A44     GOTO 0x244
0A90  3A03     XORLW 0x3
0A91  1903     BTFSC STATUS, 0x2
0A92  2A47     GOTO 0x247
0A93  2A94     GOTO 0x294
2184:          
2185:              if(inPipes[0].info.bits.busy == 1)
0A94  0021     MOVLB 0x1
0A95  1FBA     BTFSS 0xBA, 0x7
0A96  2A98     GOTO 0x298
0A97  2A99     GOTO 0x299
0A98  2AA2     GOTO 0x2A2
2186:              {
2187:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
0A99  3068     MOVLW 0x68
0A9A  00B8     MOVWF inPipes
0A9B  3000     MOVLW 0x0
0A9C  00B9     MOVWF 0xB9
2188:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
0A9D  143A     BSF 0xBA, 0x0
2189:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
0A9E  3002     MOVLW 0x2
0A9F  00F0     MOVWF 0xF0
0AA0  0870     MOVF 0xF0, W
0AA1  00BB     MOVWF 0xBB
2190:              }//end if(...)
2191:          }//end USBStdGetStatusHandler
0AA2  0008     RETURN
2192:          
2193:          /********************************************************************
2194:           * Function:        void USBStallHandler(void)
2195:           *
2196:           * PreCondition:    None
2197:           *
2198:           * Input:           None
2199:           *
2200:           * Output:          None
2201:           *
2202:           * Side Effects:
2203:           *
2204:           * Overview:        This function handles the event of a STALL
2205:           *                  occurring on the bus
2206:           *
2207:           * Note:            None
2208:           *******************************************************************/
2209:          static void USBStallHandler(void)
2210:          {
2211:              /*
2212:               * Does not really have to do anything here,
2213:               * even for the control endpoint.
2214:               * All BDs of Endpoint 0 are owned by SIE right now,
2215:               * but once a Setup Transaction is received, the ownership
2216:               * for EP0_OUT will be returned to CPU.
2217:               * When the Setup Transaction is serviced, the ownership
2218:               * for EP0_IN will then be forced back to CPU by firmware.
2219:               */
2220:          
2221:              if(U1EP0bits.EPSTALL == 1)
177A  003D     MOVLB 0x1D
177B  1C18     BTFSS UEP0, 0x0
177C  2F7E     GOTO 0x77E
177D  2F7F     GOTO 0x77F
177E  2FA0     GOTO 0x7A0
2222:              {
2223:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2224:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
177F  0021     MOVLB 0x1
1780  0854     MOVF pBDTEntryEP0OutCurrent, W
1781  0086     MOVWF FSR1L
1782  0187     CLRF FSR1H
1783  3080     MOVLW 0x80
1784  0601     XORWF INDF1, W
1785  1D03     BTFSS STATUS, 0x2
1786  2F88     GOTO 0x788
1787  2F89     GOTO 0x789
1788  2F9E     GOTO 0x79E
1789  0830     MOVF pBDTEntryIn, W
178A  0086     MOVWF FSR1L
178B  0831     MOVF 0xB1, W
178C  0087     MOVWF FSR1H
178D  3084     MOVLW 0x84
178E  0601     XORWF INDF1, W
178F  1D03     BTFSS STATUS, 0x2
1790  2F92     GOTO 0x792
1791  2F93     GOTO 0x793
1792  2F9E     GOTO 0x79E
2225:                  {
2226:                      // Set ep0Bo to stall also
2227:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1793  300C     MOVLW 0xC
1794  00F0     MOVWF 0xF0
1795  0854     MOVF pBDTEntryEP0OutCurrent, W
1796  0086     MOVWF FSR1L
1797  0187     CLRF FSR1H
1798  0870     MOVF 0xF0, W
1799  0081     MOVWF INDF1
2228:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
179A  0854     MOVF pBDTEntryEP0OutCurrent, W
179B  0086     MOVWF FSR1L
179C  0187     CLRF FSR1H
179D  1781     BSF INDF1, 0x7
2229:                  }//end if
2230:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
179E  003D     MOVLB 0x1D
179F  1018     BCF UEP0, 0x0
2231:              }//end if
2232:          
2233:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
17A0  30DF     MOVLW 0xDF
17A1  00F0     MOVWF 0xEF0
17A2  0870     MOVF 0xEF0, W
17A3  0590     ANDWF UIR, F
2234:          }
17A4  0008     RETURN
2235:          
2236:          /********************************************************************
2237:           * Function:        void USBSuspend(void)
2238:           *
2239:           * PreCondition:    None
2240:           *
2241:           * Input:           None
2242:           *
2243:           * Output:          None
2244:           *
2245:           * Side Effects:
2246:           *
2247:           * Overview:        This function handles if the host tries to
2248:           *                  suspend the device
2249:           *
2250:           * Note:            None
2251:           *******************************************************************/
2252:          static void USBSuspend(void)
2253:          {
2254:              /*
2255:               * NOTE: Do not clear UIRbits.ACTVIF here!
2256:               * Reason:
2257:               * ACTVIF is only generated once an IDLEIF has been generated.
2258:               * This is a 1:1 ratio interrupt generation.
2259:               * For every IDLEIF, there will be only one ACTVIF regardless of
2260:               * the number of subsequent bus transitions.
2261:               *
2262:               * If the ACTIF is cleared here, a problem could occur when:
2263:               * [       IDLE       ][bus activity ->
2264:               * <--- 3 ms ----->     ^
2265:               *                ^     ACTVIF=1
2266:               *                IDLEIF=1
2267:               *  #           #           #           #   (#=Program polling flags)
2268:               *                          ^
2269:               *                          This polling loop will see both
2270:               *                          IDLEIF=1 and ACTVIF=1.
2271:               *                          However, the program services IDLEIF first
2272:               *                          because ACTIVIE=0.
2273:               *                          If this routine clears the only ACTIVIF,
2274:               *                          then it can never get out of the suspend
2275:               *                          mode.
2276:               */
2277:              USBActivityIE = 1;                     // Enable bus activity interrupt
1696  003D     MOVLB 0x1D
1697  1512     BSF UIE, 0x2
2278:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1698  30EF     MOVLW 0xEF
1699  0021     MOVLB 0x1
169A  00DF     MOVWF 0xDF
169B  085F     MOVF 0xDF, W
169C  003D     MOVLB 0x1D
169D  0590     ANDWF UIR, F
2279:          
2280:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2281:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
169E  148E     BSF UCON, 0x1
2282:                                                          // mode, SIE clock inactive
2283:              #endif
2284:              USBBusIsSuspended = true;
169F  0021     MOVLB 0x1
16A0  01CF     CLRF USBBusIsSuspended
16A1  0ACF     INCF USBBusIsSuspended, F
2285:              USBTicksSinceSuspendEnd = 0;
16A2  01C6     CLRF USBTicksSinceSuspendEnd
2286:          
2287:              /*
2288:               * At this point the PIC can go into sleep,idle, or
2289:               * switch to a slower clock, etc.  This should be done in the
2290:               * USBCBSuspend() if necessary.
2291:               */
2292:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
16A3  3075     MOVLW 0x75
16A4  00D9     MOVWF __pcstackBANK1
16A5  3000     MOVLW 0x0
16A6  00DA     MOVWF 0xDA
16A7  3000     MOVLW 0x0
16A8  00DB     MOVWF pdata
16A9  3000     MOVLW 0x0
16AA  00DC     MOVWF 0xDC
16AB  3000     MOVLW 0x0
16AC  00DD     MOVWF size
16AD  00DE     MOVWF 0xDE
16AE  3188     MOVLP 0x8
16AF  2092     CALL 0x92
16B0  3196     MOVLP 0x16
2293:          }
16B1  0008     RETURN
2294:          
2295:          /********************************************************************
2296:           * Function:        void USBWakeFromSuspend(void)
2297:           *
2298:           * PreCondition:    None
2299:           *
2300:           * Input:           None
2301:           *
2302:           * Output:          None
2303:           *
2304:           * Side Effects:    None
2305:           *
2306:           * Overview:
2307:           *
2308:           * Note:            None
2309:           *******************************************************************/
2310:          static void USBWakeFromSuspend(void)
2311:          {
2312:              USBBusIsSuspended = false;
16F0  0021     MOVLB 0x1
16F1  01CF     CLRF USBBusIsSuspended
2313:          
2314:              /*
2315:               * If using clock switching, the place to restore the original
2316:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2317:               */
2318:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
16F2  3074     MOVLW 0x74
16F3  00D9     MOVWF __pcstackBANK1
16F4  3000     MOVLW 0x0
16F5  00DA     MOVWF 0xDA
16F6  3000     MOVLW 0x0
16F7  00DB     MOVWF pdata
16F8  3000     MOVLW 0x0
16F9  00DC     MOVWF 0xDC
16FA  3000     MOVLW 0x0
16FB  00DD     MOVWF size
16FC  00DE     MOVWF 0xDE
16FD  3188     MOVLP 0x8
16FE  2092     CALL 0x92
16FF  3196     MOVLP 0x16
2319:          
2320:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2321:                  //To avoid improperly clocking the USB module, make sure the oscillator
2322:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2323:                  //Make sure the correct oscillator settings are selected in the
2324:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2325:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
1700  003D     MOVLB 0x1D
1701  108E     BCF UCON, 0x1
2326:                                          // mode.
2327:              #endif
2328:          
2329:          
2330:              USBActivityIE = 0;
1702  1112     BCF UIE, 0x2
2331:          
2332:              /********************************************************************
2333:              Bug Fix: Feb 26, 2007 v2.1
2334:              *********************************************************************
2335:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2336:              up from Suspend or while the USB module is suspended. A few clock cycles
2337:              are required to synchronize the internal hardware state machine before
2338:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2339:              before the internal hardware is synchronized may not have an effect on
2340:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2341:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2342:              module may not be immediately operational while waiting for the 96 MHz
2343:              PLL to lock.
2344:              ********************************************************************/
2345:          
2346:              // UIRbits.ACTVIF = 0;                      // Removed
2347:              #if defined(__18CXX) || defined(__XC8)
2348:              while(USBActivityIF)
1703  2F0A     GOTO 0x70A
170A  1910     BTFSC UIR, 0x2
170B  2F0D     GOTO 0x70D
170C  2F0E     GOTO 0x70E
170D  2F04     GOTO 0x704
2349:              #endif
2350:              {
2351:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
1704  30FB     MOVLW 0xFB
1705  0021     MOVLB 0x1
1706  00DF     MOVWF 0xDF
1707  085F     MOVF 0xDF, W
1708  003D     MOVLB 0x1D
1709  0590     ANDWF UIR, F
2352:              }  // Added
2353:          
2354:              USBTicksSinceSuspendEnd = 0;
170E  0021     MOVLB 0x1
170F  01C6     CLRF USBTicksSinceSuspendEnd
2355:          
2356:          }//end USBWakeFromSuspend
1710  0008     RETURN
2357:          
2358:          /********************************************************************
2359:           * Function:        void USBCtrlEPService(void)
2360:           *
2361:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2362:           *
2363:           * Input:           None
2364:           *
2365:           * Output:          None
2366:           *
2367:           * Side Effects:    None
2368:           *
2369:           * Overview:        USBCtrlEPService checks for three transaction
2370:           *                  types that it knows how to service and services
2371:           *                  them:
2372:           *                  1. EP0 SETUP
2373:           *                  2. EP0 OUT
2374:           *                  3. EP0 IN
2375:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2376:           *
2377:           * Note:            None
2378:           *******************************************************************/
2379:          static void USBCtrlEPService(void)
2380:          {
2381:              //If we get to here, that means a successful transaction has just occurred
2382:              //on EP0.  This means "progress" has occurred in the currently pending
2383:              //control transfer, so we should re-initialize our timeout counter.
2384:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2385:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
0920  302D     MOVLW 0x2D
0921  0021     MOVLB 0x1
0922  00E9     MOVWF 0xE9
0923  0869     MOVF 0xE9, W
0924  00CC     MOVWF USBStatusStageTimeoutCounter
2386:              #endif
2387:          
2388:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2389:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
0925  0857     MOVF USTATcopy, W
0926  39FD     ANDLW 0xFD
0927  1D03     BTFSS STATUS, 0x2
0928  292A     GOTO 0x12A
0929  292B     GOTO 0x12B
092A  2967     GOTO 0x167
2390:              {
2391:          		//Point to the EP0 OUT buffer of the buffer that arrived
2392:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2393:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
092B  3657     LSRF USTATcopy, W
092C  393F     ANDLW 0x3F
092D  00E9     MOVWF 0xE9
092E  3001     MOVLW 0x1
092F  35E9     LSLF 0xE9, F
0930  3EFF     ADDLW 0xFF
0931  1D03     BTFSS STATUS, 0x2
0932  292F     GOTO 0x12F
0933  3569     LSLF 0xE9, W
0934  3E20     ADDLW 0x20
0935  00EA     MOVWF 0xEA
0936  086A     MOVF 0xEA, W
0937  00D4     MOVWF pBDTEntryEP0OutCurrent
2394:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2395:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2396:                  #else
2397:                      #error "unimplemented"
2398:                  #endif
2399:          
2400:          		//Set the next out to the current out packet
2401:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0938  0854     MOVF pBDTEntryEP0OutCurrent, W
0939  00C3     MOVWF pBDTEntryEP0OutNext
093A  39FF     ANDLW 0xFF
093B  1D03     BTFSS STATUS, 0x2
093C  3000     MOVLW 0x0
093D  00C4     MOVWF 0xC4
2402:          		//Toggle it to the next ping pong buffer (if applicable)
2403:                  pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
093E  3004     MOVLW 0x4
093F  0643     XORWF pBDTEntryEP0OutNext, W
0940  00C3     MOVWF pBDTEntryEP0OutNext
0941  3000     MOVLW 0x0
0942  0644     XORWF 0xC4, W
0943  00C4     MOVWF 0xC4
2404:          
2405:          		//If the current EP0 OUT buffer has a SETUP packet
2406:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
0944  0854     MOVF pBDTEntryEP0OutCurrent, W
0945  0086     MOVWF FSR1L
0946  0187     CLRF FSR1H
0947  0C01     RRF INDF1, W
0948  0C89     RRF WREG, F
0949  390F     ANDLW 0xF
094A  3A0D     XORLW 0xD
094B  1D03     BTFSS STATUS, 0x2
094C  294E     GOTO 0x14E
094D  294F     GOTO 0x14F
094E  2963     GOTO 0x163
2407:                  {
2408:          	        //The SETUP transaction data may have gone into the the CtrlTrfData
2409:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2410:          	        //before the transaction.  Therefore, we should copy the data to the
2411:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().
2412:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
094F  0854     MOVF pBDTEntryEP0OutCurrent, W
0950  3E02     ADDLW 0x2
0951  0086     MOVWF FSR1L
0952  0187     CLRF FSR1H
0953  3F40     MOVIW 0[FSR1]
0954  00F0     MOVWF 0xF0
0955  3F41     MOVIW 1[FSR1]
0956  00F1     MOVWF 0xF1
0957  3008     MOVLW 0x8
0958  00F2     MOVWF 0xF2
0959  3000     MOVLW 0x0
095A  00F3     MOVWF 0xF3
095B  3060     MOVLW 0x60
095C  3197     MOVLP 0x17
095D  27D2     CALL 0x7D2
095E  3189     MOVLP 0x9
2413:          
2414:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2415:                      USBCtrlTrfSetupHandler();
095F  3188     MOVLP 0x8
0960  20D8     CALL 0xD8
0961  3189     MOVLP 0x9
2416:                  }
0962  2973     GOTO 0x173
2417:                  else
2418:                  {
2419:          			//Handle the DATA transfer
2420:                      USBCtrlTrfOutHandler();
0963  3188     MOVLP 0x8
0964  205A     CALL 0x5A
0965  3189     MOVLP 0x9
0966  2973     GOTO 0x173
2421:                  }
2422:              }
2423:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
0967  30FD     MOVLW 0xFD
0968  0557     ANDWF USTATcopy, W
0969  00E9     MOVWF 0xE9
096A  3004     MOVLW 0x4
096B  0669     XORWF 0xE9, W
096C  1D03     BTFSS STATUS, 0x2
096D  296F     GOTO 0x16F
096E  2970     GOTO 0x170
096F  2973     GOTO 0x173
2424:              {
2425:          		//Otherwise the transmission was and EP0 IN
2426:          		//  so take care of the IN transfer
2427:                  USBCtrlTrfInHandler();
0970  318B     MOVLP 0xB
0971  238A     CALL 0x38A
0972  3189     MOVLP 0x9
2428:              }
2429:          
2430:          }//end USBCtrlEPService
0973  0008     RETURN
2431:          
2432:          /********************************************************************
2433:           * Function:        void USBCtrlTrfSetupHandler(void)
2434:           *
2435:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2436:           *
2437:           * Input:           None
2438:           *
2439:           * Output:          None
2440:           *
2441:           * Side Effects:    None
2442:           *
2443:           * Overview:        This routine is a task dispatcher and has 3 stages.
2444:           *                  1. It initializes the control transfer state machine.
2445:           *                  2. It calls on each of the module that may know how to
2446:           *                     service the Setup Request from the host.
2447:           *                     Module Example: USBD, HID, CDC, MSD, ...
2448:           *                     A callback function, USBCBCheckOtherReq(),
2449:           *                     is required to call other module handlers.
2450:           *                  3. Once each of the modules has had a chance to check if
2451:           *                     it is responsible for servicing the request, stage 3
2452:           *                     then checks direction of the transfer to determine how
2453:           *                     to prepare EP0 for the control transfer.
2454:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2455:           *
2456:           * Note:            Microchip USB Firmware has three different states for
2457:           *                  the control transfer state machine:
2458:           *                  1. WAIT_SETUP
2459:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2460:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2461:           *                  Refer to firmware manual to find out how one state
2462:           *                  is transitioned to another.
2463:           *
2464:           *                  A Control Transfer is composed of many USB transactions.
2465:           *                  When transferring data over multiple transactions,
2466:           *                  it is important to keep track of data source, data
2467:           *                  destination, and data count. These three parameters are
2468:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2469:           *                  note if the data source is from const or RAM.
2470:           *
2471:           *******************************************************************/
2472:          static void USBCtrlTrfSetupHandler(void)
2473:          {
2474:              //--------------------------------------------------------------------------
2475:              //1. Re-initialize state tracking variables related to control transfers.
2476:              //--------------------------------------------------------------------------
2477:              shortPacketStatus = SHORT_PKT_NOT_USED;
08D8  0021     MOVLB 0x1
08D9  01D3     CLRF shortPacketStatus
2478:              USBDeferStatusStagePacket = false;
08DA  01CB     CLRF USBDeferStatusStagePacket
2479:              USBDeferINDataStagePackets = false;
08DB  01C8     CLRF USBDeferINDataStagePackets
2480:              USBDeferOUTDataStagePackets = false;
08DC  01C7     CLRF USBDeferOUTDataStagePackets
2481:              BothEP0OutUOWNsSet = false;
08DD  01CD     CLRF BothEP0OutUOWNsSet
2482:              controlTransferState = WAIT_SETUP;
08DE  01D2     CLRF controlTransferState
2483:          
2484:              //Abandon any previous control transfers that might have been using EP0.
2485:              //Ordinarily, nothing actually needs abandoning, since the previous control
2486:              //transfer would have completed successfully prior to the host sending the next
2487:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2488:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2489:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2490:              //by the class request handler that will be called next.
2491:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
08DF  307F     MOVLW 0x7F
08E0  00E8     MOVWF 0xE8
08E1  0830     MOVF pBDTEntryIn, W
08E2  0086     MOVWF FSR1L
08E3  0831     MOVF 0xB1, W
08E4  0087     MOVWF FSR1H
08E5  0868     MOVF 0xE8, W
08E6  0581     ANDWF INDF1, F
2492:          
2493:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
08E7  3004     MOVLW 0x4
08E8  0630     XORWF pBDTEntryIn, W
08E9  00B0     MOVWF pBDTEntryIn
08EA  3000     MOVLW 0x0
08EB  0631     XORWF 0xB1, W
08EC  00B1     MOVWF 0xB1
2494:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
08ED  307F     MOVLW 0x7F
08EE  00E8     MOVWF 0xE8
08EF  0830     MOVF pBDTEntryIn, W
08F0  0086     MOVWF FSR1L
08F1  0831     MOVF 0xB1, W
08F2  0087     MOVWF FSR1H
08F3  0868     MOVF 0xE8, W
08F4  0581     ANDWF INDF1, F
2495:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
08F5  3004     MOVLW 0x4
08F6  0630     XORWF pBDTEntryIn, W
08F7  00B0     MOVWF pBDTEntryIn
08F8  3000     MOVLW 0x0
08F9  0631     XORWF 0xB1, W
08FA  00B1     MOVWF 0xB1
2496:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);
08FB  307F     MOVLW 0x7F
08FC  00E8     MOVWF 0xE8
08FD  0843     MOVF pBDTEntryEP0OutNext, W
08FE  0086     MOVWF FSR1L
08FF  0844     MOVF 0xC4, W
0900  0087     MOVWF FSR1H
0901  0868     MOVF 0xE8, W
0902  0581     ANDWF INDF1, F
2497:          
2498:              inPipes[0].info.Val = 0;
0903  01BA     CLRF 0xBA
2499:              inPipes[0].wCount.Val = 0;
0904  01BB     CLRF 0xBB
0905  01BC     CLRF 0xBC
2500:              outPipes[0].info.Val = 0;
0906  0022     MOVLB 0x2
0907  01A2     CLRF 0x122
2501:              outPipes[0].wCount.Val = 0;
0908  01A3     CLRF 0x123
0909  01A4     CLRF 0x124
2502:          
2503:          
2504:              //--------------------------------------------------------------------------
2505:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2506:              //--------------------------------------------------------------------------
2507:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
090A  318C     MOVLP 0xC
090B  2402     CALL 0x402
090C  3188     MOVLP 0x8
2508:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
090D  3003     MOVLW 0x3
090E  0021     MOVLB 0x1
090F  00D9     MOVWF __pcstackBANK1
0910  3000     MOVLW 0x0
0911  00DA     MOVWF 0xDA
0912  3000     MOVLW 0x0
0913  00DB     MOVWF pdata
0914  3000     MOVLW 0x0
0915  00DC     MOVWF 0xDC
0916  3000     MOVLW 0x0
0917  00DD     MOVWF size
0918  00DE     MOVWF 0xDE
0919  3188     MOVLP 0x8
091A  2092     CALL 0x92
091B  3188     MOVLP 0x8
2509:          
2510:          
2511:              //--------------------------------------------------------------------------
2512:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in
2513:              //   progress.  If one of the above handlers (in step 2) knew how to process
2514:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2515:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2516:              //   USBCtrlEPServiceComplete() function know how and which endpoints to
2517:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2518:              //   process the request.  In this case, the default behavior will be to
2519:              //   perform protocol STALL on EP0.
2520:              //--------------------------------------------------------------------------
2521:              USBCtrlEPServiceComplete();
091C  318E     MOVLP 0xE
091D  2610     CALL 0x610
091E  3188     MOVLP 0x8
2522:          }//end USBCtrlTrfSetupHandler
091F  0008     RETURN
2523:          
2524:          
2525:          /******************************************************************************
2526:           * Function:        void USBCtrlTrfOutHandler(void)
2527:           *
2528:           * PreCondition:    None
2529:           *
2530:           * Input:           None
2531:           *
2532:           * Output:          None
2533:           *
2534:           * Side Effects:    None
2535:           *
2536:           * Overview:        This routine handles an OUT transaction according to
2537:           *                  which control transfer state is currently active.
2538:           *
2539:           * Note:            Note that if the the control transfer was from
2540:           *                  host to device, the session owner should be notified
2541:           *                  at the end of each OUT transaction to service the
2542:           *                  received data.
2543:           *
2544:           *****************************************************************************/
2545:          static void USBCtrlTrfOutHandler(void)
2546:          {
2547:              if(controlTransferState == CTRL_TRF_RX)
085A  3002     MOVLW 0x2
085B  0021     MOVLB 0x1
085C  0652     XORWF controlTransferState, W
085D  1D03     BTFSS STATUS, 0x2
085E  2860     GOTO 0x60
085F  2861     GOTO 0x61
0860  2865     GOTO 0x65
2548:              {
2549:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
0861  318E     MOVLP 0xE
0862  26AC     CALL 0x6AC
0863  3188     MOVLP 0x8
2550:              }
0864  2891     GOTO 0x91
2551:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2552:              {
2553:                  //If the status stage is complete, this means we are done with the
2554:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2555:                  controlTransferState = WAIT_SETUP;
0865  01D2     CLRF controlTransferState
2556:          
2557:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2558:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2559:                  //and the last control transfer was of direction: device to host, see
2560:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2561:                  //to do anything to the BDT.
2562:                  if(BothEP0OutUOWNsSet == false)
0866  084D     MOVF BothEP0OutUOWNsSet, W
0867  1D03     BTFSS STATUS, 0x2
0868  286A     GOTO 0x6A
0869  286B     GOTO 0x6B
086A  2890     GOTO 0x90
2563:                  {
2564:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
086B  0843     MOVF pBDTEntryEP0OutNext, W
086C  3E01     ADDLW 0x1
086D  00F6     MOVWF 0xF6
086E  3000     MOVLW 0x0
086F  3D44     ADDWFC 0xC4, W
0870  00F7     MOVWF 0xF7
0871  0876     MOVF 0xF6, W
0872  0086     MOVWF FSR1L
0873  0877     MOVF 0xF7, W
0874  0087     MOVWF FSR1H
0875  3008     MOVLW 0x8
0876  0081     MOVWF INDF1
2565:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0877  3060     MOVLW 0x60
0878  00F6     MOVWF 0xF6
0879  3000     MOVLW 0x0
087A  00F7     MOVWF 0xF7
087B  0843     MOVF pBDTEntryEP0OutNext, W
087C  0086     MOVWF FSR1L
087D  0844     MOVF 0xC4, W
087E  0087     MOVWF FSR1H
087F  3142     ADDFSR 1, 2
0880  0876     MOVF 0xF6, W
0881  3FC0     MOVWI 0[FSR1]
0882  0877     MOVF 0xF7, W
0883  3FC1     MOVWI 1[FSR1]
2566:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0884  0843     MOVF pBDTEntryEP0OutNext, W
0885  0086     MOVWF FSR1L
0886  0844     MOVF 0xC4, W
0887  0087     MOVWF FSR1H
0888  300C     MOVLW 0xC
0889  0081     MOVWF INDF1
2567:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
088A  0843     MOVF pBDTEntryEP0OutNext, W
088B  0086     MOVWF FSR1L
088C  0844     MOVF 0xC4, W
088D  0087     MOVWF FSR1H
088E  1781     BSF INDF1, 0x7
2568:                  }
088F  2891     GOTO 0x91
2569:                  else
2570:                  {
2571:                      BothEP0OutUOWNsSet = false;
0890  01CD     CLRF BothEP0OutUOWNsSet
2572:                  }
2573:              }
2574:          }
0891  0008     RETURN
2575:          
2576:          /******************************************************************************
2577:           * Function:        void USBCtrlTrfInHandler(void)
2578:           *
2579:           * PreCondition:    None
2580:           *
2581:           * Input:           None
2582:           *
2583:           * Output:          None
2584:           *
2585:           * Side Effects:    None
2586:           *
2587:           * Overview:        This routine handles an IN transaction according to
2588:           *                  which control transfer state is currently active.
2589:           *
2590:           * Note:            A Set Address Request must not change the actual address
2591:           *                  of the device until the completion of the control
2592:           *                  transfer. The end of the control transfer for Set Address
2593:           *                  Request is an IN transaction. Therefore it is necessary
2594:           *                  to service this unique situation when the condition is
2595:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2596:           *                  usb9.h and its function is to specifically service this
2597:           *                  event.
2598:           *****************************************************************************/
2599:          static void USBCtrlTrfInHandler(void)
2600:          {
2601:              uint8_t lastDTS;
2602:          
2603:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
0B8A  0021     MOVLB 0x1
0B8B  0830     MOVF pBDTEntryIn, W
0B8C  0086     MOVWF FSR1L
0B8D  0831     MOVF 0xB1, W
0B8E  0087     MOVWF FSR1H
0B8F  3000     MOVLW 0x0
0B90  1B01     BTFSC INDF1, 0x6
0B91  3001     MOVLW 0x1
0B92  00F5     MOVWF 0xF5
2604:          
2605:              //switch to the next ping pong buffer
2606:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0B93  3004     MOVLW 0x4
0B94  0630     XORWF pBDTEntryIn, W
0B95  00B0     MOVWF pBDTEntryIn
0B96  3000     MOVLW 0x0
0B97  0631     XORWF 0xB1, W
0B98  00B1     MOVWF 0xB1
2607:          
2608:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2609:              //now, since the IN status stage of the (set address) control transfer has
2610:              //evidently completed successfully.
2611:              if(USBDeviceState == ADR_PENDING_STATE)
0B99  3008     MOVLW 0x8
0B9A  0655     XORWF USBDeviceState, W
0B9B  1D03     BTFSS STATUS, 0x2
0B9C  2B9E     GOTO 0x39E
0B9D  2B9F     GOTO 0x39F
0B9E  2BB4     GOTO 0x3B4
2612:              {
2613:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
0B9F  0020     MOVLB 0x0
0BA0  0862     MOVF 0x62, W
0BA1  397F     ANDLW 0x7F
0BA2  003D     MOVLB 0x1D
0BA3  0096     MOVWF UADDR
2614:                  if(U1ADDR != 0u)
0BA4  0816     MOVF UADDR, W
0BA5  1903     BTFSC STATUS, 0x2
0BA6  2BA8     GOTO 0x3A8
0BA7  2BA9     GOTO 0x3A9
0BA8  2BAF     GOTO 0x3AF
2615:                  {
2616:                      USBDeviceState=ADDRESS_STATE;
0BA9  3010     MOVLW 0x10
0BAA  00F3     MOVWF 0xEF3
0BAB  0873     MOVF 0xEF3, W
0BAC  0021     MOVLB 0x1
0BAD  00D5     MOVWF USBDeviceState
2617:                  }
0BAE  2BB4     GOTO 0x3B4
2618:                  else
2619:                  {
2620:                      USBDeviceState=DEFAULT_STATE;
0BAF  3004     MOVLW 0x4
0BB0  00F3     MOVWF 0xF3
0BB1  0873     MOVF 0xF3, W
0BB2  0021     MOVLB 0x1
0BB3  00D5     MOVWF USBDeviceState
2621:                  }
2622:              }//end if
2623:          
2624:          
2625:              if(controlTransferState == CTRL_TRF_TX)
0BB4  0352     DECF controlTransferState, W
0BB5  1D03     BTFSS STATUS, 0x2
0BB6  2BB8     GOTO 0x3B8
0BB7  2BB9     GOTO 0x3B9
0BB8  2BF9     GOTO 0x3F9
2626:              {
2627:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0BB9  3068     MOVLW 0x68
0BBA  00F3     MOVWF 0xF3
0BBB  3000     MOVLW 0x0
0BBC  00F4     MOVWF 0xF4
0BBD  0830     MOVF pBDTEntryIn, W
0BBE  0086     MOVWF FSR1L
0BBF  0831     MOVF 0xB1, W
0BC0  0087     MOVWF FSR1H
0BC1  3142     ADDFSR 1, 2
0BC2  0873     MOVF 0xF3, W
0BC3  3FC0     MOVWI 0[FSR1]
0BC4  0874     MOVF 0xF4, W
0BC5  3FC1     MOVWI 1[FSR1]
2628:                  USBCtrlTrfTxService();
0BC6  318B     MOVLP 0xB
0BC7  2315     CALL 0x315
0BC8  318B     MOVLP 0xB
2629:          
2630:                  //Check if we have already sent a short packet.  If so, configure
2631:                  //the endpoint to STALL in response to any further IN tokens (in the
2632:                  //case that the host erroneously tries to receive more data than it
2633:                  //should).
2634:                  if(shortPacketStatus == SHORT_PKT_SENT)
0BC9  3002     MOVLW 0x2
0BCA  0021     MOVLB 0x1
0BCB  0653     XORWF shortPacketStatus, W
0BCC  1D03     BTFSS STATUS, 0x2
0BCD  2BCF     GOTO 0x3CF
0BCE  2BD0     GOTO 0x3D0
0BCF  2BDC     GOTO 0x3DC
2635:                  {
2636:                      // If a short packet has been sent, don't want to send any more,
2637:                      // stall next time if host is still trying to read.
2638:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0BD0  0830     MOVF pBDTEntryIn, W
0BD1  0086     MOVWF FSR1L
0BD2  0831     MOVF 0xB1, W
0BD3  0087     MOVWF FSR1H
0BD4  3004     MOVLW 0x4
0BD5  0081     MOVWF INDF1
2639:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0BD6  0830     MOVF pBDTEntryIn, W
0BD7  0086     MOVWF FSR1L
0BD8  0831     MOVF 0xB1, W
0BD9  0087     MOVWF FSR1H
0BDA  1781     BSF INDF1, 0x7
2640:                  }
0BDB  2C01     GOTO 0x401
2641:                  else
2642:                  {
2643:                      if(lastDTS == 0)
0BDC  0875     MOVF 0xF5, W
0BDD  1D03     BTFSS STATUS, 0x2
0BDE  2BE0     GOTO 0x3E0
0BDF  2BE1     GOTO 0x3E1
0BE0  2BED     GOTO 0x3ED
2644:                      {
2645:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0BE1  0830     MOVF pBDTEntryIn, W
0BE2  0086     MOVWF FSR1L
0BE3  0831     MOVF 0xB1, W
0BE4  0087     MOVWF FSR1H
0BE5  3048     MOVLW 0x48
0BE6  0081     MOVWF INDF1
2646:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0BE7  0830     MOVF pBDTEntryIn, W
0BE8  0086     MOVWF FSR1L
0BE9  0831     MOVF 0xB1, W
0BEA  0087     MOVWF FSR1H
0BEB  1781     BSF INDF1, 0x7
2647:                      }
0BEC  2C01     GOTO 0x401
2648:                      else
2649:                      {
2650:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0BED  0830     MOVF pBDTEntryIn, W
0BEE  0086     MOVWF FSR1L
0BEF  0831     MOVF 0xB1, W
0BF0  0087     MOVWF FSR1H
0BF1  3008     MOVLW 0x8
0BF2  0081     MOVWF INDF1
2651:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0BF3  0830     MOVF pBDTEntryIn, W
0BF4  0086     MOVWF FSR1L
0BF5  0831     MOVF 0xB1, W
0BF6  0087     MOVWF FSR1H
0BF7  1781     BSF INDF1, 0x7
0BF8  2C01     GOTO 0x401
2652:                      }
2653:                  }//end if(...)else
2654:              }
2655:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2656:          	{
2657:                  //if someone is still expecting data from the control transfer
2658:                  //  then make sure to terminate that request and let them know that
2659:                  //  they are done
2660:                  if(outPipes[0].info.bits.busy == 1)
0BF9  0022     MOVLB 0x2
0BFA  1FA2     BTFSS 0x122, 0x7
0BFB  2BFD     GOTO 0x3FD
0BFC  2BFE     GOTO 0x3FE
0BFD  2BFF     GOTO 0x3FF
2661:                  {
2662:                      if(outPipes[0].pFunc != NULL)
2663:                      {
2664:                          outPipes[0].pFunc();
2665:                      }
2666:                      outPipes[0].info.bits.busy = 0;
0BFE  13A2     BCF 0x122, 0x7
2667:                  }
2668:          
2669:                  controlTransferState = WAIT_SETUP;
0BFF  0021     MOVLB 0x1
0C00  01D2     CLRF controlTransferState
2670:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2671:                  //got processed by the USBCtrlTrfRxService() handler.
2672:          	}
2673:          
2674:          }
0C01  0008     RETURN
2675:          
2676:          
2677:          /********************************************************************
2678:           * Function:        void USBCheckStdRequest(void)
2679:           *
2680:           * PreCondition:    None
2681:           *
2682:           * Input:           None
2683:           *
2684:           * Output:          None
2685:           *
2686:           * Side Effects:    None
2687:           *
2688:           * Overview:        This routine checks the setup data packet to see
2689:           *                  if it knows how to handle it
2690:           *
2691:           * Note:            None
2692:           *******************************************************************/
2693:          static void USBCheckStdRequest(void)
2694:          {
2695:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0C02  0020     MOVLB 0x0
0C03  0E60     SWAPF SetupPkt, W
0C04  0C89     RRF WREG, F
0C05  3903     ANDLW 0x3
0C06  3A00     XORLW 0x0
0C07  1903     BTFSC STATUS, 0x2
0C08  2C0A     GOTO 0x40A
0C09  2C0B     GOTO 0x40B
0C0A  2C51     GOTO 0x451
0C0B  2C7D     GOTO 0x47D
2696:          
2697:              switch(SetupPkt.bRequest)
2698:              {
2699:                  case USB_REQUEST_SET_ADDRESS:
2700:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
0C0C  17BA     BSF 0x3A, 0x7
2701:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
0C0D  3008     MOVLW 0x8
0C0E  00E6     MOVWF 0x66
0C0F  0866     MOVF 0x66, W
0C10  00D5     MOVWF 0x55
2702:                      /* See USBCtrlTrfInHandler() for the next step */
2703:                      break;
0C11  2C7D     GOTO 0x47D
2704:                  case USB_REQUEST_GET_DESCRIPTOR:
2705:                      USBStdGetDscHandler();
0C12  318C     MOVLP 0xC
0C13  247E     CALL 0x47E
0C14  318C     MOVLP 0xC
2706:                      break;
0C15  2C7D     GOTO 0x47D
2707:                  case USB_REQUEST_SET_CONFIGURATION:
2708:                      USBStdSetCfgHandler();
0C16  318D     MOVLP 0xD
0C17  2503     CALL 0x503
0C18  318C     MOVLP 0xC
2709:                      break;
0C19  2C7D     GOTO 0x47D
2710:                  case USB_REQUEST_GET_CONFIGURATION:
2711:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
0C1A  30D8     MOVLW 0xD8
0C1B  00B8     MOVWF 0x38
0C1C  3000     MOVLW 0x0
0C1D  00B9     MOVWF 0x39
2712:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0C1E  143A     BSF 0x3A, 0x0
2713:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0C1F  01BB     CLRF 0x3B
0C20  0ABB     INCF 0x3B, F
2714:                      inPipes[0].info.bits.busy = 1;
0C21  17BA     BSF 0x3A, 0x7
2715:                      break;
0C22  2C7D     GOTO 0x47D
2716:                  case USB_REQUEST_GET_STATUS:
2717:                      USBStdGetStatusHandler();
0C23  318A     MOVLP 0xA
0C24  2236     CALL 0x236
0C25  318C     MOVLP 0xC
2718:                      break;
0C26  2C7D     GOTO 0x47D
2719:                  case USB_REQUEST_CLEAR_FEATURE:
2720:                  case USB_REQUEST_SET_FEATURE:
2721:                      USBStdFeatureReqHandler();
0C27  3180     MOVLP 0x0
0C28  202F     CALL 0x2F
0C29  318C     MOVLP 0xC
2722:                      break;
0C2A  2C7D     GOTO 0x47D
2723:                  case USB_REQUEST_GET_INTERFACE:
2724:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
0C2B  0020     MOVLB 0x0
0C2C  0864     MOVF 0x64, W
0C2D  3EBB     ADDLW 0xBB
0C2E  0021     MOVLB 0x1
0C2F  00B8     MOVWF inPipes
0C30  3001     MOVLW 0x1
0C31  00B9     MOVWF 0xB9
0C32  2C1E     GOTO 0x41E
2725:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2726:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2727:                      inPipes[0].info.bits.busy = 1;
2728:                      break;
2729:                  case USB_REQUEST_SET_INTERFACE:
2730:                      inPipes[0].info.bits.busy = 1;
0C33  17BA     BSF 0xBA, 0x7
2731:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0C34  0020     MOVLB 0x0
0C35  0862     MOVF 0x62, W
0C36  0021     MOVLB 0x1
0C37  00E6     MOVWF 0xE6
0C38  0020     MOVLB 0x0
0C39  0864     MOVF 0x64, W
0C3A  3EBB     ADDLW 0xBB
0C3B  0086     MOVWF FSR1
0C3C  3001     MOVLW 0x1
0C3D  0087     MOVWF FSR1H
0C3E  0021     MOVLB 0x1
0C3F  0866     MOVF 0xE6, W
0C40  0081     MOVWF INDF1
2732:                      break;
0C41  2C7D     GOTO 0x47D
2733:                  case USB_REQUEST_SET_DESCRIPTOR:
2734:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
0C42  3002     MOVLW 0x2
0C43  00D9     MOVWF __pcstackBANK1
0C44  3000     MOVLW 0x0
0C45  00DA     MOVWF 0xDA
0C46  3000     MOVLW 0x0
0C47  00DB     MOVWF pdata
0C48  3000     MOVLW 0x0
0C49  00DC     MOVWF 0xDC
0C4A  3000     MOVLW 0x0
0C4B  00DD     MOVWF size
0C4C  00DE     MOVWF 0xDE
0C4D  3188     MOVLP 0x8
0C4E  2092     CALL 0x92
0C4F  318C     MOVLP 0xC
2735:                      break;
0C50  2C7D     GOTO 0x47D
2736:                  case USB_REQUEST_SYNCH_FRAME:
2737:                  default:
2738:                      break;
2739:              }//end switch
0C51  0861     MOVF pUEP, W
0C52  0021     MOVLB 0x1
0C53  00E6     MOVWF 0xE6
0C54  01E7     CLRF 0xE7
0C55  0867     MOVF 0xE7, W
0C56  3A00     XORLW 0x0
0C57  1903     BTFSC STATUS, 0x2
0C58  2C5A     GOTO 0x45A
0C59  2C7D     GOTO 0x47D
0C5A  0866     MOVF 0xE6, W
0C5B  3A00     XORLW 0x0
0C5C  1903     BTFSC STATUS, 0x2
0C5D  2C23     GOTO 0x423
0C5E  3A01     XORLW 0x1
0C5F  1903     BTFSC STATUS, 0x2
0C60  2C27     GOTO 0x427
0C61  3A02     XORLW 0x2
0C62  1903     BTFSC STATUS, 0x2
0C63  2C27     GOTO 0x427
0C64  3A06     XORLW 0x6
0C65  1903     BTFSC STATUS, 0x2
0C66  2C0C     GOTO 0x40C
0C67  3A03     XORLW 0x3
0C68  1903     BTFSC STATUS, 0x2
0C69  2C12     GOTO 0x412
0C6A  3A01     XORLW 0x1
0C6B  1903     BTFSC STATUS, 0x2
0C6C  2C42     GOTO 0x442
0C6D  3A0F     XORLW 0xF
0C6E  1903     BTFSC STATUS, 0x2
0C6F  2C1A     GOTO 0x41A
0C70  3A01     XORLW 0x1
0C71  1903     BTFSC STATUS, 0x2
0C72  2C16     GOTO 0x416
0C73  3A03     XORLW 0x3
0C74  1903     BTFSC STATUS, 0x2
0C75  2C2B     GOTO 0x42B
0C76  3A01     XORLW 0x1
0C77  1903     BTFSC STATUS, 0x2
0C78  2C33     GOTO 0x433
0C79  3A07     XORLW 0x7
0C7A  1903     BTFSC STATUS, 0x2
0C7B  2C7D     GOTO 0x47D
0C7C  2C7D     GOTO 0x47D
2740:          }//end USBCheckStdRequest
0C7D  0008     RETURN
2741:          
2742:          /********************************************************************
2743:           * Function:        void USBStdFeatureReqHandler(void)
2744:           *
2745:           * PreCondition:    None
2746:           *
2747:           * Input:           None
2748:           *
2749:           * Output:          Can alter BDT entries.  Can also modify USB stack
2750:           *                  Maintained variables.
2751:           *
2752:           * Side Effects:    None
2753:           *
2754:           * Overview:        This routine handles the standard SET & CLEAR
2755:           *                  FEATURES requests
2756:           *
2757:           * Note:            This is a private function, intended for internal
2758:           *                  use by the USB stack, when processing SET/CLEAR
2759:           *                  feature requests.
2760:           *******************************************************************/
2761:          static void USBStdFeatureReqHandler(void)
2762:          {
2763:              BDT_ENTRY *p;
2764:              EP_STATUS current_ep_data;
2765:              #if defined(__C32__)
2766:                  uint32_t* pUEP;
2767:              #else
2768:                  unsigned char* pUEP;
2769:              #endif
2770:          
2771:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2772:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
002F  0020     MOVLB 0x0
0030  0362     DECF 0x62, W
0031  1D03     BTFSS STATUS, 0x2
0032  2834     GOTO 0x34
0033  2835     GOTO 0x35
0034  284B     GOTO 0x4B
0035  0860     MOVF SetupPkt, W
0036  391F     ANDLW 0x1F
0037  3A00     XORLW 0x0
0038  1D03     BTFSS STATUS, 0x2
0039  283B     GOTO 0x3B
003A  283C     GOTO 0x3C
003B  284B     GOTO 0x4B
2773:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2774:              {
2775:                  inPipes[0].info.bits.busy = 1;
003C  0021     MOVLB 0x1
003D  17BA     BSF 0xBA, 0x7
2776:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
003E  3003     MOVLW 0x3
003F  0020     MOVLB 0x0
0040  0661     XORWF 0x61, W
0041  1D03     BTFSS STATUS, 0x2
0042  2844     GOTO 0x44
0043  2845     GOTO 0x45
0044  2849     GOTO 0x49
2777:                      RemoteWakeup = true;
0045  0021     MOVLB 0x1
0046  01D0     CLRF RemoteWakeup
0047  0AD0     INCF RemoteWakeup, F
0048  284B     GOTO 0x4B
2778:                  else
2779:                      RemoteWakeup = false;
0049  0021     MOVLB 0x1
004A  01D0     CLRF RemoteWakeup
2780:              }//end if
2781:          
2782:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2783:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
004B  0020     MOVLB 0x0
004C  0862     MOVF 0x62, W
004D  1D03     BTFSS STATUS, 0x2
004E  2850     GOTO 0x50
004F  2851     GOTO 0x51
0050  2995     GOTO 0x195
0051  0860     MOVF SetupPkt, W
0052  391F     ANDLW 0x1F
0053  3A02     XORLW 0x2
0054  1D03     BTFSS STATUS, 0x2
0055  2857     GOTO 0x57
0056  2858     GOTO 0x58
0057  2995     GOTO 0x195
0058  0864     MOVF 0x64, W
0059  390F     ANDLW 0xF
005A  3A00     XORLW 0x0
005B  1903     BTFSC STATUS, 0x2
005C  285E     GOTO 0x5E
005D  285F     GOTO 0x5F
005E  2995     GOTO 0x195
005F  0864     MOVF 0x64, W
0060  390F     ANDLW 0xF
0061  0021     MOVLB 0x1
0062  00DF     MOVWF 0xDF
0063  3004     MOVLW 0x4
0064  025F     SUBWF 0xDF, W
0065  1803     BTFSC STATUS, 0x0
0066  2868     GOTO 0x68
0067  2869     GOTO 0x69
0068  2995     GOTO 0x195
0069  3020     MOVLW 0x20
006A  0655     XORWF USBDeviceState, W
006B  1D03     BTFSS STATUS, 0x2
006C  286E     GOTO 0x6E
006D  286F     GOTO 0x6F
006E  2995     GOTO 0x195
2784:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2785:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2786:                 (USBDeviceState == CONFIGURED_STATE))
2787:              {
2788:          		//The request was valid.  Take control of the control transfer and
2789:          		//perform the host requested action.
2790:          		inPipes[0].info.bits.busy = 1;
006F  17BA     BSF 0xBA, 0x7
2791:          
2792:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2793:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0070  0020     MOVLB 0x0
0071  1BE4     BTFSC 0x64, 0x7
0072  2874     GOTO 0x74
0073  2875     GOTO 0x75
0074  288E     GOTO 0x8E
2794:                  {
2795:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0075  0864     MOVF 0x64, W
0076  390F     ANDLW 0xF
0077  0709     ADDWF WREG, W
0078  3EA0     ADDLW 0xA0
0079  0086     MOVWF FSR1
007A  3001     MOVLW 0x1
007B  0087     MOVWF FSR1H
007C  3F40     MOVIW 0[FSR1]
007D  0021     MOVLB 0x1
007E  00E4     MOVWF p
007F  3F41     MOVIW 1[FSR1]
0080  00E5     MOVWF 0xE5
2796:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0081  0020     MOVLB 0x0
0082  0864     MOVF 0x64, W
0083  390F     ANDLW 0xF
0084  3EAC     ADDLW 0xAC
0085  0086     MOVWF FSR1
0086  3001     MOVLW 0x1
0087  0087     MOVWF FSR1H
0088  0801     MOVF INDF1, W
0089  0021     MOVLB 0x1
008A  00DF     MOVWF 0xDF
008B  085F     MOVF 0xDF, W
008C  00E3     MOVWF i
2797:                  }
008D  28A5     GOTO 0xA5
2798:                  else
2799:                  {
2800:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
008E  0864     MOVF p, W
008F  390F     ANDLW 0xF
0090  0709     ADDWF WREG, W
0091  3EB0     ADDLW 0xB0
0092  0086     MOVWF FSR1L
0093  0187     CLRF FSR1H
0094  3F40     MOVIW 0[FSR1]
0095  0021     MOVLB 0x1
0096  00E4     MOVWF p
0097  3F41     MOVIW 1[FSR1]
0098  00E5     MOVWF 0xE5
2801:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
0099  0020     MOVLB 0x0
009A  0864     MOVF 0x64, W
009B  390F     ANDLW 0xF
009C  3EB0     ADDLW 0xB0
009D  0086     MOVWF FSR1
009E  3001     MOVLW 0x1
009F  0087     MOVWF FSR1H
00A0  0801     MOVF INDF1, W
00A1  0021     MOVLB 0x1
00A2  00DF     MOVWF 0xDF
00A3  085F     MOVF 0xDF, W
00A4  00E3     MOVWF i
2802:                  }
2803:          
2804:                  //If ping pong buffering is enabled on the requested endpoint, need
2805:                  //to point to the one that is the active BDT entry which the SIE will
2806:                  //use for the next attempted transaction on that EP number.
2807:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2808:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00A5  1863     BTFSC i, 0x0
00A6  28A8     GOTO 0xA8
00A7  28A9     GOTO 0xA9
00A8  28B4     GOTO 0xB4
2809:                      {
2810:                          p = (BDT_ENTRY*)(((uintptr_t)(p)) & (~USB_NEXT_PING_PONG));
00A9  30FB     MOVLW 0xFB
00AA  00DF     MOVWF 0xDF
00AB  30FF     MOVLW 0xFF
00AC  00E0     MOVWF p
00AD  0864     MOVF p, W
00AE  055F     ANDWF 0xDF, W
00AF  00E4     MOVWF p
00B0  0865     MOVF 0xE5, W
00B1  0560     ANDWF p, W
00B2  00E5     MOVWF 0xE5
2811:                      }
00B3  28BA     GOTO 0xBA
2812:                      else //else must have been odd
2813:                      {
2814:                          p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
00B4  3004     MOVLW 0x4
00B5  0464     IORWF p, W
00B6  00E4     MOVWF p
00B7  3000     MOVLW 0x0
00B8  0465     IORWF 0xE5, W
00B9  00E5     MOVWF 0xE5
2815:                      }
2816:                  #endif
2817:          
2818:                  //Update the BDT pointers with the new, next entry based on the feature
2819:                  //  request
2820:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00BA  0020     MOVLB 0x0
00BB  1BE4     BTFSC 0x64, 0x7
00BC  28BE     GOTO 0xBE
00BD  28BF     GOTO 0xBF
00BE  28CC     GOTO 0xCC
2821:                  {
2822:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00BF  0864     MOVF 0x64, W
00C0  390F     ANDLW 0xF
00C1  0709     ADDWF WREG, W
00C2  3EA0     ADDLW 0xA0
00C3  0086     MOVWF FSR1
00C4  3001     MOVLW 0x1
00C5  0087     MOVWF FSR1H
00C6  0021     MOVLB 0x1
00C7  0864     MOVF p, W
00C8  3FC0     MOVWI 0[FSR1]
00C9  0865     MOVF 0xE5, W
00CA  3FC1     MOVWI 1[FSR1]
2823:                  }
00CB  28D7     GOTO 0xD7
2824:                  else
2825:                  {
2826:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00CC  0864     MOVF p, W
00CD  390F     ANDLW 0xF
00CE  0709     ADDWF WREG, W
00CF  3EB0     ADDLW 0xB0
00D0  0086     MOVWF FSR1L
00D1  0187     CLRF FSR1H
00D2  0021     MOVLB 0x1
00D3  0864     MOVF p, W
00D4  3FC0     MOVWI 0[FSR1]
00D5  0865     MOVF 0xE5, W
00D6  3FC1     MOVWI 1[FSR1]
2827:                  }
2828:          
2829:          		//Check if it was a SET_FEATURE endpoint halt request
2830:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00D7  3003     MOVLW 0x3
00D8  0020     MOVLB 0x0
00D9  0661     XORWF 0x61, W
00DA  1D03     BTFSS STATUS, 0x2
00DB  28DD     GOTO 0xDD
00DC  28DE     GOTO 0xDE
00DD  2907     GOTO 0x107
2831:                  {
2832:                      if(p->STAT.UOWN == 1)
00DE  0021     MOVLB 0x1
00DF  0864     MOVF p, W
00E0  0086     MOVWF FSR1L
00E1  0865     MOVF 0xE5, W
00E2  0087     MOVWF FSR1H
00E3  1F81     BTFSS INDF1, 0x7
00E4  28E6     GOTO 0xE6
00E5  28E7     GOTO 0xE7
00E6  28FB     GOTO 0xFB
2833:                      {
2834:                          //Mark that we are terminating this transfer and that the user
2835:                          //  needs to be notified later
2836:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
00E7  0020     MOVLB 0x0
00E8  1BE4     BTFSC 0x64, 0x7
00E9  28EB     GOTO 0xEB
00EA  28EC     GOTO 0xEC
00EB  28F4     GOTO 0xF4
2837:                          {
2838:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
00EC  0864     MOVF 0x64, W
00ED  390F     ANDLW 0xF
00EE  3EAC     ADDLW 0xAC
00EF  0086     MOVWF FSR1
00F0  3001     MOVLW 0x1
00F1  0087     MOVWF FSR1H
00F2  1481     BSF INDF1, 0x1
2839:                          }
00F3  28FB     GOTO 0xFB
2840:                          else
2841:                          {
2842:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
00F4  0864     MOVF 0x64, W
00F5  390F     ANDLW 0xF
00F6  3EB0     ADDLW 0xB0
00F7  0086     MOVWF FSR1
00F8  3001     MOVLW 0x1
00F9  0087     MOVWF FSR1H
00FA  1481     BSF INDF1, 0x1
2843:                          }
2844:                      }
2845:          
2846:          			//Then STALL the endpoint
2847:                      p->STAT.Val |= _BSTALL;
00FB  0021     MOVLB 0x1
00FC  0864     MOVF p, W
00FD  0086     MOVWF FSR1L
00FE  0865     MOVF 0xE5, W
00FF  0087     MOVWF FSR1H
0100  1501     BSF INDF1, 0x2
2848:                      p->STAT.Val |= _USIE;
0101  0864     MOVF p, W
0102  0086     MOVWF FSR1L
0103  0865     MOVF 0xE5, W
0104  0087     MOVWF FSR1H
0105  1781     BSF INDF1, 0x7
2849:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0106  2995     GOTO 0x195
2850:                  else
2851:                  {
2852:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2853:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2854:                          //toggle over the to the non-active BDT
2855:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
0107  3004     MOVLW 0x4
0108  0021     MOVLB 0x1
0109  0664     XORWF p, W
010A  00E4     MOVWF p
010B  3000     MOVLW 0x0
010C  0665     XORWF 0xE5, W
010D  00E5     MOVWF 0xE5
2856:          
2857:                          if(p->STAT.UOWN == 1)
010E  0864     MOVF p, W
010F  0086     MOVWF FSR1L
0110  0865     MOVF 0xE5, W
0111  0087     MOVWF FSR1H
0112  1F81     BTFSS INDF1, 0x7
0113  2915     GOTO 0x115
0114  2916     GOTO 0x116
0115  2933     GOTO 0x133
2858:                          {
2859:                              //Clear UOWN and set DTS state so it will be correct the next time
2860:                              //the application firmware uses USBTransferOnePacket() on the EP.
2861:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
0116  307F     MOVLW 0x7F
0117  00DF     MOVWF 0xDF
0118  0864     MOVF p, W
0119  0086     MOVWF FSR1L
011A  0865     MOVF 0xE5, W
011B  0087     MOVWF FSR1H
011C  085F     MOVF 0xDF, W
011D  0581     ANDWF INDF1, F
2862:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
011E  0864     MOVF p, W
011F  0086     MOVWF FSR1L
0120  0865     MOVF 0xE5, W
0121  0087     MOVWF FSR1H
0122  1701     BSF INDF1, 0x6
2863:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0123  3005     MOVLW 0x5
0124  00D9     MOVWF __pcstackBANK1
0125  3000     MOVLW 0x0
0126  00DA     MOVWF 0xDA
0127  0865     MOVF 0xE5, W
0128  00DC     MOVWF 0xDC
0129  0864     MOVF p, W
012A  00DB     MOVWF pdata
012B  3002     MOVLW 0x2
012C  00DD     MOVWF size
012D  3000     MOVLW 0x0
012E  00DE     MOVWF 0xDE
012F  3188     MOVLP 0x8
0130  2092     CALL 0x92
0131  3180     MOVLP 0x0
2864:                          }
0132  2938     GOTO 0x138
2865:                          else
2866:                          {
2867:                              //UOWN already clear, but still need to set DTS to DATA1
2868:          					p->STAT.Val |= _DAT1;
0133  0864     MOVF p, W
0134  0086     MOVWF FSR1L
0135  0865     MOVF 0xE5, W
0136  0087     MOVWF FSR1H
0137  1701     BSF INDF1, 0x6
2869:                          }
2870:          
2871:                          //toggle back to the active BDT (the one the SIE is currently looking at
2872:                          //and will use for the next successful transaction to take place on the EP
2873:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
0138  3004     MOVLW 0x4
0139  0021     MOVLB 0x1
013A  0664     XORWF p, W
013B  00E4     MOVWF p
013C  3000     MOVLW 0x0
013D  0665     XORWF 0xE5, W
013E  00E5     MOVWF 0xE5
2874:          
2875:                          //Check if we are currently terminating, or have previously terminated
2876:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2877:                          //set DTS to the proper state, and call the application callback
2878:                          //function.
2879:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
013F  18E3     BTFSC i, 0x1
0140  2942     GOTO 0x142
0141  2943     GOTO 0x143
0142  294B     GOTO 0x14B
0143  0864     MOVF p, W
0144  0086     MOVWF FSR1L
0145  0865     MOVF 0xE5, W
0146  0087     MOVWF FSR1H
0147  1F81     BTFSS INDF1, 0x7
0148  294A     GOTO 0x14A
0149  294B     GOTO 0x14B
014A  2978     GOTO 0x178
2880:                          {
2881:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
014B  0020     MOVLB 0x0
014C  1BE4     BTFSC 0x64, 0x7
014D  294F     GOTO 0x14F
014E  2950     GOTO 0x150
014F  2958     GOTO 0x158
2882:                              {
2883:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0150  0864     MOVF 0x64, W
0151  390F     ANDLW 0xF
0152  3EAC     ADDLW 0xAC
0153  0086     MOVWF FSR1
0154  3001     MOVLW 0x1
0155  0087     MOVWF FSR1H
0156  1081     BCF INDF1, 0x1
2884:                              }
0157  295F     GOTO 0x15F
2885:                              else
2886:                              {
2887:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
0158  0864     MOVF 0x64, W
0159  390F     ANDLW 0xF
015A  3EB0     ADDLW 0xB0
015B  0086     MOVWF FSR1
015C  3001     MOVLW 0x1
015D  0087     MOVWF FSR1H
015E  1081     BCF INDF1, 0x1
2888:                              }
2889:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2890:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
015F  303B     MOVLW 0x3B
0160  0021     MOVLB 0x1
0161  00DF     MOVWF 0xDF
0162  0864     MOVF p, W
0163  0086     MOVWF FSR1L
0164  0865     MOVF 0xE5, W
0165  0087     MOVWF FSR1H
0166  085F     MOVF 0xDF, W
0167  0581     ANDWF INDF1, F
2891:                              //Call the application event handler callback function, so it can
2892:          					//decide if the endpoint should get re-armed again or not.
2893:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0168  3005     MOVLW 0x5
0169  00D9     MOVWF __pcstackBANK1
016A  3000     MOVLW 0x0
016B  00DA     MOVWF 0xDA
016C  0865     MOVF 0xE5, W
016D  00DC     MOVWF 0xDC
016E  0864     MOVF p, W
016F  00DB     MOVWF pdata
0170  3002     MOVLW 0x2
0171  00DD     MOVWF size
0172  3000     MOVLW 0x0
0173  00DE     MOVWF 0xDE
0174  3188     MOVLP 0x8
0175  2092     CALL 0x92
0176  3180     MOVLP 0x0
2894:                          }
0177  2980     GOTO 0x180
2895:                          else
2896:                          {
2897:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2898:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
0178  303B     MOVLW 0x3B
0179  00DF     MOVWF 0xDF
017A  0864     MOVF p, W
017B  0086     MOVWF FSR1L
017C  0865     MOVF 0xE5, W
017D  0087     MOVWF FSR1H
017E  085F     MOVF 0xDF, W
017F  0581     ANDWF INDF1, F
2899:                          }
2900:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2901:                          //Check if we need to call the user transfer terminated event callback function.
2902:                          //We should call the callback, if the endpoint was previously terminated,
2903:                          //or the endpoint is currently armed, and the host is performing clear
2904:                          //endpoint halt, even though the endpoint wasn't stalled.
2905:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2906:                          {
2907:                              //We are going to call the user transfer terminated callback.
2908:                              //Clear the flag so we know we took care of it and don't need
2909:                              //to call it again later.
2910:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2911:                              {
2912:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2913:                              }
2914:                              else
2915:                              {
2916:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2917:                              }
2918:          
2919:                              //Clear UOWN and remove the STALL condition.
2920:                              //  In this case we also need to set the DTS bit to 1 so that
2921:                              //  it toggles to DATA0 the next time the application firmware
2922:                              //  calls USBTransferOnePacket() (or equivalent macro).
2923:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2924:                              p->STAT.Val |= _DAT1;
2925:                              //Let the application firmware know a transaction just
2926:                              //got terminated by the host, and that it is now free to
2927:                              //re-arm the endpoint or do other tasks if desired.
2928:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2929:                          }
2930:                          else
2931:                          {
2932:                              //Clear UOWN and remove the STALL condition.
2933:                              //  In this case we also need to set the DTS bit to 1 so that
2934:                              //  it toggles to DATA0 the next time the application firmware
2935:                              //  calls USBTransferOnePacket() (or equivalent macro).
2936:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2937:                              p->STAT.Val |= _DAT1;
2938:                          }
2939:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2940:          
2941:          			//Get a pointer to the appropriate UEPn register
2942:                      #if defined(__C32__)
2943:                          pUEP = (uint32_t*)(&U1EP0);
2944:                          pUEP += (SetupPkt.EPNum*4);
2945:                      #else
2946:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0180  0020     MOVLB 0x0
0181  0864     MOVF 0x64, W
0182  390F     ANDLW 0xF
0183  3E98     ADDLW 0x98
0184  0021     MOVLB 0x1
0185  00DF     MOVWF 0xDF
0186  01E0     CLRF p
0187  300E     MOVLW 0xE
0188  3DE0     ADDWFC p, F
0189  085F     MOVF 0xDF, W
018A  00E1     MOVWF pUEP
018B  0860     MOVF p, W
018C  00E2     MOVWF i
2947:                      #endif
2948:          
2949:          			//Clear the STALL bit in the UEP register
2950:                      *pUEP &= ~UEP_STALL;
018D  30FE     MOVLW 0xFE
018E  00DF     MOVWF 0xDF
018F  0861     MOVF pUEP, W
0190  0086     MOVWF FSR1L
0191  0862     MOVF i, W
0192  0087     MOVWF FSR1H
0193  085F     MOVF 0xDF, W
0194  0581     ANDWF INDF1, F
2951:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2952:              }//end if (lots of checks for set/clear endpoint halt)
2953:          }//end USBStdFeatureReqHandler
0195  0008     RETURN
2954:          
2955:          
2956:          
2957:          
2958:          /**************************************************************************
2959:              Function:
2960:                  void USBIncrement1msInternalTimers(void)
2961:          
2962:              Description:
2963:                  This function increments internal 1ms time base counters, which are
2964:                  useful for application code (that can use a 1ms time base/counter), and
2965:                  for certain USB event timing specific purposes.
2966:          
2967:                  In USB full speed applications, the application code does not need to (and should
2968:                  not) explicitly call this function, as the USBDeviceTasks() function will
2969:                  automatically call this function whenever a 1ms time interval has elapsed
2970:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2971:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
2972:                  in USB_INTERRUPT mode).
2973:          
2974:                  In USB low speed applications, the application firmware is responsible for
2975:                  periodically calling this function at a ~1ms rate.  This can be done using
2976:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
2977:                  If the low speed application code does not call this function, the internal timers
2978:                  will not increment, and the USBGet1msTickCount() API function will not be available.
2979:                  Additionally, certain USB stack operations (like control transfer timeouts)
2980:                  may be unavailable.
2981:          
2982:              Precondition:
2983:                  This function should be called only after USBDeviceInit() has been
2984:                  called (at least once at the start of the application).  Ordinarily,
2985:                  application code should never call this function, unless it is a low speed
2986:                  USB device.
2987:          
2988:              Parameters:
2989:                  None
2990:          
2991:              Return Values:
2992:                  None
2993:          
2994:              Remarks:
2995:                  This function does not need to be called during USB suspend conditions, when
2996:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
2997:            ***************************************************************************/
2998:          void USBIncrement1msInternalTimers(void)
2999:          {
3000:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3001:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3002:              #endif
3003:          
3004:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3005:              //that needs a 1ms time base that is active during USB non-suspended operation.
3006:              USB1msTickCount++;
16B2  3001     MOVLW 0x1
16B3  0023     MOVLB 0x3
16B4  07A8     ADDWF USB1msTickCount, F
16B5  3000     MOVLW 0x0
16B6  3DA9     ADDWFC 0x1A9, F
16B7  3000     MOVLW 0x0
16B8  3DAA     ADDWFC 0x1AA, F
16B9  3000     MOVLW 0x0
16BA  3DAB     ADDWFC 0x1AB, F
3007:              if(USBIsBusSuspended() == false)
16BB  0021     MOVLB 0x1
16BC  084F     MOVF USBBusIsSuspended, W
16BD  1D03     BTFSS STATUS, 0x2
16BE  2EC0     GOTO 0x6C0
16BF  2EC1     GOTO 0x6C1
16C0  2ECE     GOTO 0x6CE
3008:              {
3009:                  USBTicksSinceSuspendEnd++;
16C1  3001     MOVLW 0x1
16C2  00F0     MOVWF 0xF0
16C3  0870     MOVF 0xF0, W
16C4  07C6     ADDWF USBTicksSinceSuspendEnd, F
3010:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3011:                  if(USBTicksSinceSuspendEnd == 0)
16C5  0846     MOVF USBTicksSinceSuspendEnd, W
16C6  1D03     BTFSS STATUS, 0x2
16C7  2EC9     GOTO 0x6C9
16C8  2ECA     GOTO 0x6CA
16C9  2ECE     GOTO 0x6CE
3012:                  {
3013:                      USBTicksSinceSuspendEnd = 255;
16CA  30FF     MOVLW 0xFF
16CB  00F0     MOVWF 0xF0
16CC  0870     MOVF 0xF0, W
16CD  00C6     MOVWF USBTicksSinceSuspendEnd
3014:                  }
3015:              }
3016:          }
16CE  0008     RETURN
3017:          
3018:          
3019:          
3020:          
3021:          /**************************************************************************
3022:              Function:
3023:                  uint32_t USBGet1msTickCount(void)
3024:          
3025:              Description:
3026:                  This function retrieves a 32-bit unsigned integer that normally increments by
3027:                  one every one millisecond.  The count value starts from zero when the
3028:                  USBDeviceInit() function is first called.  See the remarks section for
3029:                  details on special circumstances where the tick count will not increment.
3030:          
3031:              Precondition:
3032:                  This function should be called only after USBDeviceInit() has been
3033:                  called (at least once at the start of the application).
3034:          
3035:              Parameters:
3036:                  None
3037:          
3038:              Return Values:
3039:                  uint32_t representing the approximate millisecond count, since the time the
3040:                  USBDeviceInit() function was first called.
3041:          
3042:              Remarks:
3043:                  On 8-bit USB full speed devices, the internal counter is incremented on
3044:                  every SOF packet detected.  Therefore, it will not increment during suspend
3045:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3046:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3047:                  on 16-bit devices, the count continue to increment during USB suspend or
3048:                  detach events, so long as the application code has not put the microcontroller
3049:                  to sleep during these events, and the application firmware is regularly
3050:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3051:                  USB_INTERRUPT mode operation).
3052:          
3053:                  In USB low speed applications, the host does not broadcast SOF packets to
3054:                  the device, so the application firmware becomes responsible for calling
3055:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3056:                  timer interrupt handler), or else the returned value from this function will
3057:                  not increment.
3058:          
3059:                  Prior to calling USBDeviceInit() for the first time the returned value will
3060:                  be unpredictable.
3061:          
3062:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3063:                  code without risk of retrieving a partially updated 32-bit number.
3064:          
3065:                  However, this value only increments when the USBDeviceTasks() function is allowed
3066:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3067:                  function.  If however USB_POLLING mode is used, one must not block on this
3068:                  function without also calling USBDeviceTasks() continuously for the blocking
3069:                  duration (since the USB stack must still be allowed to execute, and the USB
3070:                  stack is also responsible for updating the tick counter internally).
3071:          
3072:                  If the application is operating in USB_POLLING mode, this function should
3073:                  only be called from the main loop context, and not from an interrupt handler,
3074:                  as the returned value could be incorrect, if the main loop context code was in
3075:                  the process of updating the internal count at the moment of the interrupt event.
3076:             ***************************************************************************/
3077:          uint32_t USBGet1msTickCount(void)
3078:          {
3079:              #if defined (USB_INTERRUPT)
3080:                  uint32_t localContextValue;
3081:          
3082:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3083:                  //value.  This ensures that the complete 32-bit value got read without
3084:                  //getting interrupted in between bytes.
3085:                  do
3086:                  {
3087:                      localContextValue = USB1msTickCount;
3088:                  }while(localContextValue != USB1msTickCount);
3089:          
3090:                  return localContextValue;
3091:          
3092:              #else
3093:                  return USB1msTickCount;
3094:              #endif
3095:          }
3096:          
3097:          
3098:          
3099:          
3100:          
3101:          
3102:          /** EOF USBDevice.c *****************************************************/
---  E:/Smart-Knob/pic16f1455_firmware/lib/system.c  ----------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #include "include/system.h"
21:            
22:            /** CONFIGURATION Bits **********************************************/
23:            // PIC16F1459 configuration bit settings:
24:            #if defined (USE_INTERNAL_OSC)	    // Define this in system.h if using the HFINTOSC for USB operation
25:                // CONFIG1
26:                #pragma config FOSC = INTOSC    // Oscillator Selection Bits (INTOSC oscillator: I/O function on CLKIN pin)
27:                #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
28:                #pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
29:                #pragma config MCLRE = OFF      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
30:                #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
31:                #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
32:                #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
33:                #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
34:                #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
35:            
36:                // CONFIG2
37:                #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
38:                #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
39:                #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
40:                #pragma config PLLMULT = 3x     // PLL Multipler Selection Bit (3x Output Frequency Selected)
41:                #pragma config PLLEN = ENABLED  // PLL Enable Bit (3x or 4x PLL Enabled)
42:                #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
43:                #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
44:                #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
45:                #pragma config LVP = OFF        // Low-Voltage Programming Enable (High-voltage on MCLR/VPP must be used for programming)
46:            #else
47:                // CONFIG1
48:            #pragma config FOSC = HS        // Oscillator Selection Bits (HS Oscillator, High-speed crystal/resonator connected between OSC1 and OSC2 pins)
49:            #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
50:            #pragma config PWRTE = ON       // Power-up Timer Enable (PWRT enabled)
51:            #pragma config MCLRE = ON       // MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
52:            #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
53:            #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
54:            #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
55:            #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
56:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
57:            
58:            // CONFIG2
59:            #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
60:            #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
61:            #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
62:            #pragma config PLLMULT = 4x     // PLL Multipler Selection Bit (4x Output Frequency Selected)
63:            #pragma config PLLEN = ENABLED/*********!!!!!!!!!!!!!!!
64:            
65:            
66:            
67:            !*/  // PLL Enable Bit (3x or 4x PLL Enabled)
68:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
69:            #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
70:            #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
71:            #pragma config LVP = ON         // Low-Voltage Programming Enable (Low-voltage programming enabled)
72:            #endif
73:            /*********************************************************************
74:            * Function: void SYSTEM_Initialize( SYSTEM_STATE state )
75:            *
76:            * Overview: Initializes the system.
77:            *
78:            * PreCondition: None
79:            *
80:            * Input:  SYSTEM_STATE - the state to initialize the system into
81:            *
82:            * Output: None
83:            *
84:            ********************************************************************/
85:            void SYSTEM_Initialize( SYSTEM_STATE state )
16CF  00F5     MOVWF 0xF5
86:            {
87:                ANSELC = 0;
16D0  0023     MOVLB 0x3
16D1  018E     CLRF ANSELC
88:                switch(state)
16D2  2EDC     GOTO 0x6DC
89:                {
90:                    case SYSTEM_STATE_USB_START:
91:                        #if defined(USE_INTERNAL_OSC)
92:                            //Make sure to turn on active clock tuning for USB full speed 
93:                            //operation from the INTOSC
94:                            OSCCON = 0xFC;  //HFINTOSC @ 16MHz, 3X PLL, PLL enabled
95:                            ACTCON = 0x90;  //Active clock tuning enabled for USB
96:                        #endif
97:                        LED_Enable(LED_USB_DEVICE_STATE);
16D3  3001     MOVLW 0x1
16D4  3188     MOVLP 0x8
16D5  2002     CALL 0x2
16D6  3196     MOVLP 0x16
98:                        //LED_Enable(LED_D3);
99:                        
100:                       BUTTON_Enable(BUTTON_USB_DEVICE_HID_JOYSTICK);
16D7  3001     MOVLW 0x1
16D8  3196     MOVLP 0x16
16D9  2684     CALL 0x684
16DA  3196     MOVLP 0x16
101:                       break;
16DB  2EEF     GOTO 0x6EF
102:                       
103:                   case SYSTEM_STATE_USB_SUSPEND: 
104:                       break;
105:                       
106:                   case SYSTEM_STATE_USB_RESUME:
107:                       break;
108:               }
16DC  0875     MOVF 0x1F5, W
16DD  00F3     MOVWF 0x1F3
16DE  01F4     CLRF 0x1F4
16DF  0874     MOVF 0x1F4, W
16E0  3A00     XORLW 0x0
16E1  1903     BTFSC STATUS, 0x2
16E2  2EE4     GOTO 0x6E4
16E3  2EEF     GOTO 0x6EF
16E4  0873     MOVF 0x1F3, W
16E5  3A00     XORLW 0x0
16E6  1903     BTFSC STATUS, 0x2
16E7  2ED3     GOTO 0x6D3
16E8  3A01     XORLW 0x1
16E9  1903     BTFSC STATUS, 0x2
16EA  2EEF     GOTO 0x6EF
16EB  3A03     XORLW 0x3
16EC  1903     BTFSC STATUS, 0x2
16ED  2EEF     GOTO 0x6EF
16EE  2EEF     GOTO 0x6EF
109:           }
16EF  0008     RETURN
110:           
111:           #if(__XC8_VERSION < 2000)
112:               #define INTERRUPT interrupt
113:           #else
114:               #define INTERRUPT __interrupt()
115:           #endif			
116:           			
117:           void INTERRUPT SYS_InterruptHigh(void)
0004  147E     BSF 0x1FE, 0x0
0005  3180     MOVLP 0x0
118:           {
119:               #if defined(USB_INTERRUPT)
120:                   USBDeviceTasks();
121:               #endif
122:           }
0006  107E     BCF 0x1FE, 0x0
---  E:/Smart-Knob/pic16f1455_firmware/lib/spi.c  -------------------------------------------------------
1:             #include <xc.h>
2:             #include "include/spi.h"
3:             
4:             #include "include/app_device_joystick.h"
5:             
6:             #define SPI_FREQ 6
7:             #if SPI_FREQ == 6
8:                 #define SPI_MODE MASTER_OSC_SPADD
9:             #else
10:                #define SPI_MODE MASTER_OSC_DIV4
11:            #endif
12:            
13:            #define writeByteNOread asm("MOVIW FSR1++");/*load next byte*/   \
14:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
15:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
16:                asm("BRA -2");                         /*else go back*/         \
17:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
18:                
19:            #define writeByteRead asm("MOVIW FSR1++");/*load next byte*/   \
20:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
21:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
22:                asm("BRA -2");                         /*else go back*/         \
23:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
24:                asm("MOVWI FSR0++");/*save received byte*/
25:                
26:            #if SPI_FREQ == 6
27:                #define WAIT_ADDITIONAL NOP();NOP();NOP();NOP();  NOP();NOP();NOP();NOP(); 
28:            #else
29:                #define WIAT_ADDITIONAL
30:            #endif
31:            
32:            
33:            
34:            #define writeByteNOreadFAST asm("MOVIW FSR1++");/*load next byte*/  \
35:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
36:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
37:                WAIT_ADDITIONAL                                                 \
38:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
39:                
40:            #define writeByteReadFAST asm("MOVIW FSR1++");/*load next byte*/  \
41:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
42:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
43:                WAIT_ADDITIONAL                                                 \
44:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
45:                asm("MOVWI FSR0++");/*save received byte*/
46:                
47:            
48:            #define writeByteOnlyRead asm("BTFSS SSP1STAT, 0x0"); /*if ready continue*/   \
49:                            asm("BRA -2");              /*else go back*/                  \
50:                            asm("MOVF SSP1BUF,W");      /*read the received byte into W*/ \
51:                            asm("MOVWI FSR0++");        /*save received byte*/  
52:            
53:                //TO DO OUT VECTOR
54:            #define REP8(x) x x x x x x x x
55:            
56:            #define strgf(x) str_H(x)
57:            #define str_H(X) #X
58:            #define MOVLW_ADR(X) asm(strgf(M_CONC(MOVLW 0x, X)));
59:            
60:            
61:            #define _XTAL_FREQ 48000000
62:            
63:            
64:            
65:            uint8_t garbage;
66:            
67:            uint8_t luminosity;//first control byte to receive
68:            uint8_t errors_ctr2_to_PIC;//second control byte to send
69:            
70:            uint8_t pkt_requests;//bitmask for each packet type
71:            uint8_t ctrl2_from_PIC;//second ctrl byte
72:            
73:            void spiWrite(void);
74:            
75:            void spiTask(void){
76:                pkt_requests = 0;
052D  0021     MOVLB 0x1
052E  01C5     CLRF pkt_requests
77:                if(!HIDTxHandleBusy(last_HAP_IN)){
052F  0841     MOVF last_HAP_IN, W
0530  0442     IORWF 0xC2, W
0531  1903     BTFSC STATUS, 0x2
0532  2D34     GOTO 0x534
0533  2D35     GOTO 0x535
0534  2D3D     GOTO 0x53D
0535  0841     MOVF last_HAP_IN, W
0536  0086     MOVWF FSR1L
0537  0842     MOVF 0xC2, W
0538  0087     MOVWF FSR1H
0539  1B81     BTFSC INDF1, 0x7
053A  2D3C     GOTO 0x53C
053B  2D3D     GOTO 0x53D
053C  2D3F     GOTO 0x53F
78:                    //rady to send another to PC
79:                    pkt_requests = REQUEST_HAPTIC_IN;
053D  01C5     CLRF pkt_requests
053E  0AC5     INCF pkt_requests, F
80:                }
81:                if(!HIDRxHandleBusy(last_DSP_OUT)){
053F  083F     MOVF last_DSP_OUT, W
0540  0440     IORWF 0xC0, W
0541  1903     BTFSC STATUS, 0x2
0542  2D44     GOTO 0x544
0543  2D45     GOTO 0x545
0544  2D4D     GOTO 0x54D
0545  083F     MOVF last_DSP_OUT, W
0546  0086     MOVWF FSR1L
0547  0840     MOVF 0xC0, W
0548  0087     MOVWF FSR1H
0549  1B81     BTFSC INDF1, 0x7
054A  2D4C     GOTO 0x54C
054B  2D4D     GOTO 0x54D
054C  2D51     GOTO 0x551
82:                    //rady to send another to PC
83:                    pkt_requests = REQUEST_DISPLAY_OUT;
054D  300E     MOVLW 0xE
054E  00F0     MOVWF 0xF0
054F  0870     MOVF 0xF0, W
0550  00C5     MOVWF pkt_requests
84:                }
85:                //in case we have received a start command 
86:                //from previous unserviced transaction
87:                garbage = SSPBUF;
0551  0024     MOVLB 0x4
0552  0811     MOVF SSP1BUF, W
0553  00F0     MOVWF 0x270
0554  0870     MOVF 0x270, W
0555  0022     MOVLB 0x2
0556  00A7     MOVWF garbage
88:                SSPOV = 0;
0557  0024     MOVLB 0x4
0558  1315     BCF SSP1CON1, 0x6
89:                //wait for a new byte, only for 3 microseconds
90:                
91:                    asm("MOVLB 4");
0559  0024     MOVLB 0x4
92:                REP8(asm("BTFSC SSP1STAT, 0x0"); asm("BRA OUTOFWAITSPI");)
055A  1814     BTFSC SSP1STAT, 0x0
055B  321E     BRA 0x57A
055C  1814     BTFSC SSP1STAT, 0x0
055D  321C     BRA 0x57A
055E  1814     BTFSC SSP1STAT, 0x0
055F  321A     BRA 0x57A
0560  1814     BTFSC SSP1STAT, 0x0
0561  3218     BRA 0x57A
0562  1814     BTFSC SSP1STAT, 0x0
0563  3216     BRA 0x57A
0564  1814     BTFSC SSP1STAT, 0x0
0565  3214     BRA 0x57A
0566  1814     BTFSC SSP1STAT, 0x0
0567  3212     BRA 0x57A
0568  1814     BTFSC SSP1STAT, 0x0
0569  3210     BRA 0x57A
93:                REP8(asm("BTFSC SSP1STAT, 0x0"); asm("BRA OUTOFWAITSPI");)
056A  1814     BTFSC SSP1STAT, 0x0
056B  320E     BRA 0x57A
056C  1814     BTFSC SSP1STAT, 0x0
056D  320C     BRA 0x57A
056E  1814     BTFSC SSP1STAT, 0x0
056F  320A     BRA 0x57A
0570  1814     BTFSC SSP1STAT, 0x0
0571  3208     BRA 0x57A
0572  1814     BTFSC SSP1STAT, 0x0
0573  3206     BRA 0x57A
0574  1814     BTFSC SSP1STAT, 0x0
0575  3204     BRA 0x57A
0576  1814     BTFSC SSP1STAT, 0x0
0577  3202     BRA 0x57A
0578  1814     BTFSC SSP1STAT, 0x0
0579  3200     BRA 0x57A
94:                asm("OUTOFWAITSPI: NOP");                
057A  0000     NOP
95:                
96:                ///we have waited for a "fresh" request
97:                if(BF && SSPBUF == BEGIN_TRANSFER){
057B  0024     MOVLB 0x4
057C  1C14     BTFSS SSP1STAT, 0x0
057D  2D7F     GOTO 0x57F
057E  2D80     GOTO 0x580
057F  2E14     GOTO 0x614
0580  3055     MOVLW 0x55
0581  0611     XORWF SSP1BUF, W
0582  1D03     BTFSS STATUS, 0x2
0583  2D85     GOTO 0x585
0584  2D86     GOTO 0x586
0585  2E14     GOTO 0x614
98:                    //if we have a request(we have received BEGIN_TRANSFER)
99:                    //service transfer
100:                   SSPBUF = ACK1;
0586  3076     MOVLW 0x76
0587  0091     MOVWF SSP1BUF
101:                   //in case we write exactly during a receive the WCOL will be set
102:                   
103:                   while(!BF);//wait for response
0588  1C14     BTFSS SSP1STAT, 0x0
0589  2D8B     GOTO 0x58B
058A  2D8C     GOTO 0x58C
058B  2D88     GOTO 0x588
104:                   if(SSPBUF == BEGIN_TRANSFER){
058C  3055     MOVLW 0x55
058D  0611     XORWF SSP1BUF, W
058E  1D03     BTFSS STATUS, 0x2
058F  2D91     GOTO 0x591
0590  2D92     GOTO 0x592
0591  2E18     GOTO 0x618
105:                       //we haven't just missed the NodeMCU's interval
106:                       //it sends 0x00 to indicate it timed out
107:                       //else it sends another BEGIN_TRANSFER to read the ACK1
108:                       SSPBUF = pkt_requests;
0592  0021     MOVLB 0x1
0593  0845     MOVF pkt_requests, W
0594  0024     MOVLB 0x4
0595  0091     MOVWF SSP1BUF
109:                       //we surely don't have overflow; NodeMCU waits 1us
110:                       asm("BTFSS SSP1STAT, 0x0");            //if ready continue
0596  1C14     BTFSS SSP1STAT, 0x0
111:                       asm("BRA -2");                         //else go back
0597  33FE     BRA 0x596
112:                       
113:                       luminosity = SSPBUF;
0598  0024     MOVLB 0x4
0599  0811     MOVF SSP1BUF, W
059A  00F0     MOVWF 0x270
059B  0870     MOVF 0x270, W
059C  0023     MOVLB 0x3
059D  00BA     MOVWF luminosity
114:                       
115:                       SSPBUF = ctrl2_from_PIC;
059E  0024     MOVLB 0x4
059F  0191     CLRF SSP1BUF
116:                       //we surely don't have overflow; NodeMCU waits 1us
117:                       asm("BTFSS SSP1STAT, 0x0");            //if ready continue
05A0  1C14     BTFSS SSP1STAT, 0x0
118:                       asm("BRA -2");                         //else go back
05A1  33FE     BRA 0x5A0
119:                       
120:                       errors_ctr2_to_PIC = SSPBUF;
05A2  0024     MOVLB 0x4
05A3  0811     MOVF SSP1BUF, W
05A4  00F0     MOVWF 0x270
05A5  0870     MOVF 0x270, W
05A6  0023     MOVLB 0x3
05A7  00B9     MOVWF errors_ctr2_to_PIC
121:                       //we have transmitted and received control bytes
122:                       
123:                       if(pkt_requests & REQUEST_HAPTIC_IN){
05A8  0021     MOVLB 0x1
05A9  1C45     BTFSS pkt_requests, 0x0
05AA  2DAC     GOTO 0x5AC
05AB  2DAD     GOTO 0x5AD
05AC  2DF8     GOTO 0x5F8
124:                           hap_IN_pkt_sent=0;
05AD  0022     MOVLB 0x2
05AE  01AA     CLRF hap_IN_pkt_sent
125:                           
126:                           
127:                           //read 16 bytes
128:                           MOVLW_ADR(HAPTIC_IN_ADDRESS_LO)
05AF  3050     MOVLW 0x50
129:                           asm("MOVWF FSR0L");
05B0  0084     MOVWF FSR0L
130:                           MOVLW_ADR(HAPTIC_IN_ADDRESS_HI)
05B1  3020     MOVLW 0x20
131:                           asm("MOVWF FSR0H");
05B2  0085     MOVWF FSR0H
132:                           asm("MOVLB 4");//go to bank 4, where the spbuf/stat is
05B3  0024     MOVLB 0x4
133:                           
134:                           asm("MOVF SSP1BUF,W");
05B4  0811     MOVF SSP1BUF, W
135:                           REP8(writeByteOnlyRead)
05B5  1C14     BTFSS SSP1STAT, 0x0
05B6  33FE     BRA 0x5B5
05B7  0811     MOVF SSP1BUF, W
05B8  001A     MOVWI FSR0++
05B9  1C14     BTFSS SSP1STAT, 0x0
05BA  33FE     BRA 0x5B9
05BB  0811     MOVF SSP1BUF, W
05BC  001A     MOVWI FSR0++
05BD  1C14     BTFSS SSP1STAT, 0x0
05BE  33FE     BRA 0x5BD
05BF  0811     MOVF SSP1BUF, W
05C0  001A     MOVWI FSR0++
05C1  1C14     BTFSS SSP1STAT, 0x0
05C2  33FE     BRA 0x5C1
05C3  0811     MOVF SSP1BUF, W
05C4  001A     MOVWI FSR0++
05C5  1C14     BTFSS SSP1STAT, 0x0
05C6  33FE     BRA 0x5C5
05C7  0811     MOVF SSP1BUF, W
05C8  001A     MOVWI FSR0++
05C9  1C14     BTFSS SSP1STAT, 0x0
05CA  33FE     BRA 0x5C9
05CB  0811     MOVF SSP1BUF, W
05CC  001A     MOVWI FSR0++
05CD  1C14     BTFSS SSP1STAT, 0x0
05CE  33FE     BRA 0x5CD
05CF  0811     MOVF SSP1BUF, W
05D0  001A     MOVWI FSR0++
05D1  1C14     BTFSS SSP1STAT, 0x0
05D2  33FE     BRA 0x5D1
05D3  0811     MOVF SSP1BUF, W
05D4  001A     MOVWI FSR0++
136:                           REP8(writeByteOnlyRead)
05D5  1C14     BTFSS SSP1STAT, 0x0
05D6  33FE     BRA 0x5D5
05D7  0811     MOVF SSP1BUF, W
05D8  001A     MOVWI FSR0++
05D9  1C14     BTFSS SSP1STAT, 0x0
05DA  33FE     BRA 0x5D9
05DB  0811     MOVF SSP1BUF, W
05DC  001A     MOVWI FSR0++
05DD  1C14     BTFSS SSP1STAT, 0x0
05DE  33FE     BRA 0x5DD
05DF  0811     MOVF SSP1BUF, W
05E0  001A     MOVWI FSR0++
05E1  1C14     BTFSS SSP1STAT, 0x0
05E2  33FE     BRA 0x5E1
05E3  0811     MOVF SSP1BUF, W
05E4  001A     MOVWI FSR0++
05E5  1C14     BTFSS SSP1STAT, 0x0
05E6  33FE     BRA 0x5E5
05E7  0811     MOVF SSP1BUF, W
05E8  001A     MOVWI FSR0++
05E9  1C14     BTFSS SSP1STAT, 0x0
05EA  33FE     BRA 0x5E9
05EB  0811     MOVF SSP1BUF, W
05EC  001A     MOVWI FSR0++
05ED  1C14     BTFSS SSP1STAT, 0x0
05EE  33FE     BRA 0x5ED
05EF  0811     MOVF SSP1BUF, W
05F0  001A     MOVWI FSR0++
05F1  1C14     BTFSS SSP1STAT, 0x0
05F2  33FE     BRA 0x5F1
05F3  0811     MOVF SSP1BUF, W
05F4  001A     MOVWI FSR0++
137:                                   
138:                           //asm("BTFSS SSP1STAT, 0x0"); //if ready continue   
139:                           //asm("BRA -2");              //else go back             
140:                           //asm("MOVF SSP1BUF,W");      //read the received byte into W
141:                           SSPBUF = 0x00;
05F5  0024     MOVLB 0x4
05F6  0191     CLRF SSP1BUF
142:                       }else if(pkt_requests & REQUEST_DISPLAY_OUT){
05F7  2E14     GOTO 0x614
05F8  0845     MOVF 0x245, W
05F9  390E     ANDLW 0xE
05FA  1903     BTFSC STATUS, 0x2
05FB  2DFD     GOTO 0x5FD
05FC  2DFE     GOTO 0x5FE
05FD  2E14     GOTO 0x614
143:                           display_pkt_ready = 1;
05FE  0022     MOVLB 0x2
05FF  01AC     CLRF display_pkt_ready
0600  0AAC     INCF display_pkt_ready, F
144:                           __delay_us(1);
0601  3004     MOVLW 0x4
0602  0B89     DECFSZ WREG, F
0603  2E02     GOTO 0x602
145:                           MasterinitSPI();
0604  3196     MOVLP 0x16
0605  2677     CALL 0x677
0606  3185     MOVLP 0x5
146:                           __delay_us(2);
0607  3008     MOVLW 0x8
0608  0B89     DECFSZ WREG, F
0609  2E08     GOTO 0x608
147:                           spiWrite();
060A  3181     MOVLP 0x1
060B  2196     CALL 0x196
060C  3185     MOVLP 0x5
148:                           __delay_us(3);//NodeMCU has to copy the packet
060D  300C     MOVLW 0xC
060E  0B89     DECFSZ WREG, F
060F  2E0E     GOTO 0x60E
149:                           SlaveinitSPI();
0610  3196     MOVLP 0x16
0611  2662     CALL 0x662
0612  3185     MOVLP 0x5
0613  2E14     GOTO 0x614
150:                           
151:                       }
152:                       
153:                   }else{
154:                       //we don't need to send another 0x00
155:                       //since BUF is already 0(or at least not BEGIN_TRANSFERs)
156:                       return;
157:                   }
158:                       
159:                   
160:               }
161:               //make sure no ACK1 byte is left in BUF
162:               SSPBUF = 0x00;
0614  0024     MOVLB 0x4
0615  0191     CLRF SSP1BUF
163:               WCOL=0;
0616  1395     BCF SSP1CON1, 0x7
164:               SSPOV=0;
0617  1315     BCF SSP1CON1, 0x6
165:           }
0618  0008     RETURN
166:           
167:           void spiWrite(){
168:               CS_PIN = 0;
0196  0020     MOVLB 0x0
0197  118E     BCF PORTC, 0x3
169:               //preload address
170:               //address for DISPLAY
171:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_LO)     //asm("MOVLW 0xD0");
0198  30B0     MOVLW 0xB0
172:               asm("MOVWF FSR1L");
0199  0086     MOVWF FSR1
173:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_HI)     //asm("MOVLW 0x21");
019A  3021     MOVLW 0x21
174:               asm("MOVWF FSR1H");
019B  0087     MOVWF FSR1H
175:               
176:               //go to bank 4, where the spbuf/stat is
177:               asm("MOVLB 4");
019C  0024     MOVLB 0x4
178:               
179:               REP8(REP8(writeByteNOread))
019D  0016     MOVIW FSR1++
019E  0091     MOVWF SSP1BUF
019F  1C14     BTFSS SSP1STAT, 0x0
01A0  33FE     BRA 0x19F
01A1  0811     MOVF SSP1BUF, W
01A2  0016     MOVIW FSR1++
01A3  0091     MOVWF SSP1BUF
01A4  1C14     BTFSS SSP1STAT, 0x0
01A5  33FE     BRA 0x1A4
01A6  0811     MOVF SSP1BUF, W
01A7  0016     MOVIW FSR1++
01A8  0091     MOVWF SSP1BUF
01A9  1C14     BTFSS SSP1STAT, 0x0
01AA  33FE     BRA 0x1A9
01AB  0811     MOVF SSP1BUF, W
01AC  0016     MOVIW FSR1++
01AD  0091     MOVWF SSP1BUF
01AE  1C14     BTFSS SSP1STAT, 0x0
01AF  33FE     BRA 0x1AE
01B0  0811     MOVF SSP1BUF, W
01B1  0016     MOVIW FSR1++
01B2  0091     MOVWF SSP1BUF
01B3  1C14     BTFSS SSP1STAT, 0x0
01B4  33FE     BRA 0x1B3
01B5  0811     MOVF SSP1BUF, W
01B6  0016     MOVIW FSR1++
01B7  0091     MOVWF SSP1BUF
01B8  1C14     BTFSS SSP1STAT, 0x0
01B9  33FE     BRA 0x1B8
01BA  0811     MOVF SSP1BUF, W
01BB  0016     MOVIW FSR1++
01BC  0091     MOVWF SSP1BUF
01BD  1C14     BTFSS SSP1STAT, 0x0
01BE  33FE     BRA 0x1BD
01BF  0811     MOVF SSP1BUF, W
01C0  0016     MOVIW FSR1++
01C1  0091     MOVWF SSP1BUF
01C2  1C14     BTFSS SSP1STAT, 0x0
01C3  33FE     BRA 0x1C2
01C4  0811     MOVF SSP1BUF, W
01C5  0016     MOVIW FSR1++
01C6  0091     MOVWF SSP1BUF
01C7  1C14     BTFSS SSP1STAT, 0x0
01C8  33FE     BRA 0x1C7
01C9  0811     MOVF SSP1BUF, W
01CA  0016     MOVIW FSR1++
01CB  0091     MOVWF SSP1BUF
01CC  1C14     BTFSS SSP1STAT, 0x0
01CD  33FE     BRA 0x1CC
01CE  0811     MOVF SSP1BUF, W
01CF  0016     MOVIW FSR1++
01D0  0091     MOVWF SSP1BUF
01D1  1C14     BTFSS SSP1STAT, 0x0
01D2  33FE     BRA 0x1D1
01D3  0811     MOVF SSP1BUF, W
01D4  0016     MOVIW FSR1++
01D5  0091     MOVWF SSP1BUF
01D6  1C14     BTFSS SSP1STAT, 0x0
01D7  33FE     BRA 0x1D6
01D8  0811     MOVF SSP1BUF, W
01D9  0016     MOVIW FSR1++
01DA  0091     MOVWF SSP1BUF
01DB  1C14     BTFSS SSP1STAT, 0x0
01DC  33FE     BRA 0x1DB
01DD  0811     MOVF SSP1BUF, W
01DE  0016     MOVIW FSR1++
01DF  0091     MOVWF SSP1BUF
01E0  1C14     BTFSS SSP1STAT, 0x0
01E1  33FE     BRA 0x1E0
01E2  0811     MOVF SSP1BUF, W
01E3  0016     MOVIW FSR1++
01E4  0091     MOVWF SSP1BUF
01E5  1C14     BTFSS SSP1STAT, 0x0
01E6  33FE     BRA 0x1E5
01E7  0811     MOVF SSP1BUF, W
01E8  0016     MOVIW FSR1++
01E9  0091     MOVWF SSP1BUF
01EA  1C14     BTFSS SSP1STAT, 0x0
01EB  33FE     BRA 0x1EA
01EC  0811     MOVF SSP1BUF, W
01ED  0016     MOVIW FSR1++
01EE  0091     MOVWF SSP1BUF
01EF  1C14     BTFSS SSP1STAT, 0x0
01F0  33FE     BRA 0x1EF
01F1  0811     MOVF SSP1BUF, W
01F2  0016     MOVIW FSR1++
01F3  0091     MOVWF SSP1BUF
01F4  1C14     BTFSS SSP1STAT, 0x0
01F5  33FE     BRA 0x1F4
01F6  0811     MOVF SSP1BUF, W
01F7  0016     MOVIW FSR1++
01F8  0091     MOVWF SSP1BUF
01F9  1C14     BTFSS SSP1STAT, 0x0
01FA  33FE     BRA 0x1F9
01FB  0811     MOVF SSP1BUF, W
01FC  0016     MOVIW FSR1++
01FD  0091     MOVWF SSP1BUF
01FE  1C14     BTFSS SSP1STAT, 0x0
01FF  33FE     BRA 0x1FE
0200  0811     MOVF SSP1BUF, W
0201  0016     MOVIW FSR1++
0202  0091     MOVWF SSP1BUF
0203  1C14     BTFSS SSP1STAT, 0x0
0204  33FE     BRA 0x203
0205  0811     MOVF SSP1BUF, W
0206  0016     MOVIW FSR1++
0207  0091     MOVWF SSP1BUF
0208  1C14     BTFSS SSP1STAT, 0x0
0209  33FE     BRA 0x208
020A  0811     MOVF SSP1BUF, W
020B  0016     MOVIW FSR1++
020C  0091     MOVWF SSP1BUF
020D  1C14     BTFSS SSP1STAT, 0x0
020E  33FE     BRA 0x20D
020F  0811     MOVF SSP1BUF, W
0210  0016     MOVIW FSR1++
0211  0091     MOVWF SSP1BUF
0212  1C14     BTFSS SSP1STAT, 0x0
0213  33FE     BRA 0x212
0214  0811     MOVF SSP1BUF, W
0215  0016     MOVIW FSR1++
0216  0091     MOVWF SSP1BUF
0217  1C14     BTFSS SSP1STAT, 0x0
0218  33FE     BRA 0x217
0219  0811     MOVF SSP1BUF, W
021A  0016     MOVIW FSR1++
021B  0091     MOVWF SSP1BUF
021C  1C14     BTFSS SSP1STAT, 0x0
021D  33FE     BRA 0x21C
021E  0811     MOVF SSP1BUF, W
021F  0016     MOVIW FSR1++
0220  0091     MOVWF SSP1BUF
0221  1C14     BTFSS SSP1STAT, 0x0
0222  33FE     BRA 0x221
0223  0811     MOVF SSP1BUF, W
0224  0016     MOVIW FSR1++
0225  0091     MOVWF SSP1BUF
0226  1C14     BTFSS SSP1STAT, 0x0
0227  33FE     BRA 0x226
0228  0811     MOVF SSP1BUF, W
0229  0016     MOVIW FSR1++
022A  0091     MOVWF SSP1BUF
022B  1C14     BTFSS SSP1STAT, 0x0
022C  33FE     BRA 0x22B
022D  0811     MOVF SSP1BUF, W
022E  0016     MOVIW FSR1++
022F  0091     MOVWF SSP1BUF
0230  1C14     BTFSS SSP1STAT, 0x0
0231  33FE     BRA 0x230
0232  0811     MOVF SSP1BUF, W
0233  0016     MOVIW FSR1++
0234  0091     MOVWF SSP1BUF
0235  1C14     BTFSS SSP1STAT, 0x0
0236  33FE     BRA 0x235
0237  0811     MOVF SSP1BUF, W
0238  0016     MOVIW FSR1++
0239  0091     MOVWF SSP1BUF
023A  1C14     BTFSS SSP1STAT, 0x0
023B  33FE     BRA 0x23A
023C  0811     MOVF SSP1BUF, W
023D  0016     MOVIW FSR1++
023E  0091     MOVWF SSP1BUF
023F  1C14     BTFSS SSP1STAT, 0x0
0240  33FE     BRA 0x23F
0241  0811     MOVF SSP1BUF, W
0242  0016     MOVIW FSR1++
0243  0091     MOVWF SSP1BUF
0244  1C14     BTFSS SSP1STAT, 0x0
0245  33FE     BRA 0x244
0246  0811     MOVF SSP1BUF, W
0247  0016     MOVIW FSR1++
0248  0091     MOVWF SSP1BUF
0249  1C14     BTFSS SSP1STAT, 0x0
024A  33FE     BRA 0x249
024B  0811     MOVF SSP1BUF, W
024C  0016     MOVIW FSR1++
024D  0091     MOVWF SSP1BUF
024E  1C14     BTFSS SSP1STAT, 0x0
024F  33FE     BRA 0x24E
0250  0811     MOVF SSP1BUF, W
0251  0016     MOVIW FSR1++
0252  0091     MOVWF SSP1BUF
0253  1C14     BTFSS SSP1STAT, 0x0
0254  33FE     BRA 0x253
0255  0811     MOVF SSP1BUF, W
0256  0016     MOVIW FSR1++
0257  0091     MOVWF SSP1BUF
0258  1C14     BTFSS SSP1STAT, 0x0
0259  33FE     BRA 0x258
025A  0811     MOVF SSP1BUF, W
025B  0016     MOVIW FSR1++
025C  0091     MOVWF SSP1BUF
025D  1C14     BTFSS SSP1STAT, 0x0
025E  33FE     BRA 0x25D
025F  0811     MOVF SSP1BUF, W
0260  0016     MOVIW FSR1++
0261  0091     MOVWF SSP1BUF
0262  1C14     BTFSS SSP1STAT, 0x0
0263  33FE     BRA 0x262
0264  0811     MOVF SSP1BUF, W
0265  0016     MOVIW FSR1++
0266  0091     MOVWF SSP1BUF
0267  1C14     BTFSS SSP1STAT, 0x0
0268  33FE     BRA 0x267
0269  0811     MOVF SSP1BUF, W
026A  0016     MOVIW FSR1++
026B  0091     MOVWF SSP1BUF
026C  1C14     BTFSS SSP1STAT, 0x0
026D  33FE     BRA 0x26C
026E  0811     MOVF SSP1BUF, W
026F  0016     MOVIW FSR1++
0270  0091     MOVWF SSP1BUF
0271  1C14     BTFSS SSP1STAT, 0x0
0272  33FE     BRA 0x271
0273  0811     MOVF SSP1BUF, W
0274  0016     MOVIW FSR1++
0275  0091     MOVWF SSP1BUF
0276  1C14     BTFSS SSP1STAT, 0x0
0277  33FE     BRA 0x276
0278  0811     MOVF SSP1BUF, W
0279  0016     MOVIW FSR1++
027A  0091     MOVWF SSP1BUF
027B  1C14     BTFSS SSP1STAT, 0x0
027C  33FE     BRA 0x27B
027D  0811     MOVF SSP1BUF, W
027E  0016     MOVIW FSR1++
027F  0091     MOVWF SSP1BUF
0280  1C14     BTFSS SSP1STAT, 0x0
0281  33FE     BRA 0x280
0282  0811     MOVF SSP1BUF, W
0283  0016     MOVIW FSR1++
0284  0091     MOVWF SSP1BUF
0285  1C14     BTFSS SSP1STAT, 0x0
0286  33FE     BRA 0x285
0287  0811     MOVF SSP1BUF, W
0288  0016     MOVIW FSR1++
0289  0091     MOVWF SSP1BUF
028A  1C14     BTFSS SSP1STAT, 0x0
028B  33FE     BRA 0x28A
028C  0811     MOVF SSP1BUF, W
028D  0016     MOVIW FSR1++
028E  0091     MOVWF SSP1BUF
028F  1C14     BTFSS SSP1STAT, 0x0
0290  33FE     BRA 0x28F
0291  0811     MOVF SSP1BUF, W
0292  0016     MOVIW FSR1++
0293  0091     MOVWF SSP1BUF
0294  1C14     BTFSS SSP1STAT, 0x0
0295  33FE     BRA 0x294
0296  0811     MOVF SSP1BUF, W
0297  0016     MOVIW FSR1++
0298  0091     MOVWF SSP1BUF
0299  1C14     BTFSS SSP1STAT, 0x0
029A  33FE     BRA 0x299
029B  0811     MOVF SSP1BUF, W
029C  0016     MOVIW FSR1++
029D  0091     MOVWF SSP1BUF
029E  1C14     BTFSS SSP1STAT, 0x0
029F  33FE     BRA 0x29E
02A0  0811     MOVF SSP1BUF, W
02A1  0016     MOVIW FSR1++
02A2  0091     MOVWF SSP1BUF
02A3  1C14     BTFSS SSP1STAT, 0x0
02A4  33FE     BRA 0x2A3
02A5  0811     MOVF SSP1BUF, W
02A6  0016     MOVIW FSR1++
02A7  0091     MOVWF SSP1BUF
02A8  1C14     BTFSS SSP1STAT, 0x0
02A9  33FE     BRA 0x2A8
02AA  0811     MOVF SSP1BUF, W
02AB  0016     MOVIW FSR1++
02AC  0091     MOVWF SSP1BUF
02AD  1C14     BTFSS SSP1STAT, 0x0
02AE  33FE     BRA 0x2AD
02AF  0811     MOVF SSP1BUF, W
02B0  0016     MOVIW FSR1++
02B1  0091     MOVWF SSP1BUF
02B2  1C14     BTFSS SSP1STAT, 0x0
02B3  33FE     BRA 0x2B2
02B4  0811     MOVF SSP1BUF, W
02B5  0016     MOVIW FSR1++
02B6  0091     MOVWF SSP1BUF
02B7  1C14     BTFSS SSP1STAT, 0x0
02B8  33FE     BRA 0x2B7
02B9  0811     MOVF SSP1BUF, W
02BA  0016     MOVIW FSR1++
02BB  0091     MOVWF SSP1BUF
02BC  1C14     BTFSS SSP1STAT, 0x0
02BD  33FE     BRA 0x2BC
02BE  0811     MOVF SSP1BUF, W
02BF  0016     MOVIW FSR1++
02C0  0091     MOVWF SSP1BUF
02C1  1C14     BTFSS SSP1STAT, 0x0
02C2  33FE     BRA 0x2C1
02C3  0811     MOVF SSP1BUF, W
02C4  0016     MOVIW FSR1++
02C5  0091     MOVWF SSP1BUF
02C6  1C14     BTFSS SSP1STAT, 0x0
02C7  33FE     BRA 0x2C6
02C8  0811     MOVF SSP1BUF, W
02C9  0016     MOVIW FSR1++
02CA  0091     MOVWF SSP1BUF
02CB  1C14     BTFSS SSP1STAT, 0x0
02CC  33FE     BRA 0x2CB
02CD  0811     MOVF SSP1BUF, W
02CE  0016     MOVIW FSR1++
02CF  0091     MOVWF SSP1BUF
02D0  1C14     BTFSS SSP1STAT, 0x0
02D1  33FE     BRA 0x2D0
02D2  0811     MOVF SSP1BUF, W
02D3  0016     MOVIW FSR1++
02D4  0091     MOVWF SSP1BUF
02D5  1C14     BTFSS SSP1STAT, 0x0
02D6  33FE     BRA 0x2D5
02D7  0811     MOVF SSP1BUF, W
02D8  0016     MOVIW FSR1++
02D9  0091     MOVWF SSP1BUF
02DA  1C14     BTFSS SSP1STAT, 0x0
02DB  33FE     BRA 0x2DA
02DC  0811     MOVF SSP1BUF, W
180:               //NodeMCU needs to receive one more dummy byte
181:               SSPBUF = ' ';while(!BF);
02DD  3020     MOVLW 0x20
02DE  0024     MOVLB 0x4
02DF  0091     MOVWF SSP1BUF
02E0  1C14     BTFSS SSP1STAT, 0x0
02E1  2AE3     GOTO 0x2E3
02E2  2AE4     GOTO 0x2E4
02E3  2AE0     GOTO 0x2E0
182:               CS_PIN = 1;
02E4  0020     MOVLB 0x0
02E5  158E     BSF PORTC, 0x3
183:           }
02E6  0008     RETURN
184:           
185:           void MasterinitSPI(){
186:               TRIS_CS_PIN = 0;TRIS_CLK_PIN = 0;
1677  0021     MOVLB 0x1
1678  118E     BCF TRISC, 0x3
1679  100E     BCF TRISC, 0x0
187:               CS_PIN=1;
167A  0020     MOVLB 0x0
167B  158E     BSF PORTC, 0x3
188:             
189:           #if SPI_FREQ == 6
190:               SSPADD = 1;
167C  3001     MOVLW 0x1
167D  0024     MOVLB 0x4
167E  0092     MOVWF SSP1ADD
191:           #endif
192:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
167F  3040     MOVLW 0x40
1680  0094     MOVWF SSP1STAT
193:               SSPCON = SPI_MODE | IDLE_LOW;//SSPM=0000:=;CKP=0
1681  302A     MOVLW 0x2A
1682  0095     MOVWF SSP1CON1
194:               
195:           }
1683  0008     RETURN
196:           void SlaveinitSPI(){
197:               TRIS_CS_PIN = 1;TRIS_CLK_PIN = 1;
1662  0021     MOVLB 0x1
1663  158E     BSF TRISC, 0x3
1664  140E     BSF TRISC, 0x0
198:               //BOEN = 0;
199:               //ANSC0=0;ANSC1=0;ANSC2=0;ANSC3=0; moved to system.c
200:               
201:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
1665  3040     MOVLW 0x40
1666  0024     MOVLB 0x4
1667  0094     MOVWF SSP1STAT
202:               SSPCON = SLAVE_SS_EN | IDLE_LOW;//SSPM=0000:=;CKP=0
1668  3024     MOVLW 0x24
1669  0095     MOVWF SSP1CON1
203:           }
166A  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/leds.c  ------------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <include/leds.h>
24:            #include <stdbool.h>
25:            #include <xc.h>
26:            
27:            #define LED_D1_LAT LATCbits.LATC4
28:            #define LED_D2_LAT LATCbits.LATC1
29:            #define LED_D3_LAT LATCbits.LATC2
30:            //#define LED_D4_LAT LATCbits.LATC3
31:            
32:            #define LED_D1_TRIS TRISCbits.TRISC4
33:            #define LED_D2_TRIS TRISCbits.TRISC1
34:            #define LED_D3_TRIS TRISCbits.TRISC2
35:            //#define LED_D4_TRIS TRISCbits.TRISC3
36:            
37:            #define LED_ON  1
38:            #define LED_OFF 0
39:            
40:            #define PIN_INPUT  1
41:            #define PIN_OUTPUT 0
42:            
43:            /*********************************************************************
44:            * Function: void LED_On(LED led);
45:            *
46:            * Overview: Turns requested LED on
47:            *
48:            * PreCondition: LED configured via LED_Configure()
49:            *
50:            * Input: LED led - enumeration of the LEDs available in this
51:            *        demo.  They should be meaningful names and not the names of
52:            *        the LEDs on the silkscreen on the board (as the demo code may
53:            *        be ported to other boards).
54:            *         i.e. - LED_On(LED_CONNECTION_DETECTED);
55:            *
56:            * Output: none
57:            *
58:            ********************************************************************/
59:            void LED_On(LED led)
1733  00F2     MOVWF 0x272
60:            {
61:                switch(led)
1734  2F3E     GOTO 0x73E
62:                {
63:                    case LED_D1:
64:                        LED_D1_LAT = LED_ON;
1735  0022     MOVLB 0x2
1736  160E     BSF LATC, 0x4
65:                        break;
1737  2F54     GOTO 0x754
66:            
67:                    case LED_D2:
68:                        LED_D2_LAT = LED_ON;
1738  0022     MOVLB 0x2
1739  148E     BSF LATC, 0x1
69:                        break;
173A  2F54     GOTO 0x754
70:            			
71:                    case LED_D3:
72:                        LED_D3_LAT = LED_ON;
173B  0022     MOVLB 0x2
173C  150E     BSF LATC, 0x2
73:                        break;
173D  2F54     GOTO 0x754
74:            			
75:                    /*case LED_D4:
76:                        LED_D4_LAT = LED_ON;
77:                        break;*/
78:            
79:                    case LED_NONE:
80:                        break;
81:                }
173E  0872     MOVF 0x172, W
173F  00F0     MOVWF 0x170
1740  01F1     CLRF 0x171
1741  0871     MOVF 0x171, W
1742  3A00     XORLW 0x0
1743  1903     BTFSC STATUS, 0x2
1744  2F46     GOTO 0x746
1745  2F54     GOTO 0x754
1746  0870     MOVF 0x170, W
1747  3A00     XORLW 0x0
1748  1903     BTFSC STATUS, 0x2
1749  2F54     GOTO 0x754
174A  3A01     XORLW 0x1
174B  1903     BTFSC STATUS, 0x2
174C  2F35     GOTO 0x735
174D  3A03     XORLW 0x3
174E  1903     BTFSC STATUS, 0x2
174F  2F38     GOTO 0x738
1750  3A01     XORLW 0x1
1751  1903     BTFSC STATUS, 0x2
1752  2F3B     GOTO 0x73B
1753  2F54     GOTO 0x754
82:            }
1754  0008     RETURN
83:            
84:            /*********************************************************************
85:            * Function: void LED_Off(LED led);
86:            *
87:            * Overview: Turns requested LED off
88:            *
89:            * PreCondition: LED configured via LEDConfigure()
90:            *
91:            * Input: LED led - enumeration of the LEDs available in this
92:            *        demo.  They should be meaningful names and not the names of
93:            *        the LEDs on the silkscreen on the board (as the demo code may
94:            *        be ported to other boards).
95:            *         i.e. - LED_Off(LED_CONNECTION_DETECTED);
96:            *
97:            * Output: none
98:            *
99:            ********************************************************************/
100:           void LED_Off(LED led)
1711  00F2     MOVWF 0x172
101:           {
102:               switch(led)
1712  2F1C     GOTO 0x71C
103:               {
104:                   case LED_D1:
105:                       LED_D1_LAT = LED_OFF;
1713  0022     MOVLB 0x2
1714  120E     BCF LATC, 0x4
106:                       break;
1715  2F32     GOTO 0x732
107:           
108:                   case LED_D2:
109:                       LED_D2_LAT = LED_OFF;
1716  0022     MOVLB 0x2
1717  108E     BCF LATC, 0x1
110:                       break;
1718  2F32     GOTO 0x732
111:           			
112:                   case LED_D3:
113:                       LED_D3_LAT = LED_OFF;
1719  0022     MOVLB 0x2
171A  110E     BCF LATC, 0x2
114:                       break;
171B  2F32     GOTO 0x732
115:           			
116:                   /*case LED_D4:
117:                       LED_D4_LAT = LED_OFF;
118:                       break;*/
119:           
120:                   case LED_NONE:
121:                       break;
122:               }
171C  0872     MOVF 0x172, W
171D  00F0     MOVWF 0x170
171E  01F1     CLRF 0x171
171F  0871     MOVF 0x171, W
1720  3A00     XORLW 0x0
1721  1903     BTFSC STATUS, 0x2
1722  2F24     GOTO 0x724
1723  2F32     GOTO 0x732
1724  0870     MOVF 0x170, W
1725  3A00     XORLW 0x0
1726  1903     BTFSC STATUS, 0x2
1727  2F32     GOTO 0x732
1728  3A01     XORLW 0x1
1729  1903     BTFSC STATUS, 0x2
172A  2F13     GOTO 0x713
172B  3A03     XORLW 0x3
172C  1903     BTFSC STATUS, 0x2
172D  2F16     GOTO 0x716
172E  3A01     XORLW 0x1
172F  1903     BTFSC STATUS, 0x2
1730  2F19     GOTO 0x719
1731  2F32     GOTO 0x732
123:           }
1732  0008     RETURN
124:           
125:           /*********************************************************************
126:           * Function: void LED_Toggle(LED led);
127:           *
128:           * Overview: Toggles the state of the requested LED
129:           *
130:           * PreCondition: LED configured via LEDConfigure()
131:           *
132:           * Input: LED led - enumeration of the LEDs available in this
133:           *        demo.  They should be meaningful names and not the names of
134:           *        the LEDs on the silkscreen on the board (as the demo code may
135:           *        be ported to other boards).
136:           *         i.e. - LED_Toggle(LED_CONNECTION_DETECTED);
137:           *
138:           * Output: none
139:           *
140:           ********************************************************************/
141:           void LED_Toggle(LED led)
142:           {
143:               switch(led)
144:               {
145:                   case LED_D1:
146:                       LED_D1_LAT ^= 1;
147:                       break;
148:           
149:                   case LED_D2:
150:                       LED_D2_LAT ^= 1;
151:                       break;
152:           			
153:                   case LED_D3:
154:                       //LED_D3_LAT ^= 1;
155:                       break;
156:           			
157:                   /*case LED_D4:
158:                       LED_D4_LAT ^= 1;
159:                       break;*/
160:           
161:                   case LED_NONE:
162:                       break;
163:               }
164:           }
165:           
166:           /*********************************************************************
167:           * Function: bool LED_Get(LED led);
168:           *
169:           * Overview: Returns the current state of the requested LED
170:           *
171:           * PreCondition: LED configured via LEDConfigure()
172:           *
173:           * Input: LED led - enumeration of the LEDs available in this
174:           *        demo.  They should be meaningful names and not the names of
175:           *        the LEDs on the silkscreen on the board (as the demo code may
176:           *        be ported to other boards).
177:           *         i.e. - LED_Get(LED_CONNECTION_DETECTED);
178:           *
179:           * Output: true if on, false if off
180:           *
181:           ********************************************************************/
182:           bool LED_Get(LED led)
183:           {
184:               switch(led)
185:               {
186:                   case LED_D1:
187:                       return ( (LED_D1_LAT == LED_ON) ? true : false );
188:           
189:                   case LED_D2:
190:                       return ( (LED_D2_LAT == LED_ON) ? true : false );
191:           			
192:                   case LED_D3:
193:                       return ( (LED_D3_LAT == LED_ON) ? true : false );
194:           			
195:                   /*case LED_D4:
196:                       return ( (LED_D4_LAT == LED_ON) ? true : false );*/
197:           
198:                   case LED_NONE:
199:                       return false;
200:               }
201:               
202:               return false;
203:           }
204:           
205:           /*********************************************************************
206:           * Function: void LED_Enable(LED led);
207:           *
208:           * Overview: Configures the LED for use by the other LED API
209:           *
210:           * PreCondition: none
211:           *
212:           * Input: LED led - enumeration of the LEDs available in this
213:           *        demo.  They should be meaningful names and not the names of
214:           *        the LEDs on the silkscreen on the board (as the demo code may
215:           *        be ported to other boards).
216:           *
217:           * Output: none
218:           *
219:           ********************************************************************/
220:           void LED_Enable(LED led)
0802  00F2     MOVWF 0x172
221:           {
222:               switch(led)
0803  280D     GOTO 0xD
223:               {
224:                   case LED_D1:
225:                       LED_D1_TRIS = PIN_OUTPUT;
0804  0021     MOVLB 0x1
0805  120E     BCF TRISC, 0x4
226:                       break;
0806  2823     GOTO 0x23
227:           
228:                   case LED_D2:
229:                       LED_D2_TRIS = PIN_OUTPUT;
0807  0021     MOVLB 0x1
0808  108E     BCF TRISC, 0x1
230:                       break;
0809  2823     GOTO 0x23
231:           			
232:                   case LED_D3:
233:                       LED_D3_TRIS = PIN_OUTPUT;
080A  0021     MOVLB 0x1
080B  110E     BCF TRISC, 0x2
234:                       break;
080C  2823     GOTO 0x23
235:           			
236:                   /*case LED_D4:
237:                       LED_D4_TRIS = PIN_OUTPUT;
238:                       break;*/
239:           
240:                   case LED_NONE:
241:                       break;
242:               }
080D  0872     MOVF 0xF2, W
080E  00F0     MOVWF 0xF0
080F  01F1     CLRF 0xF1
0810  0871     MOVF 0xF1, W
0811  3A00     XORLW 0x0
0812  1903     BTFSC STATUS, 0x2
0813  2815     GOTO 0x15
0814  2823     GOTO 0x23
0815  0870     MOVF 0xF0, W
0816  3A00     XORLW 0x0
0817  1903     BTFSC STATUS, 0x2
0818  2823     GOTO 0x23
0819  3A01     XORLW 0x1
081A  1903     BTFSC STATUS, 0x2
081B  2804     GOTO 0x4
081C  3A03     XORLW 0x3
081D  1903     BTFSC STATUS, 0x2
081E  2807     GOTO 0x7
081F  3A01     XORLW 0x1
0820  1903     BTFSC STATUS, 0x2
0821  280A     GOTO 0xA
0822  2823     GOTO 0x23
243:           }
0823  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/buttons.c  ---------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <xc.h>
24:            #include <stdbool.h>
25:            #include <include/buttons.h>
26:            
27:            /*** Button Definitions *********************************************/
28:            #define S1_PORT  PORTCbits.RC3
29:            
30:            #define BUTTON_PRESSED      0
31:            #define BUTTON_NOT_PRESSED  1
32:            
33:            #define PIN_INPUT           1
34:            #define PIN_OUTPUT          0
35:            
36:            #define PIN_DIGITAL         1
37:            #define PIN_ANALOG          0
38:            
39:            /*********************************************************************
40:            * Function: bool BUTTON_IsPressed(BUTTON button);
41:            *
42:            * Overview: Returns the current state of the requested button
43:            *
44:            * PreCondition: button configured via BUTTON_SetConfiguration()
45:            *
46:            * Input: BUTTON button - enumeration of the buttons available in
47:            *        this demo.  They should be meaningful names and not the names 
48:            *        of the buttons on the silkscreen on the board (as the demo 
49:            *        code may be ported to other boards).
50:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
51:            *
52:            * Output: TRUE if pressed; FALSE if not pressed.
53:            *
54:            ********************************************************************/
55:            bool BUTTON_IsPressed(BUTTON button)
56:            {
57:                ANSELC = 0;
58:                switch(button)
59:                {
60:                    case BUTTON_S1:
61:                        return ( (S1_PORT == BUTTON_PRESSED) ? true : false);
62:            
63:                    case BUTTON_NONE:
64:                        return false;
65:                }
66:                
67:                return false;
68:            }
69:            
70:            /*********************************************************************
71:            * Function: void BUTTON_Enable(BUTTON button);
72:            *
73:            * Overview: Returns the current state of the requested button
74:            *
75:            * PreCondition: button configured via BUTTON_SetConfiguration()
76:            *
77:            * Input: BUTTON button - enumeration of the buttons available in
78:            *        this demo.  They should be meaningful names and not the names
79:            *        of the buttons on the silkscreen on the board (as the demo
80:            *        code may be ported to other boards).
81:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
82:            *
83:            * Output: None
84:            *
85:            ********************************************************************/
86:            void BUTTON_Enable(BUTTON button)
1684  00F2     MOVWF 0xF2
87:            {
88:                switch(button)
1685  0872     MOVF 0xF2, W
1686  00F0     MOVWF 0xF0
1687  01F1     CLRF 0xF1
1688  0871     MOVF 0xF1, W
1689  3A00     XORLW 0x0
89:                {
90:                    case BUTTON_S1:
91:                        break;
92:            
93:                    case BUTTON_NONE:
94:                        break;
95:                }
168A  1903     BTFSC STATUS, 0x2
168B  2E8D     GOTO 0x68D
168C  2E95     GOTO 0x695
168D  0870     MOVF 0xF0, W
168E  3A00     XORLW 0x0
168F  1903     BTFSC STATUS, 0x2
1690  2E95     GOTO 0x695
1691  3A01     XORLW 0x1
1692  1903     BTFSC STATUS, 0x2
1693  2E95     GOTO 0x695
1694  2E95     GOTO 0x695
96:            }
1695  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_led_usb_status.c  ----------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            // *****************************************************************************
21:            // *****************************************************************************
22:            // Section: Included Files
23:            // *****************************************************************************
24:            // *****************************************************************************
25:            #include "stdint.h"
26:            #include "include/system.h"
27:            #include "include/usb/usb_device.h"
28:            
29:            
30:            // *****************************************************************************
31:            // *****************************************************************************
32:            // Section: File Scope or Global Constants
33:            // *****************************************************************************
34:            // *****************************************************************************
35:            
36:            
37:            // *****************************************************************************
38:            // *****************************************************************************
39:            // Section: File Scope Data Types
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            
43:            
44:            // *****************************************************************************
45:            // *****************************************************************************
46:            // Section: Macros or Functions
47:            // *****************************************************************************
48:            // *****************************************************************************
49:            
50:            void APP_LEDUpdateUSBStatus(void)
51:            {
52:                static uint16_t ledCount = 0;
53:            
54:                if(USBIsDeviceSuspended() == true)
09D3  003D     MOVLB 0x1D
09D4  1C8E     BTFSS UCON, 0x1
09D5  29D7     GOTO 0x1D7
09D6  29D8     GOTO 0x1D8
09D7  2A22     GOTO 0x222
55:                {
56:                    LED_Off(LED_USB_DEVICE_STATE);
09D8  3001     MOVLW 0x1
09D9  3197     MOVLP 0x17
09DA  2711     CALL 0x711
09DB  3189     MOVLP 0x9
09DC  2A35     GOTO 0x235
57:                    return;
58:                }
59:            
60:                switch(USBGetDeviceState())
61:                {         
62:                    case CONFIGURED_STATE:
63:                        /* We are configured.  Blink fast.
64:                         * On for 75ms, off for 75ms, then reset/repeat. */
65:                        if(ledCount == 1)
09DD  033D     DECF 0xEBD, W
09DE  043E     IORWF 0xEBE, W
09DF  1D03     BTFSS STATUS, 0x2
09E0  29E2     GOTO 0x1E2
09E1  29E3     GOTO 0x1E3
09E2  29E8     GOTO 0x1E8
66:                        {
67:                            LED_On(LED_USB_DEVICE_STATE);
09E3  3001     MOVLW 0x1
09E4  3197     MOVLP 0x17
09E5  2733     CALL 0x733
09E6  3189     MOVLP 0x9
68:                        }
09E7  2A30     GOTO 0x230
69:                        else if(ledCount == 75)
09E8  304B     MOVLW 0x4B
09E9  063D     XORWF 0xEBD, W
09EA  043E     IORWF 0xEBE, W
09EB  1D03     BTFSS STATUS, 0x2
09EC  29EE     GOTO 0x1EE
09ED  29EF     GOTO 0x1EF
09EE  29F4     GOTO 0x1F4
70:                        {
71:                            LED_Off(LED_USB_DEVICE_STATE);
09EF  3001     MOVLW 0x1
09F0  3197     MOVLP 0x17
09F1  2711     CALL 0x711
09F2  3189     MOVLP 0x9
72:                        }
09F3  2A30     GOTO 0x230
73:                        else if(ledCount > 150)
09F4  3000     MOVLW 0x0
09F5  023E     SUBWF 0xEBE, W
09F6  3097     MOVLW 0x97
09F7  1903     BTFSC STATUS, 0x2
09F8  023D     SUBWF 0xEBD, W
09F9  1C03     BTFSS STATUS, 0x0
09FA  29FC     GOTO 0x1FC
09FB  29FD     GOTO 0x1FD
09FC  2A00     GOTO 0x200
74:                        {
75:                            ledCount = 0;
09FD  01BD     CLRF 0xEBD
09FE  01BE     CLRF 0xEBE
09FF  2A30     GOTO 0x230
76:                        }
77:                        break;
0A00  2A30     GOTO 0x230
78:            
79:                    default:
80:                        /* We aren't configured yet, but we aren't suspended so let's blink with
81:                         * a slow pulse. On for 50ms, then off for 950ms, then reset/repeat. */
82:                        if(ledCount == 1)
0A01  033D     DECF 0xEBD, W
0A02  043E     IORWF 0xEBE, W
0A03  1D03     BTFSS STATUS, 0x2
0A04  2A06     GOTO 0x206
0A05  2A07     GOTO 0x207
0A06  2A0C     GOTO 0x20C
83:                        {
84:                            LED_On(LED_USB_DEVICE_STATE);
0A07  3001     MOVLW 0x1
0A08  3197     MOVLP 0x17
0A09  2733     CALL 0x733
0A0A  3189     MOVLP 0x9
85:                        }
0A0B  2A30     GOTO 0x230
86:                        else if(ledCount == 50)
0A0C  3032     MOVLW 0x32
0A0D  063D     XORWF 0xEBD, W
0A0E  043E     IORWF 0xEBE, W
0A0F  1D03     BTFSS STATUS, 0x2
0A10  2A12     GOTO 0x212
0A11  2A13     GOTO 0x213
0A12  2A18     GOTO 0x218
87:                        {
88:                            LED_Off(LED_USB_DEVICE_STATE);
0A13  3001     MOVLW 0x1
0A14  3197     MOVLP 0x17
0A15  2711     CALL 0x711
0A16  3189     MOVLP 0x9
89:                        }
0A17  2A30     GOTO 0x230
90:                        else if(ledCount > 950)
0A18  3003     MOVLW 0x3
0A19  023E     SUBWF 0xEBE, W
0A1A  30B7     MOVLW 0xB7
0A1B  1903     BTFSC STATUS, 0x2
0A1C  023D     SUBWF 0xEBD, W
0A1D  1C03     BTFSS STATUS, 0x0
0A1E  2A20     GOTO 0x220
0A1F  2A21     GOTO 0x221
0A20  2A30     GOTO 0x230
0A21  29FD     GOTO 0x1FD
91:                        {
92:                            ledCount = 0;
93:                        }
94:                        break;
95:                }
0A22  0021     MOVLB 0x1
0A23  0855     MOVF USBDeviceState, W
0A24  00F3     MOVWF 0xF3
0A25  01F4     CLRF 0xF4
0A26  0874     MOVF 0xF4, W
0A27  3A00     XORLW 0x0
0A28  1903     BTFSC STATUS, 0x2
0A29  2A2B     GOTO 0x22B
0A2A  2A01     GOTO 0x201
0A2B  0873     MOVF 0xF3, W
0A2C  3A20     XORLW 0x20
0A2D  1903     BTFSC STATUS, 0x2
0A2E  29DD     GOTO 0x1DD
0A2F  2A01     GOTO 0x201
96:            
97:                /* Increment the millisecond counter. */
98:                ledCount++;
0A30  3001     MOVLW 0x1
0A31  0021     MOVLB 0x1
0A32  07BD     ADDWF ledCount, F
0A33  3000     MOVLW 0x0
0A34  3DBE     ADDWFC 0xBE, F
99:            }
0A35  0008     RETURN
100:           
101:           /*******************************************************************************
102:            End of File
103:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_device_joystick.c  ---------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #ifndef USBJOYSTICK_C
21:            #define USBJOYSTICK_C
22:            
23:            /** INCLUDES *******************************************************/
24:            #include "include/app_device_joystick.h"
25:            
26:            #include "include/system.h"
27:            
28:            #include "include/app_led_usb_status.h"
29:            #include "include/spi.h"
30:            
31:            #include "stdint.h"
32:            
33:            /** DECLARATIONS ***************************************************/
34:            
35:            USB_VOLATILE USB_HANDLE last_HAP_IN = 0;
36:            USB_VOLATILE USB_HANDLE last_HAP_OUT = 0;
37:            USB_VOLATILE USB_HANDLE last_LED_OUT = 0;
38:            USB_VOLATILE USB_HANDLE last_DSP_OUT = 0;
39:            
40:            
41:            /*********************************************************************
42:            * Function: void APP_DeviceJoystickInitialize(void);
43:            *
44:            * Overview: Initializes the demo code
45:            *
46:            * PreCondition: None
47:            *
48:            * Input: None
49:            *
50:            * Output: None
51:            *
52:            ********************************************************************/
53:            
54:            uint8_t display_pkt_ready,LED_pkt_ready,hap_IN_pkt_sent,hap_OUT_pkt_ready;
55:            
56:            void APP_DeviceJoystickInitialize(void)
57:            {  
58:                //initialize the variable holding the handle for the last
59:                // transmission
60:                last_HAP_IN = 0;
17A5  0021     MOVLB 0x1
17A6  01C1     CLRF last_HAP_IN
17A7  01C2     CLRF 0xC2
61:                last_HAP_OUT = 0;
17A8  0023     MOVLB 0x3
17A9  01B6     CLRF last_HAP_OUT
17AA  01B7     CLRF 0x1B7
62:                last_LED_OUT = 0;
17AB  01B4     CLRF last_LED_OUT
17AC  01B5     CLRF 0x1B5
63:                last_DSP_OUT = 0;
17AD  0021     MOVLB 0x1
17AE  01BF     CLRF last_DSP_OUT
17AF  01C0     CLRF 0xC0
64:            
65:                
66:                display_pkt_ready=1;
17B0  0022     MOVLB 0x2
17B1  01AC     CLRF display_pkt_ready
17B2  0AAC     INCF display_pkt_ready, F
67:                LED_pkt_ready=1;
17B3  01AB     CLRF LED_pkt_ready
17B4  0AAB     INCF LED_pkt_ready, F
68:                hap_IN_pkt_sent=1;
17B5  01AA     CLRF hap_IN_pkt_sent
17B6  0AAA     INCF hap_IN_pkt_sent, F
69:                hap_OUT_pkt_ready=1;
17B7  01A9     CLRF hap_OUT_pkt_ready
17B8  0AA9     INCF hap_OUT_pkt_ready, F
70:            
71:                //enable the HID endpoint
72:                USBEnableEndpoint(HAPTIC_EP,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
17B9  301E     MOVLW 0x1E
17BA  00FD     MOVWF 0x17D
17BB  087D     MOVF 0x17D, W
17BC  00F7     MOVWF 0x177
17BD  3001     MOVLW 0x1
17BE  3197     MOVLP 0x17
17BF  2755     CALL 0x755
17C0  3197     MOVLP 0x17
73:                USBEnableEndpoint(LEDS_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
17C1  301E     MOVLW 0x1E
17C2  00FD     MOVWF 0x17D
17C3  087D     MOVF 0x17D, W
17C4  00F7     MOVWF 0x177
17C5  3002     MOVLW 0x2
17C6  3197     MOVLP 0x17
17C7  2755     CALL 0x755
17C8  3197     MOVLP 0x17
74:                USBEnableEndpoint(DISPLAY_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
17C9  301E     MOVLW 0x1E
17CA  00FD     MOVWF 0x17D
17CB  087D     MOVF 0x17D, W
17CC  00F7     MOVWF 0x177
17CD  3003     MOVLW 0x3
17CE  3197     MOVLP 0x17
17CF  2755     CALL 0x755
17D0  3197     MOVLP 0x17
75:            }//end UserInit
17D1  0008     RETURN
76:            
77:            /*********************************************************************
78:            * Function: void APP_DeviceJoystickTasks(void);
79:            *
80:            * Overview: Keeps the demo running.
81:            *
82:            * PreCondition: The demo should have been initialized and started via
83:            *   the APP_DeviceJoystickInitialize() and APP_DeviceJoystickStart() demos
84:            *   respectively.
85:            *
86:            * Input: None
87:            *
88:            * Output: None
89:            *
90:            ********************************************************************/
91:            
92:            uint8_t cntr=0;
93:            
94:            void APP_DeviceJoystickTasks(void)
95:            {  
96:                /* If the USB device isn't configured yet, we can't really do anything
97:                 * else since we don't have a host to talk to.  So jump back to the
98:                 * top of the while loop. */
99:                if( USBGetDeviceState() < CONFIGURED_STATE )
0619  3020     MOVLW 0x20
061A  0021     MOVLB 0x1
061B  0255     SUBWF USBDeviceState, W
061C  1803     BTFSC STATUS, 0x0
061D  2E1F     GOTO 0x61F
061E  2E20     GOTO 0x620
061F  2E21     GOTO 0x621
0620  2EF1     GOTO 0x6F1
100:               {
101:                   /* Jump back to the top of the while loop. */
102:                   return;
103:               }
104:           
105:               /* If we are currently suspended, then we need to see if we need to
106:                * issue a remote wakeup.  In either case, we shouldn't process any
107:                * keyboard commands since we aren't currently communicating to the host
108:                * thus just continue back to the start of the while loop. */
109:               if( USBIsDeviceSuspended() == true )
0621  003D     MOVLB 0x1D
0622  1C8E     BTFSS UCON, 0x1
0623  2E25     GOTO 0x625
0624  2E26     GOTO 0x626
0625  2E27     GOTO 0x627
0626  2EF1     GOTO 0x6F1
110:               {
111:                   /* Jump back to the top of the while loop. */
112:                   return;
113:               }
114:           
115:               //If the last transmission is complete
116:               if(!HIDTxHandleBusy(last_HAP_IN) && (hap_IN_pkt_sent == 0))
0627  0021     MOVLB 0x1
0628  0841     MOVF last_HAP_IN, W
0629  0442     IORWF 0xC2, W
062A  1903     BTFSC STATUS, 0x2
062B  2E2D     GOTO 0x62D
062C  2E2E     GOTO 0x62E
062D  2E36     GOTO 0x636
062E  0841     MOVF last_HAP_IN, W
062F  0086     MOVWF FSR1L
0630  0842     MOVF 0xC2, W
0631  0087     MOVWF FSR1H
0632  1B81     BTFSC INDF1, 0x7
0633  2E35     GOTO 0x635
0634  2E36     GOTO 0x636
0635  2E79     GOTO 0x679
0636  0022     MOVLB 0x2
0637  082A     MOVF hap_IN_pkt_sent, W
0638  1D03     BTFSS STATUS, 0x2
0639  2E3B     GOTO 0x63B
063A  2E3C     GOTO 0x63C
063B  2E79     GOTO 0x679
117:               {
118:                   
119:                       
120:                   haptic_in[0] = display_output[0];
063C  30B0     MOVLW 0xB0
063D  0086     MOVWF FSR1L
063E  3021     MOVLW 0x21
063F  0087     MOVWF FSR1H
0640  0801     MOVF INDF1, W
0641  00FB     MOVWF 0x17B
0642  087B     MOVF 0x17B, W
0643  0021     MOVLB 0x1
0644  00A0     MOVWF haptic_in
121:                   haptic_in[1] = display_output[1];
0645  30B0     MOVLW 0xB0
0646  0086     MOVWF FSR1L
0647  3021     MOVLW 0x21
0648  0087     MOVWF FSR1H
0649  3141     ADDFSR 1, 1
064A  0801     MOVF INDF1, W
064B  00FB     MOVWF 0xFB
064C  087B     MOVF 0xFB, W
064D  00A1     MOVWF 0xA1
122:                   haptic_in[2] = TESTB;
064E  01A2     CLRF 0xA2
123:                   haptic_in[3] = SSPCON1;
064F  0024     MOVLB 0x4
0650  0815     MOVF SSP1CON1, W
0651  00FB     MOVWF 0x27B
0652  087B     MOVF 0x27B, W
0653  0021     MOVLB 0x1
0654  00A3     MOVWF 0xA3
124:                   haptic_in[4] = SSPSTAT;
0655  0024     MOVLB 0x4
0656  0814     MOVF SSP1STAT, W
0657  00FB     MOVWF 0x27B
0658  087B     MOVF 0x27B, W
0659  0021     MOVLB 0x1
065A  00A4     MOVWF 0xA4
125:                   haptic_in[5] = display_output[63];
065B  30EF     MOVLW 0xEF
065C  0086     MOVWF FSR1L
065D  3021     MOVLW 0x21
065E  0087     MOVWF FSR1H
065F  0801     MOVF INDF1, W
0660  00FB     MOVWF 0xFB
0661  087B     MOVF 0xFB, W
0662  00A5     MOVWF 0xA5
126:                   hap_IN_pkt_sent = 1;
0663  0022     MOVLB 0x2
0664  01AA     CLRF hap_IN_pkt_sent
0665  0AAA     INCF hap_IN_pkt_sent, F
127:                       //Send the 8 byte packet over USB to the host.
128:                   last_HAP_IN = HIDTxPacket(HAPTIC_EP, (uint8_t*)&haptic_in, sizeof(haptic_in));
0666  01F0     CLRF 0x170
0667  0AF0     INCF 0x170, F
0668  30A0     MOVLW 0xA0
0669  00F1     MOVWF 0x171
066A  3000     MOVLW 0x0
066B  00F2     MOVWF 0x172
066C  3010     MOVLW 0x10
066D  00FB     MOVWF 0x17B
066E  087B     MOVF 0x17B, W
066F  00F3     MOVWF 0x173
0670  3001     MOVLW 0x1
0671  318D     MOVLP 0xD
0672  2589     CALL 0x589
0673  3186     MOVLP 0x6
0674  0871     MOVF 0x171, W
0675  0021     MOVLB 0x1
0676  00C2     MOVWF 0xC2
0677  0870     MOVF 0xF0, W
0678  00C1     MOVWF last_HAP_IN
129:                   
130:               }
131:               
132:               if(!HIDRxHandleBusy(last_HAP_OUT) && hap_OUT_pkt_ready){
0679  0023     MOVLB 0x3
067A  0836     MOVF last_HAP_OUT, W
067B  0437     IORWF 0x1B7, W
067C  1903     BTFSC STATUS, 0x2
067D  2E7F     GOTO 0x67F
067E  2E80     GOTO 0x680
067F  2E88     GOTO 0x688
0680  0836     MOVF last_HAP_OUT, W
0681  0086     MOVWF FSR1L
0682  0837     MOVF 0x1B7, W
0683  0087     MOVWF FSR1H
0684  1B81     BTFSC INDF1, 0x7
0685  2E87     GOTO 0x687
0686  2E88     GOTO 0x688
0687  2EA1     GOTO 0x6A1
0688  0022     MOVLB 0x2
0689  0829     MOVF hap_OUT_pkt_ready, W
068A  1903     BTFSC STATUS, 0x2
068B  2E8D     GOTO 0x68D
068C  2E8E     GOTO 0x68E
068D  2EA1     GOTO 0x6A1
133:                   hap_OUT_pkt_ready = 0;
068E  01A9     CLRF hap_OUT_pkt_ready
134:                   last_HAP_OUT = HIDRxPacket(HAPTIC_EP, (uint8_t*)&haptic_out, sizeof(haptic_out));
068F  01F0     CLRF 0x170
0690  3030     MOVLW 0x30
0691  00F1     MOVWF 0x171
0692  3001     MOVLW 0x1
0693  00F2     MOVWF 0x172
0694  3040     MOVLW 0x40
0695  00FB     MOVWF 0x17B
0696  087B     MOVF 0x17B, W
0697  00F3     MOVWF 0x173
0698  3001     MOVLW 0x1
0699  318D     MOVLP 0xD
069A  2589     CALL 0x589
069B  3186     MOVLP 0x6
069C  0871     MOVF 0x171, W
069D  0023     MOVLB 0x3
069E  00B7     MOVWF 0x1B7
069F  0870     MOVF 0x1F0, W
06A0  00B6     MOVWF last_HAP_OUT
135:               }
136:               if(!HIDRxHandleBusy(last_DSP_OUT) && display_pkt_ready){
06A1  0021     MOVLB 0x1
06A2  083F     MOVF last_DSP_OUT, W
06A3  0440     IORWF 0xC0, W
06A4  1903     BTFSC STATUS, 0x2
06A5  2EA7     GOTO 0x6A7
06A6  2EA8     GOTO 0x6A8
06A7  2EB0     GOTO 0x6B0
06A8  083F     MOVF last_DSP_OUT, W
06A9  0086     MOVWF FSR1L
06AA  0840     MOVF 0xC0, W
06AB  0087     MOVWF FSR1H
06AC  1B81     BTFSC INDF1, 0x7
06AD  2EAF     GOTO 0x6AF
06AE  2EB0     GOTO 0x6B0
06AF  2EC9     GOTO 0x6C9
06B0  0022     MOVLB 0x2
06B1  082C     MOVF display_pkt_ready, W
06B2  1903     BTFSC STATUS, 0x2
06B3  2EB5     GOTO 0x6B5
06B4  2EB6     GOTO 0x6B6
06B5  2EC9     GOTO 0x6C9
137:                   display_pkt_ready = 0;
06B6  01AC     CLRF display_pkt_ready
138:                   last_DSP_OUT = HIDRxPacket(DISPLAY_EP, (uint8_t*)&display_output, sizeof(display_output));
06B7  01F0     CLRF 0x170
06B8  30B0     MOVLW 0xB0
06B9  00F1     MOVWF 0x171
06BA  3021     MOVLW 0x21
06BB  00F2     MOVWF 0x172
06BC  3040     MOVLW 0x40
06BD  00FB     MOVWF 0x17B
06BE  087B     MOVF 0x17B, W
06BF  00F3     MOVWF 0x173
06C0  3003     MOVLW 0x3
06C1  318D     MOVLP 0xD
06C2  2589     CALL 0x589
06C3  3186     MOVLP 0x6
06C4  0871     MOVF 0x171, W
06C5  0021     MOVLB 0x1
06C6  00C0     MOVWF 0xC0
06C7  0870     MOVF 0xF0, W
06C8  00BF     MOVWF last_DSP_OUT
139:               }
140:               if(!HIDRxHandleBusy(last_LED_OUT) && LED_pkt_ready){
06C9  0023     MOVLB 0x3
06CA  0834     MOVF last_LED_OUT, W
06CB  0435     IORWF 0x1B5, W
06CC  1903     BTFSC STATUS, 0x2
06CD  2ECF     GOTO 0x6CF
06CE  2ED0     GOTO 0x6D0
06CF  2ED8     GOTO 0x6D8
06D0  0834     MOVF last_LED_OUT, W
06D1  0086     MOVWF FSR1L
06D2  0835     MOVF 0x1B5, W
06D3  0087     MOVWF FSR1H
06D4  1B81     BTFSC INDF1, 0x7
06D5  2ED7     GOTO 0x6D7
06D6  2ED8     GOTO 0x6D8
06D7  2EF1     GOTO 0x6F1
06D8  0022     MOVLB 0x2
06D9  082B     MOVF LED_pkt_ready, W
06DA  1903     BTFSC STATUS, 0x2
06DB  2EDD     GOTO 0x6DD
06DC  2EDE     GOTO 0x6DE
06DD  2EF1     GOTO 0x6F1
141:                   LED_pkt_ready = 0;
06DE  01AB     CLRF LED_pkt_ready
142:                   last_LED_OUT = HIDRxPacket(LEDS_EP, (uint8_t*)&leds_output, sizeof(leds_output));
06DF  01F0     CLRF 0x170
06E0  3030     MOVLW 0x30
06E1  00F1     MOVWF 0x171
06E2  3021     MOVLW 0x21
06E3  00F2     MOVWF 0x172
06E4  3031     MOVLW 0x31
06E5  00FB     MOVWF 0x17B
06E6  087B     MOVF 0x17B, W
06E7  00F3     MOVWF 0x173
06E8  3002     MOVLW 0x2
06E9  318D     MOVLP 0xD
06EA  2589     CALL 0x589
06EB  3186     MOVLP 0x6
06EC  0871     MOVF 0x171, W
06ED  0023     MOVLB 0x3
06EE  00B5     MOVWF 0x1B5
06EF  0870     MOVF 0x1F0, W
06F0  00B4     MOVWF last_LED_OUT
143:               }
144:               
145:           }//end ProcessIO
06F1  0008     RETURN
146:           
147:           #endif
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memset.c  ---------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
06F2  0871     MOVF 0x1F1, W
06F3  00FD     MOVWF 0x1FD
06F4  0870     MOVF 0x1F0, W
06F5  00FC     MOVWF 0x1FC
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
06F6  0874     MOVF 0x1F4, W
06F7  0475     IORWF 0x1F5, W
06F8  1D03     BTFSS STATUS, 0x2
06F9  2EFB     GOTO 0x6FB
06FA  2EFC     GOTO 0x6FC
06FB  2EFD     GOTO 0x6FD
06FC  2FBB     GOTO 0x7BB
14:            	s[0] = (unsigned char)c;
06FD  087C     MOVF 0x1FC, W
06FE  0086     MOVWF FSR1L
06FF  087D     MOVF 0x1FD, W
0700  0087     MOVWF FSR1H
0701  0872     MOVF 0x1F2, W
0702  0081     MOVWF INDF1
15:            	s[n-1] = (unsigned char)c;
0703  0874     MOVF 0x1F4, W
0704  077C     ADDWF 0x1FC, W
0705  00F6     MOVWF 0x1F6
0706  0875     MOVF 0x1F5, W
0707  3D7D     ADDWFC 0x1FD, W
0708  00F7     MOVWF 0x1F7
0709  0876     MOVF 0x1F6, W
070A  3EFF     ADDLW 0xFF
070B  00F8     MOVWF 0x1F8
070C  30FF     MOVLW 0xFF
070D  3D77     ADDWFC 0x1F7, W
070E  00F9     MOVWF 0x1F9
070F  0878     MOVF 0x1F8, W
0710  0086     MOVWF FSR1L
0711  0879     MOVF 0x1F9, W
0712  0087     MOVWF FSR1H
0713  0872     MOVF 0x1F2, W
0714  0081     MOVWF INDF1
16:            	if (n <= 2) return dest;
0715  3000     MOVLW 0x0
0716  0275     SUBWF 0x1F5, W
0717  3003     MOVLW 0x3
0718  1903     BTFSC STATUS, 0x2
0719  0274     SUBWF 0x1F4, W
071A  1803     BTFSC STATUS, 0x0
071B  2F1D     GOTO 0x71D
071C  2F1E     GOTO 0x71E
071D  2F1F     GOTO 0x71F
071E  2FBB     GOTO 0x7BB
17:            	s[1] = (unsigned char)c;
071F  087C     MOVF 0x1FC, W
0720  3E01     ADDLW 0x1
0721  00F6     MOVWF 0x1F6
0722  3000     MOVLW 0x0
0723  3D7D     ADDWFC 0x1FD, W
0724  00F7     MOVWF 0x1F7
0725  0876     MOVF 0x1F6, W
0726  0086     MOVWF FSR1L
0727  0877     MOVF 0x1F7, W
0728  0087     MOVWF FSR1H
0729  0872     MOVF 0x1F2, W
072A  0081     MOVWF INDF1
18:            	s[2] = (unsigned char)c;
072B  087C     MOVF 0x1FC, W
072C  3E02     ADDLW 0x2
072D  00F6     MOVWF 0x1F6
072E  3000     MOVLW 0x0
072F  3D7D     ADDWFC 0x1FD, W
0730  00F7     MOVWF 0x1F7
0731  0876     MOVF 0x1F6, W
0732  0086     MOVWF FSR1L
0733  0877     MOVF 0x1F7, W
0734  0087     MOVWF FSR1H
0735  0872     MOVF 0x1F2, W
0736  0081     MOVWF INDF1
19:            	s[n-2] = (unsigned char)c;
0737  0874     MOVF 0x1F4, W
0738  077C     ADDWF 0x1FC, W
0739  00F6     MOVWF 0x1F6
073A  0875     MOVF 0x1F5, W
073B  3D7D     ADDWFC 0x1FD, W
073C  00F7     MOVWF 0x1F7
073D  0876     MOVF 0x1F6, W
073E  3EFE     ADDLW 0xFE
073F  00F8     MOVWF 0x1F8
0740  30FF     MOVLW 0xFF
0741  3D77     ADDWFC 0x1F7, W
0742  00F9     MOVWF 0x1F9
0743  0878     MOVF 0x1F8, W
0744  0086     MOVWF FSR1L
0745  0879     MOVF 0x1F9, W
0746  0087     MOVWF FSR1H
0747  0872     MOVF 0x1F2, W
0748  0081     MOVWF INDF1
20:            	s[n-3] = (unsigned char)c;
0749  0874     MOVF 0x1F4, W
074A  077C     ADDWF 0x1FC, W
074B  00F6     MOVWF 0x1F6
074C  0875     MOVF 0x1F5, W
074D  3D7D     ADDWFC 0x1FD, W
074E  00F7     MOVWF 0x1F7
074F  0876     MOVF 0x1F6, W
0750  3EFD     ADDLW 0xFD
0751  00F8     MOVWF 0x1F8
0752  30FF     MOVLW 0xFF
0753  3D77     ADDWFC 0x1F7, W
0754  00F9     MOVWF 0x1F9
0755  0878     MOVF 0x1F8, W
0756  0086     MOVWF FSR1L
0757  0879     MOVF 0x1F9, W
0758  0087     MOVWF FSR1H
0759  0872     MOVF 0x1F2, W
075A  0081     MOVWF INDF1
21:            	if (n <= 6) return dest;
075B  3000     MOVLW 0x0
075C  0275     SUBWF 0x1F5, W
075D  3007     MOVLW 0x7
075E  1903     BTFSC STATUS, 0x2
075F  0274     SUBWF 0x1F4, W
0760  1803     BTFSC STATUS, 0x0
0761  2F63     GOTO 0x763
0762  2F64     GOTO 0x764
0763  2F65     GOTO 0x765
0764  2FBB     GOTO 0x7BB
22:            	s[3] = (unsigned char)c;
0765  087C     MOVF 0x1FC, W
0766  3E03     ADDLW 0x3
0767  00F6     MOVWF 0x1F6
0768  3000     MOVLW 0x0
0769  3D7D     ADDWFC 0x1FD, W
076A  00F7     MOVWF 0x1F7
076B  0876     MOVF 0x1F6, W
076C  0086     MOVWF FSR1L
076D  0877     MOVF 0x1F7, W
076E  0087     MOVWF FSR1H
076F  0872     MOVF 0x1F2, W
0770  0081     MOVWF INDF1
23:            	s[n-4] = (unsigned char)c;
0771  0874     MOVF 0x1F4, W
0772  077C     ADDWF 0x1FC, W
0773  00F6     MOVWF 0x1F6
0774  0875     MOVF 0x1F5, W
0775  3D7D     ADDWFC 0x1FD, W
0776  00F7     MOVWF 0x1F7
0777  0876     MOVF 0x1F6, W
0778  3EFC     ADDLW 0xFC
0779  00F8     MOVWF 0x1F8
077A  30FF     MOVLW 0xFF
077B  3D77     ADDWFC 0x1F7, W
077C  00F9     MOVWF 0x1F9
077D  0878     MOVF 0x1F8, W
077E  0086     MOVWF FSR1L
077F  0879     MOVF 0x1F9, W
0780  0087     MOVWF FSR1H
0781  0872     MOVF 0x1F2, W
0782  0081     MOVWF INDF1
24:            	if (n <= 8) return dest;
0783  3000     MOVLW 0x0
0784  0275     SUBWF 0x1F5, W
0785  3009     MOVLW 0x9
0786  1903     BTFSC STATUS, 0x2
0787  0274     SUBWF 0x1F4, W
0788  1803     BTFSC STATUS, 0x0
0789  2F8B     GOTO 0x78B
078A  2F8C     GOTO 0x78C
078B  2F8D     GOTO 0x78D
078C  2FBB     GOTO 0x7BB
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
078D  097C     COMF 0x1FC, W
078E  00F6     MOVWF 0x1F6
078F  097D     COMF 0x1FD, W
0790  00F7     MOVWF 0x1F7
0791  0AF6     INCF 0x1F6, F
0792  1903     BTFSC STATUS, 0x2
0793  0AF7     INCF 0x1F7, F
0794  3003     MOVLW 0x3
0795  0576     ANDWF 0x1F6, W
0796  00FA     MOVWF 0x1FA
0797  3000     MOVLW 0x0
0798  0577     ANDWF 0x1F7, W
0799  00FB     MOVWF 0x1FB
32:            	s += k;
079A  087A     MOVF 0x1FA, W
079B  07FC     ADDWF 0x1FC, F
079C  087B     MOVF 0x1FB, W
079D  3DFD     ADDWFC 0x1FD, F
33:            	n -= k;
079E  087A     MOVF 0x1FA, W
079F  02F4     SUBWF 0x1F4, F
07A0  087B     MOVF 0x1FB, W
07A1  3BF5     SUBWFB 0x1F5, F
34:            	n &= (size_t)-4;
07A2  30FC     MOVLW 0xFC
07A3  05F4     ANDWF 0x1F4, F
07A4  30FF     MOVLW 0xFF
07A5  05F5     ANDWF 0x1F5, F
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
07A6  2FB5     GOTO 0x7B5
07A7  087C     MOVF 0x1FC, W
07A8  0086     MOVWF FSR1L
07A9  087D     MOVF 0x1FD, W
07AA  0087     MOVWF FSR1H
07AB  0872     MOVF 0x1F2, W
07AC  0081     MOVWF INDF1
07AD  3001     MOVLW 0x1
07AE  02F4     SUBWF 0x1F4, F
07AF  3000     MOVLW 0x0
07B0  3BF5     SUBWFB 0x1F5, F
07B1  3001     MOVLW 0x1
07B2  07FC     ADDWF 0x1FC, F
07B3  3000     MOVLW 0x0
07B4  3DFD     ADDWFC 0x1FD, F
07B5  0874     MOVF 0x1F4, W
07B6  0475     IORWF 0x1F5, W
07B7  1D03     BTFSS STATUS, 0x2
07B8  2FBA     GOTO 0x7BA
07B9  2FBB     GOTO 0x7BB
07BA  2FA7     GOTO 0x7A7
87:            #endif
88:            
89:            	return dest;
90:            }
07BB  0008     RETURN
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memcpy.c  ---------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
17D2  00F8     MOVWF 0x1F8
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
17D3  0871     MOVF 0x1F1, W
17D4  00F6     MOVWF 0x1F6
17D5  0870     MOVF 0x1F0, W
17D6  00F5     MOVWF 0x1F5
12:            	d = d1;
17D7  0878     MOVF 0x1F8, W
17D8  00F4     MOVWF 0x1F4
17D9  0874     MOVF 0x1F4, W
17DA  00F9     MOVWF 0x1F9
13:            	while(n--) {
17DB  2FF3     GOTO 0x7F3
17F3  3001     MOVLW 0x1
17F4  02F2     SUBWF 0x1F2, F
17F5  3000     MOVLW 0x0
17F6  3BF3     SUBWFB 0x1F3, F
17F7  0A72     INCF 0x1F2, W
17F8  1D03     BTFSS STATUS, 0x2
17F9  2FFE     GOTO 0x7FE
17FA  0A73     INCF 0x1F3, W
17FB  1D03     BTFSS STATUS, 0x2
17FC  2FFE     GOTO 0x7FE
17FD  2FFF     GOTO 0x7FF
17FE  2FDC     GOTO 0x7DC
14:            		tmp = *s++;
17DC  0875     MOVF 0x1F5, W
17DD  0086     MOVWF FSR1L
17DE  0876     MOVF 0x1F6, W
17DF  0087     MOVWF FSR1H
17E0  0801     MOVF INDF1, W
17E1  00F4     MOVWF 0x1F4
17E2  0874     MOVF 0x1F4, W
17E3  00F7     MOVWF 0x1F7
17E4  3001     MOVLW 0x1
17E5  07F5     ADDWF 0x1F5, F
17E6  3000     MOVLW 0x0
17E7  3DF6     ADDWFC 0x1F6, F
15:            		*d++ = tmp;
17E8  0877     MOVF 0x1F7, W
17E9  00F4     MOVWF 0x1F4
17EA  0879     MOVF 0x1F9, W
17EB  0086     MOVWF FSR1L
17EC  0187     CLRF FSR1H
17ED  0874     MOVF 0x1F4, W
17EE  0081     MOVWF INDF1
17EF  3001     MOVLW 0x1
17F0  00F4     MOVWF 0x1F4
17F1  0874     MOVF 0x1F4, W
17F2  07F9     ADDWF 0x1F9, F
17F3  3001     MOVLW 0x1
17F4  02F2     SUBWF 0x1F2, F
17F5  3000     MOVLW 0x0
17F6  3BF3     SUBWFB 0x1F3, F
17F7  0A72     INCF 0x1F2, W
17F8  1D03     BTFSS STATUS, 0x2
17F9  2FFE     GOTO 0x7FE
17FA  0A73     INCF 0x1F3, W
17FB  1D03     BTFSS STATUS, 0x2
17FC  2FFE     GOTO 0x7FE
17FD  2FFF     GOTO 0x7FF
17FE  2FDC     GOTO 0x7DC
16:            	}
17:            	return d1;
18:            }
17FF  0008     RETURN
19:            
---  C:/Users/Dutu/AppData/Local/Temp/xcAs2f2c.s  -------------------------------------------------------
166B  0064     CLRWDT
166C  0180     CLRF INDF0
166D  3101     ADDFSR 0, 1
166E  3001     MOVLW 0x1
166F  02FE     SUBWF 0x1FE, F
1670  3000     MOVLW 0x0
1671  3BFF     SUBWFB 0x1FF, F
1672  087F     MOVF 0x1FF, W
1673  047E     IORWF 0x1FE, W
1674  1D03     BTFSS STATUS, 0x2
1675  2E6C     GOTO 0x66C
1676  3400     RETLW 0x0
000A  30B0     MOVLW 0xB0
000B  0084     MOVWF FSR0L
000C  3000     MOVLW 0x0
000D  0085     MOVWF FSR0H
000E  3029     MOVLW 0x29
000F  00FE     MOVWF 0x1FE
0010  3000     MOVLW 0x0
0011  00FF     MOVWF 0x1FF
0012  3196     MOVLP 0x16
0015  3020     MOVLW 0x20
0016  0084     MOVWF FSR0L
0017  3001     MOVLW 0x1
0018  0085     MOVWF FSR0H
0019  3010     MOVLW 0x10
001A  00FE     MOVWF 0x1FE
001B  3000     MOVLW 0x0
001C  00FF     MOVWF 0x1FF
001D  3196     MOVLP 0x16
0020  30A0     MOVLW 0xA0
0021  0084     MOVWF FSR0L
0022  3001     MOVLW 0x1
0023  0085     MOVWF FSR0H
0024  301E     MOVLW 0x1E
0025  00FE     MOVWF 0x1FE
0026  3000     MOVLW 0x0
0027  00FF     MOVWF 0x1FF
0028  3196     MOVLP 0x16
002B  107E     BCF 0x1FE, 0x0
002C  0020     MOVLB 0x0
002D  3188     MOVLP 0x8
