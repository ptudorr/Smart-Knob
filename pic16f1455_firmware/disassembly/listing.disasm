Disassembly Listing for USB_Device_-_HID_-_Joystick
Generated From:
E:/Smart-Knob/pic16f1455_firmware/dist/LPCUSBDK_16F1455/production/pic16f1455_firmware.production.elf
Oct 29, 2022 12:55:05 AM

---  E:/Smart-Knob/pic16f1455_firmware/main.c  ----------------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #define _XTAL_FREQ 48000000
22:            #include "include/system.h"
23:            
24:            #include "include/usb/usb.h"
25:            #include "include/usb/usb_device_hid.h"
26:            
27:            #include "include/app_device_joystick.h"
28:            #include "include/app_led_usb_status.h"
29:            
30:            #include "include/spi.h"
31:            
32:            MAIN_RETURN main(void)
33:            {
34:                
35:                TRIS_MOSI_SDI_PIN = 1;TRIS_MISO_SDO_PIN = 0;
0A7A  0021     MOVLB 0x1
0A7B  148E     BSF TRISC, 0x1
0A7C  110E     BCF TRISC, 0x2
36:                //SYSTEM_Initialize(SYSTEM_STATE_USB_START);
37:                __delay_ms(200);
0A7D  300D     MOVLW 0xD
0A7E  0021     MOVLB 0x1
0A7F  00EF     MOVWF 0xEF
0A80  302D     MOVLW 0x2D
0A81  00EE     MOVWF 0xEE
0A82  30D7     MOVLW 0xD7
0A83  0B89     DECFSZ WREG, F
0A84  2A83     GOTO 0x283
0A85  0BEE     DECFSZ 0xEE, F
0A86  2A83     GOTO 0x283
0A87  0BEF     DECFSZ 0xEF, F
0A88  2A83     GOTO 0x283
0A89  3200     BRA 0xA8A
38:                
39:                SlaveinitSPI();
0A8A  3188     MOVLP 0x8
0A8B  2069     CALL 0x69
0A8C  318A     MOVLP 0xA
40:                
41:                USBDeviceInit();
0A8D  3185     MOVLP 0x5
0A8E  2594     CALL 0x594
0A8F  318A     MOVLP 0xA
42:                USBDeviceAttach();
43:            
44:                TRISCbits.TRISC4 = 0;
0A90  0021     MOVLB 0x1
0A91  120E     BCF TRISC, 0x4
45:                
46:                while(1)
47:                {
48:                    spiTask();
0A92  3189     MOVLP 0x9
0A93  2196     CALL 0x196
0A94  318A     MOVLP 0xA
49:                    SYSTEM_Tasks();
50:                    LATCbits.LATC4 = ~LATCbits.LATC4;
0A95  1003     BCF STATUS, 0x0
0A96  0022     MOVLB 0x2
0A97  1E0E     BTFSS LATC, 0x4
0A98  1403     BSF STATUS, 0x0
0A99  1803     BTFSC STATUS, 0x0
0A9A  2A9C     GOTO 0x29C
0A9B  2A9F     GOTO 0x29F
0A9C  0022     MOVLB 0x2
0A9D  160E     BSF LATC, 0x4
0A9E  2AA1     GOTO 0x2A1
0A9F  0022     MOVLB 0x2
0AA0  120E     BCF LATC, 0x4
51:                    #if defined(USB_POLLING)
52:                        // Interrupt or polling method.  If using polling, must call
53:                        // this function periodically.  This function will take care
54:                        // of processing and responding to SETUP transactions
55:                        // (such as during the enumeration process when you first
56:                        // plug in).  USB hosts require that USB devices should accept
57:                        // and process SETUP packets in a timely fashion.  Therefore,
58:                        // when using polling, this function should be called
59:                        // regularly (such as once every 1.8ms or faster** [see
60:                        // inline code comments in usb_device.c for explanation when
61:                        // "or faster" applies])  In most cases, the USBDeviceTasks()
62:                        // function does not take very long to execute (ex: <100
63:                        // instruction cycles) before it returns.
64:                        USBDeviceTasks();
0AA1  3181     MOVLP 0x1
0AA2  21AB     CALL 0x1AB
0AA3  318A     MOVLP 0xA
65:                        USBDeviceTasks();
0AA4  3181     MOVLP 0x1
0AA5  21AB     CALL 0x1AB
0AA6  318A     MOVLP 0xA
66:                    #endif
67:            
68:                    // If the USB device isn't configured yet, we can't really do anything
69:                    // else since we don't have a host to talk to.  So jump back to the
70:                    // top of the while loop. 
71:                    if( USBGetDeviceState() < CONFIGURED_STATE )
0AA7  3020     MOVLW 0x20
0AA8  0021     MOVLB 0x1
0AA9  0254     SUBWF USBDeviceState, W
0AAA  1803     BTFSC STATUS, 0x0
0AAB  2AAD     GOTO 0x2AD
0AAC  2AAE     GOTO 0x2AE
0AAD  2AAF     GOTO 0x2AF
0AAE  2A92     GOTO 0x292
72:                    {
73:                        // Jump back to the top of the while loop. 
74:                        continue;
75:                    }
76:            
77:                    // If we are currently suspended, then we need to see if we need to
78:                    // issue a remote wakeup.  In either case, we shouldn't process any
79:                    // keyboard commands since we aren't currently communicating to the host
80:                    // thus just continue back to the start of the while loop. 
81:                    if( USBIsDeviceSuspended() == true )
0AAF  003D     MOVLB 0x1D
0AB0  1C8E     BTFSS UCON, 0x1
0AB1  2AB3     GOTO 0x2B3
0AB2  2AB4     GOTO 0x2B4
0AB3  2AB5     GOTO 0x2B5
0AB4  2A92     GOTO 0x292
82:                    {
83:                        // Jump back to the top of the while loop. 
84:                        continue;
85:                    }
86:            
87:                    //Application specific tasks
88:                    APP_DeviceJoystickTasks();
0AB5  3183     MOVLP 0x3
0AB6  23F1     CALL 0x3F1
0AB7  318A     MOVLP 0xA
0AB8  2A92     GOTO 0x292
0AB9  3180     MOVLP 0x0
89:                    
90:                    
91:                    //endfor
92:            
93:                }//end while
94:            }//end main
95:            
96:            /*******************************************************************************
97:             End of File
98:            */
99:            
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_events.c  --------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #include "include/system.h"
22:            
23:            #include "include/usb/usb.h"
24:            #include "include/usb/usb_device_hid.h"
25:            
26:            #include "include/app_device_joystick.h"
27:            #include "include/app_led_usb_status.h"
28:            
29:            /*******************************************************************
30:             * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
31:             *                        USB_EVENT event, void *pdata, uint16_t size)
32:             *
33:             * PreCondition:    None
34:             *
35:             * Input:           USB_EVENT event - the type of event
36:             *                  void *pdata - pointer to the event data
37:             *                  uint16_t size - size of the event data
38:             *
39:             * Output:          None
40:             *
41:             * Side Effects:    None
42:             *
43:             * Overview:        This function is called from the USB stack to
44:             *                  notify a user application that a USB event
45:             *                  occured.  This callback is in interrupt context
46:             *                  when the USB_INTERRUPT option is selected.
47:             *
48:             * Note:            None
49:             *******************************************************************/
50:            bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
51:            {
52:                switch( (int) event )
0AFE  2B1B     GOTO 0x31B
53:                {
54:                    case EVENT_TRANSFER:
55:                        break;
56:            
57:                    case EVENT_SOF:
58:                        /* We are using the SOF as a timer to time the LED indicator.  Call
59:                         * the LED update function here. */
60:                        APP_LEDUpdateUSBStatus();
0AFF  318C     MOVLP 0xC
0B00  243F     CALL 0x43F
0B01  318A     MOVLP 0xA
61:                        break;
0B02  2B43     GOTO 0x343
62:            
63:                    case EVENT_SUSPEND:
64:                        /* Update the LED status for the suspend event. */
65:                        APP_LEDUpdateUSBStatus();
0B03  318C     MOVLP 0xC
0B04  243F     CALL 0x43F
0B05  318A     MOVLP 0xA
66:            
67:                        //Call the hardware platform specific handler for suspend events for
68:                        //possible further action (like optionally going reconfiguring the application
69:                        //for lower power states and going to sleep during the suspend event).  This
70:                        //would normally be done in USB compliant bus powered applications, although
71:                        //no further processing is needed for purely self powered applications that
72:                        //don't consume power from the host.
73:                        SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND);
0B06  3001     MOVLW 0x1
0B07  3188     MOVLP 0x8
0B08  20C9     CALL 0xC9
0B09  318A     MOVLP 0xA
74:                        break;
0B0A  2B43     GOTO 0x343
75:            
76:                    case EVENT_RESUME:
77:                        /* Update the LED status for the resume event. */
78:                        APP_LEDUpdateUSBStatus();
0B0B  318C     MOVLP 0xC
0B0C  243F     CALL 0x43F
0B0D  318A     MOVLP 0xA
79:            
80:                        //Call the hardware platform specific resume from suspend handler (ex: to
81:                        //restore I/O pins to higher power states if they were changed during the 
82:                        //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
83:                        //of the suspend condition.
84:                        SYSTEM_Initialize(SYSTEM_STATE_USB_RESUME);
0B0E  3002     MOVLW 0x2
0B0F  3188     MOVLP 0x8
0B10  20C9     CALL 0xC9
0B11  318A     MOVLP 0xA
85:                        break;
0B12  2B43     GOTO 0x343
86:            
87:                    case EVENT_CONFIGURED:
88:                        /* When the device is configured, we can (re)initialize the demo
89:                         * code. */
90:                        APP_DeviceJoystickInitialize();
0B13  3189     MOVLP 0x9
0B14  21BF     CALL 0x1BF
0B15  318A     MOVLP 0xA
91:                        break;
0B16  2B43     GOTO 0x343
92:            
93:                    case EVENT_SET_DESCRIPTOR:
94:                        break;
95:            
96:                    case EVENT_EP0_REQUEST:
97:                        /* We have received a non-standard USB request.  The HID driver
98:                         * needs to check to see if the request was for it. */
99:                        USBCheckHIDRequest();
0B17  3182     MOVLP 0x2
0B18  22DA     CALL 0x2DA
0B19  318A     MOVLP 0xA
100:                       break;
0B1A  2B43     GOTO 0x343
101:           
102:                   case EVENT_BUS_ERROR:
103:                       break;
104:           
105:                   case EVENT_TRANSFER_TERMINATED:
106:                       break;
107:           
108:                   default:
109:                       break;
110:               }
0B1B  0021     MOVLB 0x1
0B1C  085A     MOVF 0xDA, W
0B1D  3A00     XORLW 0x0
0B1E  1903     BTFSC STATUS, 0x2
0B1F  2B24     GOTO 0x324
0B20  3A7F     XORLW 0x7F
0B21  1903     BTFSC STATUS, 0x2
0B22  2B3E     GOTO 0x33E
0B23  2B43     GOTO 0x343
0B24  0859     MOVF __pcstackBANK1, W
0B25  3A01     XORLW 0x1
0B26  1903     BTFSC STATUS, 0x2
0B27  2B13     GOTO 0x313
0B28  3A03     XORLW 0x3
0B29  1903     BTFSC STATUS, 0x2
0B2A  2B43     GOTO 0x343
0B2B  3A01     XORLW 0x1
0B2C  1903     BTFSC STATUS, 0x2
0B2D  2B17     GOTO 0x317
0B2E  3A06     XORLW 0x6
0B2F  1903     BTFSC STATUS, 0x2
0B30  2B43     GOTO 0x343
0B31  3A77     XORLW 0x77
0B32  1903     BTFSC STATUS, 0x2
0B33  2B43     GOTO 0x343
0B34  3A01     XORLW 0x1
0B35  1903     BTFSC STATUS, 0x2
0B36  2AFF     GOTO 0x2FF
0B37  3A07     XORLW 0x7
0B38  1903     BTFSC STATUS, 0x2
0B39  2B0B     GOTO 0x30B
0B3A  3A01     XORLW 0x1
0B3B  1903     BTFSC STATUS, 0x2
0B3C  2B03     GOTO 0x303
0B3D  2B43     GOTO 0x343
0B3E  0859     MOVF __pcstackBANK1, W
0B3F  3AFF     XORLW 0xFF
0B40  1903     BTFSC STATUS, 0x2
0B41  2B43     GOTO 0x343
0B42  2B43     GOTO 0x343
111:               return true;
112:           }
0B43  0008     RETURN
113:           
114:           
115:           /*******************************************************************************
116:            End of File
117:           */
118:           
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device_hid.c  ----------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Human Interface Device (HID) Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device_hid.c
30:            
31:              Summary:
32:                USB Device Human Interface Device (HID) Layer interface API.
33:            
34:              Description:
35:                USB Device Human Interface Device (HID) Layer interface API.
36:            *******************************************************************************/
37:            
38:            
39:            // *****************************************************************************
40:            // *****************************************************************************
41:            // Section: Included Files
42:            // *****************************************************************************
43:            // *****************************************************************************
44:            #include "include/usb/usb_config.h"
45:            #include "include/usb/usb.h"
46:            #include "include/usb/usb_device_hid.h"
47:            
48:            #if defined(__XC8)
49:                #define PACKED
50:                #define ALIGNED
51:            #else
52:                #define PACKED __attribute__((packed))
53:                #define ALIGNED __attribute__((aligned))
54:            #endif
55:            
56:            // *****************************************************************************
57:            // *****************************************************************************
58:            // Section: File Scope or Global Constants
59:            // *****************************************************************************
60:            // *****************************************************************************
61:            
62:            // *****************************************************************************
63:            // *****************************************************************************
64:            // Section: File Scope Data Types
65:            // *****************************************************************************
66:            // *****************************************************************************
67:            typedef struct PACKED
68:            {
69:                unsigned :8;
70:                unsigned :8;
71:                uint8_t reportId;
72:                uint8_t duration;
73:            } USB_SETUP_SET_IDLE_RATE;
74:            
75:            typedef struct PACKED
76:            {
77:                unsigned :8;
78:                unsigned :8;
79:                uint8_t protocol;
80:            } USB_SETUP_SET_PROTOCOL;
81:            
82:            // *****************************************************************************
83:            // *****************************************************************************
84:            // Section: Variables
85:            // *****************************************************************************
86:            // *****************************************************************************
87:            static uint8_t idle_rate;
88:            static uint8_t active_protocol;   // [0] Boot Protocol [1] Report Protocol
89:            
90:            extern const struct{uint8_t report[HAPTIC_RPT_SIZE];}HAPTIC_rpt;
91:            extern const struct{uint8_t report[LED_RPT_SIZE];}LED_rpt;
92:            extern const struct{uint8_t report[DISPLAY_RPT_SIZE];}DISPLAY_rpt;
93:            
94:            // *****************************************************************************
95:            // *****************************************************************************
96:            // Section: Prototypes
97:            // *****************************************************************************
98:            // *****************************************************************************
99:            #if defined USER_GET_REPORT_HANDLER
100:               void USER_GET_REPORT_HANDLER(void);
101:           #endif
102:           
103:           #if defined USER_SET_REPORT_HANDLER
104:               extern void USER_SET_REPORT_HANDLER(void);
105:           #endif
106:           
107:           // *****************************************************************************
108:           // *****************************************************************************
109:           // Section: Macros or Functions
110:           // *****************************************************************************
111:           // *****************************************************************************
112:           
113:           //To implement a set idle rate callback function in the application,
114:           //Make sure "#define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportID, newIdleRate)    USBHIDCBSetIdleRateHandler(reportID, newIdleRate)"
115:           //is placed in your usb_config.h file, and then in your application .c file,
116:           //add the void USBHIDCBSetIdleRateHandler(reportID, newIdleRate) function
117:           //implementation that saves the new idle rate and report ID info, so that it
118:           //gets used later when sending subsequent HID input report packets to the host.
119:           #ifndef USB_DEVICE_HID_IDLE_RATE_CALLBACK
120:               #define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportId, idleRate)
121:           #else
122:               extern void USB_DEVICE_HID_IDLE_RATE_CALLBACK(uint8_t reportId, uint8_t idleRate);
123:           #endif
124:           
125:           /********************************************************************
126:           	Function:
127:           		void USBCheckHIDRequest(void)
128:           
129:            	Summary:
130:            		This routine handles HID specific request that happen on EP0.
131:                   This function should be called from the USBCBCheckOtherReq() call back
132:                   function whenever implementing a HID device.
133:           
134:            	Description:
135:            		This routine handles HID specific request that happen on EP0.  These
136:                   include, but are not limited to, requests for the HID report
137:                   descriptors.  This function should be called from the
138:                   USBCBCheckOtherReq() call back function whenever using an HID device.
139:           
140:                   Typical Usage:
141:                   <code>
142:                   void USBCBCheckOtherReq(void)
143:                   {
144:                       //Since the stack didn't handle the request I need to check
145:                       //  my class drivers to see if it is for them
146:                       USBCheckHIDRequest();
147:                   }
148:                   </code>
149:           
150:           	PreCondition:
151:           		None
152:           
153:           	Parameters:
154:           		None
155:           
156:           	Return Values:
157:           		None
158:           
159:           	Remarks:
160:           		None
161:           
162:            *******************************************************************/
163:           void USBCheckHIDRequest(void)
164:           {
165:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
02DA  0020     MOVLB 0x0
02DB  0860     MOVF SetupPkt, W
02DC  391F     ANDLW 0x1F
02DD  3A01     XORLW 0x1
02DE  1903     BTFSC STATUS, 0x2
02DF  2AE1     GOTO 0x2E1
02E0  2AE2     GOTO 0x2E2
02E1  2AE3     GOTO 0x2E3
02E2  2BF0     GOTO 0x3F0
166:               if(SetupPkt.bIntfID != HID_INTF_HAP_ID && SetupPkt.bIntfID != HID_INTF_LED_ID && SetupPkt.bIntfID != HID_INTF_DSP_ID ) return;
02E3  0864     MOVF 0x64, W
02E4  1903     BTFSC STATUS, 0x2
02E5  2AE7     GOTO 0x2E7
02E6  2AE8     GOTO 0x2E8
02E7  2AF4     GOTO 0x2F4
02E8  0364     DECF 0x64, W
02E9  1903     BTFSC STATUS, 0x2
02EA  2AEC     GOTO 0x2EC
02EB  2AED     GOTO 0x2ED
02EC  2AF4     GOTO 0x2F4
02ED  3002     MOVLW 0x2
02EE  0664     XORWF 0x64, W
02EF  1903     BTFSC STATUS, 0x2
02F0  2AF2     GOTO 0x2F2
02F1  2AF3     GOTO 0x2F3
02F2  2AF4     GOTO 0x2F4
02F3  2BF0     GOTO 0x3F0
167:           
168:               /*
169:                * There are two standard requests that hid.c may support.
170:                * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
171:                * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
172:                */
173:               if(SetupPkt.bRequest == USB_REQUEST_GET_DESCRIPTOR)
02F4  3006     MOVLW 0x6
02F5  0661     XORWF 0x61, W
02F6  1D03     BTFSS STATUS, 0x2
02F7  2AF9     GOTO 0x2F9
02F8  2AFA     GOTO 0x2FA
02F9  2B96     GOTO 0x396
02FA  2B83     GOTO 0x383
174:               {
175:                   switch(SetupPkt.bDescriptorType)
176:                   {
177:                       case DSC_HID: //HID Descriptor
178:                           if(USBActiveConfiguration == 1)
02FB  0021     MOVLB 0x1
02FC  0358     DECF USBActiveConfiguration, W
02FD  1D03     BTFSS STATUS, 0x2
02FE  2B00     GOTO 0x300
02FF  2B01     GOTO 0x301
0300  2B96     GOTO 0x396
179:                           {
180:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
0301  0020     MOVLB 0x0
0302  0864     MOVF 0x64, W
0303  0465     IORWF 0x65, W
0304  1D03     BTFSS STATUS, 0x2
0305  2B07     GOTO 0x307
0306  2B08     GOTO 0x308
0307  2B15     GOTO 0x315
181:                                   USBEP0SendROMPtr(
0308  3012     MOVLW 0x12
0309  0021     MOVLB 0x1
030A  00B8     MOVWF inPipes
030B  3090     MOVLW 0x90
030C  00B9     MOVWF 0xB9
030D  3009     MOVLW 0x9
030E  00BB     MOVWF 0xBB
030F  3000     MOVLW 0x0
0310  00BC     MOVWF 0xBC
0311  30C0     MOVLW 0xC0
0312  00F0     MOVWF 0xF0
0313  0870     MOVF 0xF0, W
0314  00BA     MOVWF 0xBA
182:                                       (const uint8_t*)&configDescriptor1 + 18,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
183:                                       sizeof(USB_HID_DSC)+3,
184:                                       USB_EP0_INCLUDE_ZERO);
185:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
0315  0020     MOVLB 0x0
0316  0364     DECF 0x64, W
0317  0465     IORWF 0x65, W
0318  1D03     BTFSS STATUS, 0x2
0319  2B1B     GOTO 0x31B
031A  2B1C     GOTO 0x31C
031B  2B29     GOTO 0x329
186:                                   USBEP0SendROMPtr(
031C  3032     MOVLW 0x32
031D  0021     MOVLB 0x1
031E  00B8     MOVWF inPipes
031F  3090     MOVLW 0x90
0320  00B9     MOVWF 0xB9
0321  3009     MOVLW 0x9
0322  00BB     MOVWF 0xBB
0323  3000     MOVLW 0x0
0324  00BC     MOVWF 0xBC
0325  30C0     MOVLW 0xC0
0326  00F0     MOVWF 0xF0
0327  0870     MOVF 0xF0, W
0328  00BA     MOVWF 0xBA
187:                                       (const uint8_t*)&configDescriptor1 + 50,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
188:                                       sizeof(USB_HID_DSC)+3,
189:                                       USB_EP0_INCLUDE_ZERO);
190:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
0329  3002     MOVLW 0x2
032A  0020     MOVLB 0x0
032B  0664     XORWF 0x64, W
032C  0465     IORWF 0x65, W
032D  1D03     BTFSS STATUS, 0x2
032E  2B30     GOTO 0x330
032F  2B31     GOTO 0x331
0330  2B96     GOTO 0x396
191:                                   USBEP0SendROMPtr(
0331  3052     MOVLW 0x52
0332  0021     MOVLB 0x1
0333  00B8     MOVWF inPipes
0334  3090     MOVLW 0x90
0335  00B9     MOVWF 0xB9
0336  3009     MOVLW 0x9
0337  00BB     MOVWF 0xBB
0338  3000     MOVLW 0x0
0339  00BC     MOVWF 0xBC
033A  30C0     MOVLW 0xC0
033B  00F0     MOVWF 0xF0
033C  0870     MOVF 0xF0, W
033D  00BA     MOVWF 0xBA
033E  2B96     GOTO 0x396
192:                                       (const uint8_t*)&configDescriptor1 + 82,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
193:                                       sizeof(USB_HID_DSC)+3,
194:                                       USB_EP0_INCLUDE_ZERO);
195:                           }
196:                           break;
197:                       case DSC_RPT:  //Report Descriptor
198:                           if(USBActiveConfiguration == 1)
033F  0021     MOVLB 0x1
0340  0358     DECF USBActiveConfiguration, W
0341  1D03     BTFSS STATUS, 0x2
0342  2B44     GOTO 0x344
0343  2B45     GOTO 0x345
0344  2B96     GOTO 0x396
199:                           {
200:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
0345  0020     MOVLB 0x0
0346  0864     MOVF 0x64, W
0347  0465     IORWF 0x65, W
0348  1D03     BTFSS STATUS, 0x2
0349  2B4B     GOTO 0x34B
034A  2B4C     GOTO 0x34C
034B  2B59     GOTO 0x359
201:                                   USBEP0SendROMPtr(
034C  3069     MOVLW 0x69
034D  0021     MOVLB 0x1
034E  00B8     MOVWF inPipes
034F  3090     MOVLW 0x90
0350  00B9     MOVWF 0xB9
0351  3057     MOVLW 0x57
0352  00BB     MOVWF 0xBB
0353  3000     MOVLW 0x0
0354  00BC     MOVWF 0xBC
0355  30C0     MOVLW 0xC0
0356  00F0     MOVWF 0xF0
0357  0870     MOVF 0xF0, W
0358  00BA     MOVWF 0xBA
202:                                       (const uint8_t*)&HAPTIC_rpt,
203:                                       HAPTIC_RPT_SIZE,     //See usbcfg.h
204:                                       USB_EP0_INCLUDE_ZERO);
205:                               
206:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
0359  0020     MOVLB 0x0
035A  0364     DECF 0x64, W
035B  0465     IORWF 0x65, W
035C  1D03     BTFSS STATUS, 0x2
035D  2B5F     GOTO 0x35F
035E  2B60     GOTO 0x360
035F  2B6D     GOTO 0x36D
207:                                   USBEP0SendROMPtr(
0360  30F4     MOVLW 0xF4
0361  0021     MOVLB 0x1
0362  00B8     MOVWF inPipes
0363  3090     MOVLW 0x90
0364  00B9     MOVWF 0xB9
0365  301C     MOVLW 0x1C
0366  00BB     MOVWF 0xBB
0367  3000     MOVLW 0x0
0368  00BC     MOVWF 0xBC
0369  30C0     MOVLW 0xC0
036A  00F0     MOVWF 0xF0
036B  0870     MOVF 0xF0, W
036C  00BA     MOVWF 0xBA
208:                                       (const uint8_t*)&LED_rpt,
209:                                       LED_RPT_SIZE,     //See usbcfg.h
210:                                       USB_EP0_INCLUDE_ZERO);
211:                               
212:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
036D  3002     MOVLW 0x2
036E  0020     MOVLB 0x0
036F  0664     XORWF 0x64, W
0370  0465     IORWF 0x65, W
0371  1D03     BTFSS STATUS, 0x2
0372  2B74     GOTO 0x374
0373  2B75     GOTO 0x375
0374  2B96     GOTO 0x396
213:                                   USBEP0SendROMPtr(
0375  302C     MOVLW 0x2C
0376  0021     MOVLB 0x1
0377  00B8     MOVWF inPipes
0378  3091     MOVLW 0x91
0379  00B9     MOVWF 0xB9
037A  301C     MOVLW 0x1C
037B  00BB     MOVWF 0xBB
037C  3000     MOVLW 0x0
037D  00BC     MOVWF 0xBC
037E  30C0     MOVLW 0xC0
037F  00F0     MOVWF 0xF0
0380  0870     MOVF 0xF0, W
0381  00BA     MOVWF 0xBA
0382  2B96     GOTO 0x396
214:                                       (const uint8_t*)&DISPLAY_rpt,
215:                                       LED_RPT_SIZE,     //See usbcfg.h
216:                                       USB_EP0_INCLUDE_ZERO);
217:                           }
218:                           break;
219:                       case DSC_PHY:  //Physical Descriptor
220:           				//Note: The below placeholder code is commented out.  HID Physical Descriptors are optional and are not used
221:           				//in many types of HID applications.  If an application does not have a physical descriptor,
222:           				//then the device should return STALL in response to this request (stack will do this automatically
223:           				//if no-one claims ownership of the control transfer).
224:           				//If an application does implement a physical descriptor, then make sure to declare
225:           				//hid_phy01 (rom structure containing the descriptor data), and hid_phy01 (the size of the descriptors in uint8_ts),
226:           				//and then uncomment the below code.
227:                           //if(USBActiveConfiguration == 1)
228:                           //{
229:                           //    USBEP0SendROMPtr((const uint8_t*)&hid_phy01, sizeof(hid_phy01), USB_EP0_INCLUDE_ZERO);
230:                           //}
231:                           break;
232:                   }//end switch(SetupPkt.bDescriptorType)
0383  0863     MOVF i, W
0384  00F0     MOVWF 0xF0
0385  01F1     CLRF 0xF1
0386  0871     MOVF 0xF1, W
0387  3A00     XORLW 0x0
0388  1903     BTFSC STATUS, 0x2
0389  2B8B     GOTO 0x38B
038A  2B96     GOTO 0x396
038B  0870     MOVF 0xF0, W
038C  3A21     XORLW 0x21
038D  1903     BTFSC STATUS, 0x2
038E  2AFB     GOTO 0x2FB
038F  3A03     XORLW 0x3
0390  1903     BTFSC STATUS, 0x2
0391  2B3F     GOTO 0x33F
0392  3A01     XORLW 0x1
0393  1903     BTFSC STATUS, 0x2
0394  2B96     GOTO 0x396
0395  2B96     GOTO 0x396
233:               }//end if(SetupPkt.bRequest == GET_DSC)
234:           
235:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD)
0396  0020     MOVLB 0x0
0397  0E60     SWAPF SetupPkt, W
0398  0C89     RRF WREG, F
0399  3903     ANDLW 0x3
039A  3A01     XORLW 0x1
039B  1903     BTFSC STATUS, 0x2
039C  2B9E     GOTO 0x39E
039D  2B9F     GOTO 0x39F
039E  2BD4     GOTO 0x3D4
039F  2BF0     GOTO 0x3F0
236:               {
237:                   return;
238:               }
239:           
240:               switch(SetupPkt.bRequest)
241:               {
242:                   case GET_REPORT:
243:                       #if defined USER_GET_REPORT_HANDLER
244:                           USER_GET_REPORT_HANDLER();
245:                       #endif
246:                       break;
247:                   case SET_REPORT:
248:                       #if defined USER_SET_REPORT_HANDLER
249:                           USER_SET_REPORT_HANDLER();
250:                       #endif
251:                       break;
252:                   case GET_IDLE:
253:                       USBEP0SendRAMPtr(
03A0  30D6     MOVLW 0xD6
03A1  0021     MOVLB 0x1
03A2  00B8     MOVWF inPipes
03A3  3000     MOVLW 0x0
03A4  00B9     MOVWF 0xB9
03A5  3001     MOVLW 0x1
03A6  00BB     MOVWF 0xBB
03A7  3000     MOVLW 0x0
03A8  00BC     MOVWF 0xBC
03A9  30C1     MOVLW 0xC1
03AA  00F0     MOVWF 0xF0
03AB  0870     MOVF 0xF0, W
03AC  00BA     MOVWF 0xBA
254:                           (uint8_t*)&idle_rate,
255:                           1,
256:                           USB_EP0_INCLUDE_ZERO);
257:                       break;
03AD  2BF0     GOTO 0x3F0
258:                   case SET_IDLE:
259:                       USBEP0Transmit(USB_EP0_NO_DATA);
03AE  3080     MOVLW 0x80
03AF  00F0     MOVWF 0xF0
03B0  0870     MOVF 0xF0, W
03B1  0021     MOVLB 0x1
03B2  00BA     MOVWF 0xBA
260:                       idle_rate = SetupPkt.W_Value.byte.HB;
03B3  0020     MOVLB 0x0
03B4  0863     MOVF 0x63, W
03B5  00F0     MOVWF __pcstackCOMMON
03B6  0870     MOVF __pcstackCOMMON, W
03B7  0021     MOVLB 0x1
03B8  00D6     MOVWF idle_rate
261:                       USB_DEVICE_HID_IDLE_RATE_CALLBACK(SetupPkt.W_Value.byte.LB, idle_rate);
262:                       break;
03B9  2BF0     GOTO 0x3F0
263:                   case GET_PROTOCOL:
264:                       USBEP0SendRAMPtr(
03BA  30D5     MOVLW 0xD5
03BB  0021     MOVLB 0x1
03BC  00B8     MOVWF inPipes
03BD  3000     MOVLW 0x0
03BE  00B9     MOVWF 0xB9
03BF  3001     MOVLW 0x1
03C0  00BB     MOVWF 0xBB
03C1  3000     MOVLW 0x0
03C2  00BC     MOVWF 0xBC
03C3  3081     MOVLW 0x81
03C4  00F0     MOVWF 0xF0
03C5  0870     MOVF 0xF0, W
03C6  00BA     MOVWF 0xBA
265:                           (uint8_t*)&active_protocol,
266:                           1,
267:                           USB_EP0_NO_OPTIONS);
268:                       break;
03C7  2BF0     GOTO 0x3F0
269:                   case SET_PROTOCOL:
270:                       USBEP0Transmit(USB_EP0_NO_DATA);
03C8  3080     MOVLW 0x80
03C9  00F0     MOVWF 0xF0
03CA  0870     MOVF 0xF0, W
03CB  0021     MOVLB 0x1
03CC  00BA     MOVWF 0xBA
271:                       active_protocol = SetupPkt.W_Value.byte.LB;
03CD  0020     MOVLB 0x0
03CE  0862     MOVF 0x62, W
03CF  00F0     MOVWF __pcstackCOMMON
03D0  0870     MOVF __pcstackCOMMON, W
03D1  0021     MOVLB 0x1
03D2  00D5     MOVWF active_protocol
272:                       break;
03D3  2BF0     GOTO 0x3F0
273:               }//end switch(SetupPkt.bRequest)
03D4  0861     MOVF pUEP, W
03D5  00F0     MOVWF 0xF0
03D6  01F1     CLRF 0xF1
03D7  0871     MOVF 0xF1, W
03D8  3A00     XORLW 0x0
03D9  1903     BTFSC STATUS, 0x2
03DA  2BDC     GOTO 0x3DC
03DB  2BF0     GOTO 0x3F0
03DC  0870     MOVF 0xF0, W
03DD  3A01     XORLW 0x1
03DE  1903     BTFSC STATUS, 0x2
03DF  2BF0     GOTO 0x3F0
03E0  3A03     XORLW 0x3
03E1  1903     BTFSC STATUS, 0x2
03E2  2BA0     GOTO 0x3A0
03E3  3A01     XORLW 0x1
03E4  1903     BTFSC STATUS, 0x2
03E5  2BBA     GOTO 0x3BA
03E6  3A0A     XORLW 0xA
03E7  1903     BTFSC STATUS, 0x2
03E8  2BF0     GOTO 0x3F0
03E9  3A03     XORLW 0x3
03EA  1903     BTFSC STATUS, 0x2
03EB  2BAE     GOTO 0x3AE
03EC  3A01     XORLW 0x1
03ED  1903     BTFSC STATUS, 0x2
03EE  2BC8     GOTO 0x3C8
03EF  2BF0     GOTO 0x3F0
274:           
275:           }//end USBCheckHIDRequest
03F0  0008     RETURN
276:           
277:           /********************************************************************
278:               Function:
279:                   USB_HANDLE HIDTxPacket(uint8_t ep, uint8_t* data, uint16_t len)
280:           
281:               Summary:
282:                   Sends the specified data out the specified endpoint
283:           
284:               Description:
285:                   This function sends the specified data out the specified
286:                   endpoint and returns a handle to the transfer information.
287:           
288:                   Typical Usage:
289:                   <code>
290:                   //make sure that the last transfer isn't busy by checking the handle
291:                   if(!HIDTxHandleBusy(USBInHandle))
292:                   {
293:                       //Send the data contained in the ToSendDataBuffer[] array out on
294:                       //  endpoint HID_EP
295:                       USBInHandle = HIDTxPacket(HID_EP,(uint8_t*)&ToSendDataBuffer[0],sizeof(ToSendDataBuffer));
296:                   }
297:                   </code>
298:           
299:               PreCondition:
300:                   None
301:           
302:               Parameters:
303:                   uint8_t ep    - the endpoint you want to send the data out of
304:                   uint8_t* data - pointer to the data that you wish to send
305:                   uint16_t len   - the length of the data that you wish to send
306:           
307:               Return Values:
308:                   USB_HANDLE - a handle for the transfer.  This information
309:                   should be kept to track the status of the transfer
310:           
311:               Remarks:
312:                   None
313:           
314:            *******************************************************************/
315:            // Implemented as a macro. See usb_function_hid.h
316:           
317:           /********************************************************************
318:               Function:
319:                   USB_HANDLE HIDRxPacket(uint8_t ep, uint8_t* data, uint16_t len)
320:           
321:               Summary:
322:                   Receives the specified data out the specified endpoint
323:           
324:               Description:
325:                   Receives the specified data out the specified endpoint.
326:           
327:                   Typical Usage:
328:                   <code>
329:                   //Read 64-uint8_ts from endpoint HID_EP, into the ReceivedDataBuffer array.
330:                   //  Make sure to save the return handle so that we can check it later
331:                   //  to determine when the transfer is complete.
332:                   USBOutHandle = HIDRxPacket(HID_EP,(uint8_t*)&ReceivedDataBuffer,64);
333:                   </code>
334:           
335:               PreCondition:
336:                   None
337:           
338:               Parameters:
339:                   uint8_t ep    - the endpoint you want to receive the data into
340:                   uint8_t* data - pointer to where the data will go when it arrives
341:                   uint16_t len   - the length of the data that you wish to receive
342:           
343:               Return Values:
344:                   USB_HANDLE - a handle for the transfer.  This information
345:                   should be kept to track the status of the transfer
346:           
347:               Remarks:
348:                   None
349:           
350:            *******************************************************************/
351:             // Implemented as a macro. See usb_function_hid.h
352:           
353:           /*******************************************************************************
354:            End of File
355:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device.c  --------------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <xc.h>
46:            
47:            #include <stdint.h>
48:            #include <stddef.h>
49:            #include <string.h>
50:            
51:            #include "include/usb/usb_config.h"
52:            
53:            #include "include/usb/usb.h"
54:            #include "include/usb/usb_ch9.h"
55:            #include "include/usb/usb_device.h"
56:            #include "include/usb/usb_device_local.h"
57:            
58:            #ifndef uintptr_t
59:                #if  defined(__XC8__) || defined(__XC16__)
60:                    #define uintptr_t uint16_t
61:                #elif defined (__XC32__)
62:                    #define uintptr_t uint32_t
63:                #endif
64:            #endif
65:            
66:            #if defined(USB_USE_MSD)
67:                #include "usb_device_msd.h"
68:            #endif
69:            
70:            // *****************************************************************************
71:            // *****************************************************************************
72:            // Section: File Scope or Global Constants
73:            // *****************************************************************************
74:            // *****************************************************************************
75:            #if !defined(USE_USB_BUS_SENSE_IO)
76:                //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                //been properly defined elsewhere in the project.
79:                #undef USB_BUS_SENSE
80:                #define USB_BUS_SENSE 1
81:            #endif
82:            
83:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                #define _DTS_CHECKING_ENABLED 0
85:            #else
86:                #define _DTS_CHECKING_ENABLED _DTSEN
87:            #endif
88:            
89:            #if !defined(self_power)
90:                //Assume the application is always bus powered, unless self_power has been
91:                //defined elsewhere in the project
92:                #define self_power 0    //0 = bus powered
93:            #endif
94:            
95:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                //Assume the application only implements one configuration descriptor,
97:                //unless otherwise specified elsewhere in the project
98:                #define USB_MAX_NUM_CONFIG_DSC      1
99:            #endif
100:           
101:           #if defined(__XC8)
102:               //Suppress expected/harmless compiler warning message about unused RAM variables
103:               //and certain function pointer usage.
104:               //Certain variables and function pointers are not used if you don't use all
105:               //of the USB stack APIs.  However, these variables should not be
106:               //removed (since they are still used/needed in some applications, and this
107:               //is a common file shared by many projects, some of which rely on the "unused"
108:               //variables/function pointers).
109:               #pragma warning disable 1090
110:               #if __XC8_VERSION > 1300
111:                   #pragma warning disable 1471
112:               #endif
113:           #endif
114:           
115:           // *****************************************************************************
116:           // *****************************************************************************
117:           // Section: File Scope Data Types
118:           // *****************************************************************************
119:           // *****************************************************************************
120:           typedef union
121:           {
122:               uint8_t Val;
123:               struct __PACKED
124:               {
125:                   unsigned b0:1;
126:                   unsigned b1:1;
127:                   unsigned b2:1;
128:                   unsigned b3:1;
129:                   unsigned b4:1;
130:                   unsigned b5:1;
131:                   unsigned b6:1;
132:                   unsigned b7:1;
133:               } bits;
134:           } uint8_t_VAL, uint8_t_BITS;
135:           
136:           // *****************************************************************************
137:           // *****************************************************************************
138:           // Section: Variables
139:           // *****************************************************************************
140:           // *****************************************************************************
141:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:           USB_VOLATILE uint8_t USBActiveConfiguration;
143:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:           USB_VOLATILE uint8_t shortPacketStatus;
149:           USB_VOLATILE uint8_t controlTransferState;
150:           USB_VOLATILE IN_PIPE inPipes[1];
151:           USB_VOLATILE OUT_PIPE outPipes[1];
152:           USB_VOLATILE uint8_t *pDst;
153:           USB_VOLATILE bool RemoteWakeup;
154:           USB_VOLATILE bool USBBusIsSuspended;
155:           USB_VOLATILE USTAT_FIELDS USTATcopy;
156:           USB_VOLATILE uint8_t endpoint_number;
157:           USB_VOLATILE bool BothEP0OutUOWNsSet;
158:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:           volatile bool USBDeferStatusStagePacket;
162:           volatile bool USBStatusStageEnabledFlag1;
163:           volatile bool USBStatusStageEnabledFlag2;
164:           volatile bool USBDeferINDataStagePackets;
165:           volatile bool USBDeferOUTDataStagePackets;
166:           USB_VOLATILE uint32_t USB1msTickCount;
167:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:           
169:           /** USB FIXED LOCATION VARIABLES ***********************************/
170:           #if defined(COMPILER_MPLAB_C18)
171:               #pragma udata USB_BDT=USB_BDT_ADDRESS
172:           #endif
173:           
174:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:           
176:           /********************************************************************
177:            * EP0 Buffer Space
178:            *******************************************************************/
179:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:           
182:           /********************************************************************
183:            * non-EP0 Buffer Space
184:            *******************************************************************/
185:           #if defined(USB_USE_MSD)
186:               //Check if the MSD application specific USB endpoint buffer placement address
187:               //macros have already been defined or not (ex: in a processor specific header)
188:               //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:               //must be at a certain address range on certain microcontrollers).
190:               #if !defined(MSD_CBW_ADDR_TAG)
191:                   //Not previously defined.  Assume in this case all microcontroller RAM is
192:                   //USB module accessible, and therefore, no specific address tag value is needed.
193:                   #define MSD_CBW_ADDR_TAG
194:                   #define MSD_CSW_ADDR_TAG
195:               #endif
196:           	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:           	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:           
199:               #if defined(__18CXX) || defined(__XC8)
200:                   #if(__XC8_VERSION < 2000)
201:                   volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
202:                   #else
203:                       volatile char msd_buffer[512] __at(MSD_BUFFER_ADDRESS);
204:                   #endif
205:               #else
206:                   volatile char msd_buffer[512];
207:           	#endif
208:           #endif
209:           
210:           //Depricated in v2.2 - will be removed in a future revision
211:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
212:               //Device descriptor
213:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
214:           #else
215:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
216:           #endif
217:           
218:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
219:               //Array of configuration descriptors
220:               extern const uint8_t *const USB_CD_Ptr[];
221:           #else
222:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
223:           #endif
224:           
225:           extern const uint8_t *const USB_SD_Ptr[];
226:           
227:           
228:           // *****************************************************************************
229:           // *****************************************************************************
230:           // Section: Private and External Prototypes
231:           // *****************************************************************************
232:           // *****************************************************************************
233:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
234:           
235:           static void USBCtrlEPService(void);
236:           static void USBCtrlTrfSetupHandler(void);
237:           static void USBCtrlTrfInHandler(void);
238:           static void USBCheckStdRequest(void);
239:           static void USBStdGetDscHandler(void);
240:           static void USBCtrlEPServiceComplete(void);
241:           static void USBCtrlTrfTxService(void);
242:           static void USBCtrlTrfRxService(void);
243:           static void USBStdSetCfgHandler(void);
244:           static void USBStdGetStatusHandler(void);
245:           static void USBStdFeatureReqHandler(void);
246:           static void USBCtrlTrfOutHandler(void);
247:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
248:           static void USBWakeFromSuspend(void);
249:           static void USBSuspend(void);
250:           static void USBStallHandler(void);
251:           
252:           // *****************************************************************************
253:           // *****************************************************************************
254:           // Section: Macros or Functions
255:           // *****************************************************************************
256:           // *****************************************************************************
257:           
258:           /**************************************************************************
259:               Function:
260:                   void USBDeviceInit(void)
261:           
262:               Description:
263:                   This function initializes the device stack it in the default state. The
264:                   USB module will be completely reset including all of the internal
265:                   variables, registers, and interrupt flags.
266:           
267:               Precondition:
268:                   This function must be called before any of the other USB Device
269:                   functions can be called, including USBDeviceTasks().
270:           
271:               Parameters:
272:                   None
273:           
274:               Return Values:
275:                   None
276:           
277:               Remarks:
278:                   None
279:           
280:             ***************************************************************************/
281:           void USBDeviceInit(void)
282:           {
283:               uint8_t i;
284:           
285:               USBDisableInterrupts();
0594  0021     MOVLB 0x1
0595  1112     BCF PIE2, 0x2
286:           
287:               //Make sure that if a GPIO output driver exists on VBUS, that it is
288:               //tri-stated to avoid potential contention with the host
289:               USB_HAL_VBUSTristate();
290:           
291:               // Clear all USB error flags
292:               USBClearInterruptRegister(U1EIR);
0596  003D     MOVLB 0x1D
0597  0193     CLRF UEIR
293:           
294:               // Clears all USB interrupts
295:               USBClearInterruptRegister(U1IR);
0598  0190     CLRF UIR
296:           
297:               //Clear all of the endpoint control registers
298:               U1EP0 = 0;
0599  0198     CLRF UEP0
299:           
300:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
059A  300E     MOVLW 0xE
059B  00F2     MOVWF 0xEF2
059C  3099     MOVLW 0x99
059D  00F1     MOVWF 0xEF1
059E  01F3     CLRF _USBStdSetCfgHandler
059F  0871     MOVF 0xEF1, W
05A0  0086     MOVWF FSR1L
05A1  0872     MOVF 0xEF2, W
05A2  0087     MOVWF FSR1H
05A3  0181     CLRF INDF1
05A4  3001     MOVLW 0x1
05A5  07F1     ADDWF 0xEF1, F
05A6  3000     MOVLW 0x0
05A7  3DF2     ADDWFC 0xEF2, F
05A8  3001     MOVLW 0x1
05A9  00F0     MOVWF 0xEF0
05AA  0870     MOVF 0xEF0, W
05AB  07F3     ADDWF _USBStdSetCfgHandler, F
05AC  3003     MOVLW 0x3
05AD  0273     SUBWF _USBStdSetCfgHandler, W
05AE  1C03     BTFSS STATUS, 0x0
05AF  2DB1     GOTO 0x5B1
05B0  2DB2     GOTO 0x5B2
05B1  2D9F     GOTO 0x59F
301:           
302:               SetConfigurationOptions();
05B2  3016     MOVLW 0x16
05B3  003D     MOVLB 0x1D
05B4  0091     MOVWF UCFG
05B5  309F     MOVLW 0x9F
05B6  0097     MOVWF UEIE
05B7  307B     MOVLW 0x7B
05B8  0092     MOVWF UIE
303:           
304:               //power up the module (if not already powered)
305:               USBPowerModule();
306:           
307:               //set the address of the BDT (if applicable)
308:               USBSetBDTAddress(BDT);
309:           
310:               //Clear all of the BDT entries
311:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
05B9  01F4     CLRF 0xEF4
312:               {
313:                   BDT[i].Val = 0x00;
05BA  0874     MOVF 0xEF4, W
05BB  00F0     MOVWF 0xEF0
05BC  3001     MOVLW 0x1
05BD  35F0     LSLF 0xEF0, F
05BE  3EFF     ADDLW 0xFF
05BF  1D03     BTFSS STATUS, 0x2
05C0  2DBD     GOTO 0x5BD
05C1  3570     LSLF 0xEF0, W
05C2  3E20     ADDLW 0x20
05C3  0086     MOVWF FSR1L
05C4  0187     CLRF FSR1H
05C5  3000     MOVLW 0x0
05C6  3FC0     MOVWI 0[FSR1]
05C7  3000     MOVLW 0x0
05C8  3FC1     MOVWI 1[FSR1]
05C9  3FC2     MOVWI 2[FSR1]
05CA  3FC3     MOVWI 3[FSR1]
314:               }
05CB  3001     MOVLW 0x1
05CC  00F0     MOVWF 0xEF0
05CD  0870     MOVF 0xEF0, W
05CE  07F4     ADDWF 0xEF4, F
05CF  3010     MOVLW 0x10
05D0  0274     SUBWF 0xEF4, W
05D1  1C03     BTFSS STATUS, 0x0
05D2  2DD4     GOTO 0x5D4
05D3  2DD5     GOTO 0x5D5
05D4  2DBA     GOTO 0x5BA
315:           
316:               // Assert reset request to all of the Ping Pong buffer pointers
317:               USBPingPongBufferReset = 1;
05D5  003D     MOVLB 0x1D
05D6  170E     BSF UCON, 0x6
318:           
319:               // Reset to default address
320:               U1ADDR = 0x00;
05D7  0196     CLRF UADDR
321:           
322:               // Make sure packet processing is enabled
323:               USBPacketDisable = 0;
05D8  120E     BCF UCON, 0x4
324:           
325:               //Stop trying to reset ping pong buffer pointers
326:               USBPingPongBufferReset = 0;
05D9  130E     BCF UCON, 0x6
327:           
328:               // Flush any pending transactions
329:               do
330:               {
331:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
05DA  30F7     MOVLW 0xF7
05DB  00F0     MOVWF 0xEF0
05DC  0870     MOVF 0xEF0, W
05DD  0590     ANDWF UIR, F
332:                   //Initialize USB stack software state variables
333:                   inPipes[0].info.Val = 0;
05DE  0021     MOVLB 0x1
05DF  01BA     CLRF 0xBA
334:                   outPipes[0].info.Val = 0;
05E0  0022     MOVLB 0x2
05E1  01A2     CLRF 0x122
335:                   outPipes[0].wCount.Val = 0;
05E2  01A3     CLRF 0x123
05E3  01A4     CLRF 0x124
336:               }while(USBTransactionCompleteIF == 1);
05E4  003D     MOVLB 0x1D
05E5  1990     BTFSC UIR, 0x3
05E6  2DE8     GOTO 0x5E8
05E7  2DE9     GOTO 0x5E9
05E8  2DDA     GOTO 0x5DA
337:           
338:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
339:               //try and arm a status stage, even before the first control transfer starts.
340:               USBStatusStageEnabledFlag1 = true;
05E9  3001     MOVLW 0x1
05EA  00F0     MOVWF 0xEF0
05EB  0870     MOVF 0xEF0, W
05EC  0021     MOVLB 0x1
05ED  00C9     MOVWF USBStatusStageEnabledFlag1
341:               USBStatusStageEnabledFlag2 = true;
05EE  3001     MOVLW 0x1
05EF  00F0     MOVWF 0xF0
05F0  0870     MOVF 0xF0, W
05F1  00C8     MOVWF USBStatusStageEnabledFlag2
342:               //Initialize other flags
343:               USBDeferINDataStagePackets = false;
05F2  01C7     CLRF USBDeferINDataStagePackets
344:               USBDeferOUTDataStagePackets = false;
05F3  01C6     CLRF USBDeferOUTDataStagePackets
345:               USBBusIsSuspended = false;
05F4  01CE     CLRF USBBusIsSuspended
346:           
347:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
348:               //pointers to NULL, so they don't get used inadvertently.
349:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
05F5  01F4     CLRF 0xF4
350:               {
351:                   pBDTEntryIn[i] = 0u;
05F6  3574     LSLF 0xF4, W
05F7  3EB0     ADDLW 0xB0
05F8  0086     MOVWF FSR1L
05F9  0187     CLRF FSR1H
05FA  3000     MOVLW 0x0
05FB  3FC0     MOVWI 0[FSR1]
05FC  3FC1     MOVWI 1[FSR1]
352:                   pBDTEntryOut[i] = 0u;
05FD  3574     LSLF 0xF4, W
05FE  3EA0     ADDLW 0xA0
05FF  0086     MOVWF FSR1L
0600  3001     MOVLW 0x1
0601  0087     MOVWF FSR1H
0602  3000     MOVLW 0x0
0603  3FC0     MOVWI 0[FSR1]
0604  3FC1     MOVWI 1[FSR1]
353:                   ep_data_in[i].Val = 0u;
0605  0874     MOVF 0xF4, W
0606  3EB0     ADDLW 0xB0
0607  0086     MOVWF FSR1L
0608  3001     MOVLW 0x1
0609  0087     MOVWF FSR1H
060A  0181     CLRF INDF1
354:                   ep_data_out[i].Val = 0u;
060B  0874     MOVF 0xF4, W
060C  3EAC     ADDLW 0xAC
060D  0086     MOVWF FSR1L
060E  3001     MOVLW 0x1
060F  0087     MOVWF FSR1H
0610  0181     CLRF INDF1
355:               }
0611  3001     MOVLW 0x1
0612  00F0     MOVWF 0xF0
0613  0870     MOVF 0xF0, W
0614  07F4     ADDWF 0xF4, F
0615  3004     MOVLW 0x4
0616  0274     SUBWF 0xF4, W
0617  1C03     BTFSS STATUS, 0x0
0618  2E1A     GOTO 0x61A
0619  2E1B     GOTO 0x61B
061A  2DF6     GOTO 0x5F6
356:           
357:               //Get ready for the first packet
358:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
061B  3028     MOVLW 0x28
061C  0021     MOVLB 0x1
061D  00B0     MOVWF pBDTEntryIn
061E  3000     MOVLW 0x0
061F  00B1     MOVWF 0xB1
359:               // Initialize EP0 as a Ctrl EP
360:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;
0620  3016     MOVLW 0x16
0621  003D     MOVLB 0x1D
0622  0098     MOVWF UEP0
361:           	//Prepare for the first SETUP on EP0 OUT
362:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0623  3000     MOVLW 0x0
0624  0020     MOVLB 0x0
0625  00A3     MOVWF 0x23
0626  3060     MOVLW 0x60
0627  00A2     MOVWF 0x22
363:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0628  3008     MOVLW 0x8
0629  00A1     MOVWF 0x21
364:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
062A  3004     MOVLW 0x4
062B  00F0     MOVWF __pcstackCOMMON
062C  0870     MOVF __pcstackCOMMON, W
062D  00A0     MOVWF BDT
365:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
062E  17A0     BSF BDT, 0x7
366:           
367:               // Clear active configuration
368:               USBActiveConfiguration = 0;
062F  0021     MOVLB 0x1
0630  01D8     CLRF USBActiveConfiguration
369:           
370:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
0631  3000     MOVLW 0x0
0632  0023     MOVLB 0x3
0633  00AB     MOVWF _USBDeviceTasks
0634  3000     MOVLW 0x0
0635  00AA     MOVWF 0x1AA
0636  3000     MOVLW 0x0
0637  00A9     MOVWF 0x1A9
0638  3000     MOVLW 0x0
0639  00A8     MOVWF USB1msTickCount
371:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
063A  0021     MOVLB 0x1
063B  01C5     CLRF USBTicksSinceSuspendEnd
372:           
373:               //Indicate that we are now in the detached state
374:               USBDeviceState = DETACHED_STATE;
063C  01D4     CLRF USBDeviceState
375:           }
063D  0008     RETURN
376:           
377:           
378:           
379:           /**************************************************************************
380:             Function:
381:                   void USBDeviceTasks(void)
382:           
383:             Summary:
384:               This function is the main state machine/transaction handler of the USB
385:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
386:               (usb_config.h user option) the USBDeviceTasks() function should be called
387:               periodically to receive and transmit packets through the stack. This
388:               function also takes care of control transfers associated with the USB
389:               enumeration process, and detecting various USB events (such as suspend).
390:               This function should be called at least once every 1.8ms during the USB
391:               enumeration process. After the enumeration process is complete (which can
392:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
393:               USBDeviceTasks() handler may be called the faster of: either once
394:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
395:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
396:               a minimum rate of either the frequency that USBTransferOnePacket() gets
397:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
398:               near the top of usb_device.c for more details about minimum timing
399:               requirements when calling USBDeviceTasks().
400:           
401:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
402:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
403:               mode, the USBDeviceTasks() handler only needs to execute when a USB
404:               interrupt occurs, and therefore only needs to be called from the interrupt
405:               context.
406:           
407:             Description:
408:               This function is the main state machine/transaction handler of the USB
409:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
410:               (usb_config.h user option) the USBDeviceTasks() function should be called
411:               periodically to receive and transmit packets through the stack. This
412:               function also takes care of control transfers associated with the USB
413:               enumeration process, and detecting various USB events (such as suspend).
414:               This function should be called at least once every 1.8ms during the USB
415:               enumeration process. After the enumeration process is complete (which can
416:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
417:               USBDeviceTasks() handler may be called the faster of: either once
418:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
419:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
420:               a minimum rate of either the frequency that USBTransferOnePacket() gets
421:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
422:               near the top of usb_device.c for more details about minimum timing
423:               requirements when calling USBDeviceTasks().
424:           
425:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
426:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
427:               mode, the USBDeviceTasks() handler only needs to execute when a USB
428:               interrupt occurs, and therefore only needs to be called from the interrupt
429:               context.
430:           
431:               Typical usage:
432:               <code>
433:               void main(void)
434:               {
435:                   USBDeviceInit();
436:                   while(1)
437:                   {
438:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
439:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
440:                          (USBIsDeviceSuspended() == true))
441:                       {
442:                           //Either the device is not configured or we are suspended,
443:                           // so we don't want to execute any USB related application code
444:                           continue;   //go back to the top of the while loop
445:                       }
446:                       else
447:                       {
448:                           //Otherwise we are free to run USB and non-USB related user
449:                           //application code.
450:                           UserApplication();
451:                       }
452:                   }
453:               }
454:               </code>
455:           
456:             Precondition:
457:               Make sure the USBDeviceInit() function has been called prior to calling
458:               USBDeviceTasks() for the first time.
459:             Remarks:
460:               USBDeviceTasks() does not need to be called while in the USB suspend mode,
461:               if the user application firmware in the USBCBSuspend() callback function
462:               enables the ACTVIF USB interrupt source and put the microcontroller into
463:               sleep mode.  If the application firmware decides not to sleep the
464:               microcontroller core during USB suspend (ex: continues running at full
465:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
466:               function must still be called periodically, at a rate frequent enough to
467:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
468:               a worst case primary oscillator and PLL start up time of less than 5ms, then
469:               USBDeviceTasks() should be called once every 5ms in this scenario.
470:           
471:               When the USB cable is detached, or the USB host is not actively powering
472:               the VBUS line to +5V nominal, the application firmware does not always have
473:               to call USBDeviceTasks() frequently, as no USB activity will be taking
474:               place.  However, if USBDeviceTasks() is not called regularly, some
475:               alternative means of promptly detecting when VBUS is powered (indicating
476:               host attachment), or not powered (host powered down or USB cable unplugged)
477:               is still needed.  For self or dual self/bus powered USB applications, see
478:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional
479:               considerations.
480:               ***************************************************************************/
481:           void USBDeviceTasks(void)
482:           {
483:               uint8_t i;
484:           
485:               #ifdef USB_SUPPORT_OTG
486:                   //SRP Time Out Check
487:                   if (USBOTGSRPIsReady())
488:                   {
489:                       if (USBT1MSECIF && USBT1MSECIE)
490:                       {
491:                           if (USBOTGGetSRPTimeOutFlag())
492:                           {
493:                               if (USBOTGIsSRPTimeOutExpired())
494:                               {
495:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
496:                               }
497:                           }
498:           
499:                           //Clear Interrupt Flag
500:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
501:                       }
502:                   }
503:               #endif
504:           
505:               #if defined(USB_POLLING)
506:               //If the interrupt option is selected then the customer is required
507:               //  to notify the stack when the device is attached or removed from the
508:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
509:               if (USB_BUS_SENSE != 1)
510:               {
511:                    // Disable module & detach from bus
512:                    U1CON = 0;
513:           
514:                    // Mask all USB interrupts
515:                    U1IE = 0;
516:           
517:                    //Move to the detached state
518:                    USBDeviceState = DETACHED_STATE;
519:           
520:                    #ifdef  USB_SUPPORT_OTG
521:                        //Disable D+ Pullup
522:                        U1OTGCONbits.DPPULUP = 0;
523:           
524:                        //Disable HNP
525:                        USBOTGDisableHnp();
526:           
527:                        //Deactivate HNP
528:                        USBOTGDeactivateHnp();
529:           
530:                        //If ID Pin Changed State
531:                        if (USBIDIF && USBIDIE)
532:                        {
533:                            //Re-detect & Initialize
534:                             USBOTGInitialize();
535:           
536:                             //Clear ID Interrupt Flag
537:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
538:                        }
539:                    #endif
540:           
541:                    #if defined __C30__ || defined __XC16__
542:                        //USBClearInterruptFlag(U1OTGIR, 3);
543:                    #endif
544:                       //return so that we don't go through the rest of
545:                       //the state machine
546:                    USBClearUSBInterrupt();
547:                    return;
548:               }
549:           
550:           	#ifdef USB_SUPPORT_OTG
551:               //If Session Is Started Then
552:               else
553:           	{
554:                   //If SRP Is Ready
555:                   if (USBOTGSRPIsReady())
556:                   {
557:                       //Clear SRPReady
558:                       USBOTGClearSRPReady();
559:           
560:                       //Clear SRP Timeout Flag
561:                       USBOTGClearSRPTimeOutFlag();
562:           
563:                       //Indicate Session Started
564:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
565:                   }
566:               }
567:           	#endif	//#ifdef USB_SUPPORT_OTG
568:           
569:               //if we are in the detached state
570:               if(USBDeviceState == DETACHED_STATE)
01AB  0021     MOVLB 0x1
01AC  0854     MOVF USBDeviceState, W
01AD  1D03     BTFSS STATUS, 0x2
01AE  29B0     GOTO 0x1B0
01AF  29B1     GOTO 0x1B1
01B0  29C3     GOTO 0x1C3
571:               {
572:           	    //Initialize register to known value
573:                   U1CON = 0;
01B1  003D     MOVLB 0x1D
01B2  018E     CLRF UCON
574:           
575:                   // Mask all USB interrupts
576:                   U1IE = 0;
01B3  0192     CLRF UIE
577:           
578:                   //Enable/set things like: pull ups, full/low-speed mode,
579:                   //set the ping pong mode, and set internal transceiver
580:                   SetConfigurationOptions();
01B4  3016     MOVLW 0x16
01B5  0091     MOVWF UCFG
01B6  309F     MOVLW 0x9F
01B7  0097     MOVWF UEIE
01B8  307B     MOVLW 0x7B
01B9  0092     MOVWF UIE
581:           
582:                   // Enable module & attach to bus
583:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
01BA  29BC     GOTO 0x1BC
01BB  158E     BSF UCON, 0x3
01BC  1D8E     BTFSS UCON, 0x3
01BD  29BF     GOTO 0x1BF
01BE  29C0     GOTO 0x1C0
01BF  29BB     GOTO 0x1BB
584:           
585:                   //moved to the attached state
586:                   USBDeviceState = ATTACHED_STATE;
01C0  0021     MOVLB 0x1
01C1  01D4     CLRF USBDeviceState
01C2  0AD4     INCF USBDeviceState, F
587:           
588:                   #ifdef  USB_SUPPORT_OTG
589:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
590:                   #endif
591:               }
592:           	#endif  //#if defined(USB_POLLING)
593:           
594:               if(USBDeviceState == ATTACHED_STATE)
01C3  0354     DECF USBDeviceState, W
01C4  1D03     BTFSS STATUS, 0x2
01C5  29C7     GOTO 0x1C7
01C6  29C8     GOTO 0x1C8
01C7  29D6     GOTO 0x1D6
595:               {
596:                   /*
597:                    * After enabling the USB module, it takes some time for the
598:                    * voltage on the D+ or D- line to rise high enough to get out
599:                    * of the SE0 condition. The USB Reset interrupt should not be
600:                    * unmasked until the SE0 condition is cleared. This helps
601:                    * prevent the firmware from misinterpreting this unique event
602:                    * as a USB bus reset from the USB host.
603:                    */
604:           
605:                   if(!USBSE0Event)
01C8  003D     MOVLB 0x1D
01C9  1A8E     BTFSC UCON, 0x5
01CA  29CC     GOTO 0x1CC
01CB  29CD     GOTO 0x1CD
01CC  29D6     GOTO 0x1D6
606:                   {
607:                       //We recently attached, make sure we are in a clean state
608:                       #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
609:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
610:                                           //during attach de-bounce interval
611:                       #else
612:                           USBClearInterruptRegister(U1IR);
01CD  0190     CLRF UIR
613:                       #endif
614:           
615:                       #if defined(USB_POLLING)
616:                           U1IE=0;                        // Mask all USB interrupts
01CE  0192     CLRF UIE
617:                       #endif
618:                       USBResetIE = 1;             // Unmask RESET interrupt
01CF  1412     BSF UIE, 0x0
619:                       USBIdleIE = 1;             // Unmask IDLE interrupt
01D0  1612     BSF UIE, 0x4
620:                       USBDeviceState = POWERED_STATE;
01D1  3002     MOVLW 0x2
01D2  0021     MOVLB 0x1
01D3  00EB     MOVWF 0xEB
01D4  086B     MOVF 0xEB, W
01D5  00D4     MOVWF USBDeviceState
621:                   }
622:               }
623:           
624:               #ifdef  USB_SUPPORT_OTG
625:                   //If ID Pin Changed State
626:                   if (USBIDIF && USBIDIE)
627:                   {
628:                       //Re-detect & Initialize
629:                       USBOTGInitialize();
630:           
631:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
632:                   }
633:               #endif
634:           
635:               /*
636:                * Task A: Service USB Activity Interrupt
637:                */
638:               if(USBActivityIF && USBActivityIE)
01D6  003D     MOVLB 0x1D
01D7  1D10     BTFSS UIR, 0x2
01D8  29DA     GOTO 0x1DA
01D9  29DB     GOTO 0x1DB
01DA  29E8     GOTO 0x1E8
01DB  1D12     BTFSS UIE, 0x2
01DC  29DE     GOTO 0x1DE
01DD  29DF     GOTO 0x1DF
01DE  29E8     GOTO 0x1E8
639:               {
640:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
01DF  30FB     MOVLW 0xFB
01E0  0021     MOVLB 0x1
01E1  00EB     MOVWF 0xEB
01E2  086B     MOVF 0xEB, W
01E3  003D     MOVLB 0x1D
01E4  0590     ANDWF UIR, F
641:                   #if defined(USB_SUPPORT_OTG)
642:                       U1OTGIR = 0x10;
643:                   #else
644:                       USBWakeFromSuspend();
01E5  3188     MOVLP 0x8
01E6  20EA     CALL 0xEA
01E7  3181     MOVLP 0x1
645:                   #endif
646:               }
647:           
648:               /*
649:                * Pointless to continue servicing if the device is in suspend mode.
650:                */
651:               if(USBSuspendControl==1)
01E8  003D     MOVLB 0x1D
01E9  1C8E     BTFSS UCON, 0x1
01EA  29EC     GOTO 0x1EC
01EB  29ED     GOTO 0x1ED
01EC  29F0     GOTO 0x1F0
652:               {
653:                   USBClearUSBInterrupt();
01ED  0020     MOVLB 0x0
01EE  1112     BCF PIR2, 0x2
654:                   return;
01EF  2AD9     GOTO 0x2D9
655:               }
656:           
657:               /*
658:                * Task B: Service USB Bus Reset Interrupt.
659:                * When bus reset is received during suspend, ACTVIF will be set first,
660:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
661:                * This is why URSTIF is checked after ACTVIF.
662:                *
663:                * The USB reset flag is masked when the USB state is in
664:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
665:                * cause a USB reset event during these two states.
666:                */
667:               if(USBResetIF && USBResetIE)
01F0  1C10     BTFSS start, 0x0
01F1  29F3     GOTO 0x1F3
01F2  29F4     GOTO 0x1F4
01F3  2A05     GOTO 0x205
01F4  1C12     BTFSS PIR2, 0x0
01F5  29F7     GOTO 0x1F7
01F6  29F8     GOTO 0x1F8
01F7  2A05     GOTO 0x205
668:               {
669:                   USBDeviceInit();
01F8  3185     MOVLP 0x5
01F9  2594     CALL 0x594
01FA  3181     MOVLP 0x1
670:           
671:                   //Re-enable the interrupts since the USBDeviceInit() function will
672:                   //  disable them.  This will do nothing in a polling setup
673:                   USBUnmaskInterrupts();
674:           
675:                   USBDeviceState = DEFAULT_STATE;
01FB  3004     MOVLW 0x4
01FC  0021     MOVLB 0x1
01FD  00EB     MOVWF 0xEB
01FE  086B     MOVF 0xEB, W
01FF  00D4     MOVWF USBDeviceState
676:           
677:                   #ifdef USB_SUPPORT_OTG
678:                        //Disable HNP
679:                        USBOTGDisableHnp();
680:           
681:                        //Deactivate HNP
682:                        USBOTGDeactivateHnp();
683:                   #endif
684:           
685:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
0200  30FE     MOVLW 0xFE
0201  00EB     MOVWF 0xEB
0202  086B     MOVF 0xEB, W
0203  003D     MOVLB 0x1D
0204  0590     ANDWF UIR, F
686:               }
687:           
688:               /*
689:                * Task C: Service other USB interrupts
690:                */
691:               if(USBIdleIF && USBIdleIE)
0205  1E10     BTFSS UIR, 0x4
0206  2A08     GOTO 0x208
0207  2A09     GOTO 0x209
0208  2A10     GOTO 0x210
0209  1E12     BTFSS UIE, 0x4
020A  2A0C     GOTO 0x20C
020B  2A0D     GOTO 0x20D
020C  2A10     GOTO 0x210
692:               {
693:                   #ifdef  USB_SUPPORT_OTG
694:                       //If Suspended, Try to switch to Host
695:                       USBOTGSelectRole(ROLE_HOST);
696:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
697:                   #else
698:                       USBSuspend();
020D  3188     MOVLP 0x8
020E  2090     CALL 0x90
020F  3181     MOVLP 0x1
699:                   #endif
700:               }
701:           
702:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
703:                   //Check if a 1ms interval has elapsed.
704:                   if(USBT1MSECIF)
705:                   {
706:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
707:                       USBIncrement1msInternalTimers();
708:                   }
709:               #endif
710:           
711:               //Start-of-Frame Interrupt
712:               if(USBSOFIF)
0210  003D     MOVLB 0x1D
0211  1F10     BTFSS UIR, 0x6
0212  2A14     GOTO 0x214
0213  2A15     GOTO 0x215
0214  2A42     GOTO 0x242
713:               {
714:                   //Call the user SOF event callback if enabled.
715:                   if(USBSOFIE)
0215  1F12     BTFSS UIE, 0x6
0216  2A18     GOTO 0x218
0217  2A19     GOTO 0x219
0218  2A29     GOTO 0x229
716:                   {
717:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
0219  3073     MOVLW 0x73
021A  0021     MOVLB 0x1
021B  00D9     MOVWF __pcstackBANK1
021C  3000     MOVLW 0x0
021D  00DA     MOVWF 0xDA
021E  3000     MOVLW 0x0
021F  00DB     MOVWF pdata
0220  3000     MOVLW 0x0
0221  00DC     MOVWF 0xDC
0222  3001     MOVLW 0x1
0223  00DD     MOVWF size
0224  3000     MOVLW 0x0
0225  00DE     MOVWF 0xDE
0226  318A     MOVLP 0xA
0227  22FE     CALL 0x2FE
0228  3181     MOVLP 0x1
718:                   }
719:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
0229  30BF     MOVLW 0xBF
022A  0021     MOVLB 0x1
022B  00EB     MOVWF 0xEB
022C  086B     MOVF 0xEB, W
022D  003D     MOVLB 0x1D
022E  0590     ANDWF UIR, F
720:           
721:                   #if defined(__XC8__) || defined(__C18__)
722:                       USBIncrement1msInternalTimers();
022F  3188     MOVLP 0x8
0230  20AC     CALL 0xAC
0231  3181     MOVLP 0x1
723:                   #endif
724:           
725:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
726:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
727:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
728:                           #warning "Double click this message.  See inline code comments."
729:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
730:                           //not strictly needed in all applications (ex: those that never call
731:                           //USBDeferStatusStage() and don't use host to device (OUT) control
732:                           //transfers with data stage).
733:                           //However, if this feature is enabled and used in a low speed application,
734:                           //it is required for the application code to periodically call the
735:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
736:                       #endif
737:           
738:                       //Decrement our status stage counter.
739:                       if(USBStatusStageTimeoutCounter != 0u)
0232  0021     MOVLB 0x1
0233  084B     MOVF USBStatusStageTimeoutCounter, W
0234  1903     BTFSC STATUS, 0x2
0235  2A37     GOTO 0x237
0236  2A38     GOTO 0x238
0237  2A3A     GOTO 0x23A
740:                       {
741:                           USBStatusStageTimeoutCounter--;
0238  3001     MOVLW 0x1
0239  02CB     SUBWF USBStatusStageTimeoutCounter, F
742:                       }
743:                       //Check if too much time has elapsed since progress was made in
744:                       //processing the control transfer, without arming the status stage.
745:                       //If so, auto-arm the status stage to ensure that the control
746:                       //transfer can [eventually] complete, within the timing limits
747:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
748:                       if(USBStatusStageTimeoutCounter == 0)
023A  084B     MOVF USBStatusStageTimeoutCounter, W
023B  1D03     BTFSS STATUS, 0x2
023C  2A3E     GOTO 0x23E
023D  2A3F     GOTO 0x23F
023E  2A42     GOTO 0x242
749:                       {
750:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
023F  318D     MOVLP 0xD
0240  250F     CALL 0x50F
0241  3181     MOVLP 0x1
751:                       }
752:                   #endif
753:               }
754:           
755:               if(USBStallIF && USBStallIE)
0242  003D     MOVLB 0x1D
0243  1E90     BTFSS UIR, 0x5
0244  2A46     GOTO 0x246
0245  2A47     GOTO 0x247
0246  2A4E     GOTO 0x24E
0247  1E92     BTFSS UIE, 0x5
0248  2A4A     GOTO 0x24A
0249  2A4B     GOTO 0x24B
024A  2A4E     GOTO 0x24E
756:               {
757:                   USBStallHandler();
024B  3189     MOVLP 0x9
024C  21E9     CALL 0x1E9
024D  3181     MOVLP 0x1
758:               }
759:           
760:               if(USBErrorIF && USBErrorIE)
024E  003D     MOVLB 0x1D
024F  1C90     BTFSS UIR, 0x1
0250  2A52     GOTO 0x252
0251  2A53     GOTO 0x253
0252  2A69     GOTO 0x269
0253  1C92     BTFSS UIE, 0x1
0254  2A56     GOTO 0x256
0255  2A57     GOTO 0x257
0256  2A69     GOTO 0x269
761:               {
762:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
0257  30FF     MOVLW 0xFF
0258  0021     MOVLB 0x1
0259  00D9     MOVWF __pcstackBANK1
025A  307F     MOVLW 0x7F
025B  00DA     MOVWF 0xDA
025C  3000     MOVLW 0x0
025D  00DB     MOVWF pdata
025E  3000     MOVLW 0x0
025F  00DC     MOVWF 0xDC
0260  3001     MOVLW 0x1
0261  00DD     MOVWF size
0262  3000     MOVLW 0x0
0263  00DE     MOVWF 0xDE
0264  318A     MOVLP 0xA
0265  22FE     CALL 0x2FE
0266  3181     MOVLP 0x1
763:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
0267  003D     MOVLB 0x1D
0268  0193     CLRF UEIR
764:           
765:                   //On PIC18, clearing the source of the error will automatically clear
766:                   //  the interrupt flag.  On other devices the interrupt flag must be
767:                   //  manually cleared.
768:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
769:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
770:                   #endif
771:               }
772:           
773:               /*
774:                * Pointless to continue servicing if the host has not sent a bus reset.
775:                * Once bus reset is received, the device transitions into the DEFAULT
776:                * state and is ready for communication.
777:                */
778:               if(USBDeviceState < DEFAULT_STATE)
0269  3004     MOVLW 0x4
026A  0021     MOVLB 0x1
026B  0254     SUBWF USBDeviceState, W
026C  1803     BTFSC STATUS, 0x0
026D  2A6F     GOTO 0x26F
026E  2A70     GOTO 0x270
026F  2A73     GOTO 0x273
779:               {
780:                   USBClearUSBInterrupt();
0270  0020     MOVLB 0x0
0271  1112     BCF PIR2, 0x2
781:                   return;
0272  2AD9     GOTO 0x2D9
782:               }
783:           
784:               /*
785:                * Task D: Servicing USB Transaction Complete Interrupt
786:                */
787:               if(USBTransactionCompleteIE)
0273  003D     MOVLB 0x1D
0274  1D92     BTFSS UIE, 0x3
0275  2A77     GOTO 0x277
0276  2A78     GOTO 0x278
0277  2AD7     GOTO 0x2D7
788:               {
789:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
0278  0021     MOVLB 0x1
0279  01ED     CLRF i
790:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
791:                       if(USBTransactionCompleteIF)
027A  003D     MOVLB 0x1D
027B  1D90     BTFSS UIR, 0x3
027C  2A7E     GOTO 0x27E
027D  2A7F     GOTO 0x27F
027E  2AD7     GOTO 0x2D7
792:                       {
793:                           //Save and extract USTAT register info.  Will use this info later.
794:                           USTATcopy.Val = U1STAT;
027F  080F     MOVF USTAT, W
0280  0021     MOVLB 0x1
0281  00EB     MOVWF 0xEB
0282  086B     MOVF 0xEB, W
0283  00D7     MOVWF USTATcopy
795:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
0284  0C57     RRF USTATcopy, W
0285  00EB     MOVWF 0xEB
0286  0CEB     RRF 0xEB, F
0287  0C6B     RRF 0xEB, W
0288  390F     ANDLW 0xF
0289  00EC     MOVWF 0xEC
028A  086C     MOVF 0xEC, W
028B  00CD     MOVWF endpoint_number
796:           
797:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
028C  30F7     MOVLW 0xF7
028D  00EB     MOVWF 0xEB
028E  086B     MOVF 0xEB, W
028F  003D     MOVLB 0x1D
0290  0590     ANDWF UIR, F
798:           
799:                           //Keep track of the hardware ping pong state for endpoints other
800:                           //than EP0, if ping pong buffering is enabled.
801:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
802:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
0291  0021     MOVLB 0x1
0292  1957     BTFSC USTATcopy, 0x2
0293  2A95     GOTO 0x295
0294  2A96     GOTO 0x296
0295  2AA6     GOTO 0x2A6
803:                           {
804:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
0296  084D     MOVF endpoint_number, W
0297  3EAC     ADDLW 0xAC
0298  0086     MOVWF FSR1L
0299  3001     MOVLW 0x1
029A  0087     MOVWF FSR1H
029B  0801     MOVF INDF1, W
029C  3901     ANDLW 0x1
029D  00EB     MOVWF 0xEB
029E  3001     MOVLW 0x1
029F  06EB     XORWF 0xEB, F
02A0  0801     MOVF INDF1, W
02A1  066B     XORWF 0xEB, W
02A2  39FE     ANDLW 0xFE
02A3  066B     XORWF 0xEB, W
02A4  0081     MOVWF INDF1
805:                           }
02A5  2AB5     GOTO 0x2B5
806:                           else
807:                           {
808:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
02A6  084D     MOVF endpoint_number, W
02A7  3EB0     ADDLW 0xB0
02A8  0086     MOVWF FSR1L
02A9  3001     MOVLW 0x1
02AA  0087     MOVWF FSR1H
02AB  0801     MOVF INDF1, W
02AC  3901     ANDLW 0x1
02AD  00EB     MOVWF 0xEB
02AE  3001     MOVLW 0x1
02AF  06EB     XORWF 0xEB, F
02B0  0801     MOVF INDF1, W
02B1  066B     XORWF 0xEB, W
02B2  39FE     ANDLW 0xFE
02B3  066B     XORWF 0xEB, W
02B4  0081     MOVWF INDF1
809:                           }
810:                           #endif
811:           
812:                           //USBCtrlEPService only services transactions over EP0.
813:                           //It ignores all other EP transactions.
814:                           if(endpoint_number == 0)
02B5  084D     MOVF endpoint_number, W
02B6  1D03     BTFSS STATUS, 0x2
02B7  2AB9     GOTO 0x2B9
02B8  2ABA     GOTO 0x2BA
02B9  2ABE     GOTO 0x2BE
815:                           {
816:                               USBCtrlEPService();
02BA  318B     MOVLP 0xB
02BB  238C     CALL 0x38C
02BC  3181     MOVLP 0x1
817:                           }
02BD  2ACC     GOTO 0x2CC
818:                           else
819:                           {
820:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
02BE  3072     MOVLW 0x72
02BF  00D9     MOVWF __pcstackBANK1
02C0  3000     MOVLW 0x0
02C1  00DA     MOVWF 0xDA
02C2  30D7     MOVLW 0xD7
02C3  00DB     MOVWF pdata
02C4  3000     MOVLW 0x0
02C5  00DC     MOVWF 0xDC
02C6  3000     MOVLW 0x0
02C7  00DD     MOVWF size
02C8  00DE     MOVWF 0xDE
02C9  318A     MOVLP 0xA
02CA  22FE     CALL 0x2FE
02CB  3181     MOVLP 0x1
821:                           }
822:                       }//end if(USBTransactionCompleteIF)
823:                       else
824:                       {
825:                           break;	//USTAT FIFO must be empty.
826:                       }
827:                   }//end for()
02CC  3001     MOVLW 0x1
02CD  0021     MOVLB 0x1
02CE  00EB     MOVWF 0xEB
02CF  086B     MOVF 0xEB, W
02D0  07ED     ADDWF i, F
02D1  3004     MOVLW 0x4
02D2  026D     SUBWF i, W
02D3  1C03     BTFSS STATUS, 0x0
02D4  2AD6     GOTO 0x2D6
02D5  2AD7     GOTO 0x2D7
02D6  2A7A     GOTO 0x27A
828:               }//end if(USBTransactionCompleteIE)
829:           
830:               USBClearUSBInterrupt();
02D7  0020     MOVLB 0x0
02D8  1112     BCF PIR2, 0x2
831:           }//end of USBDeviceTasks()
02D9  0008     RETURN
832:           
833:           /*******************************************************************************
834:             Function:
835:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
836:           
837:             Summary:
838:               This function will enable the specified endpoint with the specified
839:               options
840:             Description:
841:               This function will enable the specified endpoint with the specified
842:               options.
843:           
844:               Typical Usage:
845:               <code>
846:               void USBCBInitEP(void)
847:               {
848:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
849:                   USBMSDInit();
850:               }
851:               </code>
852:           
853:               In the above example endpoint number MSD_DATA_IN_EP is being configured
854:               for both IN and OUT traffic with handshaking enabled. Also since
855:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
856:               explicitly disable SETUP packets on this endpoint.
857:             Conditions:
858:               None
859:             Input:
860:               uint8_t ep -       the endpoint to be configured
861:               uint8_t options -  optional settings for the endpoint. The options should
862:                               be ORed together to form a single options string. The
863:                               available optional settings for the endpoint. The
864:                               options should be ORed together to form a single options
865:                               string. The available options are the following\:
866:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
867:                                 NAK)
868:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
869:                                 NAK)
870:                               * USB_OUT_ENABLED enables the out direction
871:                               * USB_OUT_DISABLED disables the out direction
872:                               * USB_IN_ENABLED enables the in direction
873:                               * USB_IN_DISABLED disables the in direction
874:                               * USB_ALLOW_SETUP enables control transfers
875:                               * USB_DISALLOW_SETUP disables control transfers
876:                               * USB_STALL_ENDPOINT STALLs this endpoint
877:             Return:
878:               None
879:             Remarks:
880:               None
881:             *****************************************************************************/
882:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
0971  00FC     MOVWF ep
883:           {
884:               unsigned char* p;
885:           
886:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and
887:               //starting DTS state in the BDT entry.
888:               if(options & USB_OUT_ENABLED)
0972  1D77     BTFSS tmp, 0x2
0973  2975     GOTO 0x175
0974  2976     GOTO 0x176
0975  297B     GOTO 0x17B
889:               {
890:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
0976  01F0     CLRF __pcstackCOMMON
0977  087C     MOVF ep, W
0978  318A     MOVLP 0xA
0979  22BB     CALL 0x2BB
097A  3189     MOVLP 0x9
891:               }
892:               if(options & USB_IN_ENABLED)
097B  1CF7     BTFSS tmp, 0x1
097C  297E     GOTO 0x17E
097D  297F     GOTO 0x17F
097E  2985     GOTO 0x185
893:               {
894:                   USBConfigureEndpoint(ep, IN_TO_HOST);
097F  01F0     CLRF __pcstackCOMMON
0980  0AF0     INCF __pcstackCOMMON, F
0981  087C     MOVF ep, W
0982  318A     MOVLP 0xA
0983  22BB     CALL 0x2BB
0984  3189     MOVLP 0x9
895:               }
896:           
897:               //Update the relevant UEPx register to actually enable the endpoint with
898:               //the specified options (ex: handshaking enabled, control transfers allowed,
899:               //etc.)
900:               #if defined(__C32__)
901:                   p = (unsigned char*)(&U1EP0+(4*ep));
902:               #else
903:                   p = (unsigned char*)(&U1EP0+ep);
0985  087C     MOVF ep, W
0986  3E98     ADDLW 0x98
0987  00F8     MOVWF d1
0988  01F9     CLRF d
0989  300E     MOVLW 0xE
098A  3DF9     ADDWFC d, F
098B  0878     MOVF d1, W
098C  00FA     MOVWF p
098D  0879     MOVF d, W
098E  00FB     MOVWF 0x7B
904:               #endif
905:               *p = options;
098F  087A     MOVF p, W
0990  0086     MOVWF FSR1
0991  087B     MOVF 0x7B, W
0992  0087     MOVWF FSR1H
0993  0877     MOVF tmp, W
0994  0081     MOVWF INDF1
906:           }
0995  0008     RETURN
907:           
908:           
909:           /*************************************************************************
910:             Function:
911:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
912:           
913:             Summary:
914:               Transfers a single packet (one transaction) of data on the USB bus.
915:           
916:             Description:
917:               The USBTransferOnePacket() function prepares a USB endpoint
918:               so that it may send data to the host (an IN transaction), or
919:               receive data from the host (an OUT transaction).  The
920:               USBTransferOnePacket() function can be used both to receive	and
921:               send data to the host.  This function is the primary API function
922:               provided by the USB stack firmware for sending or receiving application
923:               data over the USB port.
924:           
925:               The USBTransferOnePacket() is intended for use with all application
926:               endpoints.  It is not used for sending or receiving application data
927:               through endpoint 0 by using control transfers.  Separate API
928:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
929:               USBEP0SendROMPtr() are provided for this purpose.
930:           
931:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
932:               entry associated with an endpoint buffer, and sets the UOWN bit, which
933:               prepares the USB hardware to allow the transaction to complete.  The
934:               application firmware can use the USBHandleBusy() macro to check the
935:               status of the transaction, to see if the data has been successfully
936:               transmitted yet.
937:           
938:           
939:               Typical Usage
940:               <code>
941:               //make sure that the we are in the configured state
942:               if(USBGetDeviceState() == CONFIGURED_STATE)
943:               {
944:                   //make sure that the last transaction isn't busy by checking the handle
945:                   if(!USBHandleBusy(USBInHandle))
946:                   {
947:           	        //Write the new data that we wish to send to the host to the INPacket[] array
948:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
949:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
950:           	        //INPacket[2] = ... (fill in the rest of the packet data)
951:           
952:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
953:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
954:                   }
955:               }
956:               </code>
957:           
958:             Conditions:
959:               Before calling USBTransferOnePacket(), the following should be true.
960:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
961:               2.  A transaction is not already pending on the specified endpoint.  This
962:                   is done by checking the previous request using the USBHandleBusy()
963:                   macro (see the typical usage example).
964:               3.  The host has already sent a set configuration request and the
965:                   enumeration process is complete.
966:                   This can be checked by verifying that the USBGetDeviceState()
967:                   macro returns "CONFIGURED_STATE", prior to calling
968:                   USBTransferOnePacket().
969:           
970:             Input:
971:               uint8_t ep - The endpoint number that the data will be transmitted or
972:           	          received on
973:               uint8_t dir - The direction of the transfer
974:                          This value is either OUT_FROM_HOST or IN_TO_HOST
975:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
976:                            the data to be sent to the host.  For OUT transactions: pointer
977:                            to the RAM buffer that the received data should get written to.
978:              uint8_t len - Length of the data needing to be sent (for IN transactions).
979:                         For OUT transactions, the len parameter should normally be set
980:                         to the endpoint size specified in the endpoint descriptor.
981:           
982:             Return Values:
983:               USB_HANDLE - handle to the transfer.  The handle is a pointer to
984:                            the BDT entry associated with this transaction.  The
985:                            status of the transaction (ex: if it is complete or still
986:                            pending) can be checked using the USBHandleBusy() macro
987:                            and supplying the USB_HANDLE provided by
988:                            USBTransferOnePacket().
989:           
990:             Remarks:
991:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
992:               callback function, the set configuration is still being processed and the
993:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case,
994:               the USBTransferOnePacket() may still be called, but make sure that the
995:               endpoint has been enabled and initialized by the USBEnableEndpoint()
996:               function first.
997:           
998:             *************************************************************************/
999:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
0F79  00F8     MOVWF d1
1000:          {
1001:              volatile BDT_ENTRY* handle;
1002:          
1003:              //If the direction is IN
1004:              if(dir != 0)
0F7A  0870     MOVF __pcstackCOMMON, W
0F7B  1903     BTFSC STATUS, 0x2
0F7C  2F7E     GOTO 0x77E
0F7D  2F7F     GOTO 0x77F
0F7E  2F88     GOTO 0x788
1005:              {
1006:                  //point to the IN BDT of the specified endpoint
1007:                  handle = pBDTEntryIn[ep];
0F7F  3578     LSLF d1, W
0F80  3EB0     ADDLW 0xB0
0F81  0086     MOVWF FSR1
0F82  0187     CLRF FSR1H
0F83  3F40     MOVIW 0[FSR1]
0F84  00F9     MOVWF d
0F85  3F41     MOVIW 1[FSR1]
0F86  00FA     MOVWF p
1008:              }
0F87  2F91     GOTO 0x791
1009:              else
1010:              {
1011:                  //else point to the OUT BDT of the specified endpoint
1012:                  handle = pBDTEntryOut[ep];
0F88  3578     LSLF d1, W
0F89  3EA0     ADDLW 0xA0
0F8A  0086     MOVWF FSR1
0F8B  3001     MOVLW 0x1
0F8C  0087     MOVWF FSR1H
0F8D  3F40     MOVIW 0[FSR1]
0F8E  00F9     MOVWF d
0F8F  3F41     MOVIW 1[FSR1]
0F90  00FA     MOVWF p
1013:              }
1014:          
1015:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1016:              //pBDTEntryOut[ep]) is initialized before using it.
1017:              if(handle == 0)
0F91  0879     MOVF d, W
0F92  047A     IORWF p, W
0F93  1D03     BTFSS STATUS, 0x2
0F94  2F96     GOTO 0x796
0F95  2F97     GOTO 0x797
0F96  2F9A     GOTO 0x79A
1018:              {
1019:                  return 0;
0F97  01F0     CLRF __pcstackCOMMON
0F98  01F1     CLRF p
0F99  2FFF     GOTO 0x7FF
1020:              }
1021:          
1022:              //Toggle the DTS bit if required
1023:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1024:                  handle->STAT.Val ^= _DTSMASK;
1025:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1026:                  if(ep != 0)
1027:                  {
1028:                      handle->STAT.Val ^= _DTSMASK;
1029:                  }
1030:              #endif
1031:          
1032:              //Set the data pointer, data length, and enable the endpoint
1033:              handle->ADR = ConvertToPhysicalAddress(data);
0F9A  30FF     MOVLW 0xFF
0F9B  0571     ANDWF p, W
0F9C  00F4     MOVWF i
0F9D  307F     MOVLW 0x7F
0F9E  0572     ANDWF n, W
0F9F  00F5     MOVWF s
0FA0  0879     MOVF d, W
0FA1  0086     MOVWF FSR1
0FA2  087A     MOVF p, W
0FA3  0087     MOVWF FSR1H
0FA4  3142     ADDFSR 1, 2
0FA5  0874     MOVF i, W
0FA6  3FC0     MOVWI 0[FSR1]
0FA7  0875     MOVF s, W
0FA8  3FC1     MOVWI 1[FSR1]
1034:              handle->CNT = len;
0FA9  0879     MOVF d, W
0FAA  3E01     ADDLW 0x1
0FAB  00F4     MOVWF i
0FAC  3000     MOVLW 0x0
0FAD  3D7A     ADDWFC p, W
0FAE  00F5     MOVWF s
0FAF  0874     MOVF i, W
0FB0  0086     MOVWF FSR1
0FB1  0875     MOVF s, W
0FB2  0087     MOVWF FSR1H
0FB3  0873     MOVF i, W
0FB4  0081     MOVWF INDF1
1035:              handle->STAT.Val &= _DTSMASK;
0FB5  3040     MOVLW 0x40
0FB6  00F4     MOVWF i
0FB7  0879     MOVF d, W
0FB8  0086     MOVWF FSR1
0FB9  087A     MOVF p, W
0FBA  0087     MOVWF FSR1H
0FBB  0874     MOVF i, W
0FBC  0581     ANDWF INDF1, F
1036:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
0FBD  0879     MOVF d, W
0FBE  0086     MOVWF FSR1
0FBF  087A     MOVF p, W
0FC0  0087     MOVWF FSR1H
0FC1  1581     BSF INDF1, 0x3
1037:              handle->STAT.Val |= _USIE;
0FC2  0879     MOVF d, W
0FC3  0086     MOVWF FSR1
0FC4  087A     MOVF p, W
0FC5  0087     MOVWF FSR1H
0FC6  1781     BSF INDF1, 0x7
1038:          
1039:              //Point to the next buffer for ping pong purposes.
1040:              if(dir != OUT_FROM_HOST)
0FC7  0870     MOVF __pcstackCOMMON, W
0FC8  1903     BTFSC STATUS, 0x2
0FC9  2FCB     GOTO 0x7CB
0FCA  2FCC     GOTO 0x7CC
0FCB  2FE3     GOTO 0x7E3
1041:              {
1042:                  //toggle over the to the next buffer for an IN endpoint
1043:                  pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
0FCC  3578     LSLF d1, W
0FCD  3EB0     ADDLW 0xB0
0FCE  0086     MOVWF FSR1
0FCF  0187     CLRF FSR1H
0FD0  3F40     MOVIW 0[FSR1]
0FD1  00F4     MOVWF i
0FD2  3F41     MOVIW 1[FSR1]
0FD3  00F5     MOVWF s
0FD4  3004     MOVLW 0x4
0FD5  0674     XORWF i, W
0FD6  00F6     MOVWF handle
0FD7  3000     MOVLW 0x0
0FD8  0675     XORWF s, W
0FD9  00F7     MOVWF tmp
0FDA  3578     LSLF d1, W
0FDB  3EB0     ADDLW 0xB0
0FDC  0086     MOVWF FSR1
0FDD  0187     CLRF FSR1H
0FDE  0876     MOVF handle, W
0FDF  3FC0     MOVWI 0[FSR1]
0FE0  0877     MOVF tmp, W
0FE1  3FC1     MOVWI 1[FSR1]
1044:              }
0FE2  2FFB     GOTO 0x7FB
1045:              else
1046:              {
1047:                  //toggle over the to the next buffer for an OUT endpoint
1048:                  pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
0FE3  3578     LSLF d1, W
0FE4  3EA0     ADDLW 0xA0
0FE5  0086     MOVWF FSR1
0FE6  3001     MOVLW 0x1
0FE7  0087     MOVWF FSR1H
0FE8  3F40     MOVIW 0[FSR1]
0FE9  00F4     MOVWF i
0FEA  3F41     MOVIW 1[FSR1]
0FEB  00F5     MOVWF s
0FEC  3004     MOVLW 0x4
0FED  0674     XORWF i, W
0FEE  00F6     MOVWF handle
0FEF  3000     MOVLW 0x0
0FF0  0675     XORWF s, W
0FF1  00F7     MOVWF tmp
0FF2  3578     LSLF d1, W
0FF3  3EA0     ADDLW 0xA0
0FF4  0086     MOVWF FSR1
0FF5  3001     MOVLW 0x1
0FF6  0087     MOVWF FSR1H
0FF7  0876     MOVF handle, W
0FF8  3FC0     MOVWI 0[FSR1]
0FF9  0877     MOVF tmp, W
0FFA  3FC1     MOVWI 1[FSR1]
1049:              }
1050:              return (USB_HANDLE)handle;
0FFB  087A     MOVF p, W
0FFC  00F1     MOVWF p
0FFD  0879     MOVF d, W
0FFE  00F0     MOVWF __pcstackCOMMON
1051:          }
0FFF  0008     RETURN
1052:          
1053:          
1054:          /********************************************************************
1055:              Function:
1056:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1057:          
1058:              Summary:
1059:                   Configures the specified endpoint to send STALL to the host, the next
1060:                   time the host tries to access the endpoint.
1061:          
1062:              PreCondition:
1063:                  None
1064:          
1065:              Parameters:
1066:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1067:                  uint8_t dir - The direction of the endpoint to STALL, either
1068:                             IN_TO_HOST or OUT_FROM_HOST.
1069:          
1070:              Return Values:
1071:                  None
1072:          
1073:              Remarks:
1074:                  None
1075:          
1076:           *******************************************************************/
1077:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
1078:          {
1079:              BDT_ENTRY *p;
1080:          
1081:              if(ep == 0)
1082:              {
1083:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1084:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP
1085:                  //packet that will arrive.
1086:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1087:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1088:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1089:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1090:                  pBDTEntryIn[0]->STAT.Val = _BSTALL;
1091:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1092:          
1093:              }
1094:              else
1095:              {
1096:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1097:                  p->STAT.Val |= _BSTALL;
1098:                  p->STAT.Val |= _USIE;
1099:          
1100:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1101:                  //then stall that entry as well
1102:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1103:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1104:                  p->STAT.Val |= _BSTALL;
1105:                  p->STAT.Val |= _USIE;
1106:                  #endif
1107:              }
1108:          }
1109:          
1110:          /**************************************************************************
1111:              Function:
1112:                  void USBCancelIO(uint8_t endpoint)
1113:          
1114:              Description:
1115:                  This function cancels the transfers pending on the specified endpoint.
1116:                  This function can only be used after a SETUP packet is received and
1117:                  before that setup packet is handled.  This is the time period in which
1118:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1119:                  returns to the stack.
1120:          
1121:              Precondition:
1122:          
1123:              Parameters:
1124:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1125:          
1126:              Return Values:
1127:                  None
1128:          
1129:              Remarks:
1130:                  None
1131:          
1132:            **************************************************************************/
1133:          void USBCancelIO(uint8_t endpoint)
1134:          {
1135:              if(USBPacketDisable == 1)
1136:              {
1137:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1138:              	//to mess with the BDT right now.
1139:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1140:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1141:          
1142:              	//Need to do additional handling if ping-pong buffering is being used
1143:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1144:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1145:                  //(either due to SIE clearing it after a transaction, or the firmware
1146:                  //clearing it) makes hardware ping pong pointer advance.
1147:                  pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
1148:          
1149:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1150:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1151:                  #endif
1152:              }
1153:          }
1154:          
1155:          /**************************************************************************
1156:              Function:
1157:                  void USBDeviceDetach(void)
1158:          
1159:              Summary:
1160:                  This function configures the USB module to "soft detach" itself from
1161:                  the USB host.
1162:          
1163:              Description:
1164:                  This function configures the USB module to perform a "soft detach"
1165:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1166:                  lets the host know the device is present and attached.  This will make
1167:                  the host think that the device has been unplugged.  This is potentially
1168:                  useful, as it allows the USB device to force the host to re-enumerate
1169:                  the device (on the firmware has re-enabled the USB module/pull up, by
1170:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1171:          
1172:              Precondition:
1173:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1174:                  section if USB_POLLING mode option is being used (usb_config.h option).
1175:          
1176:                  Additionally, this function should only be called from the main() loop
1177:                  context.  Do not call this function from within an interrupt handler, as
1178:                  this function may modify global interrupt enable bits and settings.
1179:          
1180:              Parameters:
1181:                  None
1182:          
1183:              Return Values:
1184:                  None
1185:          
1186:              Remarks:
1187:                  If the application firmware calls USBDeviceDetach(), it is strongly
1188:                  recommended that the firmware wait at least >= 80ms before calling
1189:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1190:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1191:                  hosts may interpret this as an unexpected "glitch" rather than as a
1192:                  physical removal/re-attachment of the USB device.  In this case the host
1193:                  may simply ignore the event without re-enumerating the device.  To
1194:                  ensure that the host properly detects and processes the device soft
1195:                  detach/re-attach, it is recommended to make sure the device remains
1196:                  detached long enough to mimic a real human controlled USB
1197:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1198:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1199:          
1200:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1201:                  or take long to execute.  It is the application firmwares
1202:                  responsibility for adding the 80+ms delay, when using these API
1203:                  functions.
1204:          
1205:                  Note: The Windows plug and play event handler processing is fairly
1206:                  slow, especially in certain versions of Windows, and for certain USB
1207:                  device classes.  It has been observed that some device classes need to
1208:                  provide even more USB detach dwell interval (before calling
1209:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1210:                  If the USB device is a CDC class device, it is recommended to wait
1211:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1212:                  to provide the plug and play event handler enough time to finish
1213:                  processing the removal event, before the re-attach occurs.
1214:          
1215:                  If the application is using the USB_POLLING mode option, then the
1216:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.
1217:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO"
1218:                  and "#define USB_BUS_SENSE" options in the
1219:                  HardwareProfile – [platform name].h file.
1220:          
1221:                  When using the USB_POLLING mode option, and the
1222:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then
1223:                  the USB stack assumes that it should always enable the USB module at
1224:                  pretty much all times.  Basically, anytime the application firmware
1225:                  calls USBDeviceTasks(), the firmware will automatically enable the USB
1226:                  module.  This mode would typically be selected if the application was
1227:                  designed to be a purely bus powered device.  In this case, the
1228:                  application is powered from the +5V VBUS supply from the USB port, so
1229:                  it is correct and sensible in this type of application to power up and
1230:                  turn on the USB module, at anytime that the microcontroller is
1231:                  powered (which implies the USB cable is attached and the host is also
1232:                  powered).
1233:          
1234:                  In a self powered application, the USB stack is designed with the
1235:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO"
1236:                  option in the HardwareProfile – [platform name].h file.  When this
1237:                  option is defined, then the USBDeviceTasks() function will automatically
1238:                  check the I/O pin port value of the designated pin (based on the
1239:                  #define USB_BUS_SENSE option in the HardwareProfile – [platform name].h
1240:                  file), every time the application calls USBDeviceTasks().  If the
1241:                  USBDeviceTasks() function is executed and finds that the pin defined by
1242:                  the #define USB_BUS_SENSE is in a logic low state, then it will
1243:                  automatically disable the USB module and tri-state the D+ and D- pins.
1244:                  If however the USBDeviceTasks() function is executed and finds the pin
1245:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it
1246:                  will automatically enable the USB module, if it has not already been
1247:                  enabled.
1248:          
1249:            **************************************************************************/
1250:          #if defined(USB_INTERRUPT)
1251:          void USBDeviceDetach(void)
1252:          {
1253:              //If the interrupt option is selected then the customer is required
1254:              //  to notify the stack when the device is attached or removed from the
1255:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1256:          #ifdef USB_SUPPORT_OTG
1257:              if (USB_BUS_SENSE != 1)
1258:          #endif
1259:              {
1260:                   // Disable module & detach from bus
1261:                   U1CON = 0;
1262:          
1263:                   // Mask all USB interrupts
1264:                   U1IE = 0;
1265:          
1266:                   //Move to the detached state
1267:                   USBDeviceState = DETACHED_STATE;
1268:          
1269:                   #ifdef  USB_SUPPORT_OTG
1270:                       //Disable D+ Pull-up
1271:                       U1OTGCONbits.DPPULUP = 0;
1272:          
1273:                       //Disable HNP
1274:                       USBOTGDisableHnp();
1275:          
1276:                       //Deactivate HNP
1277:                       USBOTGDeactivateHnp();
1278:          
1279:                       //If ID Pin Changed State
1280:                       if (USBIDIF && USBIDIE)
1281:                       {
1282:                           //Re-detect & Initialize
1283:                            USBOTGInitialize();
1284:          
1285:                            //Clear ID Interrupt Flag
1286:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1287:                       }
1288:                   #endif
1289:          
1290:                   #if defined __C30__ || defined __XC16__
1291:                       //USBClearInterruptFlag(U1OTGIR, 3);
1292:                   #endif
1293:                      //return so that we don't go through the rest of
1294:                      //the state machine
1295:                    return;
1296:              }
1297:          
1298:          #ifdef USB_SUPPORT_OTG
1299:              //If Session Is Started Then
1300:             else
1301:             {
1302:                  //If SRP Is Ready
1303:                  if (USBOTGSRPIsReady())
1304:                  {
1305:                      //Clear SRPReady
1306:                      USBOTGClearSRPReady();
1307:          
1308:                      //Clear SRP Timeout Flag
1309:                      USBOTGClearSRPTimeOutFlag();
1310:          
1311:                      //Indicate Session Started
1312:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1313:                  }
1314:              }
1315:          #endif
1316:          }
1317:          #endif  //#if defined(USB_INTERRUPT)
1318:          /**************************************************************************
1319:              Function:
1320:                  void USBDeviceAttach(void)
1321:          
1322:              Summary:
1323:                  Checks if VBUS is present, and that the USB module is not already
1324:                  initialized, and if so, enables the USB module so as to signal device
1325:                  attachment to the USB host.
1326:          
1327:              Description:
1328:                  This function indicates to the USB host that the USB device has been
1329:                  attached to the bus.  This function needs to be called in order for the
1330:                  device to start to enumerate on the bus.
1331:          
1332:              Precondition:
1333:                  Should only be called when USB_INTERRUPT is defined.  Also, should only
1334:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1335:                  from within an interrupt handler, as the USBDeviceAttach() function
1336:                  may modify global interrupt enable bits and settings.
1337:          
1338:                  For normal USB devices:
1339:                  Make sure that if the module was previously on, that it has been turned off
1340:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1341:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1342:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes
1343:                  reject this event, since no human could ever unplug and re-attach a USB device in a
1344:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind
1345:                  of glitch and ignore the event altogether.
1346:              Parameters:
1347:                  None
1348:          
1349:              Return Values:
1350:                  None
1351:          
1352:              Remarks:
1353:          		See also the USBDeviceDetach() API function documentation.
1354:          ****************************************************************************/
1355:          #if defined(USB_INTERRUPT)
1356:          void USBDeviceAttach(void)
1357:          {
1358:              //if we are in the detached state
1359:              if(USBDeviceState == DETACHED_STATE)
1360:              {
1361:                  if(USB_BUS_SENSE == 1)
1362:                  {
1363:              	    //Initialize registers to known states.
1364:                      U1CON = 0;
1365:          
1366:                      // Mask all USB interrupts
1367:                      U1IE = 0;
1368:          
1369:                      //Configure things like: pull ups, full/low-speed mode,
1370:                      //set the ping pong mode, and set internal transceiver
1371:                      SetConfigurationOptions();
1372:          
1373:                      USBEnableInterrupts();  //Modifies global interrupt settings
1374:          
1375:                      // Enable module & attach to bus
1376:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1377:          
1378:                      //moved to the attached state
1379:                      USBDeviceState = ATTACHED_STATE;
1380:          
1381:                      #ifdef  USB_SUPPORT_OTG
1382:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
1383:                      #endif
1384:                  }
1385:              }
1386:          }
1387:          #endif  //#if defined(USB_INTERRUPT)
1388:          
1389:          
1390:          /*******************************************************************************
1391:            Function: void USBCtrlEPAllowStatusStage(void);
1392:          
1393:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1394:                      (based on the controlTransferState) to allow the status stage packet
1395:                      of a control transfer to complete.  This function gets used
1396:                      internally by the USB stack itself, but it may also be called from
1397:                      the application firmware, IF the application firmware called
1398:                      the USBDeferStatusStage() function during the initial processing
1399:                      of the control transfer request.  In this case, the application
1400:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1401:                      completed processing and handling the data stage portion of the
1402:                      request.
1403:          
1404:                      If the application firmware has no need for delaying control
1405:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1406:                      application firmware should not call USBCtrlEPAllowStatusStage().
1407:          
1408:            Description:
1409:          
1410:            Conditions:
1411:              None
1412:          
1413:            Input:
1414:          
1415:            Return:
1416:          
1417:            Remarks:
1418:              None
1419:            *****************************************************************************/
1420:          void USBCtrlEPAllowStatusStage(void)
1421:          {
1422:              //Check and set two flags, prior to actually modifying any BDT entries.
1423:              //This double checking is necessary to make certain that
1424:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once
1425:              //in main loop context, while simultaneously getting an interrupt which
1426:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1427:              if(USBStatusStageEnabledFlag1 == false)
0D0F  0021     MOVLB 0x1
0D10  0849     MOVF USBStatusStageEnabledFlag1, W
0D11  1D03     BTFSS STATUS, 0x2
0D12  2D14     GOTO 0x514
0D13  2D15     GOTO 0x515
0D14  2D80     GOTO 0x580
1428:              {
1429:                  USBStatusStageEnabledFlag1 = true;
0D15  3001     MOVLW 0x1
0D16  00F0     MOVWF 0xF0
0D17  0870     MOVF 0xF0, W
0D18  00C9     MOVWF USBStatusStageEnabledFlag1
1430:                  if(USBStatusStageEnabledFlag2 == false)
0D19  0848     MOVF USBStatusStageEnabledFlag2, W
0D1A  1D03     BTFSS STATUS, 0x2
0D1B  2D1D     GOTO 0x51D
0D1C  2D1E     GOTO 0x51E
0D1D  2D80     GOTO 0x580
1431:                  {
1432:                      USBStatusStageEnabledFlag2 = true;
0D1E  3001     MOVLW 0x1
0D1F  00F0     MOVWF 0xF0
0D20  0870     MOVF 0xF0, W
0D21  00C8     MOVWF USBStatusStageEnabledFlag2
1433:          
1434:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1435:                      //stage), based on the type of control transfer currently pending.
1436:                      if(controlTransferState == CTRL_TRF_RX)
0D22  3002     MOVLW 0x2
0D23  0651     XORWF controlTransferState, W
0D24  1D03     BTFSS STATUS, 0x2
0D25  2D27     GOTO 0x527
0D26  2D28     GOTO 0x528
0D27  2D3A     GOTO 0x53A
1437:                      {
1438:                          pBDTEntryIn[0]->CNT = 0;
0D28  0830     MOVF pBDTEntryIn, W
0D29  0086     MOVWF FSR1L
0D2A  0831     MOVF 0xB1, W
0D2B  0087     MOVWF FSR1H
0D2C  3141     ADDFSR 1, 1
0D2D  0181     CLRF INDF1
1439:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0D2E  0830     MOVF pBDTEntryIn, W
0D2F  0086     MOVWF FSR1L
0D30  0831     MOVF 0xB1, W
0D31  0087     MOVWF FSR1H
0D32  3048     MOVLW 0x48
0D33  0081     MOVWF INDF1
1440:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0D34  0830     MOVF pBDTEntryIn, W
0D35  0086     MOVWF FSR1L
0D36  0831     MOVF 0xB1, W
0D37  0087     MOVWF FSR1H
0D38  1781     BSF INDF1, 0x7
1441:                      }
0D39  2D80     GOTO 0x580
1442:                      else if(controlTransferState == CTRL_TRF_TX)
0D3A  0351     DECF controlTransferState, W
0D3B  1D03     BTFSS STATUS, 0x2
0D3C  2D3E     GOTO 0x53E
0D3D  2D3F     GOTO 0x53F
0D3E  2D80     GOTO 0x580
1443:                      {
1444:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
0D3F  01CC     CLRF BothEP0OutUOWNsSet
1445:          
1446:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1447:                          //next SETUP packet.
1448:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1449:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
0D40  3008     MOVLW 0x8
0D41  00F0     MOVWF 0xF0
0D42  0A53     INCF pBDTEntryEP0OutCurrent, W
0D43  0086     MOVWF FSR1L
0D44  0187     CLRF FSR1H
0D45  0870     MOVF 0xF0, W
0D46  0081     MOVWF INDF1
1450:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
0D47  3060     MOVLW 0x60
0D48  00F0     MOVWF 0xF0
0D49  3000     MOVLW 0x0
0D4A  00F1     MOVWF 0xF1
0D4B  0853     MOVF pBDTEntryEP0OutCurrent, W
0D4C  3E02     ADDLW 0x2
0D4D  0086     MOVWF FSR1L
0D4E  0187     CLRF FSR1H
0D4F  0870     MOVF 0xF0, W
0D50  3FC0     MOVWI 0[FSR1]
0D51  0871     MOVF 0xF1, W
0D52  3FC1     MOVWI 1[FSR1]
1451:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
0D53  3004     MOVLW 0x4
0D54  00F0     MOVWF 0xF0
0D55  0853     MOVF pBDTEntryEP0OutCurrent, W
0D56  0086     MOVWF FSR1L
0D57  0187     CLRF FSR1H
0D58  0870     MOVF 0xF0, W
0D59  0081     MOVWF INDF1
1452:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0D5A  0853     MOVF pBDTEntryEP0OutCurrent, W
0D5B  0086     MOVWF FSR1L
0D5C  0187     CLRF FSR1H
0D5D  1781     BSF INDF1, 0x7
1453:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
0D5E  01CC     CLRF BothEP0OutUOWNsSet
0D5F  0ACC     INCF BothEP0OutUOWNsSet, F
1454:                          #endif
1455:          
1456:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1457:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0D60  0841     MOVF pBDTEntryEP0OutNext, W
0D61  3E01     ADDLW 0x1
0D62  00F0     MOVWF 0xF0
0D63  3000     MOVLW 0x0
0D64  3D42     ADDWFC 0xC2, W
0D65  00F1     MOVWF 0xF1
0D66  0870     MOVF 0xF0, W
0D67  0086     MOVWF FSR1L
0D68  0871     MOVF 0xF1, W
0D69  0087     MOVWF FSR1H
0D6A  3008     MOVLW 0x8
0D6B  0081     MOVWF INDF1
1458:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0D6C  3060     MOVLW 0x60
0D6D  00F0     MOVWF 0xF0
0D6E  3000     MOVLW 0x0
0D6F  00F1     MOVWF 0xF1
0D70  0841     MOVF pBDTEntryEP0OutNext, W
0D71  0086     MOVWF FSR1L
0D72  0842     MOVF 0xC2, W
0D73  0087     MOVWF FSR1H
0D74  3142     ADDFSR 1, 2
0D75  0870     MOVF 0xF0, W
0D76  3FC0     MOVWI 0[FSR1]
0D77  0871     MOVF 0xF1, W
0D78  3FC1     MOVWI 1[FSR1]
1459:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
0D79  0841     MOVF pBDTEntryEP0OutNext, W
0D7A  0086     MOVWF FSR1L
0D7B  0842     MOVF 0xC2, W
0D7C  0087     MOVWF FSR1H
0D7D  3080     MOVLW 0x80
0D7E  0081     MOVWF INDF1
0D7F  2D80     GOTO 0x580
1460:                      }
1461:                  }
1462:              }
1463:          }
0D80  0008     RETURN
1464:          
1465:          
1466:          /*******************************************************************************
1467:            Function: void USBCtrlEPAllowDataStage(void);
1468:          
1469:            Summary: This function allows the data stage of either a host-to-device or
1470:                      device-to-host control transfer (with data stage) to complete.
1471:                      This function is meant to be used in conjunction with either the
1472:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1473:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1474:                      then the firmware does not need to manually call
1475:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1476:                      instead.
1477:          
1478:            Description:
1479:          
1480:            Conditions: A control transfer (with data stage) should already be pending,
1481:                          if the firmware calls this function.  Additionally, the firmware
1482:                          should have called either USBDeferOUTDataStage() or
1483:                          USBDeferINDataStage() at the start of the control transfer, if
1484:                          the firmware will be calling this function manually.
1485:          
1486:            Input:
1487:          
1488:            Return:
1489:          
1490:            Remarks:
1491:            *****************************************************************************/
1492:          void USBCtrlEPAllowDataStage(void)
1493:          {
1494:              USBDeferINDataStagePackets = false;
0BE0  0021     MOVLB 0x1
0BE1  01C7     CLRF USBDeferINDataStagePackets
1495:              USBDeferOUTDataStagePackets = false;
0BE2  01C6     CLRF USBDeferOUTDataStagePackets
1496:          
1497:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
0BE3  3002     MOVLW 0x2
0BE4  0651     XORWF controlTransferState, W
0BE5  1D03     BTFSS STATUS, 0x2
0BE6  2BE8     GOTO 0x3E8
0BE7  2BE9     GOTO 0x3E9
0BE8  2C0E     GOTO 0x40E
1498:              {
1499:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1500:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0BE9  0841     MOVF pBDTEntryEP0OutNext, W
0BEA  3E01     ADDLW 0x1
0BEB  00F3     MOVWF 0xF3
0BEC  3000     MOVLW 0x0
0BED  3D42     ADDWFC 0xC2, W
0BEE  00F4     MOVWF 0xF4
0BEF  0873     MOVF 0xF3, W
0BF0  0086     MOVWF FSR1L
0BF1  0874     MOVF 0xF4, W
0BF2  0087     MOVWF FSR1H
0BF3  3008     MOVLW 0x8
0BF4  0081     MOVWF INDF1
1501:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0BF5  3068     MOVLW 0x68
0BF6  00F3     MOVWF 0xF3
0BF7  3000     MOVLW 0x0
0BF8  00F4     MOVWF 0xF4
0BF9  0841     MOVF pBDTEntryEP0OutNext, W
0BFA  0086     MOVWF FSR1L
0BFB  0842     MOVF 0xC2, W
0BFC  0087     MOVWF FSR1H
0BFD  3142     ADDFSR 1, 2
0BFE  0873     MOVF 0xF3, W
0BFF  3FC0     MOVWI 0[FSR1]
0C00  0874     MOVF 0xF4, W
0C01  3FC1     MOVWI 1[FSR1]
1502:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0C02  0841     MOVF pBDTEntryEP0OutNext, W
0C03  0086     MOVWF FSR1L
0C04  0842     MOVF 0xC2, W
0C05  0087     MOVWF FSR1H
0C06  3048     MOVLW 0x48
0C07  0081     MOVWF INDF1
1503:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0C08  0841     MOVF pBDTEntryEP0OutNext, W
0C09  0086     MOVWF FSR1L
0C0A  0842     MOVF 0xC2, W
0C0B  0087     MOVWF FSR1H
0C0C  1781     BSF INDF1, 0x7
1504:              }
0C0D  2C3E     GOTO 0x43E
1505:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1506:              {
1507:                  //Error check the data stage byte count.  Make sure the user specified
1508:                  //value was no greater than the number of bytes the host requested.
1509:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
0C0E  083C     MOVF 0xBC, W
0C0F  0020     MOVLB 0x0
0C10  0267     SUBWF 0x67, W
0C11  1D03     BTFSS STATUS, 0x2
0C12  2C17     GOTO 0x417
0C13  0021     MOVLB 0x1
0C14  083B     MOVF 0xBB, W
0C15  0020     MOVLB 0x0
0C16  0266     SUBWF 0x66, W
0C17  1803     BTFSC STATUS, 0x0
0C18  2C1A     GOTO 0x41A
0C19  2C1B     GOTO 0x41B
0C1A  2C22     GOTO 0x422
1510:          		{
1511:          			inPipes[0].wCount.Val = SetupPkt.wLength;
0C1B  0867     MOVF 0x67, W
0C1C  0021     MOVLB 0x1
0C1D  00BC     MOVWF 0xBC
0C1E  0020     MOVLB 0x0
0C1F  0866     MOVF 0x66, W
0C20  0021     MOVLB 0x1
0C21  00BB     MOVWF 0xBB
1512:          		}
1513:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
0C22  318D     MOVLP 0xD
0C23  2581     CALL 0x581
0C24  318B     MOVLP 0xB
1514:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1515:          
1516:          	    //Cnt should have been initialized by responsible request owner (ex: by
1517:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1518:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0C25  3068     MOVLW 0x68
0C26  00F3     MOVWF 0xF3
0C27  3000     MOVLW 0x0
0C28  00F4     MOVWF 0xF4
0C29  0021     MOVLB 0x1
0C2A  0830     MOVF pBDTEntryIn, W
0C2B  0086     MOVWF FSR1L
0C2C  0831     MOVF 0xB1, W
0C2D  0087     MOVWF FSR1H
0C2E  3142     ADDFSR 1, 2
0C2F  0873     MOVF 0xF3, W
0C30  3FC0     MOVWI 0[FSR1]
0C31  0874     MOVF 0xF4, W
0C32  3FC1     MOVWI 1[FSR1]
1519:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0C33  0830     MOVF pBDTEntryIn, W
0C34  0086     MOVWF FSR1L
0C35  0831     MOVF 0xB1, W
0C36  0087     MOVWF FSR1H
0C37  3048     MOVLW 0x48
0C38  0081     MOVWF INDF1
1520:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
0C39  0830     MOVF pBDTEntryIn, W
0C3A  0086     MOVWF FSR1L
0C3B  0831     MOVF 0xB1, W
0C3C  0087     MOVWF FSR1H
0C3D  1781     BSF INDF1, 0x7
1521:              }
1522:          }
0C3E  0008     RETURN
1523:          
1524:          
1525:          /******************************************************************************/
1526:          /** Internal Functions *********************************************************/
1527:          /******************************************************************************/
1528:          
1529:          /********************************************************************
1530:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1531:           *
1532:           * PreCondition:    None
1533:           *
1534:           * Input:           uint8_t EPNum - the endpoint to be configured
1535:           *                  uint8_t direction - the direction to be configured
1536:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1537:           *
1538:           * Output:          None
1539:           *
1540:           * Side Effects:    None
1541:           *
1542:           * Overview:        This function will configure the specified
1543:           *                  endpoint
1544:           *
1545:           * Note:            None
1546:           *******************************************************************/
1547:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
0ABB  00F5     MOVWF 0xF5
1548:          {
1549:              volatile BDT_ENTRY* handle;
1550:          
1551:              //Compute a pointer to the even BDT entry corresponding to the
1552:              //EPNum and direction values passed to this function.
1553:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
0ABC  3020     MOVLW 0x20
0ABD  00F1     MOVWF 0xF1
0ABE  0871     MOVF 0xF1, W
0ABF  00F6     MOVWF 0xF6
1554:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
0AC0  0870     MOVF 0xF0, W
0AC1  00F1     MOVWF 0xF1
0AC2  3001     MOVLW 0x1
0AC3  35F1     LSLF 0xF1, F
0AC4  0B89     DECFSZ WREG, F
0AC5  2AC3     GOTO 0x2C3
0AC6  0875     MOVF 0xF5, W
0AC7  00F2     MOVWF 0xF2
0AC8  3001     MOVLW 0x1
0AC9  35F2     LSLF 0xF2, F
0ACA  3EFF     ADDLW 0xFF
0ACB  1D03     BTFSS STATUS, 0x2
0ACC  2AC9     GOTO 0x2C9
0ACD  3572     LSLF 0xF2, W
0ACE  0771     ADDWF 0xF1, W
0ACF  00F3     MOVWF 0xF3
0AD0  3001     MOVLW 0x1
0AD1  35F3     LSLF 0xF3, F
0AD2  3EFF     ADDLW 0xFF
0AD3  1D03     BTFSS STATUS, 0x2
0AD4  2AD1     GOTO 0x2D1
0AD5  3573     LSLF 0xF3, W
0AD6  00F4     MOVWF 0xF4
0AD7  0874     MOVF 0xF4, W
0AD8  07F6     ADDWF 0xF6, F
1555:          
1556:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler()
0AD9  0876     MOVF 0xF6, W
0ADA  0086     MOVWF FSR1L
0ADB  0187     CLRF FSR1H
0ADC  1381     BCF INDF1, 0x7
1557:              //already cleared the entire BDT table
1558:          
1559:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1560:              //for USBTransferOnePacket() API calls.
1561:              if(direction == OUT_FROM_HOST)
0ADD  0870     MOVF 0xF0, W
0ADE  1D03     BTFSS STATUS, 0x2
0ADF  2AE1     GOTO 0x2E1
0AE0  2AE2     GOTO 0x2E2
0AE1  2AEC     GOTO 0x2EC
1562:              {
1563:                  pBDTEntryOut[EPNum] = handle;
0AE2  3575     LSLF 0xF5, W
0AE3  3EA0     ADDLW 0xA0
0AE4  0086     MOVWF FSR1L
0AE5  3001     MOVLW 0x1
0AE6  0087     MOVWF FSR1H
0AE7  0876     MOVF 0xF6, W
0AE8  3FC0     MOVWI 0[FSR1]
0AE9  3000     MOVLW 0x0
0AEA  3FC1     MOVWI 1[FSR1]
1564:              }
0AEB  2AF4     GOTO 0x2F4
1565:              else
1566:              {
1567:                  pBDTEntryIn[EPNum] = handle;
0AEC  3575     LSLF 0xF5, W
0AED  3EB0     ADDLW 0xB0
0AEE  0086     MOVWF FSR1L
0AEF  0187     CLRF FSR1H
0AF0  0876     MOVF 0xF6, W
0AF1  3FC0     MOVWI 0[FSR1]
0AF2  3000     MOVLW 0x0
0AF3  3FC1     MOVWI 1[FSR1]
1568:              }
1569:          
1570:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1571:                  handle->STAT.DTS = 0;
0AF4  0876     MOVF 0xF6, W
0AF5  0086     MOVWF FSR1L
0AF6  0187     CLRF FSR1H
0AF7  1301     BCF INDF1, 0x6
1572:                  (handle+1)->STAT.DTS = 1;
0AF8  0876     MOVF 0xF6, W
0AF9  3E04     ADDLW 0x4
0AFA  0086     MOVWF FSR1L
0AFB  0187     CLRF FSR1H
0AFC  1701     BSF INDF1, 0x6
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1574:                  //Set DTS to one because the first thing we will do
1575:                  //when transmitting is toggle the bit
1576:                  handle->STAT.DTS = 1;
1577:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1578:                  if(EPNum != 0)
1579:                  {
1580:                      handle->STAT.DTS = 1;
1581:                  }
1582:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1583:                  if(EPNum != 0)
1584:                  {
1585:                      handle->STAT.DTS = 0;
1586:                      (handle+1)->STAT.DTS = 1;
1587:                  }
1588:              #endif
1589:          }
0AFD  0008     RETURN
1590:          
1591:          
1592:          /******************************************************************************
1593:           * Function:        void USBCtrlEPServiceComplete(void)
1594:           *
1595:           * PreCondition:    None
1596:           *
1597:           * Input:           None
1598:           *
1599:           * Output:          None
1600:           *
1601:           * Side Effects:    None
1602:           *
1603:           * Overview:        This routine wrap up the remaining tasks in servicing
1604:           *                  a Setup Request. Its main task is to set the endpoint
1605:           *                  controls appropriately for a given situation. See code
1606:           *                  below.
1607:           *                  There are three main scenarios:
1608:           *                  a) There was no handler for the Request, in this case
1609:           *                     a STALL should be sent out.
1610:           *                  b) The host has requested a read control transfer,
1611:           *                     endpoints are required to be setup in a specific way.
1612:           *                  c) The host has requested a write control transfer, or
1613:           *                     a control data stage is not required, endpoints are
1614:           *                     required to be setup in a specific way.
1615:           *
1616:           *                  Packet processing is resumed by clearing PKTDIS bit.
1617:           *
1618:           * Note:            None
1619:           *****************************************************************************/
1620:          static void USBCtrlEPServiceComplete(void)
1621:          {
1622:              /*
1623:               * PKTDIS bit is set when a Setup Transaction is received.
1624:               * Clear to resume packet processing.
1625:               */
1626:              USBPacketDisable = 0;
06E8  003D     MOVLB 0x1D
06E9  120E     BCF UCON, 0x4
1627:          
1628:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1629:          	//control transfer is currently in progress.  We need to know the type of control
1630:          	//transfer that is currently pending, in order to know how to properly arm the
1631:          	//EP0 IN and EP0 OUT endpoints.
1632:              if(inPipes[0].info.bits.busy == 0)
06EA  0021     MOVLB 0x1
06EB  1BBA     BTFSC 0xBA, 0x7
06EC  2EEE     GOTO 0x6EE
06ED  2EEF     GOTO 0x6EF
06EE  2F36     GOTO 0x736
1633:              {
1634:                  if(outPipes[0].info.bits.busy == 1)
06EF  0022     MOVLB 0x2
06F0  1FA2     BTFSS 0x122, 0x7
06F1  2EF3     GOTO 0x6F3
06F2  2EF4     GOTO 0x6F4
06F3  2F05     GOTO 0x705
1635:                  {
1636:                      controlTransferState = CTRL_TRF_RX;
06F4  3002     MOVLW 0x2
06F5  00F5     MOVWF 0x175
06F6  0875     MOVF 0x175, W
06F7  0021     MOVLB 0x1
06F8  00D1     MOVWF controlTransferState
1637:                      /*
1638:                       * Control Write:
1639:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1640:                       */
1641:          
1642:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1643:                      //   function decided to defer the data stage (ex: because the intended
1644:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1645:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1646:                      //   once it is ready to begin receiving the data.
1647:                      if(USBDeferOUTDataStagePackets == false)
06F9  0846     MOVF USBDeferOUTDataStagePackets, W
06FA  1D03     BTFSS STATUS, 0x2
06FB  2EFD     GOTO 0x6FD
06FC  2EFE     GOTO 0x6FE
06FD  2F01     GOTO 0x701
1648:                      {
1649:                          USBCtrlEPAllowDataStage();
06FE  318B     MOVLP 0xB
06FF  23E0     CALL 0x3E0
0700  3186     MOVLP 0x6
1650:                      }
1651:          
1652:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage()
1653:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1654:                      USBStatusStageEnabledFlag2 = false;
0701  0021     MOVLB 0x1
0702  01C8     CLRF USBStatusStageEnabledFlag2
1655:                      USBStatusStageEnabledFlag1 = false;
0703  01C9     CLRF USBStatusStageEnabledFlag1
1656:                  }
0704  2F83     GOTO 0x783
1657:                  else
1658:                  {
1659:                      /*
1660:                       * If no one knows how to service this request then stall.
1661:                       * Must also prepare EP0 to receive the next SETUP transaction.
1662:                       */
1663:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0705  0021     MOVLB 0x1
0706  0841     MOVF pBDTEntryEP0OutNext, W
0707  3E01     ADDLW 0x1
0708  00F5     MOVWF 0xF5
0709  3000     MOVLW 0x0
070A  3D42     ADDWFC 0xC2, W
070B  00F6     MOVWF 0xF6
070C  0875     MOVF 0xF5, W
070D  0086     MOVWF FSR1L
070E  0876     MOVF 0xF6, W
070F  0087     MOVWF FSR1H
0710  3008     MOVLW 0x8
0711  0081     MOVWF INDF1
1664:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0712  3060     MOVLW 0x60
0713  00F5     MOVWF 0xF5
0714  3000     MOVLW 0x0
0715  00F6     MOVWF 0xF6
0716  0841     MOVF pBDTEntryEP0OutNext, W
0717  0086     MOVWF FSR1L
0718  0842     MOVF 0xC2, W
0719  0087     MOVWF FSR1H
071A  3142     ADDFSR 1, 2
071B  0875     MOVF 0xF5, W
071C  3FC0     MOVWI 0[FSR1]
071D  0876     MOVF 0xF6, W
071E  3FC1     MOVWI 1[FSR1]
1665:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
071F  0841     MOVF pBDTEntryEP0OutNext, W
0720  0086     MOVWF FSR1L
0721  0842     MOVF 0xC2, W
0722  0087     MOVWF FSR1H
0723  300C     MOVLW 0xC
0724  0081     MOVWF INDF1
1666:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0725  0841     MOVF pBDTEntryEP0OutNext, W
0726  0086     MOVWF FSR1L
0727  0842     MOVF 0xC2, W
0728  0087     MOVWF FSR1H
0729  1781     BSF INDF1, 0x7
1667:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
072A  0830     MOVF pBDTEntryIn, W
072B  0086     MOVWF FSR1L
072C  0831     MOVF 0xB1, W
072D  0087     MOVWF FSR1H
072E  3004     MOVLW 0x4
072F  0081     MOVWF INDF1
1668:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0730  0830     MOVF pBDTEntryIn, W
0731  0086     MOVWF FSR1L
0732  0831     MOVF 0xB1, W
0733  0087     MOVWF FSR1H
0734  1781     BSF INDF1, 0x7
0735  2F83     GOTO 0x783
1669:                  }
1670:              }
1671:              else    // A module has claimed ownership of the control transfer session.
1672:              {
1673:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0736  0020     MOVLB 0x0
0737  1FE0     BTFSS SetupPkt, 0x7
0738  2F3A     GOTO 0x73A
0739  2F3B     GOTO 0x73B
073A  2F52     GOTO 0x752
1674:          		{
1675:          			controlTransferState = CTRL_TRF_TX;
073B  0021     MOVLB 0x1
073C  01D1     CLRF controlTransferState
073D  0AD1     INCF controlTransferState, F
1676:          			/*
1677:          			 * Control Read:
1678:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1679:          			 *
1680:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1681:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1682:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1683:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1684:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1685:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1686:          			 *    is ready to begin sending the data, it should then call the
1687:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1688:          			 */
1689:          			if(USBDeferINDataStagePackets == false)
073E  0847     MOVF USBDeferINDataStagePackets, W
073F  1D03     BTFSS STATUS, 0x2
0740  2F42     GOTO 0x742
0741  2F43     GOTO 0x743
0742  2F46     GOTO 0x746
1690:                      {
1691:                          USBCtrlEPAllowDataStage();
0743  318B     MOVLP 0xB
0744  23E0     CALL 0x3E0
0745  3186     MOVLP 0x6
1692:          			}
1693:          
1694:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1695:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1696:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1697:                      //    is ready.  If the class request handler does this, it needs to be careful to
1698:                      //    be written so that it can handle the early termination scenario.
1699:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1700:                      //    1.  The desired total number of bytes were sent to the host.
1701:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that
1702:                      //        started the control transfer) has been reached.
1703:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless
1704:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1705:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1706:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1707:                      //        option can take care of this for you.
1708:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1709:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1710:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1711:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this
1712:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1713:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1714:                      USBStatusStageEnabledFlag2 = false;
0746  0021     MOVLB 0x1
0747  01C8     CLRF USBStatusStageEnabledFlag2
1715:                      USBStatusStageEnabledFlag1 = false;
0748  01C9     CLRF USBStatusStageEnabledFlag1
1716:                      if(USBDeferStatusStagePacket == false)
0749  084A     MOVF USBDeferStatusStagePacket, W
074A  1D03     BTFSS STATUS, 0x2
074B  2F4D     GOTO 0x74D
074C  2F4E     GOTO 0x74E
074D  2F83     GOTO 0x783
1717:                      {
1718:                          USBCtrlEPAllowStatusStage();
074E  318D     MOVLP 0xD
074F  250F     CALL 0x50F
0750  3186     MOVLP 0x6
0751  2F83     GOTO 0x783
1719:                      }
1720:          		}
1721:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1722:          		{
1723:          			//This situation occurs for special types of control transfers,
1724:          			//such as that which occurs when the host sends a SET_ADDRESS
1725:          			//control transfer.  Ex:
1726:          			//
1727:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1728:          
1729:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1730:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1731:          			//an IN status stage.
1732:          
1733:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
0752  3002     MOVLW 0x2
0753  00F5     MOVWF 0xF5
0754  0875     MOVF 0xF5, W
0755  0021     MOVLB 0x1
0756  00D1     MOVWF controlTransferState
1734:          
1735:          			//1. Prepare OUT EP to receive the next SETUP packet.
1736:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0757  0841     MOVF pBDTEntryEP0OutNext, W
0758  3E01     ADDLW 0x1
0759  00F5     MOVWF 0xF5
075A  3000     MOVLW 0x0
075B  3D42     ADDWFC 0xC2, W
075C  00F6     MOVWF 0xF6
075D  0875     MOVF 0xF5, W
075E  0086     MOVWF FSR1L
075F  0876     MOVF 0xF6, W
0760  0087     MOVWF FSR1H
0761  3008     MOVLW 0x8
0762  0081     MOVWF INDF1
1737:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0763  3060     MOVLW 0x60
0764  00F5     MOVWF 0xF5
0765  3000     MOVLW 0x0
0766  00F6     MOVWF 0xF6
0767  0841     MOVF pBDTEntryEP0OutNext, W
0768  0086     MOVWF FSR1L
0769  0842     MOVF 0xC2, W
076A  0087     MOVWF FSR1H
076B  3142     ADDFSR 1, 2
076C  0875     MOVF 0xF5, W
076D  3FC0     MOVWI 0[FSR1]
076E  0876     MOVF 0xF6, W
076F  3FC1     MOVWI 1[FSR1]
1738:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0770  0841     MOVF pBDTEntryEP0OutNext, W
0771  0086     MOVWF FSR1L
0772  0842     MOVF 0xC2, W
0773  0087     MOVWF FSR1H
0774  3004     MOVLW 0x4
0775  0081     MOVWF INDF1
1739:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0776  0841     MOVF pBDTEntryEP0OutNext, W
0777  0086     MOVWF FSR1L
0778  0842     MOVF 0xC2, W
0779  0087     MOVWF FSR1H
077A  1781     BSF INDF1, 0x7
1740:          
1741:          			//2. Prepare for IN status stage of the control transfer
1742:                      USBStatusStageEnabledFlag2 = false;
077B  01C8     CLRF USBStatusStageEnabledFlag2
1743:                      USBStatusStageEnabledFlag1 = false;
077C  01C9     CLRF USBStatusStageEnabledFlag1
1744:          			if(USBDeferStatusStagePacket == false)
077D  084A     MOVF USBDeferStatusStagePacket, W
077E  1D03     BTFSS STATUS, 0x2
077F  2F81     GOTO 0x781
0780  2F82     GOTO 0x782
0781  2F83     GOTO 0x783
0782  2F4E     GOTO 0x74E
1745:                      {
1746:                          USBCtrlEPAllowStatusStage();
1747:                      }
1748:          		}
1749:          
1750:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1751:          
1752:          }//end USBCtrlEPServiceComplete
0783  0008     RETURN
1753:          
1754:          
1755:          /******************************************************************************
1756:           * Function:        void USBCtrlTrfTxService(void)
1757:           *
1758:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1759:           *
1760:           * Input:           None
1761:           *
1762:           * Output:          None
1763:           *
1764:           * Side Effects:    None
1765:           *
1766:           * Overview:        This routine is used for device to host control transfers
1767:           *					(IN transactions).  This function takes care of managing a
1768:           *                  transfer over multiple USB transactions.
1769:           *					This routine should be called from only two places.
1770:           *                  One from USBCtrlEPServiceComplete() and one from
1771:           *                  USBCtrlTrfInHandler().
1772:           *
1773:           * Note:
1774:           *****************************************************************************/
1775:          static void USBCtrlTrfTxService(void)
1776:          {
1777:              uint8_t byteToSend;
1778:          
1779:              //Figure out how many bytes of data to send in the next IN transaction.
1780:              //Assume a full size packet, unless otherwise determined below.
1781:              byteToSend = USB_EP0_BUFF_SIZE;
0D81  3008     MOVLW 0x8
0D82  00F0     MOVWF 0xF0
0D83  0870     MOVF 0xF0, W
0D84  00F2     MOVWF 0xF2
1782:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
0D85  3000     MOVLW 0x0
0D86  0021     MOVLB 0x1
0D87  023C     SUBWF 0xBC, W
0D88  3008     MOVLW 0x8
0D89  1903     BTFSC STATUS, 0x2
0D8A  023B     SUBWF 0xBB, W
0D8B  1803     BTFSC STATUS, 0x0
0D8C  2D8E     GOTO 0x58E
0D8D  2D8F     GOTO 0x58F
0D8E  2DA4     GOTO 0x5A4
1783:              {
1784:                  byteToSend = (uint8_t)(inPipes[0].wCount.Val);
0D8F  083B     MOVF 0xBB, W
0D90  00F0     MOVWF 0xF0
0D91  0870     MOVF 0xF0, W
0D92  00F2     MOVWF 0xF2
1785:          
1786:                  //Keep track of whether or not we have sent a "short packet" yet.
1787:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1788:                  //after we have sent all of the intended data.  This makes sure the
1789:                  //hardware STALLs if the host erroneously tries to send more IN token
1790:                  //packets, requesting more data than intended in the control transfer.
1791:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
0D93  0852     MOVF shortPacketStatus, W
0D94  1D03     BTFSS STATUS, 0x2
0D95  2D97     GOTO 0x597
0D96  2D98     GOTO 0x598
0D97  2D9B     GOTO 0x59B
1792:                  {
1793:                      shortPacketStatus = SHORT_PKT_PENDING;
0D98  01D2     CLRF shortPacketStatus
0D99  0AD2     INCF shortPacketStatus, F
1794:                  }
0D9A  2DA4     GOTO 0x5A4
1795:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
0D9B  0352     DECF shortPacketStatus, W
0D9C  1D03     BTFSS STATUS, 0x2
0D9D  2D9F     GOTO 0x59F
0D9E  2DA0     GOTO 0x5A0
0D9F  2DA4     GOTO 0x5A4
1796:                  {
1797:                      shortPacketStatus = SHORT_PKT_SENT;
0DA0  3002     MOVLW 0x2
0DA1  00F0     MOVWF 0xF0
0DA2  0870     MOVF 0xF0, W
0DA3  00D2     MOVWF shortPacketStatus
1798:                  }
1799:              }
1800:          
1801:              //Keep track of how many bytes remain to be sent in the transfer, by
1802:              //subtracting the number of bytes about to be sent from the total.
1803:              inPipes[0].wCount.Val -= byteToSend;
0DA4  0872     MOVF 0xF2, W
0DA5  00F0     MOVWF 0xF0
0DA6  01F1     CLRF 0xF1
0DA7  0870     MOVF 0xF0, W
0DA8  02BB     SUBWF 0xBB, F
0DA9  0871     MOVF 0xF1, W
0DAA  3BBC     SUBWFB 0xBC, F
1804:          
1805:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1806:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1807:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1808:              pBDTEntryIn[0]->CNT = byteToSend;
0DAB  0830     MOVF pBDTEntryIn, W
0DAC  3E01     ADDLW 0x1
0DAD  00F0     MOVWF 0xF0
0DAE  3000     MOVLW 0x0
0DAF  3D31     ADDWFC 0xB1, W
0DB0  00F1     MOVWF 0xF1
0DB1  0870     MOVF 0xF0, W
0DB2  0086     MOVWF FSR1L
0DB3  0871     MOVF 0xF1, W
0DB4  0087     MOVWF FSR1H
0DB5  0872     MOVF 0xF2, W
0DB6  0081     MOVWF INDF1
1809:          
1810:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1811:              //which we will send to the host.
1812:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
0DB7  3068     MOVLW 0x68
0DB8  00F0     MOVWF 0xF0
0DB9  0870     MOVF 0xF0, W
0DBA  00D0     MOVWF pDst
1813:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
0DBB  183A     BTFSC 0xBA, 0x0
0DBC  2DBE     GOTO 0x5BE
0DBD  2DBF     GOTO 0x5BF
0DBE  2DF0     GOTO 0x5F0
0DBF  2DD5     GOTO 0x5D5
1814:              {
1815:                  while(byteToSend)
0DD5  0872     MOVF 0xF2, W
0DD6  1D03     BTFSS STATUS, 0x2
0DD7  2DD9     GOTO 0x5D9
0DD8  2DDA     GOTO 0x5DA
0DD9  2DC0     GOTO 0x5C0
0DDA  2DF5     GOTO 0x5F5
1816:                  {
1817:                      *pDst++ = *inPipes[0].pSrc.bRom++;
0DC0  0838     MOVF inPipes, W
0DC1  0084     MOVWF FSR0L
0DC2  0839     MOVF 0xB9, W
0DC3  0085     MOVWF FSR0H
0DC4  0800     MOVF INDF0, W
0DC5  00F0     MOVWF 0xF0
0DC6  0850     MOVF pDst, W
0DC7  0086     MOVWF FSR1L
0DC8  0187     CLRF FSR1H
0DC9  0870     MOVF 0xF0, W
0DCA  0081     MOVWF INDF1
0DCB  3001     MOVLW 0x1
0DCC  07B8     ADDWF inPipes, F
0DCD  3000     MOVLW 0x0
0DCE  3DB9     ADDWFC 0xB9, F
0DCF  3001     MOVLW 0x1
0DD0  00F0     MOVWF 0xF0
0DD1  0870     MOVF 0xF0, W
0DD2  07D0     ADDWF pDst, F
1818:                      byteToSend--;
0DD3  3001     MOVLW 0x1
0DD4  02F2     SUBWF 0xF2, F
1819:                  }//end while(byte_to_send.Val)
1820:              }
1821:              else  // RAM
1822:              {
1823:                  while(byteToSend)
0DF0  0872     MOVF 0xF2, W
0DF1  1D03     BTFSS STATUS, 0x2
0DF2  2DF4     GOTO 0x5F4
0DF3  2DF5     GOTO 0x5F5
0DF4  2DDB     GOTO 0x5DB
1824:                  {
1825:                      *pDst++ = *inPipes[0].pSrc.bRam++;
0DDB  0838     MOVF inPipes, W
0DDC  0084     MOVWF FSR0L
0DDD  0839     MOVF 0xB9, W
0DDE  0085     MOVWF FSR0H
0DDF  0800     MOVF INDF0, W
0DE0  00F0     MOVWF 0xF0
0DE1  0850     MOVF pDst, W
0DE2  0086     MOVWF FSR1L
0DE3  0187     CLRF FSR1H
0DE4  0870     MOVF 0xF0, W
0DE5  0081     MOVWF INDF1
0DE6  3001     MOVLW 0x1
0DE7  07B8     ADDWF inPipes, F
0DE8  3000     MOVLW 0x0
0DE9  3DB9     ADDWFC 0xB9, F
0DEA  3001     MOVLW 0x1
0DEB  00F0     MOVWF 0xF0
0DEC  0870     MOVF 0xF0, W
0DED  07D0     ADDWF pDst, F
1826:                      byteToSend--;
0DEE  3001     MOVLW 0x1
0DEF  02F2     SUBWF 0xF2, F
0DF0  0872     MOVF 0xF2, W
0DF1  1D03     BTFSS STATUS, 0x2
0DF2  2DF4     GOTO 0x5F4
0DF3  2DF5     GOTO 0x5F5
0DF4  2DDB     GOTO 0x5DB
1827:                  }//end while(byte_to_send.Val)
1828:              }//end if(usb_stat.ctrl_trf_mem == _const)
1829:          }//end USBCtrlTrfTxService
0DF5  0008     RETURN
1830:          
1831:          /******************************************************************************
1832:           * Function:        void USBCtrlTrfRxService(void)
1833:           *
1834:           * PreCondition:    pDst and wCount are setup properly.
1835:           *                  pSrc is always &CtrlTrfData
1836:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1837:           *                  wCount should be set to 0 at the start of each control
1838:           *                  transfer.
1839:           *
1840:           * Input:           None
1841:           *
1842:           * Output:          None
1843:           *
1844:           * Side Effects:    None
1845:           *
1846:           * Overview:        This routine is used for host to device control transfers
1847:           *					(uses OUT transactions).  This function receives the data that arrives
1848:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1849:           *					buffer.  Once the host has sent all the data it was intending
1850:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1851:           *					handler (unless it is NULL), so that it can be used by the
1852:           *					intended target firmware.
1853:           *
1854:           * Note:            None
1855:           *****************************************************************************/
1856:          static void USBCtrlTrfRxService(void)
1857:          {
1858:              uint8_t byteToRead;
1859:              uint8_t i;
1860:          
1861:              //Load byteToRead with the number of bytes the host just sent us in the
1862:              //last OUT transaction.
1863:              byteToRead = pBDTEntryEP0OutCurrent->CNT;
063E  0021     MOVLB 0x1
063F  0853     MOVF pBDTEntryEP0OutCurrent, W
0640  0086     MOVWF FSR1L
0641  0187     CLRF FSR1H
0642  3F41     MOVIW 1[FSR1]
0643  00F5     MOVWF 0xF5
1864:          
1865:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1866:              //of remaining bytes expected to be received from the host, in the control
1867:              //transfer.  First check to see if the host sent us more bytes than the
1868:              //application firmware was expecting to receive.
1869:              if(byteToRead > outPipes[0].wCount.Val)
0644  0875     MOVF 0xF5, W
0645  00F2     MOVWF 0xF2
0646  01F3     CLRF 0xF3
0647  0873     MOVF 0xF3, W
0648  0022     MOVLB 0x2
0649  0224     SUBWF 0x124, W
064A  1D03     BTFSS STATUS, 0x2
064B  2E4E     GOTO 0x64E
064C  0872     MOVF 0x172, W
064D  0223     SUBWF 0x123, W
064E  1803     BTFSC STATUS, 0x0
064F  2E51     GOTO 0x651
0650  2E52     GOTO 0x652
0651  2E56     GOTO 0x656
1870:              {
1871:                  byteToRead = (uint8_t)(outPipes[0].wCount.Val);
0652  0823     MOVF 0x123, W
0653  00F2     MOVWF 0x172
0654  0872     MOVF 0x172, W
0655  00F5     MOVWF 0x175
1872:              }
1873:              //Reduce the number of remaining bytes by the number we just received.
1874:              outPipes[0].wCount.Val -= byteToRead;
0656  0875     MOVF 0x175, W
0657  00F2     MOVWF 0x172
0658  01F3     CLRF 0x173
0659  0872     MOVF 0x172, W
065A  02A3     SUBWF 0x123, F
065B  0873     MOVF 0x173, W
065C  3BA4     SUBWFB 0x124, F
1875:          
1876:              //Copy the OUT DATAx packet bytes that we just received from the host,
1877:              //into the user application buffer space.
1878:              for(i=0;i<byteToRead;i++)
065D  01F4     CLRF 0x174
065E  2E72     GOTO 0x672
1879:              {
1880:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
065F  0874     MOVF 0x174, W
0660  3E68     ADDLW 0x68
0661  0086     MOVWF FSR1L
0662  0187     CLRF FSR1H
0663  0801     MOVF INDF1, W
0664  00F2     MOVWF 0x172
0665  0820     MOVF outPipes, W
0666  0086     MOVWF FSR1L
0667  0187     CLRF FSR1H
0668  0872     MOVF 0x172, W
0669  0081     MOVWF INDF1
066A  3001     MOVLW 0x1
066B  00F2     MOVWF 0x172
066C  0872     MOVF 0x172, W
066D  07A0     ADDWF outPipes, F
1881:              }//end while(byteToRead.Val)
066E  3001     MOVLW 0x1
066F  00F2     MOVWF 0x172
0670  0872     MOVF 0x172, W
0671  07F4     ADDWF 0x174, F
0672  0875     MOVF 0x175, W
0673  0274     SUBWF 0x174, W
0674  1C03     BTFSS STATUS, 0x0
0675  2E77     GOTO 0x677
0676  2E78     GOTO 0x678
0677  2E5F     GOTO 0x65F
1882:          
1883:              //If there is more data to receive, prepare EP0 OUT so that it can receive
1884:          	//the next packet in the sequence.
1885:              if(outPipes[0].wCount.Val > 0)
0678  0823     MOVF 0x123, W
0679  0424     IORWF 0x124, W
067A  1903     BTFSC STATUS, 0x2
067B  2E7D     GOTO 0x67D
067C  2E7E     GOTO 0x67E
067D  2EB7     GOTO 0x6B7
1886:              {
1887:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
067E  0021     MOVLB 0x1
067F  0841     MOVF pBDTEntryEP0OutNext, W
0680  3E01     ADDLW 0x1
0681  00F2     MOVWF 0xF2
0682  3000     MOVLW 0x0
0683  3D42     ADDWFC 0xC2, W
0684  00F3     MOVWF 0xF3
0685  0872     MOVF 0xF2, W
0686  0086     MOVWF FSR1L
0687  0873     MOVF 0xF3, W
0688  0087     MOVWF FSR1H
0689  3008     MOVLW 0x8
068A  0081     MOVWF INDF1
1888:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
068B  3068     MOVLW 0x68
068C  00F2     MOVWF 0xF2
068D  3000     MOVLW 0x0
068E  00F3     MOVWF 0xF3
068F  0841     MOVF pBDTEntryEP0OutNext, W
0690  0086     MOVWF FSR1L
0691  0842     MOVF 0xC2, W
0692  0087     MOVWF FSR1H
0693  3142     ADDFSR 1, 2
0694  0872     MOVF 0xF2, W
0695  3FC0     MOVWI 0[FSR1]
0696  0873     MOVF 0xF3, W
0697  3FC1     MOVWI 1[FSR1]
1889:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
0698  0853     MOVF pBDTEntryEP0OutCurrent, W
0699  0086     MOVWF FSR1L
069A  0187     CLRF FSR1H
069B  1B01     BTFSC INDF1, 0x6
069C  2E9E     GOTO 0x69E
069D  2E9F     GOTO 0x69F
069E  2EAB     GOTO 0x6AB
1890:                  {
1891:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
069F  0841     MOVF pBDTEntryEP0OutNext, W
06A0  0086     MOVWF FSR1L
06A1  0842     MOVF 0xC2, W
06A2  0087     MOVWF FSR1H
06A3  3048     MOVLW 0x48
06A4  0081     MOVWF INDF1
1892:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
06A5  0841     MOVF pBDTEntryEP0OutNext, W
06A6  0086     MOVWF FSR1L
06A7  0842     MOVF 0xC2, W
06A8  0087     MOVWF FSR1H
06A9  1781     BSF INDF1, 0x7
1893:                  }
06AA  2EE7     GOTO 0x6E7
1894:                  else
1895:                  {
1896:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
06AB  0841     MOVF pBDTEntryEP0OutNext, W
06AC  0086     MOVWF FSR1L
06AD  0842     MOVF 0xC2, W
06AE  0087     MOVWF FSR1H
06AF  3008     MOVLW 0x8
06B0  0081     MOVWF INDF1
1897:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
06B1  0841     MOVF pBDTEntryEP0OutNext, W
06B2  0086     MOVWF FSR1L
06B3  0842     MOVF 0xC2, W
06B4  0087     MOVWF FSR1H
06B5  1781     BSF INDF1, 0x7
06B6  2EE7     GOTO 0x6E7
1898:                  }
1899:              }
1900:              else
1901:              {
1902:          	    //We have received all OUT packets that we were expecting to
1903:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1904:          		//the next SETUP transaction that may arrive.
1905:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
06B7  0021     MOVLB 0x1
06B8  0841     MOVF pBDTEntryEP0OutNext, W
06B9  3E01     ADDLW 0x1
06BA  00F2     MOVWF 0xF2
06BB  3000     MOVLW 0x0
06BC  3D42     ADDWFC 0xC2, W
06BD  00F3     MOVWF 0xF3
06BE  0872     MOVF 0xF2, W
06BF  0086     MOVWF FSR1L
06C0  0873     MOVF 0xF3, W
06C1  0087     MOVWF FSR1H
06C2  3008     MOVLW 0x8
06C3  0081     MOVWF INDF1
1906:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
06C4  3060     MOVLW 0x60
06C5  00F2     MOVWF 0xF2
06C6  3000     MOVLW 0x0
06C7  00F3     MOVWF 0xF3
06C8  0841     MOVF pBDTEntryEP0OutNext, W
06C9  0086     MOVWF FSR1L
06CA  0842     MOVF 0xC2, W
06CB  0087     MOVWF FSR1H
06CC  3142     ADDFSR 1, 2
06CD  0872     MOVF 0xF2, W
06CE  3FC0     MOVWI 0[FSR1]
06CF  0873     MOVF 0xF3, W
06D0  3FC1     MOVWI 1[FSR1]
1907:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1908:                  //control transfers.  However, set BSTALL in case the host tries to send
1909:                  //more data than it claims it was going to send.
1910:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
06D1  0841     MOVF pBDTEntryEP0OutNext, W
06D2  0086     MOVWF FSR1L
06D3  0842     MOVF 0xC2, W
06D4  0087     MOVWF FSR1H
06D5  3004     MOVLW 0x4
06D6  0081     MOVWF INDF1
1911:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
06D7  0841     MOVF pBDTEntryEP0OutNext, W
06D8  0086     MOVWF FSR1L
06D9  0842     MOVF 0xC2, W
06DA  0087     MOVWF FSR1H
06DB  1781     BSF INDF1, 0x7
1912:          
1913:          		//All data bytes for the host to device control write (OUT) have now been
1914:          		//received successfully.
1915:          		//Go ahead and call the user specified callback function, to use/consume
1916:          		//the control transfer data (ex: if the "void (*function)" parameter
1917:          		//was non-NULL when USBEP0Receive() was called).
1918:                  if(outPipes[0].pFunc != NULL)
1919:                  {
1920:                      #if defined(__XC8)
1921:                          //Special pragmas to suppress an expected/harmless warning
1922:                          //message when building with the XC8 compiler
1923:                          #pragma warning push
1924:                          #pragma warning disable 1088
1925:                          outPipes[0].pFunc();    //Call the user's callback function
1926:                          #pragma warning pop
1927:                      #else
1928:                          outPipes[0].pFunc();    //Call the user's callback function
1929:                      #endif
1930:                  }
1931:                  outPipes[0].info.bits.busy = 0;
06DC  0022     MOVLB 0x2
06DD  13A2     BCF 0x122, 0x7
1932:          
1933:                  //Ready to arm status stage IN transaction now, if the application
1934:                  //firmware has completed processing the request.  If it is still busy
1935:                  //and needs more time to finish handling the request, then the user
1936:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1937:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1938:                  //this case, it is the application's firmware responsibility to call
1939:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1940:                  //Note: The application firmware must process the request and call
1941:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1942:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1943:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1944:                  //more details.
1945:                  if(USBDeferStatusStagePacket == false)
06DE  0021     MOVLB 0x1
06DF  084A     MOVF USBDeferStatusStagePacket, W
06E0  1D03     BTFSS STATUS, 0x2
06E1  2EE3     GOTO 0x6E3
06E2  2EE4     GOTO 0x6E4
06E3  2EE7     GOTO 0x6E7
1946:                  {
1947:                      USBCtrlEPAllowStatusStage();
06E4  318D     MOVLP 0xD
06E5  250F     CALL 0x50F
06E6  3186     MOVLP 0x6
1948:                  }
1949:              }
1950:          
1951:          }//end USBCtrlTrfRxService
06E7  0008     RETURN
1952:          
1953:          
1954:          /********************************************************************
1955:           * Function:        void USBStdSetCfgHandler(void)
1956:           *
1957:           * PreCondition:    None
1958:           *
1959:           * Input:           None
1960:           *
1961:           * Output:          None
1962:           *
1963:           * Side Effects:    None
1964:           *
1965:           * Overview:        This routine first disables all endpoints by
1966:           *                  clearing UEP registers. It then configures
1967:           *                  (initializes) endpoints by calling the callback
1968:           *                  function USBCBInitEP().
1969:           *
1970:           * Note:            None
1971:           *******************************************************************/
1972:          static void USBStdSetCfgHandler(void)
1973:          {
1974:              uint8_t i;
1975:          
1976:              // This will generate a zero length packet
1977:              inPipes[0].info.bits.busy = 1;
0EF3  0021     MOVLB 0x1
0EF4  17BA     BSF 0xBA, 0x7
1978:          
1979:              //Clear all of the endpoint control registers
1980:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0EF5  300E     MOVLW 0xE
0EF6  00E1     MOVWF pUEP
0EF7  3099     MOVLW 0x99
0EF8  00E0     MOVWF p
0EF9  01E2     CLRF i
0EFA  0860     MOVF p, W
0EFB  0086     MOVWF FSR1L
0EFC  0861     MOVF pUEP, W
0EFD  0087     MOVWF FSR1H
0EFE  0181     CLRF INDF1
0EFF  3001     MOVLW 0x1
0F00  07E0     ADDWF p, F
0F01  3000     MOVLW 0x0
0F02  3DE1     ADDWFC pUEP, F
0F03  3001     MOVLW 0x1
0F04  00DF     MOVWF 0xDF
0F05  085F     MOVF 0xDF, W
0F06  07E2     ADDWF i, F
0F07  3003     MOVLW 0x3
0F08  0262     SUBWF i, W
0F09  1C03     BTFSS STATUS, 0x0
0F0A  2F0C     GOTO 0x70C
0F0B  2F0D     GOTO 0x70D
0F0C  2EFA     GOTO 0x6FA
1981:          
1982:              //Clear all of the BDT entries
1983:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
0F0D  3020     MOVLW 0x20
0F0E  00F0     MOVWF 0xF0
0F0F  3000     MOVLW 0x0
0F10  00F1     MOVWF 0xF1
0F11  3000     MOVLW 0x0
0F12  00F2     MOVWF 0xF2
0F13  00F3     MOVWF 0xF3
0F14  3040     MOVLW 0x40
0F15  00F4     MOVWF 0xF4
0F16  3000     MOVLW 0x0
0F17  00F5     MOVWF 0xF5
0F18  3184     MOVLP 0x4
0F19  24CA     CALL 0x4CA
0F1A  318E     MOVLP 0xE
1984:          
1985:              // Assert reset request to all of the Ping Pong buffer pointers
1986:              USBPingPongBufferReset = 1;
0F1B  003D     MOVLB 0x1D
0F1C  170E     BSF UCON, 0x6
1987:          
1988:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1989:          	//the EVEN buffer being the next one that will be used), since we are also
1990:          	//doing a hardware ping pong pointer reset above.
1991:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0F1D  0021     MOVLB 0x1
0F1E  01E3     CLRF i
1992:          	{
1993:          		ep_data_in[i].Val = 0u;
0F1F  0863     MOVF i, W
0F20  3EB0     ADDLW 0xB0
0F21  0086     MOVWF FSR1L
0F22  3001     MOVLW 0x1
0F23  0087     MOVWF FSR1H
0F24  0181     CLRF INDF1
1994:                  ep_data_out[i].Val = 0u;
0F25  0863     MOVF i, W
0F26  3EAC     ADDLW 0xAC
0F27  0086     MOVWF FSR1L
0F28  3001     MOVLW 0x1
0F29  0087     MOVWF FSR1H
0F2A  0181     CLRF INDF1
1995:          	}
0F2B  3001     MOVLW 0x1
0F2C  00DF     MOVWF 0xDF
0F2D  085F     MOVF 0xDF, W
0F2E  07E3     ADDWF i, F
0F2F  3004     MOVLW 0x4
0F30  0263     SUBWF i, W
0F31  1C03     BTFSS STATUS, 0x0
0F32  2F34     GOTO 0x734
0F33  2F35     GOTO 0x735
0F34  2F1F     GOTO 0x71F
1996:          
1997:              //clear the alternate interface settings
1998:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0F35  30BD     MOVLW 0xBD
0F36  00F0     MOVWF 0xF0
0F37  3001     MOVLW 0x1
0F38  00F1     MOVWF 0xF1
0F39  3000     MOVLW 0x0
0F3A  00F2     MOVWF 0xF2
0F3B  00F3     MOVWF 0xF3
0F3C  3003     MOVLW 0x3
0F3D  00F4     MOVWF 0xF4
0F3E  3000     MOVLW 0x0
0F3F  00F5     MOVWF 0xF5
0F40  3184     MOVLP 0x4
0F41  24CA     CALL 0x4CA
0F42  318E     MOVLP 0xE
1999:          
2000:              //Stop trying to reset ping pong buffer pointers
2001:              USBPingPongBufferReset = 0;
0F43  003D     MOVLB 0x1D
0F44  130E     BCF UCON, 0x6
2002:          
2003:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0F45  3028     MOVLW 0x28
0F46  0021     MOVLB 0x1
0F47  00B0     MOVWF pBDTEntryIn
0F48  3000     MOVLW 0x0
0F49  00B1     MOVWF 0xB1
2004:          
2005:          	//Set the next out to the current out packet
2006:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0F4A  3020     MOVLW 0x20
0F4B  00DF     MOVWF 0xDF
0F4C  085F     MOVF 0xDF, W
0F4D  00D3     MOVWF pBDTEntryEP0OutCurrent
2007:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0F4E  0853     MOVF pBDTEntryEP0OutCurrent, W
0F4F  00C1     MOVWF pBDTEntryEP0OutNext
0F50  39FF     ANDLW 0xFF
0F51  1D03     BTFSS STATUS, 0x2
0F52  3000     MOVLW 0x0
0F53  00C2     MOVWF 0xC2
2008:          
2009:              //set the current configuration
2010:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0F54  0020     MOVLB 0x0
0F55  0862     MOVF 0x62, W
0F56  0021     MOVLB 0x1
0F57  00DF     MOVWF 0xDF
0F58  085F     MOVF 0xDF, W
0F59  00D8     MOVWF USBActiveConfiguration
2011:          
2012:              //if the configuration value == 0
2013:              if(USBActiveConfiguration == 0)
0F5A  0858     MOVF USBActiveConfiguration, W
0F5B  1D03     BTFSS STATUS, 0x2
0F5C  2F5E     GOTO 0x75E
0F5D  2F5F     GOTO 0x75F
0F5E  2F64     GOTO 0x764
2014:              {
2015:                  //Go back to the addressed state
2016:                  USBDeviceState = ADDRESS_STATE;
0F5F  3010     MOVLW 0x10
0F60  00DF     MOVWF 0xDF
0F61  085F     MOVF 0xDF, W
0F62  00D4     MOVWF USBDeviceState
2017:              }
0F63  2F78     GOTO 0x778
2018:              else
2019:              {
2020:                  //initialize the required endpoints
2021:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0F64  3001     MOVLW 0x1
0F65  00D9     MOVWF __pcstackBANK1
0F66  3000     MOVLW 0x0
0F67  00DA     MOVWF 0xDA
0F68  30D8     MOVLW 0xD8
0F69  00DB     MOVWF pdata
0F6A  3000     MOVLW 0x0
0F6B  00DC     MOVWF 0xDC
0F6C  3001     MOVLW 0x1
0F6D  00DD     MOVWF size
0F6E  3000     MOVLW 0x0
0F6F  00DE     MOVWF 0xDE
0F70  318A     MOVLP 0xA
0F71  22FE     CALL 0x2FE
0F72  318E     MOVLP 0xE
2022:          
2023:                  //Otherwise go to the configured state.  Update the state variable last,
2024:                  //after performing all of the set configuration related initialization
2025:                  //tasks.
2026:                  USBDeviceState = CONFIGURED_STATE;
0F73  3020     MOVLW 0x20
0F74  0021     MOVLB 0x1
0F75  00DF     MOVWF 0xDF
0F76  085F     MOVF 0xDF, W
0F77  00D4     MOVWF USBDeviceState
2027:              }//end if(SetupPkt.bConfigurationValue == 0)
2028:          }//end USBStdSetCfgHandler
0F78  0008     RETURN
2029:          
2030:          
2031:          /********************************************************************
2032:           * Function:        void USBStdGetDscHandler(void)
2033:           *
2034:           * PreCondition:    None
2035:           *
2036:           * Input:           None
2037:           *
2038:           * Output:          None
2039:           *
2040:           * Side Effects:    None
2041:           *
2042:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2043:           *                  request.
2044:           *
2045:           * Note:            None
2046:           *******************************************************************/
2047:          static void USBStdGetDscHandler(void)
2048:          {
2049:              if(SetupPkt.bmRequestType == 0x80)
0E6E  3080     MOVLW 0x80
0E6F  0020     MOVLB 0x0
0E70  0660     XORWF SetupPkt, W
0E71  1D03     BTFSS STATUS, 0x2
0E72  2E74     GOTO 0x674
0E73  2E75     GOTO 0x675
0E74  2EF2     GOTO 0x6F2
2050:              {
2051:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0E75  30C0     MOVLW 0xC0
0E76  00F0     MOVWF __pcstackCOMMON
0E77  0870     MOVF __pcstackCOMMON, W
0E78  0021     MOVLB 0x1
0E79  00BA     MOVWF 0xBA
2052:          
2053:                  switch(SetupPkt.bDescriptorType)
0E7A  2EDE     GOTO 0x6DE
2054:                  {
2055:                      case USB_DESCRIPTOR_DEVICE:
2056:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2057:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2058:                          #else
2059:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0E7B  3042     MOVLW 0x42
0E7C  0021     MOVLB 0x1
0E7D  00B8     MOVWF inPipes
0E7E  3091     MOVLW 0x91
0E7F  00B9     MOVWF 0xB9
2060:                          #endif
2061:                          inPipes[0].wCount.Val = sizeof(device_dsc);
0E80  3012     MOVLW 0x12
0E81  00BB     MOVWF 0xBB
0E82  3000     MOVLW 0x0
0E83  00BC     MOVWF 0xBC
2062:                          break;
0E84  2EF2     GOTO 0x6F2
2063:                      case USB_DESCRIPTOR_CONFIGURATION:
2064:                          //First perform error case check, to make sure the host is requesting a
2065:                          //legal descriptor index.  If the request index is illegal, don't do
2066:                          //anything (so that the default STALL response will be sent).
2067:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0E85  0862     MOVF i, W
0E86  1D03     BTFSS STATUS, 0x2
0E87  2E89     GOTO 0x689
0E88  2E8A     GOTO 0x68A
0E89  2EB9     GOTO 0x6B9
2068:                          {
2069:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2070:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2071:                              #else
2072:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0E8A  0862     MOVF i, W
0E8B  00F0     MOVWF 0xF0
0E8C  01F1     CLRF 0xF1
0E8D  35F0     LSLF 0xF0, F
0E8E  0DF1     RLF 0xF1, F
0E8F  305E     MOVLW 0x5E
0E90  0770     ADDWF 0xF0, W
0E91  0084     MOVWF FSR0L
0E92  3091     MOVLW 0x91
0E93  3D71     ADDWFC 0xF1, W
0E94  0085     MOVWF FSR0H
0E95  3F00     MOVIW 0[FSR0]
0E96  0021     MOVLB 0x1
0E97  00B8     MOVWF inPipes
0E98  3F01     MOVIW 1[FSR0]
0E99  00B9     MOVWF 0xB9
2073:                              #endif
2074:          
2075:                              //This must be loaded using byte addressing.  The source pointer
2076:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2077:                              //  in an address error on the dereference.
2078:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0E9A  0839     MOVF 0xB9, W
0E9B  00F1     MOVWF 0xF1
0E9C  0838     MOVF inPipes, W
0E9D  00F0     MOVWF 0xF0
0E9E  3002     MOVLW 0x2
0E9F  0770     ADDWF 0xF0, W
0EA0  0084     MOVWF FSR0L
0EA1  0871     MOVF 0xF1, W
0EA2  1803     BTFSC STATUS, 0x0
0EA3  0A71     INCF 0xF1, W
0EA4  0085     MOVWF FSR0H
0EA5  0800     MOVF INDF0, W
0EA6  00F2     MOVWF 0xF2
0EA7  0872     MOVF 0xF2, W
0EA8  00BB     MOVWF 0xBB
2079:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0EA9  0839     MOVF 0xB9, W
0EAA  00F1     MOVWF 0xF1
0EAB  0838     MOVF inPipes, W
0EAC  00F0     MOVWF 0xF0
0EAD  3003     MOVLW 0x3
0EAE  0770     ADDWF 0xF0, W
0EAF  0084     MOVWF FSR0L
0EB0  0871     MOVF 0xF1, W
0EB1  1803     BTFSC STATUS, 0x0
0EB2  0A71     INCF 0xF1, W
0EB3  0085     MOVWF FSR0H
0EB4  0800     MOVF INDF0, W
0EB5  00F2     MOVWF 0xF2
0EB6  0872     MOVF 0xF2, W
0EB7  00BC     MOVWF 0xBC
2080:                          }
0EB8  2EF2     GOTO 0x6F2
2081:          				else
2082:          				{
2083:          					inPipes[0].info.Val = 0;
0EB9  0021     MOVLB 0x1
0EBA  01BA     CLRF 0xBA
0EBB  2EF2     GOTO 0x6F2
2084:          				}
2085:                          break;
2086:                      case USB_DESCRIPTOR_STRING:
2087:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2088:                          //  later it is now mandatory.  This should be defined in usb_config.h and should
2089:                          //  indicate the number of string descriptors.
2090:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0EBC  3003     MOVLW 0x3
0EBD  0262     SUBWF i, W
0EBE  1803     BTFSC STATUS, 0x0
0EBF  2EC1     GOTO 0x6C1
0EC0  2EC2     GOTO 0x6C2
0EC1  2EB9     GOTO 0x6B9
2091:                          {
2092:                              //Get a pointer to the String descriptor requested
2093:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0EC2  0862     MOVF i, W
0EC3  00F0     MOVWF 0xF0
0EC4  01F1     CLRF 0xF1
0EC5  35F0     LSLF 0xF0, F
0EC6  0DF1     RLF 0xF1, F
0EC7  3054     MOVLW 0x54
0EC8  0770     ADDWF 0xF0, W
0EC9  0084     MOVWF FSR0L
0ECA  3091     MOVLW 0x91
0ECB  3D71     ADDWFC 0xF1, W
0ECC  0085     MOVWF FSR0H
0ECD  3F00     MOVIW 0[FSR0]
0ECE  0021     MOVLB 0x1
0ECF  00B8     MOVWF inPipes
0ED0  3F01     MOVIW 1[FSR0]
0ED1  00B9     MOVWF 0xB9
2094:                              // Set data count
2095:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
0ED2  0838     MOVF inPipes, W
0ED3  0084     MOVWF FSR0L
0ED4  0839     MOVF 0xB9, W
0ED5  0085     MOVWF FSR0H
0ED6  0800     MOVF INDF0, W
0ED7  00F0     MOVWF 0xF0
0ED8  01F1     CLRF 0xF1
0ED9  0870     MOVF 0xF0, W
0EDA  00BB     MOVWF 0xBB
0EDB  0871     MOVF 0xF1, W
0EDC  00BC     MOVWF 0xBC
2096:                          }
0EDD  2EF2     GOTO 0x6F2
2097:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2098:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2099:                          {
2100:                              //Get a pointer to the special MS OS string descriptor requested
2101:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2102:                              // Set data count
2103:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
2104:                          }
2105:                          #endif
2106:                          else
2107:                          {
2108:                              inPipes[0].info.Val = 0;
2109:                          }
2110:                          break;
2111:                      default:
2112:                          inPipes[0].info.Val = 0;
2113:                          break;
2114:                  }//end switch
0EDE  0020     MOVLB 0x0
0EDF  0863     MOVF 0x63, W
0EE0  00F0     MOVWF __pcstackCOMMON
0EE1  01F1     CLRF p
0EE2  0871     MOVF p, W
0EE3  3A00     XORLW 0x0
0EE4  1903     BTFSC STATUS, 0x2
0EE5  2EE7     GOTO 0x6E7
0EE6  2EB9     GOTO 0x6B9
0EE7  0870     MOVF __pcstackCOMMON, W
0EE8  3A01     XORLW 0x1
0EE9  1903     BTFSC STATUS, 0x2
0EEA  2E7B     GOTO 0x67B
0EEB  3A03     XORLW 0x3
0EEC  1903     BTFSC STATUS, 0x2
0EED  2E85     GOTO 0x685
0EEE  3A01     XORLW 0x1
0EEF  1903     BTFSC STATUS, 0x2
0EF0  2EBC     GOTO 0x6BC
0EF1  2EB9     GOTO 0x6B9
2115:              }//end if
2116:          }//end USBStdGetDscHandler
0EF2  0008     RETURN
2117:          
2118:          /********************************************************************
2119:           * Function:        void USBStdGetStatusHandler(void)
2120:           *
2121:           * PreCondition:    None
2122:           *
2123:           * Input:           None
2124:           *
2125:           * Output:          None
2126:           *
2127:           * Side Effects:    None
2128:           *
2129:           * Overview:        This routine handles the standard GET_STATUS request
2130:           *
2131:           * Note:            None
2132:           *******************************************************************/
2133:          static void USBStdGetStatusHandler(void)
2134:          {
2135:              CtrlTrfData[0] = 0;                 // Initialize content
0CA2  0020     MOVLB 0x0
0CA3  01E8     CLRF CtrlTrfData
2136:              CtrlTrfData[1] = 0;
0CA4  01E9     CLRF 0x69
2137:          
2138:              switch(SetupPkt.Recipient)
0CA5  2CEC     GOTO 0x4EC
2139:              {
2140:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2141:                      inPipes[0].info.bits.busy = 1;
0CA6  0021     MOVLB 0x1
0CA7  17BA     BSF 0xBA, 0x7
2142:                      /*
2143:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2144:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2145:                       */
2146:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2147:                      {
2148:                          CtrlTrfData[0]|=0x01;
2149:                      }
2150:          
2151:                      if(RemoteWakeup == true)
0CA8  034F     DECF RemoteWakeup, W
0CA9  1D03     BTFSS STATUS, 0x2
0CAA  2CAC     GOTO 0x4AC
0CAB  2CAD     GOTO 0x4AD
0CAC  2D00     GOTO 0x500
2152:                      {
2153:                          CtrlTrfData[0]|=0x02;
0CAD  0020     MOVLB 0x0
0CAE  14E8     BSF CtrlTrfData, 0x1
0CAF  2D00     GOTO 0x500
2154:                      }
2155:                      break;
2156:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2157:                      inPipes[0].info.bits.busy = 1;     // No data to update
0CB0  0021     MOVLB 0x1
0CB1  17BA     BSF 0xBA, 0x7
2158:                      break;
0CB2  2D00     GOTO 0x500
2159:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2160:                      inPipes[0].info.bits.busy = 1;
0CB3  0021     MOVLB 0x1
0CB4  17BA     BSF 0xBA, 0x7
2161:                      /*
2162:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2163:                       */
2164:                      if(SetupPkt.EPNum != 0)
0CB5  0020     MOVLB 0x0
0CB6  0864     MOVF 0x64, W
0CB7  390F     ANDLW 0xF
0CB8  3A00     XORLW 0x0
0CB9  1903     BTFSC STATUS, 0x2
0CBA  2CBC     GOTO 0x4BC
0CBB  2CBD     GOTO 0x4BD
0CBC  2D00     GOTO 0x500
2165:                      {
2166:                          BDT_ENTRY *p;
2167:          
2168:                          if(SetupPkt.EPDir == 0)
0CBD  1BE4     BTFSC 0x64, 0x7
0CBE  2CC0     GOTO 0x4C0
0CBF  2CC1     GOTO 0x4C1
0CC0  2CCD     GOTO 0x4CD
2169:                          {
2170:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0CC1  0864     MOVF 0x64, W
0CC2  390F     ANDLW 0xF
0CC3  0709     ADDWF WREG, W
0CC4  3EA0     ADDLW 0xA0
0CC5  0086     MOVWF FSR1
0CC6  3001     MOVLW 0x1
0CC7  0087     MOVWF FSR1H
0CC8  3F40     MOVIW 0[FSR1]
0CC9  00F2     MOVWF n
0CCA  3F41     MOVIW 1[FSR1]
0CCB  00F3     MOVWF i
2171:                          }
0CCC  2CD7     GOTO 0x4D7
2172:                          else
2173:                          {
2174:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0CCD  0864     MOVF 0x64, W
0CCE  390F     ANDLW 0xF
0CCF  0709     ADDWF WREG, W
0CD0  3EB0     ADDLW 0xB0
0CD1  0086     MOVWF FSR1
0CD2  0187     CLRF FSR1H
0CD3  3F40     MOVIW 0[FSR1]
0CD4  00F2     MOVWF n
0CD5  3F41     MOVIW 1[FSR1]
0CD6  00F3     MOVWF i
2175:                          }
2176:          
2177:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
0CD7  0872     MOVF n, W
0CD8  0086     MOVWF FSR1
0CD9  0873     MOVF i, W
0CDA  0087     MOVWF FSR1H
0CDB  1F81     BTFSS INDF1, 0x7
0CDC  2CDE     GOTO 0x4DE
0CDD  2CDF     GOTO 0x4DF
0CDE  2D00     GOTO 0x500
0CDF  0872     MOVF n, W
0CE0  0086     MOVWF FSR1
0CE1  0873     MOVF i, W
0CE2  0087     MOVWF FSR1H
0CE3  1D01     BTFSS INDF1, 0x2
0CE4  2CE6     GOTO 0x4E6
0CE5  2CE7     GOTO 0x4E7
0CE6  2D00     GOTO 0x500
2178:                          {
2179:                              CtrlTrfData[0]=0x01;    // Set bit0
0CE7  3001     MOVLW 0x1
0CE8  00F0     MOVWF __pcstackCOMMON
0CE9  0870     MOVF __pcstackCOMMON, W
0CEA  00E8     MOVWF CtrlTrfData
0CEB  2D00     GOTO 0x500
2180:                          }
2181:                      }
2182:                      break;
2183:              }//end switch
0CEC  0860     MOVF SetupPkt, W
0CED  391F     ANDLW 0x1F
0CEE  00F0     MOVWF __pcstackCOMMON
0CEF  01F1     CLRF p
0CF0  0871     MOVF p, W
0CF1  3A00     XORLW 0x0
0CF2  1903     BTFSC STATUS, 0x2
0CF3  2CF5     GOTO 0x4F5
0CF4  2D00     GOTO 0x500
0CF5  0870     MOVF __pcstackCOMMON, W
0CF6  3A00     XORLW 0x0
0CF7  1903     BTFSC STATUS, 0x2
0CF8  2CA6     GOTO 0x4A6
0CF9  3A01     XORLW 0x1
0CFA  1903     BTFSC STATUS, 0x2
0CFB  2CB0     GOTO 0x4B0
0CFC  3A03     XORLW 0x3
0CFD  1903     BTFSC STATUS, 0x2
0CFE  2CB3     GOTO 0x4B3
0CFF  2D00     GOTO 0x500
2184:          
2185:              if(inPipes[0].info.bits.busy == 1)
0D00  0021     MOVLB 0x1
0D01  1FBA     BTFSS 0xBA, 0x7
0D02  2D04     GOTO 0x504
0D03  2D05     GOTO 0x505
0D04  2D0E     GOTO 0x50E
2186:              {
2187:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
0D05  3068     MOVLW 0x68
0D06  00B8     MOVWF inPipes
0D07  3000     MOVLW 0x0
0D08  00B9     MOVWF 0xB9
2188:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
0D09  143A     BSF 0xBA, 0x0
2189:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
0D0A  3002     MOVLW 0x2
0D0B  00F0     MOVWF 0xF0
0D0C  0870     MOVF 0xF0, W
0D0D  00BB     MOVWF 0xBB
2190:              }//end if(...)
2191:          }//end USBStdGetStatusHandler
0D0E  0008     RETURN
2192:          
2193:          /********************************************************************
2194:           * Function:        void USBStallHandler(void)
2195:           *
2196:           * PreCondition:    None
2197:           *
2198:           * Input:           None
2199:           *
2200:           * Output:          None
2201:           *
2202:           * Side Effects:
2203:           *
2204:           * Overview:        This function handles the event of a STALL
2205:           *                  occurring on the bus
2206:           *
2207:           * Note:            None
2208:           *******************************************************************/
2209:          static void USBStallHandler(void)
2210:          {
2211:              /*
2212:               * Does not really have to do anything here,
2213:               * even for the control endpoint.
2214:               * All BDs of Endpoint 0 are owned by SIE right now,
2215:               * but once a Setup Transaction is received, the ownership
2216:               * for EP0_OUT will be returned to CPU.
2217:               * When the Setup Transaction is serviced, the ownership
2218:               * for EP0_IN will then be forced back to CPU by firmware.
2219:               */
2220:          
2221:              if(U1EP0bits.EPSTALL == 1)
09E9  003D     MOVLB 0x1D
09EA  1C18     BTFSS UEP0, 0x0
09EB  29ED     GOTO 0x1ED
09EC  29EE     GOTO 0x1EE
09ED  2A0F     GOTO 0x20F
2222:              {
2223:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2224:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
09EE  0021     MOVLB 0x1
09EF  0853     MOVF pBDTEntryEP0OutCurrent, W
09F0  0086     MOVWF FSR1L
09F1  0187     CLRF FSR1H
09F2  3080     MOVLW 0x80
09F3  0601     XORWF INDF1, W
09F4  1D03     BTFSS STATUS, 0x2
09F5  29F7     GOTO 0x1F7
09F6  29F8     GOTO 0x1F8
09F7  2A0D     GOTO 0x20D
09F8  0830     MOVF pBDTEntryIn, W
09F9  0086     MOVWF FSR1L
09FA  0831     MOVF 0xB1, W
09FB  0087     MOVWF FSR1H
09FC  3084     MOVLW 0x84
09FD  0601     XORWF INDF1, W
09FE  1D03     BTFSS STATUS, 0x2
09FF  2A01     GOTO 0x201
0A00  2A02     GOTO 0x202
0A01  2A0D     GOTO 0x20D
2225:                  {
2226:                      // Set ep0Bo to stall also
2227:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0A02  300C     MOVLW 0xC
0A03  00F0     MOVWF 0xF0
0A04  0853     MOVF pBDTEntryEP0OutCurrent, W
0A05  0086     MOVWF FSR1L
0A06  0187     CLRF FSR1H
0A07  0870     MOVF 0xF0, W
0A08  0081     MOVWF INDF1
2228:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0A09  0853     MOVF pBDTEntryEP0OutCurrent, W
0A0A  0086     MOVWF FSR1L
0A0B  0187     CLRF FSR1H
0A0C  1781     BSF INDF1, 0x7
2229:                  }//end if
2230:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
0A0D  003D     MOVLB 0x1D
0A0E  1018     BCF UEP0, 0x0
2231:              }//end if
2232:          
2233:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
0A0F  30DF     MOVLW 0xDF
0A10  00F0     MOVWF 0xEF0
0A11  0870     MOVF 0xEF0, W
0A12  0590     ANDWF UIR, F
2234:          }
0A13  0008     RETURN
2235:          
2236:          /********************************************************************
2237:           * Function:        void USBSuspend(void)
2238:           *
2239:           * PreCondition:    None
2240:           *
2241:           * Input:           None
2242:           *
2243:           * Output:          None
2244:           *
2245:           * Side Effects:
2246:           *
2247:           * Overview:        This function handles if the host tries to
2248:           *                  suspend the device
2249:           *
2250:           * Note:            None
2251:           *******************************************************************/
2252:          static void USBSuspend(void)
2253:          {
2254:              /*
2255:               * NOTE: Do not clear UIRbits.ACTVIF here!
2256:               * Reason:
2257:               * ACTVIF is only generated once an IDLEIF has been generated.
2258:               * This is a 1:1 ratio interrupt generation.
2259:               * For every IDLEIF, there will be only one ACTVIF regardless of
2260:               * the number of subsequent bus transitions.
2261:               *
2262:               * If the ACTIF is cleared here, a problem could occur when:
2263:               * [       IDLE       ][bus activity ->
2264:               * <--- 3 ms ----->     ^
2265:               *                ^     ACTVIF=1
2266:               *                IDLEIF=1
2267:               *  #           #           #           #   (#=Program polling flags)
2268:               *                          ^
2269:               *                          This polling loop will see both
2270:               *                          IDLEIF=1 and ACTVIF=1.
2271:               *                          However, the program services IDLEIF first
2272:               *                          because ACTIVIE=0.
2273:               *                          If this routine clears the only ACTIVIF,
2274:               *                          then it can never get out of the suspend
2275:               *                          mode.
2276:               */
2277:              USBActivityIE = 1;                     // Enable bus activity interrupt
0890  003D     MOVLB 0x1D
0891  1512     BSF UIE, 0x2
2278:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
0892  30EF     MOVLW 0xEF
0893  0021     MOVLB 0x1
0894  00DF     MOVWF 0xDF
0895  085F     MOVF 0xDF, W
0896  003D     MOVLB 0x1D
0897  0590     ANDWF UIR, F
2279:          
2280:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2281:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
0898  148E     BSF UCON, 0x1
2282:                                                          // mode, SIE clock inactive
2283:              #endif
2284:              USBBusIsSuspended = true;
0899  0021     MOVLB 0x1
089A  01CE     CLRF USBBusIsSuspended
089B  0ACE     INCF USBBusIsSuspended, F
2285:              USBTicksSinceSuspendEnd = 0;
089C  01C5     CLRF USBTicksSinceSuspendEnd
2286:          
2287:              /*
2288:               * At this point the PIC can go into sleep,idle, or
2289:               * switch to a slower clock, etc.  This should be done in the
2290:               * USBCBSuspend() if necessary.
2291:               */
2292:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
089D  3075     MOVLW 0x75
089E  00D9     MOVWF __pcstackBANK1
089F  3000     MOVLW 0x0
08A0  00DA     MOVWF 0xDA
08A1  3000     MOVLW 0x0
08A2  00DB     MOVWF pdata
08A3  3000     MOVLW 0x0
08A4  00DC     MOVWF 0xDC
08A5  3000     MOVLW 0x0
08A6  00DD     MOVWF size
08A7  00DE     MOVWF 0xDE
08A8  318A     MOVLP 0xA
08A9  22FE     CALL 0x2FE
08AA  3188     MOVLP 0x8
2293:          }
08AB  0008     RETURN
2294:          
2295:          /********************************************************************
2296:           * Function:        void USBWakeFromSuspend(void)
2297:           *
2298:           * PreCondition:    None
2299:           *
2300:           * Input:           None
2301:           *
2302:           * Output:          None
2303:           *
2304:           * Side Effects:    None
2305:           *
2306:           * Overview:
2307:           *
2308:           * Note:            None
2309:           *******************************************************************/
2310:          static void USBWakeFromSuspend(void)
2311:          {
2312:              USBBusIsSuspended = false;
08EA  0021     MOVLB 0x1
08EB  01CE     CLRF USBBusIsSuspended
2313:          
2314:              /*
2315:               * If using clock switching, the place to restore the original
2316:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2317:               */
2318:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
08EC  3074     MOVLW 0x74
08ED  00D9     MOVWF __pcstackBANK1
08EE  3000     MOVLW 0x0
08EF  00DA     MOVWF 0xDA
08F0  3000     MOVLW 0x0
08F1  00DB     MOVWF pdata
08F2  3000     MOVLW 0x0
08F3  00DC     MOVWF 0xDC
08F4  3000     MOVLW 0x0
08F5  00DD     MOVWF size
08F6  00DE     MOVWF 0xDE
08F7  318A     MOVLP 0xA
08F8  22FE     CALL 0x2FE
08F9  3188     MOVLP 0x8
2319:          
2320:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2321:                  //To avoid improperly clocking the USB module, make sure the oscillator
2322:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2323:                  //Make sure the correct oscillator settings are selected in the
2324:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2325:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
08FA  003D     MOVLB 0x1D
08FB  108E     BCF UCON, 0x1
2326:                                          // mode.
2327:              #endif
2328:          
2329:          
2330:              USBActivityIE = 0;
08FC  1112     BCF UIE, 0x2
2331:          
2332:              /********************************************************************
2333:              Bug Fix: Feb 26, 2007 v2.1
2334:              *********************************************************************
2335:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2336:              up from Suspend or while the USB module is suspended. A few clock cycles
2337:              are required to synchronize the internal hardware state machine before
2338:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2339:              before the internal hardware is synchronized may not have an effect on
2340:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2341:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2342:              module may not be immediately operational while waiting for the 96 MHz
2343:              PLL to lock.
2344:              ********************************************************************/
2345:          
2346:              // UIRbits.ACTVIF = 0;                      // Removed
2347:              #if defined(__18CXX) || defined(__XC8)
2348:              while(USBActivityIF)
08FD  2904     GOTO 0x104
0904  1910     BTFSC UIR, 0x2
0905  2907     GOTO 0x107
0906  2908     GOTO 0x108
0907  28FE     GOTO 0xFE
2349:              #endif
2350:              {
2351:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
08FE  30FB     MOVLW 0xFB
08FF  0021     MOVLB 0x1
0900  00DF     MOVWF 0xDF
0901  085F     MOVF 0xDF, W
0902  003D     MOVLB 0x1D
0903  0590     ANDWF UIR, F
2352:              }  // Added
2353:          
2354:              USBTicksSinceSuspendEnd = 0;
0908  0021     MOVLB 0x1
0909  01C5     CLRF USBTicksSinceSuspendEnd
2355:          
2356:          }//end USBWakeFromSuspend
090A  0008     RETURN
2357:          
2358:          /********************************************************************
2359:           * Function:        void USBCtrlEPService(void)
2360:           *
2361:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2362:           *
2363:           * Input:           None
2364:           *
2365:           * Output:          None
2366:           *
2367:           * Side Effects:    None
2368:           *
2369:           * Overview:        USBCtrlEPService checks for three transaction
2370:           *                  types that it knows how to service and services
2371:           *                  them:
2372:           *                  1. EP0 SETUP
2373:           *                  2. EP0 OUT
2374:           *                  3. EP0 IN
2375:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2376:           *
2377:           * Note:            None
2378:           *******************************************************************/
2379:          static void USBCtrlEPService(void)
2380:          {
2381:              //If we get to here, that means a successful transaction has just occurred
2382:              //on EP0.  This means "progress" has occurred in the currently pending
2383:              //control transfer, so we should re-initialize our timeout counter.
2384:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2385:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
0B8C  302D     MOVLW 0x2D
0B8D  0021     MOVLB 0x1
0B8E  00E9     MOVWF 0xE9
0B8F  0869     MOVF 0xE9, W
0B90  00CB     MOVWF USBStatusStageTimeoutCounter
2386:              #endif
2387:          
2388:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2389:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
0B91  0857     MOVF USTATcopy, W
0B92  39FD     ANDLW 0xFD
0B93  1D03     BTFSS STATUS, 0x2
0B94  2B96     GOTO 0x396
0B95  2B97     GOTO 0x397
0B96  2BD3     GOTO 0x3D3
2390:              {
2391:          		//Point to the EP0 OUT buffer of the buffer that arrived
2392:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2393:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
0B97  3657     LSRF USTATcopy, W
0B98  393F     ANDLW 0x3F
0B99  00E9     MOVWF 0xE9
0B9A  3001     MOVLW 0x1
0B9B  35E9     LSLF 0xE9, F
0B9C  3EFF     ADDLW 0xFF
0B9D  1D03     BTFSS STATUS, 0x2
0B9E  2B9B     GOTO 0x39B
0B9F  3569     LSLF 0xE9, W
0BA0  3E20     ADDLW 0x20
0BA1  00EA     MOVWF 0xEA
0BA2  086A     MOVF 0xEA, W
0BA3  00D3     MOVWF pBDTEntryEP0OutCurrent
2394:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2395:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2396:                  #else
2397:                      #error "unimplemented"
2398:                  #endif
2399:          
2400:          		//Set the next out to the current out packet
2401:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0BA4  0853     MOVF pBDTEntryEP0OutCurrent, W
0BA5  00C1     MOVWF pBDTEntryEP0OutNext
0BA6  39FF     ANDLW 0xFF
0BA7  1D03     BTFSS STATUS, 0x2
0BA8  3000     MOVLW 0x0
0BA9  00C2     MOVWF 0xC2
2402:          		//Toggle it to the next ping pong buffer (if applicable)
2403:                  pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
0BAA  3004     MOVLW 0x4
0BAB  0641     XORWF pBDTEntryEP0OutNext, W
0BAC  00C1     MOVWF pBDTEntryEP0OutNext
0BAD  3000     MOVLW 0x0
0BAE  0642     XORWF 0xC2, W
0BAF  00C2     MOVWF 0xC2
2404:          
2405:          		//If the current EP0 OUT buffer has a SETUP packet
2406:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
0BB0  0853     MOVF pBDTEntryEP0OutCurrent, W
0BB1  0086     MOVWF FSR1L
0BB2  0187     CLRF FSR1H
0BB3  0C01     RRF INDF1, W
0BB4  0C89     RRF WREG, F
0BB5  390F     ANDLW 0xF
0BB6  3A0D     XORLW 0xD
0BB7  1D03     BTFSS STATUS, 0x2
0BB8  2BBA     GOTO 0x3BA
0BB9  2BBB     GOTO 0x3BB
0BBA  2BCF     GOTO 0x3CF
2407:                  {
2408:          	        //The SETUP transaction data may have gone into the the CtrlTrfData
2409:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2410:          	        //before the transaction.  Therefore, we should copy the data to the
2411:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().
2412:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
0BBB  0853     MOVF pBDTEntryEP0OutCurrent, W
0BBC  3E02     ADDLW 0x2
0BBD  0086     MOVWF FSR1L
0BBE  0187     CLRF FSR1H
0BBF  3F40     MOVIW 0[FSR1]
0BC0  00F0     MOVWF 0xF0
0BC1  3F41     MOVIW 1[FSR1]
0BC2  00F1     MOVWF 0xF1
0BC3  3008     MOVLW 0x8
0BC4  00F2     MOVWF 0xF2
0BC5  3000     MOVLW 0x0
0BC6  00F3     MOVWF 0xF3
0BC7  3060     MOVLW 0x60
0BC8  318A     MOVLP 0xA
0BC9  2214     CALL 0x214
0BCA  318B     MOVLP 0xB
2413:          
2414:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2415:                      USBCtrlTrfSetupHandler();
0BCB  318B     MOVLP 0xB
0BCC  2344     CALL 0x344
0BCD  318B     MOVLP 0xB
2416:                  }
0BCE  2BDF     GOTO 0x3DF
2417:                  else
2418:                  {
2419:          			//Handle the DATA transfer
2420:                      USBCtrlTrfOutHandler();
0BCF  318A     MOVLP 0xA
0BD0  2242     CALL 0x242
0BD1  318B     MOVLP 0xB
0BD2  2BDF     GOTO 0x3DF
2421:                  }
2422:              }
2423:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
0BD3  30FD     MOVLW 0xFD
0BD4  0557     ANDWF USTATcopy, W
0BD5  00E9     MOVWF 0xE9
0BD6  3004     MOVLW 0x4
0BD7  0669     XORWF 0xE9, W
0BD8  1D03     BTFSS STATUS, 0x2
0BD9  2BDB     GOTO 0x3DB
0BDA  2BDC     GOTO 0x3DC
0BDB  2BDF     GOTO 0x3DF
2424:              {
2425:          		//Otherwise the transmission was and EP0 IN
2426:          		//  so take care of the IN transfer
2427:                  USBCtrlTrfInHandler();
0BDC  318D     MOVLP 0xD
0BDD  25F6     CALL 0x5F6
0BDE  318B     MOVLP 0xB
2428:              }
2429:          
2430:          }//end USBCtrlEPService
0BDF  0008     RETURN
2431:          
2432:          /********************************************************************
2433:           * Function:        void USBCtrlTrfSetupHandler(void)
2434:           *
2435:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2436:           *
2437:           * Input:           None
2438:           *
2439:           * Output:          None
2440:           *
2441:           * Side Effects:    None
2442:           *
2443:           * Overview:        This routine is a task dispatcher and has 3 stages.
2444:           *                  1. It initializes the control transfer state machine.
2445:           *                  2. It calls on each of the module that may know how to
2446:           *                     service the Setup Request from the host.
2447:           *                     Module Example: USBD, HID, CDC, MSD, ...
2448:           *                     A callback function, USBCBCheckOtherReq(),
2449:           *                     is required to call other module handlers.
2450:           *                  3. Once each of the modules has had a chance to check if
2451:           *                     it is responsible for servicing the request, stage 3
2452:           *                     then checks direction of the transfer to determine how
2453:           *                     to prepare EP0 for the control transfer.
2454:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2455:           *
2456:           * Note:            Microchip USB Firmware has three different states for
2457:           *                  the control transfer state machine:
2458:           *                  1. WAIT_SETUP
2459:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2460:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2461:           *                  Refer to firmware manual to find out how one state
2462:           *                  is transitioned to another.
2463:           *
2464:           *                  A Control Transfer is composed of many USB transactions.
2465:           *                  When transferring data over multiple transactions,
2466:           *                  it is important to keep track of data source, data
2467:           *                  destination, and data count. These three parameters are
2468:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2469:           *                  note if the data source is from const or RAM.
2470:           *
2471:           *******************************************************************/
2472:          static void USBCtrlTrfSetupHandler(void)
2473:          {
2474:              //--------------------------------------------------------------------------
2475:              //1. Re-initialize state tracking variables related to control transfers.
2476:              //--------------------------------------------------------------------------
2477:              shortPacketStatus = SHORT_PKT_NOT_USED;
0B44  0021     MOVLB 0x1
0B45  01D2     CLRF shortPacketStatus
2478:              USBDeferStatusStagePacket = false;
0B46  01CA     CLRF USBDeferStatusStagePacket
2479:              USBDeferINDataStagePackets = false;
0B47  01C7     CLRF USBDeferINDataStagePackets
2480:              USBDeferOUTDataStagePackets = false;
0B48  01C6     CLRF USBDeferOUTDataStagePackets
2481:              BothEP0OutUOWNsSet = false;
0B49  01CC     CLRF BothEP0OutUOWNsSet
2482:              controlTransferState = WAIT_SETUP;
0B4A  01D1     CLRF controlTransferState
2483:          
2484:              //Abandon any previous control transfers that might have been using EP0.
2485:              //Ordinarily, nothing actually needs abandoning, since the previous control
2486:              //transfer would have completed successfully prior to the host sending the next
2487:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2488:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2489:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2490:              //by the class request handler that will be called next.
2491:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
0B4B  307F     MOVLW 0x7F
0B4C  00E8     MOVWF 0xE8
0B4D  0830     MOVF pBDTEntryIn, W
0B4E  0086     MOVWF FSR1L
0B4F  0831     MOVF 0xB1, W
0B50  0087     MOVWF FSR1H
0B51  0868     MOVF 0xE8, W
0B52  0581     ANDWF INDF1, F
2492:          
2493:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0B53  3004     MOVLW 0x4
0B54  0630     XORWF pBDTEntryIn, W
0B55  00B0     MOVWF pBDTEntryIn
0B56  3000     MOVLW 0x0
0B57  0631     XORWF 0xB1, W
0B58  00B1     MOVWF 0xB1
2494:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
0B59  307F     MOVLW 0x7F
0B5A  00E8     MOVWF 0xE8
0B5B  0830     MOVF pBDTEntryIn, W
0B5C  0086     MOVWF FSR1L
0B5D  0831     MOVF 0xB1, W
0B5E  0087     MOVWF FSR1H
0B5F  0868     MOVF 0xE8, W
0B60  0581     ANDWF INDF1, F
2495:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0B61  3004     MOVLW 0x4
0B62  0630     XORWF pBDTEntryIn, W
0B63  00B0     MOVWF pBDTEntryIn
0B64  3000     MOVLW 0x0
0B65  0631     XORWF 0xB1, W
0B66  00B1     MOVWF 0xB1
2496:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);
0B67  307F     MOVLW 0x7F
0B68  00E8     MOVWF 0xE8
0B69  0841     MOVF pBDTEntryEP0OutNext, W
0B6A  0086     MOVWF FSR1L
0B6B  0842     MOVF 0xC2, W
0B6C  0087     MOVWF FSR1H
0B6D  0868     MOVF 0xE8, W
0B6E  0581     ANDWF INDF1, F
2497:          
2498:              inPipes[0].info.Val = 0;
0B6F  01BA     CLRF 0xBA
2499:              inPipes[0].wCount.Val = 0;
0B70  01BB     CLRF 0xBB
0B71  01BC     CLRF 0xBC
2500:              outPipes[0].info.Val = 0;
0B72  0022     MOVLB 0x2
0B73  01A2     CLRF 0x122
2501:              outPipes[0].wCount.Val = 0;
0B74  01A3     CLRF 0x123
0B75  01A4     CLRF 0x124
2502:          
2503:          
2504:              //--------------------------------------------------------------------------
2505:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2506:              //--------------------------------------------------------------------------
2507:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
0B76  3187     MOVLP 0x7
0B77  2784     CALL 0x784
0B78  318B     MOVLP 0xB
2508:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
0B79  3003     MOVLW 0x3
0B7A  0021     MOVLB 0x1
0B7B  00D9     MOVWF __pcstackBANK1
0B7C  3000     MOVLW 0x0
0B7D  00DA     MOVWF 0xDA
0B7E  3000     MOVLW 0x0
0B7F  00DB     MOVWF pdata
0B80  3000     MOVLW 0x0
0B81  00DC     MOVWF 0xDC
0B82  3000     MOVLW 0x0
0B83  00DD     MOVWF size
0B84  00DE     MOVWF 0xDE
0B85  318A     MOVLP 0xA
0B86  22FE     CALL 0x2FE
0B87  318B     MOVLP 0xB
2509:          
2510:          
2511:              //--------------------------------------------------------------------------
2512:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in
2513:              //   progress.  If one of the above handlers (in step 2) knew how to process
2514:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2515:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2516:              //   USBCtrlEPServiceComplete() function know how and which endpoints to
2517:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2518:              //   process the request.  In this case, the default behavior will be to
2519:              //   perform protocol STALL on EP0.
2520:              //--------------------------------------------------------------------------
2521:              USBCtrlEPServiceComplete();
0B88  3186     MOVLP 0x6
0B89  26E8     CALL 0x6E8
0B8A  318B     MOVLP 0xB
2522:          }//end USBCtrlTrfSetupHandler
0B8B  0008     RETURN
2523:          
2524:          
2525:          /******************************************************************************
2526:           * Function:        void USBCtrlTrfOutHandler(void)
2527:           *
2528:           * PreCondition:    None
2529:           *
2530:           * Input:           None
2531:           *
2532:           * Output:          None
2533:           *
2534:           * Side Effects:    None
2535:           *
2536:           * Overview:        This routine handles an OUT transaction according to
2537:           *                  which control transfer state is currently active.
2538:           *
2539:           * Note:            Note that if the the control transfer was from
2540:           *                  host to device, the session owner should be notified
2541:           *                  at the end of each OUT transaction to service the
2542:           *                  received data.
2543:           *
2544:           *****************************************************************************/
2545:          static void USBCtrlTrfOutHandler(void)
2546:          {
2547:              if(controlTransferState == CTRL_TRF_RX)
0A42  3002     MOVLW 0x2
0A43  0021     MOVLB 0x1
0A44  0651     XORWF controlTransferState, W
0A45  1D03     BTFSS STATUS, 0x2
0A46  2A48     GOTO 0x248
0A47  2A49     GOTO 0x249
0A48  2A4D     GOTO 0x24D
2548:              {
2549:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
0A49  3186     MOVLP 0x6
0A4A  263E     CALL 0x63E
0A4B  318A     MOVLP 0xA
2550:              }
0A4C  2A79     GOTO 0x279
2551:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2552:              {
2553:                  //If the status stage is complete, this means we are done with the
2554:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2555:                  controlTransferState = WAIT_SETUP;
0A4D  01D1     CLRF controlTransferState
2556:          
2557:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2558:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2559:                  //and the last control transfer was of direction: device to host, see
2560:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2561:                  //to do anything to the BDT.
2562:                  if(BothEP0OutUOWNsSet == false)
0A4E  084C     MOVF BothEP0OutUOWNsSet, W
0A4F  1D03     BTFSS STATUS, 0x2
0A50  2A52     GOTO 0x252
0A51  2A53     GOTO 0x253
0A52  2A78     GOTO 0x278
2563:                  {
2564:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0A53  0841     MOVF pBDTEntryEP0OutNext, W
0A54  3E01     ADDLW 0x1
0A55  00F6     MOVWF 0xF6
0A56  3000     MOVLW 0x0
0A57  3D42     ADDWFC 0xC2, W
0A58  00F7     MOVWF 0xF7
0A59  0876     MOVF 0xF6, W
0A5A  0086     MOVWF FSR1L
0A5B  0877     MOVF 0xF7, W
0A5C  0087     MOVWF FSR1H
0A5D  3008     MOVLW 0x8
0A5E  0081     MOVWF INDF1
2565:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0A5F  3060     MOVLW 0x60
0A60  00F6     MOVWF 0xF6
0A61  3000     MOVLW 0x0
0A62  00F7     MOVWF 0xF7
0A63  0841     MOVF pBDTEntryEP0OutNext, W
0A64  0086     MOVWF FSR1L
0A65  0842     MOVF 0xC2, W
0A66  0087     MOVWF FSR1H
0A67  3142     ADDFSR 1, 2
0A68  0876     MOVF 0xF6, W
0A69  3FC0     MOVWI 0[FSR1]
0A6A  0877     MOVF 0xF7, W
0A6B  3FC1     MOVWI 1[FSR1]
2566:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0A6C  0841     MOVF pBDTEntryEP0OutNext, W
0A6D  0086     MOVWF FSR1L
0A6E  0842     MOVF 0xC2, W
0A6F  0087     MOVWF FSR1H
0A70  300C     MOVLW 0xC
0A71  0081     MOVWF INDF1
2567:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0A72  0841     MOVF pBDTEntryEP0OutNext, W
0A73  0086     MOVWF FSR1L
0A74  0842     MOVF 0xC2, W
0A75  0087     MOVWF FSR1H
0A76  1781     BSF INDF1, 0x7
2568:                  }
0A77  2A79     GOTO 0x279
2569:                  else
2570:                  {
2571:                      BothEP0OutUOWNsSet = false;
0A78  01CC     CLRF BothEP0OutUOWNsSet
2572:                  }
2573:              }
2574:          }
0A79  0008     RETURN
2575:          
2576:          /******************************************************************************
2577:           * Function:        void USBCtrlTrfInHandler(void)
2578:           *
2579:           * PreCondition:    None
2580:           *
2581:           * Input:           None
2582:           *
2583:           * Output:          None
2584:           *
2585:           * Side Effects:    None
2586:           *
2587:           * Overview:        This routine handles an IN transaction according to
2588:           *                  which control transfer state is currently active.
2589:           *
2590:           * Note:            A Set Address Request must not change the actual address
2591:           *                  of the device until the completion of the control
2592:           *                  transfer. The end of the control transfer for Set Address
2593:           *                  Request is an IN transaction. Therefore it is necessary
2594:           *                  to service this unique situation when the condition is
2595:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2596:           *                  usb9.h and its function is to specifically service this
2597:           *                  event.
2598:           *****************************************************************************/
2599:          static void USBCtrlTrfInHandler(void)
2600:          {
2601:              uint8_t lastDTS;
2602:          
2603:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
0DF6  0021     MOVLB 0x1
0DF7  0830     MOVF pBDTEntryIn, W
0DF8  0086     MOVWF FSR1L
0DF9  0831     MOVF 0xB1, W
0DFA  0087     MOVWF FSR1H
0DFB  3000     MOVLW 0x0
0DFC  1B01     BTFSC INDF1, 0x6
0DFD  3001     MOVLW 0x1
0DFE  00F5     MOVWF 0xF5
2604:          
2605:              //switch to the next ping pong buffer
2606:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0DFF  3004     MOVLW 0x4
0E00  0630     XORWF pBDTEntryIn, W
0E01  00B0     MOVWF pBDTEntryIn
0E02  3000     MOVLW 0x0
0E03  0631     XORWF 0xB1, W
0E04  00B1     MOVWF 0xB1
2607:          
2608:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2609:              //now, since the IN status stage of the (set address) control transfer has
2610:              //evidently completed successfully.
2611:              if(USBDeviceState == ADR_PENDING_STATE)
0E05  3008     MOVLW 0x8
0E06  0654     XORWF USBDeviceState, W
0E07  1D03     BTFSS STATUS, 0x2
0E08  2E0A     GOTO 0x60A
0E09  2E0B     GOTO 0x60B
0E0A  2E20     GOTO 0x620
2612:              {
2613:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
0E0B  0020     MOVLB 0x0
0E0C  0862     MOVF 0x62, W
0E0D  397F     ANDLW 0x7F
0E0E  003D     MOVLB 0x1D
0E0F  0096     MOVWF UADDR
2614:                  if(U1ADDR != 0u)
0E10  0816     MOVF UADDR, W
0E11  1903     BTFSC STATUS, 0x2
0E12  2E14     GOTO 0x614
0E13  2E15     GOTO 0x615
0E14  2E1B     GOTO 0x61B
2615:                  {
2616:                      USBDeviceState=ADDRESS_STATE;
0E15  3010     MOVLW 0x10
0E16  00F3     MOVWF _USBStdSetCfgHandler
0E17  0873     MOVF _USBStdSetCfgHandler, W
0E18  0021     MOVLB 0x1
0E19  00D4     MOVWF USBDeviceState
2617:                  }
0E1A  2E20     GOTO 0x620
2618:                  else
2619:                  {
2620:                      USBDeviceState=DEFAULT_STATE;
0E1B  3004     MOVLW 0x4
0E1C  00F3     MOVWF 0xF3
0E1D  0873     MOVF 0xF3, W
0E1E  0021     MOVLB 0x1
0E1F  00D4     MOVWF USBDeviceState
2621:                  }
2622:              }//end if
2623:          
2624:          
2625:              if(controlTransferState == CTRL_TRF_TX)
0E20  0351     DECF controlTransferState, W
0E21  1D03     BTFSS STATUS, 0x2
0E22  2E24     GOTO 0x624
0E23  2E25     GOTO 0x625
0E24  2E65     GOTO 0x665
2626:              {
2627:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0E25  3068     MOVLW 0x68
0E26  00F3     MOVWF 0xF3
0E27  3000     MOVLW 0x0
0E28  00F4     MOVWF 0xF4
0E29  0830     MOVF pBDTEntryIn, W
0E2A  0086     MOVWF FSR1L
0E2B  0831     MOVF 0xB1, W
0E2C  0087     MOVWF FSR1H
0E2D  3142     ADDFSR 1, 2
0E2E  0873     MOVF 0xF3, W
0E2F  3FC0     MOVWI 0[FSR1]
0E30  0874     MOVF 0xF4, W
0E31  3FC1     MOVWI 1[FSR1]
2628:                  USBCtrlTrfTxService();
0E32  318D     MOVLP 0xD
0E33  2581     CALL 0x581
0E34  318D     MOVLP 0xD
2629:          
2630:                  //Check if we have already sent a short packet.  If so, configure
2631:                  //the endpoint to STALL in response to any further IN tokens (in the
2632:                  //case that the host erroneously tries to receive more data than it
2633:                  //should).
2634:                  if(shortPacketStatus == SHORT_PKT_SENT)
0E35  3002     MOVLW 0x2
0E36  0021     MOVLB 0x1
0E37  0652     XORWF shortPacketStatus, W
0E38  1D03     BTFSS STATUS, 0x2
0E39  2E3B     GOTO 0x63B
0E3A  2E3C     GOTO 0x63C
0E3B  2E48     GOTO 0x648
2635:                  {
2636:                      // If a short packet has been sent, don't want to send any more,
2637:                      // stall next time if host is still trying to read.
2638:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0E3C  0830     MOVF pBDTEntryIn, W
0E3D  0086     MOVWF FSR1L
0E3E  0831     MOVF 0xB1, W
0E3F  0087     MOVWF FSR1H
0E40  3004     MOVLW 0x4
0E41  0081     MOVWF INDF1
2639:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0E42  0830     MOVF pBDTEntryIn, W
0E43  0086     MOVWF FSR1L
0E44  0831     MOVF 0xB1, W
0E45  0087     MOVWF FSR1H
0E46  1781     BSF INDF1, 0x7
2640:                  }
0E47  2E6D     GOTO 0x66D
2641:                  else
2642:                  {
2643:                      if(lastDTS == 0)
0E48  0875     MOVF 0xF5, W
0E49  1D03     BTFSS STATUS, 0x2
0E4A  2E4C     GOTO 0x64C
0E4B  2E4D     GOTO 0x64D
0E4C  2E59     GOTO 0x659
2644:                      {
2645:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0E4D  0830     MOVF pBDTEntryIn, W
0E4E  0086     MOVWF FSR1L
0E4F  0831     MOVF 0xB1, W
0E50  0087     MOVWF FSR1H
0E51  3048     MOVLW 0x48
0E52  0081     MOVWF INDF1
2646:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0E53  0830     MOVF pBDTEntryIn, W
0E54  0086     MOVWF FSR1L
0E55  0831     MOVF 0xB1, W
0E56  0087     MOVWF FSR1H
0E57  1781     BSF INDF1, 0x7
2647:                      }
0E58  2E6D     GOTO 0x66D
2648:                      else
2649:                      {
2650:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0E59  0830     MOVF pBDTEntryIn, W
0E5A  0086     MOVWF FSR1L
0E5B  0831     MOVF 0xB1, W
0E5C  0087     MOVWF FSR1H
0E5D  3008     MOVLW 0x8
0E5E  0081     MOVWF INDF1
2651:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0E5F  0830     MOVF pBDTEntryIn, W
0E60  0086     MOVWF FSR1L
0E61  0831     MOVF 0xB1, W
0E62  0087     MOVWF FSR1H
0E63  1781     BSF INDF1, 0x7
0E64  2E6D     GOTO 0x66D
2652:                      }
2653:                  }//end if(...)else
2654:              }
2655:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2656:          	{
2657:                  //if someone is still expecting data from the control transfer
2658:                  //  then make sure to terminate that request and let them know that
2659:                  //  they are done
2660:                  if(outPipes[0].info.bits.busy == 1)
0E65  0022     MOVLB 0x2
0E66  1FA2     BTFSS 0x122, 0x7
0E67  2E69     GOTO 0x669
0E68  2E6A     GOTO 0x66A
0E69  2E6B     GOTO 0x66B
2661:                  {
2662:                      if(outPipes[0].pFunc != NULL)
2663:                      {
2664:                          outPipes[0].pFunc();
2665:                      }
2666:                      outPipes[0].info.bits.busy = 0;
0E6A  13A2     BCF 0x122, 0x7
2667:                  }
2668:          
2669:                  controlTransferState = WAIT_SETUP;
0E6B  0021     MOVLB 0x1
0E6C  01D1     CLRF controlTransferState
2670:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2671:                  //got processed by the USBCtrlTrfRxService() handler.
2672:          	}
2673:          
2674:          }
0E6D  0008     RETURN
2675:          
2676:          
2677:          /********************************************************************
2678:           * Function:        void USBCheckStdRequest(void)
2679:           *
2680:           * PreCondition:    None
2681:           *
2682:           * Input:           None
2683:           *
2684:           * Output:          None
2685:           *
2686:           * Side Effects:    None
2687:           *
2688:           * Overview:        This routine checks the setup data packet to see
2689:           *                  if it knows how to handle it
2690:           *
2691:           * Note:            None
2692:           *******************************************************************/
2693:          static void USBCheckStdRequest(void)
2694:          {
2695:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0784  0020     MOVLB 0x0
0785  0E60     SWAPF SetupPkt, W
0786  0C89     RRF WREG, F
0787  3903     ANDLW 0x3
0788  3A00     XORLW 0x0
0789  1903     BTFSC STATUS, 0x2
078A  2F8C     GOTO 0x78C
078B  2F8D     GOTO 0x78D
078C  2FD3     GOTO 0x7D3
078D  2FFF     GOTO 0x7FF
2696:          
2697:              switch(SetupPkt.bRequest)
2698:              {
2699:                  case USB_REQUEST_SET_ADDRESS:
2700:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
078E  17BA     BSF 0x3A, 0x7
2701:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
078F  3008     MOVLW 0x8
0790  00E6     MOVWF 0x66
0791  0866     MOVF 0x66, W
0792  00D4     MOVWF 0x54
2702:                      /* See USBCtrlTrfInHandler() for the next step */
2703:                      break;
0793  2FFF     GOTO 0x7FF
2704:                  case USB_REQUEST_GET_DESCRIPTOR:
2705:                      USBStdGetDscHandler();
0794  318E     MOVLP 0xE
0795  266E     CALL 0x66E
0796  3187     MOVLP 0x7
2706:                      break;
0797  2FFF     GOTO 0x7FF
2707:                  case USB_REQUEST_SET_CONFIGURATION:
2708:                      USBStdSetCfgHandler();
0798  318E     MOVLP 0xE
0799  26F3     CALL 0x6F3
079A  3187     MOVLP 0x7
2709:                      break;
079B  2FFF     GOTO 0x7FF
2710:                  case USB_REQUEST_GET_CONFIGURATION:
2711:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
079C  30D8     MOVLW 0xD8
079D  00B8     MOVWF 0x38
079E  3000     MOVLW 0x0
079F  00B9     MOVWF 0x39
2712:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
07A0  143A     BSF 0x3A, 0x0
2713:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
07A1  01BB     CLRF 0x3B
07A2  0ABB     INCF 0x3B, F
2714:                      inPipes[0].info.bits.busy = 1;
07A3  17BA     BSF 0x3A, 0x7
2715:                      break;
07A4  2FFF     GOTO 0x7FF
2716:                  case USB_REQUEST_GET_STATUS:
2717:                      USBStdGetStatusHandler();
07A5  318C     MOVLP 0xC
07A6  24A2     CALL 0x4A2
07A7  3187     MOVLP 0x7
2718:                      break;
07A8  2FFF     GOTO 0x7FF
2719:                  case USB_REQUEST_CLEAR_FEATURE:
2720:                  case USB_REQUEST_SET_FEATURE:
2721:                      USBStdFeatureReqHandler();
07A9  3180     MOVLP 0x0
07AA  2044     CALL 0x44
07AB  3187     MOVLP 0x7
2722:                      break;
07AC  2FFF     GOTO 0x7FF
2723:                  case USB_REQUEST_GET_INTERFACE:
2724:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
07AD  0020     MOVLB 0x0
07AE  0864     MOVF 0x64, W
07AF  3EBD     ADDLW 0xBD
07B0  0021     MOVLB 0x1
07B1  00B8     MOVWF inPipes
07B2  3001     MOVLW 0x1
07B3  00B9     MOVWF 0xB9
07B4  2FA0     GOTO 0x7A0
2725:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2726:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2727:                      inPipes[0].info.bits.busy = 1;
2728:                      break;
2729:                  case USB_REQUEST_SET_INTERFACE:
2730:                      inPipes[0].info.bits.busy = 1;
07B5  17BA     BSF 0xBA, 0x7
2731:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
07B6  0020     MOVLB 0x0
07B7  0862     MOVF 0x62, W
07B8  0021     MOVLB 0x1
07B9  00E6     MOVWF 0xE6
07BA  0020     MOVLB 0x0
07BB  0864     MOVF 0x64, W
07BC  3EBD     ADDLW 0xBD
07BD  0086     MOVWF FSR1
07BE  3001     MOVLW 0x1
07BF  0087     MOVWF FSR1H
07C0  0021     MOVLB 0x1
07C1  0866     MOVF 0xE6, W
07C2  0081     MOVWF INDF1
2732:                      break;
07C3  2FFF     GOTO 0x7FF
2733:                  case USB_REQUEST_SET_DESCRIPTOR:
2734:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
07C4  3002     MOVLW 0x2
07C5  00D9     MOVWF __pcstackBANK1
07C6  3000     MOVLW 0x0
07C7  00DA     MOVWF 0xDA
07C8  3000     MOVLW 0x0
07C9  00DB     MOVWF pdata
07CA  3000     MOVLW 0x0
07CB  00DC     MOVWF 0xDC
07CC  3000     MOVLW 0x0
07CD  00DD     MOVWF size
07CE  00DE     MOVWF 0xDE
07CF  318A     MOVLP 0xA
07D0  22FE     CALL 0x2FE
07D1  3187     MOVLP 0x7
2735:                      break;
07D2  2FFF     GOTO 0x7FF
2736:                  case USB_REQUEST_SYNCH_FRAME:
2737:                  default:
2738:                      break;
2739:              }//end switch
07D3  0861     MOVF pUEP, W
07D4  0021     MOVLB 0x1
07D5  00E6     MOVWF 0xE6
07D6  01E7     CLRF 0xE7
07D7  0867     MOVF 0xE7, W
07D8  3A00     XORLW 0x0
07D9  1903     BTFSC STATUS, 0x2
07DA  2FDC     GOTO 0x7DC
07DB  2FFF     GOTO 0x7FF
07DC  0866     MOVF 0xE6, W
07DD  3A00     XORLW 0x0
07DE  1903     BTFSC STATUS, 0x2
07DF  2FA5     GOTO 0x7A5
07E0  3A01     XORLW 0x1
07E1  1903     BTFSC STATUS, 0x2
07E2  2FA9     GOTO 0x7A9
07E3  3A02     XORLW 0x2
07E4  1903     BTFSC STATUS, 0x2
07E5  2FA9     GOTO 0x7A9
07E6  3A06     XORLW 0x6
07E7  1903     BTFSC STATUS, 0x2
07E8  2F8E     GOTO 0x78E
07E9  3A03     XORLW 0x3
07EA  1903     BTFSC STATUS, 0x2
07EB  2F94     GOTO 0x794
07EC  3A01     XORLW 0x1
07ED  1903     BTFSC STATUS, 0x2
07EE  2FC4     GOTO 0x7C4
07EF  3A0F     XORLW 0xF
07F0  1903     BTFSC STATUS, 0x2
07F1  2F9C     GOTO 0x79C
07F2  3A01     XORLW 0x1
07F3  1903     BTFSC STATUS, 0x2
07F4  2F98     GOTO 0x798
07F5  3A03     XORLW 0x3
07F6  1903     BTFSC STATUS, 0x2
07F7  2FAD     GOTO 0x7AD
07F8  3A01     XORLW 0x1
07F9  1903     BTFSC STATUS, 0x2
07FA  2FB5     GOTO 0x7B5
07FB  3A07     XORLW 0x7
07FC  1903     BTFSC STATUS, 0x2
07FD  2FFF     GOTO 0x7FF
07FE  2FFF     GOTO 0x7FF
2740:          }//end USBCheckStdRequest
07FF  0008     RETURN
2741:          
2742:          /********************************************************************
2743:           * Function:        void USBStdFeatureReqHandler(void)
2744:           *
2745:           * PreCondition:    None
2746:           *
2747:           * Input:           None
2748:           *
2749:           * Output:          Can alter BDT entries.  Can also modify USB stack
2750:           *                  Maintained variables.
2751:           *
2752:           * Side Effects:    None
2753:           *
2754:           * Overview:        This routine handles the standard SET & CLEAR
2755:           *                  FEATURES requests
2756:           *
2757:           * Note:            This is a private function, intended for internal
2758:           *                  use by the USB stack, when processing SET/CLEAR
2759:           *                  feature requests.
2760:           *******************************************************************/
2761:          static void USBStdFeatureReqHandler(void)
2762:          {
2763:              BDT_ENTRY *p;
2764:              EP_STATUS current_ep_data;
2765:              #if defined(__C32__)
2766:                  uint32_t* pUEP;
2767:              #else
2768:                  unsigned char* pUEP;
2769:              #endif
2770:          
2771:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2772:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
0044  0020     MOVLB 0x0
0045  0362     DECF 0x62, W
0046  1D03     BTFSS STATUS, 0x2
0047  2849     GOTO 0x49
0048  284A     GOTO 0x4A
0049  2860     GOTO 0x60
004A  0860     MOVF SetupPkt, W
004B  391F     ANDLW 0x1F
004C  3A00     XORLW 0x0
004D  1D03     BTFSS STATUS, 0x2
004E  2850     GOTO 0x50
004F  2851     GOTO 0x51
0050  2860     GOTO 0x60
2773:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2774:              {
2775:                  inPipes[0].info.bits.busy = 1;
0051  0021     MOVLB 0x1
0052  17BA     BSF 0xBA, 0x7
2776:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0053  3003     MOVLW 0x3
0054  0020     MOVLB 0x0
0055  0661     XORWF 0x61, W
0056  1D03     BTFSS STATUS, 0x2
0057  2859     GOTO 0x59
0058  285A     GOTO 0x5A
0059  285E     GOTO 0x5E
2777:                      RemoteWakeup = true;
005A  0021     MOVLB 0x1
005B  01CF     CLRF RemoteWakeup
005C  0ACF     INCF RemoteWakeup, F
005D  2860     GOTO 0x60
2778:                  else
2779:                      RemoteWakeup = false;
005E  0021     MOVLB 0x1
005F  01CF     CLRF RemoteWakeup
2780:              }//end if
2781:          
2782:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2783:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
0060  0020     MOVLB 0x0
0061  0862     MOVF 0x62, W
0062  1D03     BTFSS STATUS, 0x2
0063  2865     GOTO 0x65
0064  2866     GOTO 0x66
0065  29AA     GOTO 0x1AA
0066  0860     MOVF SetupPkt, W
0067  391F     ANDLW 0x1F
0068  3A02     XORLW 0x2
0069  1D03     BTFSS STATUS, 0x2
006A  286C     GOTO 0x6C
006B  286D     GOTO 0x6D
006C  29AA     GOTO 0x1AA
006D  0864     MOVF 0x64, W
006E  390F     ANDLW 0xF
006F  3A00     XORLW 0x0
0070  1903     BTFSC STATUS, 0x2
0071  2873     GOTO 0x73
0072  2874     GOTO 0x74
0073  29AA     GOTO 0x1AA
0074  0864     MOVF 0x64, W
0075  390F     ANDLW 0xF
0076  0021     MOVLB 0x1
0077  00DF     MOVWF 0xDF
0078  3004     MOVLW 0x4
0079  025F     SUBWF 0xDF, W
007A  1803     BTFSC STATUS, 0x0
007B  287D     GOTO 0x7D
007C  287E     GOTO 0x7E
007D  29AA     GOTO 0x1AA
007E  3020     MOVLW 0x20
007F  0654     XORWF USBDeviceState, W
0080  1D03     BTFSS STATUS, 0x2
0081  2883     GOTO 0x83
0082  2884     GOTO 0x84
0083  29AA     GOTO 0x1AA
2784:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2785:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2786:                 (USBDeviceState == CONFIGURED_STATE))
2787:              {
2788:          		//The request was valid.  Take control of the control transfer and
2789:          		//perform the host requested action.
2790:          		inPipes[0].info.bits.busy = 1;
0084  17BA     BSF 0xBA, 0x7
2791:          
2792:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2793:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0085  0020     MOVLB 0x0
0086  1BE4     BTFSC 0x64, 0x7
0087  2889     GOTO 0x89
0088  288A     GOTO 0x8A
0089  28A3     GOTO 0xA3
2794:                  {
2795:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
008A  0864     MOVF 0x64, W
008B  390F     ANDLW 0xF
008C  0709     ADDWF WREG, W
008D  3EA0     ADDLW 0xA0
008E  0086     MOVWF FSR1
008F  3001     MOVLW 0x1
0090  0087     MOVWF FSR1H
0091  3F40     MOVIW 0[FSR1]
0092  0021     MOVLB 0x1
0093  00E4     MOVWF p
0094  3F41     MOVIW 1[FSR1]
0095  00E5     MOVWF 0xE5
2796:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0096  0020     MOVLB 0x0
0097  0864     MOVF 0x64, W
0098  390F     ANDLW 0xF
0099  3EAC     ADDLW 0xAC
009A  0086     MOVWF FSR1
009B  3001     MOVLW 0x1
009C  0087     MOVWF FSR1H
009D  0801     MOVF INDF1, W
009E  0021     MOVLB 0x1
009F  00DF     MOVWF 0xDF
00A0  085F     MOVF 0xDF, W
00A1  00E3     MOVWF i
2797:                  }
00A2  28BA     GOTO 0xBA
2798:                  else
2799:                  {
2800:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00A3  0864     MOVF p, W
00A4  390F     ANDLW 0xF
00A5  0709     ADDWF WREG, W
00A6  3EB0     ADDLW 0xB0
00A7  0086     MOVWF FSR1L
00A8  0187     CLRF FSR1H
00A9  3F40     MOVIW 0[FSR1]
00AA  0021     MOVLB 0x1
00AB  00E4     MOVWF p
00AC  3F41     MOVIW 1[FSR1]
00AD  00E5     MOVWF 0xE5
2801:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
00AE  0020     MOVLB 0x0
00AF  0864     MOVF 0x64, W
00B0  390F     ANDLW 0xF
00B1  3EB0     ADDLW 0xB0
00B2  0086     MOVWF FSR1
00B3  3001     MOVLW 0x1
00B4  0087     MOVWF FSR1H
00B5  0801     MOVF INDF1, W
00B6  0021     MOVLB 0x1
00B7  00DF     MOVWF 0xDF
00B8  085F     MOVF 0xDF, W
00B9  00E3     MOVWF i
2802:                  }
2803:          
2804:                  //If ping pong buffering is enabled on the requested endpoint, need
2805:                  //to point to the one that is the active BDT entry which the SIE will
2806:                  //use for the next attempted transaction on that EP number.
2807:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2808:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00BA  1863     BTFSC i, 0x0
00BB  28BD     GOTO 0xBD
00BC  28BE     GOTO 0xBE
00BD  28C9     GOTO 0xC9
2809:                      {
2810:                          p = (BDT_ENTRY*)(((uintptr_t)(p)) & (~USB_NEXT_PING_PONG));
00BE  30FB     MOVLW 0xFB
00BF  00DF     MOVWF 0xDF
00C0  30FF     MOVLW 0xFF
00C1  00E0     MOVWF p
00C2  0864     MOVF p, W
00C3  055F     ANDWF 0xDF, W
00C4  00E4     MOVWF p
00C5  0865     MOVF 0xE5, W
00C6  0560     ANDWF p, W
00C7  00E5     MOVWF 0xE5
2811:                      }
00C8  28CF     GOTO 0xCF
2812:                      else //else must have been odd
2813:                      {
2814:                          p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
00C9  3004     MOVLW 0x4
00CA  0464     IORWF p, W
00CB  00E4     MOVWF p
00CC  3000     MOVLW 0x0
00CD  0465     IORWF 0xE5, W
00CE  00E5     MOVWF 0xE5
2815:                      }
2816:                  #endif
2817:          
2818:                  //Update the BDT pointers with the new, next entry based on the feature
2819:                  //  request
2820:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00CF  0020     MOVLB 0x0
00D0  1BE4     BTFSC 0x64, 0x7
00D1  28D3     GOTO 0xD3
00D2  28D4     GOTO 0xD4
00D3  28E1     GOTO 0xE1
2821:                  {
2822:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00D4  0864     MOVF 0x64, W
00D5  390F     ANDLW 0xF
00D6  0709     ADDWF WREG, W
00D7  3EA0     ADDLW 0xA0
00D8  0086     MOVWF FSR1
00D9  3001     MOVLW 0x1
00DA  0087     MOVWF FSR1H
00DB  0021     MOVLB 0x1
00DC  0864     MOVF p, W
00DD  3FC0     MOVWI 0[FSR1]
00DE  0865     MOVF 0xE5, W
00DF  3FC1     MOVWI 1[FSR1]
2823:                  }
00E0  28EC     GOTO 0xEC
2824:                  else
2825:                  {
2826:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00E1  0864     MOVF p, W
00E2  390F     ANDLW 0xF
00E3  0709     ADDWF WREG, W
00E4  3EB0     ADDLW 0xB0
00E5  0086     MOVWF FSR1L
00E6  0187     CLRF FSR1H
00E7  0021     MOVLB 0x1
00E8  0864     MOVF p, W
00E9  3FC0     MOVWI 0[FSR1]
00EA  0865     MOVF 0xE5, W
00EB  3FC1     MOVWI 1[FSR1]
2827:                  }
2828:          
2829:          		//Check if it was a SET_FEATURE endpoint halt request
2830:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00EC  3003     MOVLW 0x3
00ED  0020     MOVLB 0x0
00EE  0661     XORWF 0x61, W
00EF  1D03     BTFSS STATUS, 0x2
00F0  28F2     GOTO 0xF2
00F1  28F3     GOTO 0xF3
00F2  291C     GOTO 0x11C
2831:                  {
2832:                      if(p->STAT.UOWN == 1)
00F3  0021     MOVLB 0x1
00F4  0864     MOVF p, W
00F5  0086     MOVWF FSR1L
00F6  0865     MOVF 0xE5, W
00F7  0087     MOVWF FSR1H
00F8  1F81     BTFSS INDF1, 0x7
00F9  28FB     GOTO 0xFB
00FA  28FC     GOTO 0xFC
00FB  2910     GOTO 0x110
2833:                      {
2834:                          //Mark that we are terminating this transfer and that the user
2835:                          //  needs to be notified later
2836:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
00FC  0020     MOVLB 0x0
00FD  1BE4     BTFSC 0x64, 0x7
00FE  2900     GOTO 0x100
00FF  2901     GOTO 0x101
0100  2909     GOTO 0x109
2837:                          {
2838:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0101  0864     MOVF 0x64, W
0102  390F     ANDLW 0xF
0103  3EAC     ADDLW 0xAC
0104  0086     MOVWF FSR1
0105  3001     MOVLW 0x1
0106  0087     MOVWF FSR1H
0107  1481     BSF INDF1, 0x1
2839:                          }
0108  2910     GOTO 0x110
2840:                          else
2841:                          {
2842:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
0109  0864     MOVF 0x64, W
010A  390F     ANDLW 0xF
010B  3EB0     ADDLW 0xB0
010C  0086     MOVWF FSR1
010D  3001     MOVLW 0x1
010E  0087     MOVWF FSR1H
010F  1481     BSF INDF1, 0x1
2843:                          }
2844:                      }
2845:          
2846:          			//Then STALL the endpoint
2847:                      p->STAT.Val |= _BSTALL;
0110  0021     MOVLB 0x1
0111  0864     MOVF p, W
0112  0086     MOVWF FSR1L
0113  0865     MOVF 0xE5, W
0114  0087     MOVWF FSR1H
0115  1501     BSF INDF1, 0x2
2848:                      p->STAT.Val |= _USIE;
0116  0864     MOVF p, W
0117  0086     MOVWF FSR1L
0118  0865     MOVF 0xE5, W
0119  0087     MOVWF FSR1H
011A  1781     BSF INDF1, 0x7
2849:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
011B  29AA     GOTO 0x1AA
2850:                  else
2851:                  {
2852:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2853:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2854:                          //toggle over the to the non-active BDT
2855:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
011C  3004     MOVLW 0x4
011D  0021     MOVLB 0x1
011E  0664     XORWF p, W
011F  00E4     MOVWF p
0120  3000     MOVLW 0x0
0121  0665     XORWF 0xE5, W
0122  00E5     MOVWF 0xE5
2856:          
2857:                          if(p->STAT.UOWN == 1)
0123  0864     MOVF p, W
0124  0086     MOVWF FSR1L
0125  0865     MOVF 0xE5, W
0126  0087     MOVWF FSR1H
0127  1F81     BTFSS INDF1, 0x7
0128  292A     GOTO 0x12A
0129  292B     GOTO 0x12B
012A  2948     GOTO 0x148
2858:                          {
2859:                              //Clear UOWN and set DTS state so it will be correct the next time
2860:                              //the application firmware uses USBTransferOnePacket() on the EP.
2861:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
012B  307F     MOVLW 0x7F
012C  00DF     MOVWF 0xDF
012D  0864     MOVF p, W
012E  0086     MOVWF FSR1L
012F  0865     MOVF 0xE5, W
0130  0087     MOVWF FSR1H
0131  085F     MOVF 0xDF, W
0132  0581     ANDWF INDF1, F
2862:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
0133  0864     MOVF p, W
0134  0086     MOVWF FSR1L
0135  0865     MOVF 0xE5, W
0136  0087     MOVWF FSR1H
0137  1701     BSF INDF1, 0x6
2863:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0138  3005     MOVLW 0x5
0139  00D9     MOVWF __pcstackBANK1
013A  3000     MOVLW 0x0
013B  00DA     MOVWF 0xDA
013C  0865     MOVF 0xE5, W
013D  00DC     MOVWF 0xDC
013E  0864     MOVF p, W
013F  00DB     MOVWF pdata
0140  3002     MOVLW 0x2
0141  00DD     MOVWF size
0142  3000     MOVLW 0x0
0143  00DE     MOVWF 0xDE
0144  318A     MOVLP 0xA
0145  22FE     CALL 0x2FE
0146  3180     MOVLP 0x0
2864:                          }
0147  294D     GOTO 0x14D
2865:                          else
2866:                          {
2867:                              //UOWN already clear, but still need to set DTS to DATA1
2868:          					p->STAT.Val |= _DAT1;
0148  0864     MOVF p, W
0149  0086     MOVWF FSR1L
014A  0865     MOVF 0xE5, W
014B  0087     MOVWF FSR1H
014C  1701     BSF INDF1, 0x6
2869:                          }
2870:          
2871:                          //toggle back to the active BDT (the one the SIE is currently looking at
2872:                          //and will use for the next successful transaction to take place on the EP
2873:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
014D  3004     MOVLW 0x4
014E  0021     MOVLB 0x1
014F  0664     XORWF p, W
0150  00E4     MOVWF p
0151  3000     MOVLW 0x0
0152  0665     XORWF 0xE5, W
0153  00E5     MOVWF 0xE5
2874:          
2875:                          //Check if we are currently terminating, or have previously terminated
2876:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2877:                          //set DTS to the proper state, and call the application callback
2878:                          //function.
2879:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
0154  18E3     BTFSC i, 0x1
0155  2957     GOTO 0x157
0156  2958     GOTO 0x158
0157  2960     GOTO 0x160
0158  0864     MOVF p, W
0159  0086     MOVWF FSR1L
015A  0865     MOVF 0xE5, W
015B  0087     MOVWF FSR1H
015C  1F81     BTFSS INDF1, 0x7
015D  295F     GOTO 0x15F
015E  2960     GOTO 0x160
015F  298D     GOTO 0x18D
2880:                          {
2881:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0160  0020     MOVLB 0x0
0161  1BE4     BTFSC 0x64, 0x7
0162  2964     GOTO 0x164
0163  2965     GOTO 0x165
0164  296D     GOTO 0x16D
2882:                              {
2883:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0165  0864     MOVF 0x64, W
0166  390F     ANDLW 0xF
0167  3EAC     ADDLW 0xAC
0168  0086     MOVWF FSR1
0169  3001     MOVLW 0x1
016A  0087     MOVWF FSR1H
016B  1081     BCF INDF1, 0x1
2884:                              }
016C  2974     GOTO 0x174
2885:                              else
2886:                              {
2887:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
016D  0864     MOVF 0x64, W
016E  390F     ANDLW 0xF
016F  3EB0     ADDLW 0xB0
0170  0086     MOVWF FSR1
0171  3001     MOVLW 0x1
0172  0087     MOVWF FSR1H
0173  1081     BCF INDF1, 0x1
2888:                              }
2889:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2890:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
0174  303B     MOVLW 0x3B
0175  0021     MOVLB 0x1
0176  00DF     MOVWF 0xDF
0177  0864     MOVF p, W
0178  0086     MOVWF FSR1L
0179  0865     MOVF 0xE5, W
017A  0087     MOVWF FSR1H
017B  085F     MOVF 0xDF, W
017C  0581     ANDWF INDF1, F
2891:                              //Call the application event handler callback function, so it can
2892:          					//decide if the endpoint should get re-armed again or not.
2893:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
017D  3005     MOVLW 0x5
017E  00D9     MOVWF __pcstackBANK1
017F  3000     MOVLW 0x0
0180  00DA     MOVWF 0xDA
0181  0865     MOVF 0xE5, W
0182  00DC     MOVWF 0xDC
0183  0864     MOVF p, W
0184  00DB     MOVWF pdata
0185  3002     MOVLW 0x2
0186  00DD     MOVWF size
0187  3000     MOVLW 0x0
0188  00DE     MOVWF 0xDE
0189  318A     MOVLP 0xA
018A  22FE     CALL 0x2FE
018B  3180     MOVLP 0x0
2894:                          }
018C  2995     GOTO 0x195
2895:                          else
2896:                          {
2897:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2898:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
018D  303B     MOVLW 0x3B
018E  00DF     MOVWF 0xDF
018F  0864     MOVF p, W
0190  0086     MOVWF FSR1L
0191  0865     MOVF 0xE5, W
0192  0087     MOVWF FSR1H
0193  085F     MOVF 0xDF, W
0194  0581     ANDWF INDF1, F
2899:                          }
2900:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2901:                          //Check if we need to call the user transfer terminated event callback function.
2902:                          //We should call the callback, if the endpoint was previously terminated,
2903:                          //or the endpoint is currently armed, and the host is performing clear
2904:                          //endpoint halt, even though the endpoint wasn't stalled.
2905:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2906:                          {
2907:                              //We are going to call the user transfer terminated callback.
2908:                              //Clear the flag so we know we took care of it and don't need
2909:                              //to call it again later.
2910:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2911:                              {
2912:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2913:                              }
2914:                              else
2915:                              {
2916:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2917:                              }
2918:          
2919:                              //Clear UOWN and remove the STALL condition.
2920:                              //  In this case we also need to set the DTS bit to 1 so that
2921:                              //  it toggles to DATA0 the next time the application firmware
2922:                              //  calls USBTransferOnePacket() (or equivalent macro).
2923:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2924:                              p->STAT.Val |= _DAT1;
2925:                              //Let the application firmware know a transaction just
2926:                              //got terminated by the host, and that it is now free to
2927:                              //re-arm the endpoint or do other tasks if desired.
2928:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2929:                          }
2930:                          else
2931:                          {
2932:                              //Clear UOWN and remove the STALL condition.
2933:                              //  In this case we also need to set the DTS bit to 1 so that
2934:                              //  it toggles to DATA0 the next time the application firmware
2935:                              //  calls USBTransferOnePacket() (or equivalent macro).
2936:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2937:                              p->STAT.Val |= _DAT1;
2938:                          }
2939:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2940:          
2941:          			//Get a pointer to the appropriate UEPn register
2942:                      #if defined(__C32__)
2943:                          pUEP = (uint32_t*)(&U1EP0);
2944:                          pUEP += (SetupPkt.EPNum*4);
2945:                      #else
2946:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0195  0020     MOVLB 0x0
0196  0864     MOVF 0x64, W
0197  390F     ANDLW 0xF
0198  3E98     ADDLW 0x98
0199  0021     MOVLB 0x1
019A  00DF     MOVWF 0xDF
019B  01E0     CLRF p
019C  300E     MOVLW 0xE
019D  3DE0     ADDWFC p, F
019E  085F     MOVF 0xDF, W
019F  00E1     MOVWF pUEP
01A0  0860     MOVF p, W
01A1  00E2     MOVWF i
2947:                      #endif
2948:          
2949:          			//Clear the STALL bit in the UEP register
2950:                      *pUEP &= ~UEP_STALL;
01A2  30FE     MOVLW 0xFE
01A3  00DF     MOVWF 0xDF
01A4  0861     MOVF pUEP, W
01A5  0086     MOVWF FSR1L
01A6  0862     MOVF i, W
01A7  0087     MOVWF FSR1H
01A8  085F     MOVF 0xDF, W
01A9  0581     ANDWF INDF1, F
2951:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2952:              }//end if (lots of checks for set/clear endpoint halt)
2953:          }//end USBStdFeatureReqHandler
01AA  0008     RETURN
2954:          
2955:          
2956:          
2957:          
2958:          /**************************************************************************
2959:              Function:
2960:                  void USBIncrement1msInternalTimers(void)
2961:          
2962:              Description:
2963:                  This function increments internal 1ms time base counters, which are
2964:                  useful for application code (that can use a 1ms time base/counter), and
2965:                  for certain USB event timing specific purposes.
2966:          
2967:                  In USB full speed applications, the application code does not need to (and should
2968:                  not) explicitly call this function, as the USBDeviceTasks() function will
2969:                  automatically call this function whenever a 1ms time interval has elapsed
2970:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2971:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
2972:                  in USB_INTERRUPT mode).
2973:          
2974:                  In USB low speed applications, the application firmware is responsible for
2975:                  periodically calling this function at a ~1ms rate.  This can be done using
2976:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
2977:                  If the low speed application code does not call this function, the internal timers
2978:                  will not increment, and the USBGet1msTickCount() API function will not be available.
2979:                  Additionally, certain USB stack operations (like control transfer timeouts)
2980:                  may be unavailable.
2981:          
2982:              Precondition:
2983:                  This function should be called only after USBDeviceInit() has been
2984:                  called (at least once at the start of the application).  Ordinarily,
2985:                  application code should never call this function, unless it is a low speed
2986:                  USB device.
2987:          
2988:              Parameters:
2989:                  None
2990:          
2991:              Return Values:
2992:                  None
2993:          
2994:              Remarks:
2995:                  This function does not need to be called during USB suspend conditions, when
2996:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
2997:            ***************************************************************************/
2998:          void USBIncrement1msInternalTimers(void)
2999:          {
3000:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3001:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3002:              #endif
3003:          
3004:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3005:              //that needs a 1ms time base that is active during USB non-suspended operation.
3006:              USB1msTickCount++;
08AC  3001     MOVLW 0x1
08AD  0023     MOVLB 0x3
08AE  07A8     ADDWF USB1msTickCount, F
08AF  3000     MOVLW 0x0
08B0  3DA9     ADDWFC 0x1A9, F
08B1  3000     MOVLW 0x0
08B2  3DAA     ADDWFC 0x1AA, F
08B3  3000     MOVLW 0x0
08B4  3DAB     ADDWFC _USBDeviceTasks, F
3007:              if(USBIsBusSuspended() == false)
08B5  0021     MOVLB 0x1
08B6  084E     MOVF USBBusIsSuspended, W
08B7  1D03     BTFSS STATUS, 0x2
08B8  28BA     GOTO 0xBA
08B9  28BB     GOTO 0xBB
08BA  28C8     GOTO 0xC8
3008:              {
3009:                  USBTicksSinceSuspendEnd++;
08BB  3001     MOVLW 0x1
08BC  00F0     MOVWF 0xF0
08BD  0870     MOVF 0xF0, W
08BE  07C5     ADDWF USBTicksSinceSuspendEnd, F
3010:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3011:                  if(USBTicksSinceSuspendEnd == 0)
08BF  0845     MOVF USBTicksSinceSuspendEnd, W
08C0  1D03     BTFSS STATUS, 0x2
08C1  28C3     GOTO 0xC3
08C2  28C4     GOTO 0xC4
08C3  28C8     GOTO 0xC8
3012:                  {
3013:                      USBTicksSinceSuspendEnd = 255;
08C4  30FF     MOVLW 0xFF
08C5  00F0     MOVWF 0xF0
08C6  0870     MOVF 0xF0, W
08C7  00C5     MOVWF USBTicksSinceSuspendEnd
3014:                  }
3015:              }
3016:          }
08C8  0008     RETURN
3017:          
3018:          
3019:          
3020:          
3021:          /**************************************************************************
3022:              Function:
3023:                  uint32_t USBGet1msTickCount(void)
3024:          
3025:              Description:
3026:                  This function retrieves a 32-bit unsigned integer that normally increments by
3027:                  one every one millisecond.  The count value starts from zero when the
3028:                  USBDeviceInit() function is first called.  See the remarks section for
3029:                  details on special circumstances where the tick count will not increment.
3030:          
3031:              Precondition:
3032:                  This function should be called only after USBDeviceInit() has been
3033:                  called (at least once at the start of the application).
3034:          
3035:              Parameters:
3036:                  None
3037:          
3038:              Return Values:
3039:                  uint32_t representing the approximate millisecond count, since the time the
3040:                  USBDeviceInit() function was first called.
3041:          
3042:              Remarks:
3043:                  On 8-bit USB full speed devices, the internal counter is incremented on
3044:                  every SOF packet detected.  Therefore, it will not increment during suspend
3045:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3046:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3047:                  on 16-bit devices, the count continue to increment during USB suspend or
3048:                  detach events, so long as the application code has not put the microcontroller
3049:                  to sleep during these events, and the application firmware is regularly
3050:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3051:                  USB_INTERRUPT mode operation).
3052:          
3053:                  In USB low speed applications, the host does not broadcast SOF packets to
3054:                  the device, so the application firmware becomes responsible for calling
3055:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3056:                  timer interrupt handler), or else the returned value from this function will
3057:                  not increment.
3058:          
3059:                  Prior to calling USBDeviceInit() for the first time the returned value will
3060:                  be unpredictable.
3061:          
3062:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3063:                  code without risk of retrieving a partially updated 32-bit number.
3064:          
3065:                  However, this value only increments when the USBDeviceTasks() function is allowed
3066:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3067:                  function.  If however USB_POLLING mode is used, one must not block on this
3068:                  function without also calling USBDeviceTasks() continuously for the blocking
3069:                  duration (since the USB stack must still be allowed to execute, and the USB
3070:                  stack is also responsible for updating the tick counter internally).
3071:          
3072:                  If the application is operating in USB_POLLING mode, this function should
3073:                  only be called from the main loop context, and not from an interrupt handler,
3074:                  as the returned value could be incorrect, if the main loop context code was in
3075:                  the process of updating the internal count at the moment of the interrupt event.
3076:             ***************************************************************************/
3077:          uint32_t USBGet1msTickCount(void)
3078:          {
3079:              #if defined (USB_INTERRUPT)
3080:                  uint32_t localContextValue;
3081:          
3082:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3083:                  //value.  This ensures that the complete 32-bit value got read without
3084:                  //getting interrupted in between bytes.
3085:                  do
3086:                  {
3087:                      localContextValue = USB1msTickCount;
3088:                  }while(localContextValue != USB1msTickCount);
3089:          
3090:                  return localContextValue;
3091:          
3092:              #else
3093:                  return USB1msTickCount;
3094:              #endif
3095:          }
3096:          
3097:          
3098:          
3099:          
3100:          
3101:          
3102:          /** EOF USBDevice.c *****************************************************/
---  E:/Smart-Knob/pic16f1455_firmware/lib/system.c  ----------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #include "include/system.h"
21:            
22:            /** CONFIGURATION Bits **********************************************/
23:            // PIC16F1459 configuration bit settings:
24:            #if defined (USE_INTERNAL_OSC)	    // Define this in system.h if using the HFINTOSC for USB operation
25:                // CONFIG1
26:                #pragma config FOSC = INTOSC    // Oscillator Selection Bits (INTOSC oscillator: I/O function on CLKIN pin)
27:                #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
28:                #pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
29:                #pragma config MCLRE = OFF      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
30:                #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
31:                #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
32:                #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
33:                #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
34:                #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
35:            
36:                // CONFIG2
37:                #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
38:                #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
39:                #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
40:                #pragma config PLLMULT = 3x     // PLL Multipler Selection Bit (3x Output Frequency Selected)
41:                #pragma config PLLEN = ENABLED  // PLL Enable Bit (3x or 4x PLL Enabled)
42:                #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
43:                #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
44:                #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
45:                #pragma config LVP = OFF        // Low-Voltage Programming Enable (High-voltage on MCLR/VPP must be used for programming)
46:            #else
47:                // CONFIG1
48:            #pragma config FOSC = HS        // Oscillator Selection Bits (HS Oscillator, High-speed crystal/resonator connected between OSC1 and OSC2 pins)
49:            #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
50:            #pragma config PWRTE = ON       // Power-up Timer Enable (PWRT enabled)
51:            #pragma config MCLRE = ON       // MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
52:            #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
53:            #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
54:            #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
55:            #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
56:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
57:            
58:            // CONFIG2
59:            #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
60:            #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
61:            #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
62:            #pragma config PLLMULT = 4x     // PLL Multipler Selection Bit (4x Output Frequency Selected)
63:            #pragma config PLLEN = ENABLED/*********!!!!!!!!!!!!!!!
64:            
65:            
66:            
67:            !*/  // PLL Enable Bit (3x or 4x PLL Enabled)
68:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
69:            #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
70:            #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
71:            #pragma config LVP = ON         // Low-Voltage Programming Enable (Low-voltage programming enabled)
72:            #endif
73:            /*********************************************************************
74:            * Function: void SYSTEM_Initialize( SYSTEM_STATE state )
75:            *
76:            * Overview: Initializes the system.
77:            *
78:            * PreCondition: None
79:            *
80:            * Input:  SYSTEM_STATE - the state to initialize the system into
81:            *
82:            * Output: None
83:            *
84:            ********************************************************************/
85:            void SYSTEM_Initialize( SYSTEM_STATE state )
08C9  00F5     MOVWF 0xF5
86:            {
87:                ANSELC = 0;
08CA  0023     MOVLB 0x3
08CB  018E     CLRF ANSELC
88:                switch(state)
08CC  28D6     GOTO 0xD6
89:                {
90:                    case SYSTEM_STATE_USB_START:
91:                        #if defined(USE_INTERNAL_OSC)
92:                            //Make sure to turn on active clock tuning for USB full speed 
93:                            //operation from the INTOSC
94:                            OSCCON = 0xFC;  //HFINTOSC @ 16MHz, 3X PLL, PLL enabled
95:                            ACTCON = 0x90;  //Active clock tuning enabled for USB
96:                        #endif
97:                        LED_Enable(LED_USB_DEVICE_STATE);
08CD  3001     MOVLW 0x1
08CE  3189     MOVLP 0x9
08CF  214F     CALL 0x14F
08D0  3188     MOVLP 0x8
98:                        //LED_Enable(LED_D3);
99:                        
100:                       BUTTON_Enable(BUTTON_USB_DEVICE_HID_JOYSTICK);
08D1  3001     MOVLW 0x1
08D2  3188     MOVLP 0x8
08D3  207E     CALL 0x7E
08D4  3188     MOVLP 0x8
101:                       break;
08D5  28E9     GOTO 0xE9
102:                       
103:                   case SYSTEM_STATE_USB_SUSPEND: 
104:                       break;
105:                       
106:                   case SYSTEM_STATE_USB_RESUME:
107:                       break;
108:               }
08D6  0875     MOVF 0x1F5, W
08D7  00F3     MOVWF 0x1F3
08D8  01F4     CLRF 0x1F4
08D9  0874     MOVF 0x1F4, W
08DA  3A00     XORLW 0x0
08DB  1903     BTFSC STATUS, 0x2
08DC  28DE     GOTO 0xDE
08DD  28E9     GOTO 0xE9
08DE  0873     MOVF 0x1F3, W
08DF  3A00     XORLW 0x0
08E0  1903     BTFSC STATUS, 0x2
08E1  28CD     GOTO 0xCD
08E2  3A01     XORLW 0x1
08E3  1903     BTFSC STATUS, 0x2
08E4  28E9     GOTO 0xE9
08E5  3A03     XORLW 0x3
08E6  1903     BTFSC STATUS, 0x2
08E7  28E9     GOTO 0xE9
08E8  28E9     GOTO 0xE9
109:           }
08E9  0008     RETURN
110:           
111:           #if(__XC8_VERSION < 2000)
112:               #define INTERRUPT interrupt
113:           #else
114:               #define INTERRUPT __interrupt()
115:           #endif			
116:           			
117:           void INTERRUPT SYS_InterruptHigh(void)
0004  147E     BSF 0x1FE, 0x0
0005  3180     MOVLP 0x0
118:           {
119:               #if defined(USB_INTERRUPT)
120:                   USBDeviceTasks();
121:               #endif
122:           }
0006  107E     BCF 0x1FE, 0x0
---  E:/Smart-Knob/pic16f1455_firmware/lib/spi.c  -------------------------------------------------------
1:             #include <xc.h>
2:             #include "include/spi.h"
3:             
4:             #include "include/app_device_joystick.h"
5:             
6:             #define SPI_FREQ 6
7:             #if SPI_FREQ == 6
8:                 #define SPI_MODE MASTER_OSC_SPADD
9:             #else
10:                #define SPI_MODE MASTER_OSC_DIV4
11:            #endif
12:            
13:            #define writeByteNOread asm("MOVIW FSR1++");/*load next byte*/   \
14:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
15:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
16:                asm("BRA -2");                         /*else go back*/         \
17:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
18:                
19:            #define writeByteRead asm("MOVIW FSR1++");/*load next byte*/   \
20:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
21:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
22:                asm("BRA -2");                         /*else go back*/         \
23:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
24:                asm("MOVWI FSR0++");/*save received byte*/
25:                
26:            #if SPI_FREQ == 6
27:                #define WAIT_ADDITIONAL NOP();NOP();NOP();NOP();  NOP();NOP();NOP();NOP(); 
28:            #else
29:                #define WIAT_ADDITIONAL
30:            #endif
31:            
32:            
33:            
34:            #define writeByteNOreadFAST asm("MOVIW FSR1++");/*load next byte*/  \
35:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
36:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
37:                WAIT_ADDITIONAL                                                 \
38:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
39:                
40:            #define writeByteReadFAST asm("MOVIW FSR1++");/*load next byte*/  \
41:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
42:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
43:                WAIT_ADDITIONAL                                                 \
44:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
45:                asm("MOVWI FSR0++");/*save received byte*/
46:                
47:            
48:            #define ByteOnlyRead asm("BTFSS SSP1STAT, 0x0"); /*if ready continue*/   \
49:                            asm("BRA -2");              /*else go back*/                  \
50:                            asm("MOVF SSP1BUF,W");      /*read the received byte into W*/ \
51:                            asm("MOVWI FSR0++");        /*save received byte*/  
52:            
53:                //TO DO OUT VECTOR
54:            #define REP8(x) x x x x x x x x
55:            
56:            #define strgf(x) str_H(x)
57:            #define str_H(X) #X
58:            #define MOVLW_ADR(X) asm(strgf(M_CONC(MOVLW 0x, X)));
59:            
60:            
61:            #define _XTAL_FREQ 48000000
62:            
63:            
64:            
65:            uint8_t garbage;
66:            
67:            uint8_t luminosity;//first control byte to receive
68:            uint8_t errors_ctr2_to_PIC;//second control byte to send
69:            
70:            uint8_t pkt_requests;//bitmask for each packet type
71:            uint8_t ctrl2_from_PIC;//second ctrl byte
72:            
73:            void spiTask(void){
74:                pkt_requests = 0;
0996  0022     MOVLB 0x2
0997  01A7     CLRF pkt_requests
75:                if(!HIDTxHandleBusy(last_HAP_IN)){
0998  0021     MOVLB 0x1
0999  083F     MOVF last_HAP_IN, W
099A  0440     IORWF 0xC0, W
099B  1903     BTFSC STATUS, 0x2
099C  299E     GOTO 0x19E
099D  299F     GOTO 0x19F
099E  29A7     GOTO 0x1A7
099F  083F     MOVF last_HAP_IN, W
09A0  0086     MOVWF FSR1L
09A1  0840     MOVF 0xC0, W
09A2  0087     MOVWF FSR1H
09A3  1B81     BTFSC INDF1, 0x7
09A4  29A6     GOTO 0x1A6
09A5  29A7     GOTO 0x1A7
09A6  29AA     GOTO 0x1AA
76:                    //rady to send another to PC
77:                    pkt_requests = REQUEST_HAPTIC_IN;
09A7  0022     MOVLB 0x2
09A8  01A7     CLRF pkt_requests
09A9  0AA7     INCF pkt_requests, F
78:                }
79:                
80:                /*asm("MOVLB 0");
81:                //iu=f CS=1 jump back
82:                asm("BTFSC PORTC, 0x3");            //if CS=0 continue
83:                asm("BRA -2");*/
84:                while(PORTCbits.RC3);
09AA  0020     MOVLB 0x0
09AB  198E     BTFSC PORTC, 0x3
09AC  29AE     GOTO 0x1AE
09AD  29AF     GOTO 0x1AF
09AE  29AA     GOTO 0x1AA
85:                
86:                SSPBUF = 45;
09AF  302D     MOVLW 0x2D
09B0  0024     MOVLB 0x4
09B1  0091     MOVWF SSP1BUF
87:                while(!BF);
09B2  1C14     BTFSS SSP1STAT, 0x0
09B3  29B5     GOTO 0x1B5
09B4  29B6     GOTO 0x1B6
09B5  29B2     GOTO 0x1B2
88:                luminosity = SSPBUF;
09B6  0811     MOVF SSP1BUF, W
09B7  00F0     MOVWF 0x270
09B8  0870     MOVF 0x270, W
09B9  0022     MOVLB 0x2
09BA  00A9     MOVWF luminosity
89:            
90:            
91:                WCOL=0;
09BB  0024     MOVLB 0x4
09BC  1395     BCF SSP1CON1, 0x7
92:                SSPOV=0;
09BD  1315     BCF SSP1CON1, 0x6
93:            }
09BE  0008     RETURN
94:            
95:            char v[8]="ABCDEFGH";
96:            
97:            void spwrh(){
98:                /*
99:                 
100:                * 
101:                * 
102:                * MOVLW 0xD0
103:           0B9E  0086     MOVWF FSR1L
104:           0B9F  3021     MOVLW 0x21
105:           0BA0  0087     MOVWF FSR1H
106:           0BA1  3141     ADDFSR 1, 1--------------
107:           0BA2  0801     MOVF INDF1, W
108:           0BA3  0091     MOVWF SSP1BUF
109:           0BA4  1C14     BTFSS SSP1STAT, 0x0
110:           0BA5  2BA7     GOTO 0x3A7
111:           0BA6  2BA8     GOTO 0x3A8
112:           0BA7  2BA4     GOTO 0x3A4
113:                */
114:               ////TESTING RECEIVE ON DISPLAY AND SEND ON HAPTIC
115:               //preload address
116:               //address for DISPLAY
117:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_LO)     //asm("MOVLW 0xD0");
118:               asm("MOVWF FSR1L");
119:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_HI)     //asm("MOVLW 0x21");
120:               asm("MOVWF FSR1H");
121:               
122:               //address for HAPTIC_IN
123:               /*asm("MOVLW 0x30");
124:               asm("MOVWF FSR0L");
125:               asm("MOVLW 0x22");
126:               asm("MOVWF FSR0H");*/
127:               
128:               
129:               //go to bank 4, where the spbuf/stat is
130:               asm("MOVLB 4");
131:               
132:               REP8(REP8(writeByteNOread))
133:               
134:                
135:               /*SSPBUF = display_output[0];while(!BF);//7f=DEL
136:               SSPBUF = display_output[1];while(!BF);//7f=DEL
137:               SSPBUF = display_output[2];while(!BF);//7f=DEL
138:               SSPBUF = display_output[3];while(!BF);//7f=DEL
139:               SSPBUF = display_output[4];while(!BF);//7f=DEL
140:               SSPBUF = display_output[5];while(!BF);//7f=DEL
141:               SSPBUF = display_output[6];while(!BF);//7f=
142:               SSPBUF = display_output[7];while(!BF);//7f=DEL*/
143:               
144:           }
145:           int cnt_tr=0;
146:           
147:           void spiWrite(){
148:               if(cnt_tr<1000){ 
149:                  cnt_tr++;
150:                   return;
151:               }
152:               cnt_tr=0;
153:               CS_PIN = 0;
154:               //__delay_us(100);
155:               
156:               spwrh();
157:               //spwrh("ASDFQWER");
158:               //spwrh("POIUYTRE");
159:               //spwrh("PLMNJKOI");
160:               //spwrh("GHBNVFTY");
161:               //spwrh("12398754");
162:               //spwrh(",./;'[]-");
163:               //spwrh("GHtjhv/]");
164:               //spwrh("-=6`4f;z");
165:               
166:               SSPBUF = ' ';while(!BF);
167:               CS_PIN = 1;
168:           }
169:           
170:           void MasterinitSPI(){
171:               TRIS_CS_PIN = 0;TRIS_CLK_PIN = 0;
172:             
173:           #if SPI_FREQ == 6
174:               SSPADD = 1;
175:           #endif
176:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
177:               SSPCON = SPI_MODE | IDLE_LOW;//SSPM=0000:=;CKP=0
178:               
179:           }
180:           void SlaveinitSPI(){
181:               TRIS_CS_PIN = 1;TRIS_CLK_PIN = 1;
0869  0021     MOVLB 0x1
086A  158E     BSF TRISC, 0x3
086B  140E     BSF TRISC, 0x0
182:               //BOEN = 0;
183:               //ANSC0=0;ANSC1=0;ANSC2=0;ANSC3=0; moved to system.c
184:               
185:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
086C  3040     MOVLW 0x40
086D  0024     MOVLB 0x4
086E  0094     MOVWF SSP1STAT
186:               SSPCON = SLAVE_SS_EN | IDLE_LOW;//SSPM=0000:=;CKP=0
086F  3024     MOVLW 0x24
0870  0095     MOVWF SSP1CON1
187:           }
0871  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/leds.c  ------------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <include/leds.h>
24:            #include <stdbool.h>
25:            #include <xc.h>
26:            
27:            #define LED_D1_LAT LATCbits.LATC4
28:            #define LED_D2_LAT LATCbits.LATC1
29:            #define LED_D3_LAT LATCbits.LATC2
30:            //#define LED_D4_LAT LATCbits.LATC3
31:            
32:            #define LED_D1_TRIS TRISCbits.TRISC4
33:            #define LED_D2_TRIS TRISCbits.TRISC1
34:            #define LED_D3_TRIS TRISCbits.TRISC2
35:            //#define LED_D4_TRIS TRISCbits.TRISC3
36:            
37:            #define LED_ON  1
38:            #define LED_OFF 0
39:            
40:            #define PIN_INPUT  1
41:            #define PIN_OUTPUT 0
42:            
43:            /*********************************************************************
44:            * Function: void LED_On(LED led);
45:            *
46:            * Overview: Turns requested LED on
47:            *
48:            * PreCondition: LED configured via LED_Configure()
49:            *
50:            * Input: LED led - enumeration of the LEDs available in this
51:            *        demo.  They should be meaningful names and not the names of
52:            *        the LEDs on the silkscreen on the board (as the demo code may
53:            *        be ported to other boards).
54:            *         i.e. - LED_On(LED_CONNECTION_DETECTED);
55:            *
56:            * Output: none
57:            *
58:            ********************************************************************/
59:            void LED_On(LED led)
092D  00F2     MOVWF 0x272
60:            {
61:                switch(led)
092E  2938     GOTO 0x138
62:                {
63:                    case LED_D1:
64:                        LED_D1_LAT = LED_ON;
092F  0022     MOVLB 0x2
0930  160E     BSF LATC, 0x4
65:                        break;
0931  294E     GOTO 0x14E
66:            
67:                    case LED_D2:
68:                        LED_D2_LAT = LED_ON;
0932  0022     MOVLB 0x2
0933  148E     BSF LATC, 0x1
69:                        break;
0934  294E     GOTO 0x14E
70:            			
71:                    case LED_D3:
72:                        LED_D3_LAT = LED_ON;
0935  0022     MOVLB 0x2
0936  150E     BSF LATC, 0x2
73:                        break;
0937  294E     GOTO 0x14E
74:            			
75:                    /*case LED_D4:
76:                        LED_D4_LAT = LED_ON;
77:                        break;*/
78:            
79:                    case LED_NONE:
80:                        break;
81:                }
0938  0872     MOVF 0x172, W
0939  00F0     MOVWF 0x170
093A  01F1     CLRF 0x171
093B  0871     MOVF 0x171, W
093C  3A00     XORLW 0x0
093D  1903     BTFSC STATUS, 0x2
093E  2940     GOTO 0x140
093F  294E     GOTO 0x14E
0940  0870     MOVF 0x170, W
0941  3A00     XORLW 0x0
0942  1903     BTFSC STATUS, 0x2
0943  294E     GOTO 0x14E
0944  3A01     XORLW 0x1
0945  1903     BTFSC STATUS, 0x2
0946  292F     GOTO 0x12F
0947  3A03     XORLW 0x3
0948  1903     BTFSC STATUS, 0x2
0949  2932     GOTO 0x132
094A  3A01     XORLW 0x1
094B  1903     BTFSC STATUS, 0x2
094C  2935     GOTO 0x135
094D  294E     GOTO 0x14E
82:            }
094E  0008     RETURN
83:            
84:            /*********************************************************************
85:            * Function: void LED_Off(LED led);
86:            *
87:            * Overview: Turns requested LED off
88:            *
89:            * PreCondition: LED configured via LEDConfigure()
90:            *
91:            * Input: LED led - enumeration of the LEDs available in this
92:            *        demo.  They should be meaningful names and not the names of
93:            *        the LEDs on the silkscreen on the board (as the demo code may
94:            *        be ported to other boards).
95:            *         i.e. - LED_Off(LED_CONNECTION_DETECTED);
96:            *
97:            * Output: none
98:            *
99:            ********************************************************************/
100:           void LED_Off(LED led)
090B  00F2     MOVWF 0x172
101:           {
102:               switch(led)
090C  2916     GOTO 0x116
103:               {
104:                   case LED_D1:
105:                       LED_D1_LAT = LED_OFF;
090D  0022     MOVLB 0x2
090E  120E     BCF LATC, 0x4
106:                       break;
090F  292C     GOTO 0x12C
107:           
108:                   case LED_D2:
109:                       LED_D2_LAT = LED_OFF;
0910  0022     MOVLB 0x2
0911  108E     BCF LATC, 0x1
110:                       break;
0912  292C     GOTO 0x12C
111:           			
112:                   case LED_D3:
113:                       LED_D3_LAT = LED_OFF;
0913  0022     MOVLB 0x2
0914  110E     BCF LATC, 0x2
114:                       break;
0915  292C     GOTO 0x12C
115:           			
116:                   /*case LED_D4:
117:                       LED_D4_LAT = LED_OFF;
118:                       break;*/
119:           
120:                   case LED_NONE:
121:                       break;
122:               }
0916  0872     MOVF 0x172, W
0917  00F0     MOVWF 0x170
0918  01F1     CLRF 0x171
0919  0871     MOVF 0x171, W
091A  3A00     XORLW 0x0
091B  1903     BTFSC STATUS, 0x2
091C  291E     GOTO 0x11E
091D  292C     GOTO 0x12C
091E  0870     MOVF 0x170, W
091F  3A00     XORLW 0x0
0920  1903     BTFSC STATUS, 0x2
0921  292C     GOTO 0x12C
0922  3A01     XORLW 0x1
0923  1903     BTFSC STATUS, 0x2
0924  290D     GOTO 0x10D
0925  3A03     XORLW 0x3
0926  1903     BTFSC STATUS, 0x2
0927  2910     GOTO 0x110
0928  3A01     XORLW 0x1
0929  1903     BTFSC STATUS, 0x2
092A  2913     GOTO 0x113
092B  292C     GOTO 0x12C
123:           }
092C  0008     RETURN
124:           
125:           /*********************************************************************
126:           * Function: void LED_Toggle(LED led);
127:           *
128:           * Overview: Toggles the state of the requested LED
129:           *
130:           * PreCondition: LED configured via LEDConfigure()
131:           *
132:           * Input: LED led - enumeration of the LEDs available in this
133:           *        demo.  They should be meaningful names and not the names of
134:           *        the LEDs on the silkscreen on the board (as the demo code may
135:           *        be ported to other boards).
136:           *         i.e. - LED_Toggle(LED_CONNECTION_DETECTED);
137:           *
138:           * Output: none
139:           *
140:           ********************************************************************/
141:           void LED_Toggle(LED led)
142:           {
143:               switch(led)
144:               {
145:                   case LED_D1:
146:                       LED_D1_LAT ^= 1;
147:                       break;
148:           
149:                   case LED_D2:
150:                       LED_D2_LAT ^= 1;
151:                       break;
152:           			
153:                   case LED_D3:
154:                       //LED_D3_LAT ^= 1;
155:                       break;
156:           			
157:                   /*case LED_D4:
158:                       LED_D4_LAT ^= 1;
159:                       break;*/
160:           
161:                   case LED_NONE:
162:                       break;
163:               }
164:           }
165:           
166:           /*********************************************************************
167:           * Function: bool LED_Get(LED led);
168:           *
169:           * Overview: Returns the current state of the requested LED
170:           *
171:           * PreCondition: LED configured via LEDConfigure()
172:           *
173:           * Input: LED led - enumeration of the LEDs available in this
174:           *        demo.  They should be meaningful names and not the names of
175:           *        the LEDs on the silkscreen on the board (as the demo code may
176:           *        be ported to other boards).
177:           *         i.e. - LED_Get(LED_CONNECTION_DETECTED);
178:           *
179:           * Output: true if on, false if off
180:           *
181:           ********************************************************************/
182:           bool LED_Get(LED led)
183:           {
184:               switch(led)
185:               {
186:                   case LED_D1:
187:                       return ( (LED_D1_LAT == LED_ON) ? true : false );
188:           
189:                   case LED_D2:
190:                       return ( (LED_D2_LAT == LED_ON) ? true : false );
191:           			
192:                   case LED_D3:
193:                       return ( (LED_D3_LAT == LED_ON) ? true : false );
194:           			
195:                   /*case LED_D4:
196:                       return ( (LED_D4_LAT == LED_ON) ? true : false );*/
197:           
198:                   case LED_NONE:
199:                       return false;
200:               }
201:               
202:               return false;
203:           }
204:           
205:           /*********************************************************************
206:           * Function: void LED_Enable(LED led);
207:           *
208:           * Overview: Configures the LED for use by the other LED API
209:           *
210:           * PreCondition: none
211:           *
212:           * Input: LED led - enumeration of the LEDs available in this
213:           *        demo.  They should be meaningful names and not the names of
214:           *        the LEDs on the silkscreen on the board (as the demo code may
215:           *        be ported to other boards).
216:           *
217:           * Output: none
218:           *
219:           ********************************************************************/
220:           void LED_Enable(LED led)
094F  00F2     MOVWF 0x172
221:           {
222:               switch(led)
0950  295A     GOTO 0x15A
223:               {
224:                   case LED_D1:
225:                       LED_D1_TRIS = PIN_OUTPUT;
0951  0021     MOVLB 0x1
0952  120E     BCF TRISC, 0x4
226:                       break;
0953  2970     GOTO 0x170
227:           
228:                   case LED_D2:
229:                       LED_D2_TRIS = PIN_OUTPUT;
0954  0021     MOVLB 0x1
0955  108E     BCF TRISC, 0x1
230:                       break;
0956  2970     GOTO 0x170
231:           			
232:                   case LED_D3:
233:                       LED_D3_TRIS = PIN_OUTPUT;
0957  0021     MOVLB 0x1
0958  110E     BCF TRISC, 0x2
234:                       break;
0959  2970     GOTO 0x170
235:           			
236:                   /*case LED_D4:
237:                       LED_D4_TRIS = PIN_OUTPUT;
238:                       break;*/
239:           
240:                   case LED_NONE:
241:                       break;
242:               }
095A  0872     MOVF 0xF2, W
095B  00F0     MOVWF 0xF0
095C  01F1     CLRF 0xF1
095D  0871     MOVF 0xF1, W
095E  3A00     XORLW 0x0
095F  1903     BTFSC STATUS, 0x2
0960  2962     GOTO 0x162
0961  2970     GOTO 0x170
0962  0870     MOVF 0xF0, W
0963  3A00     XORLW 0x0
0964  1903     BTFSC STATUS, 0x2
0965  2970     GOTO 0x170
0966  3A01     XORLW 0x1
0967  1903     BTFSC STATUS, 0x2
0968  2951     GOTO 0x151
0969  3A03     XORLW 0x3
096A  1903     BTFSC STATUS, 0x2
096B  2954     GOTO 0x154
096C  3A01     XORLW 0x1
096D  1903     BTFSC STATUS, 0x2
096E  2957     GOTO 0x157
096F  2970     GOTO 0x170
243:           }
0970  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/buttons.c  ---------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <xc.h>
24:            #include <stdbool.h>
25:            #include <include/buttons.h>
26:            
27:            /*** Button Definitions *********************************************/
28:            #define S1_PORT  PORTCbits.RC3
29:            
30:            #define BUTTON_PRESSED      0
31:            #define BUTTON_NOT_PRESSED  1
32:            
33:            #define PIN_INPUT           1
34:            #define PIN_OUTPUT          0
35:            
36:            #define PIN_DIGITAL         1
37:            #define PIN_ANALOG          0
38:            
39:            /*********************************************************************
40:            * Function: bool BUTTON_IsPressed(BUTTON button);
41:            *
42:            * Overview: Returns the current state of the requested button
43:            *
44:            * PreCondition: button configured via BUTTON_SetConfiguration()
45:            *
46:            * Input: BUTTON button - enumeration of the buttons available in
47:            *        this demo.  They should be meaningful names and not the names 
48:            *        of the buttons on the silkscreen on the board (as the demo 
49:            *        code may be ported to other boards).
50:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
51:            *
52:            * Output: TRUE if pressed; FALSE if not pressed.
53:            *
54:            ********************************************************************/
55:            bool BUTTON_IsPressed(BUTTON button)
56:            {
57:                ANSELC = 0;
58:                switch(button)
59:                {
60:                    case BUTTON_S1:
61:                        return ( (S1_PORT == BUTTON_PRESSED) ? true : false);
62:            
63:                    case BUTTON_NONE:
64:                        return false;
65:                }
66:                
67:                return false;
68:            }
69:            
70:            /*********************************************************************
71:            * Function: void BUTTON_Enable(BUTTON button);
72:            *
73:            * Overview: Returns the current state of the requested button
74:            *
75:            * PreCondition: button configured via BUTTON_SetConfiguration()
76:            *
77:            * Input: BUTTON button - enumeration of the buttons available in
78:            *        this demo.  They should be meaningful names and not the names
79:            *        of the buttons on the silkscreen on the board (as the demo
80:            *        code may be ported to other boards).
81:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
82:            *
83:            * Output: None
84:            *
85:            ********************************************************************/
86:            void BUTTON_Enable(BUTTON button)
087E  00F2     MOVWF 0xF2
87:            {
88:                switch(button)
087F  0872     MOVF 0xF2, W
0880  00F0     MOVWF 0xF0
0881  01F1     CLRF 0xF1
0882  0871     MOVF 0xF1, W
0883  3A00     XORLW 0x0
89:                {
90:                    case BUTTON_S1:
91:                        break;
92:            
93:                    case BUTTON_NONE:
94:                        break;
95:                }
0884  1903     BTFSC STATUS, 0x2
0885  2887     GOTO 0x87
0886  288F     GOTO 0x8F
0887  0870     MOVF 0xF0, W
0888  3A00     XORLW 0x0
0889  1903     BTFSC STATUS, 0x2
088A  288F     GOTO 0x8F
088B  3A01     XORLW 0x1
088C  1903     BTFSC STATUS, 0x2
088D  288F     GOTO 0x8F
088E  288F     GOTO 0x8F
96:            }
088F  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_led_usb_status.c  ----------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            // *****************************************************************************
21:            // *****************************************************************************
22:            // Section: Included Files
23:            // *****************************************************************************
24:            // *****************************************************************************
25:            #include "stdint.h"
26:            #include "include/system.h"
27:            #include "include/usb/usb_device.h"
28:            
29:            
30:            // *****************************************************************************
31:            // *****************************************************************************
32:            // Section: File Scope or Global Constants
33:            // *****************************************************************************
34:            // *****************************************************************************
35:            
36:            
37:            // *****************************************************************************
38:            // *****************************************************************************
39:            // Section: File Scope Data Types
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            
43:            
44:            // *****************************************************************************
45:            // *****************************************************************************
46:            // Section: Macros or Functions
47:            // *****************************************************************************
48:            // *****************************************************************************
49:            
50:            void APP_LEDUpdateUSBStatus(void)
51:            {
52:                static uint16_t ledCount = 0;
53:            
54:                if(USBIsDeviceSuspended() == true)
0C3F  003D     MOVLB 0x1D
0C40  1C8E     BTFSS UCON, 0x1
0C41  2C43     GOTO 0x443
0C42  2C44     GOTO 0x444
0C43  2C8E     GOTO 0x48E
55:                {
56:                    LED_Off(LED_USB_DEVICE_STATE);
0C44  3001     MOVLW 0x1
0C45  3189     MOVLP 0x9
0C46  210B     CALL 0x10B
0C47  318C     MOVLP 0xC
0C48  2CA1     GOTO 0x4A1
57:                    return;
58:                }
59:            
60:                switch(USBGetDeviceState())
61:                {         
62:                    case CONFIGURED_STATE:
63:                        /* We are configured.  Blink fast.
64:                         * On for 75ms, off for 75ms, then reset/repeat. */
65:                        if(ledCount == 1)
0C49  033D     DECF 0xEBD, W
0C4A  043E     IORWF 0xEBE, W
0C4B  1D03     BTFSS STATUS, 0x2
0C4C  2C4E     GOTO 0x44E
0C4D  2C4F     GOTO 0x44F
0C4E  2C54     GOTO 0x454
66:                        {
67:                            LED_On(LED_USB_DEVICE_STATE);
0C4F  3001     MOVLW 0x1
0C50  3189     MOVLP 0x9
0C51  212D     CALL 0x12D
0C52  318C     MOVLP 0xC
68:                        }
0C53  2C9C     GOTO 0x49C
69:                        else if(ledCount == 75)
0C54  304B     MOVLW 0x4B
0C55  063D     XORWF 0xEBD, W
0C56  043E     IORWF 0xEBE, W
0C57  1D03     BTFSS STATUS, 0x2
0C58  2C5A     GOTO 0x45A
0C59  2C5B     GOTO 0x45B
0C5A  2C60     GOTO 0x460
70:                        {
71:                            LED_Off(LED_USB_DEVICE_STATE);
0C5B  3001     MOVLW 0x1
0C5C  3189     MOVLP 0x9
0C5D  210B     CALL 0x10B
0C5E  318C     MOVLP 0xC
72:                        }
0C5F  2C9C     GOTO 0x49C
73:                        else if(ledCount > 150)
0C60  3000     MOVLW 0x0
0C61  023E     SUBWF 0xEBE, W
0C62  3097     MOVLW 0x97
0C63  1903     BTFSC STATUS, 0x2
0C64  023D     SUBWF 0xEBD, W
0C65  1C03     BTFSS STATUS, 0x0
0C66  2C68     GOTO 0x468
0C67  2C69     GOTO 0x469
0C68  2C6C     GOTO 0x46C
74:                        {
75:                            ledCount = 0;
0C69  01BD     CLRF 0xEBD
0C6A  01BE     CLRF 0xEBE
0C6B  2C9C     GOTO 0x49C
76:                        }
77:                        break;
0C6C  2C9C     GOTO 0x49C
78:            
79:                    default:
80:                        /* We aren't configured yet, but we aren't suspended so let's blink with
81:                         * a slow pulse. On for 50ms, then off for 950ms, then reset/repeat. */
82:                        if(ledCount == 1)
0C6D  033D     DECF 0xEBD, W
0C6E  043E     IORWF 0xEBE, W
0C6F  1D03     BTFSS STATUS, 0x2
0C70  2C72     GOTO 0x472
0C71  2C73     GOTO 0x473
0C72  2C78     GOTO 0x478
83:                        {
84:                            LED_On(LED_USB_DEVICE_STATE);
0C73  3001     MOVLW 0x1
0C74  3189     MOVLP 0x9
0C75  212D     CALL 0x12D
0C76  318C     MOVLP 0xC
85:                        }
0C77  2C9C     GOTO 0x49C
86:                        else if(ledCount == 50)
0C78  3032     MOVLW 0x32
0C79  063D     XORWF 0xEBD, W
0C7A  043E     IORWF 0xEBE, W
0C7B  1D03     BTFSS STATUS, 0x2
0C7C  2C7E     GOTO 0x47E
0C7D  2C7F     GOTO 0x47F
0C7E  2C84     GOTO 0x484
87:                        {
88:                            LED_Off(LED_USB_DEVICE_STATE);
0C7F  3001     MOVLW 0x1
0C80  3189     MOVLP 0x9
0C81  210B     CALL 0x10B
0C82  318C     MOVLP 0xC
89:                        }
0C83  2C9C     GOTO 0x49C
90:                        else if(ledCount > 950)
0C84  3003     MOVLW 0x3
0C85  023E     SUBWF 0xEBE, W
0C86  30B7     MOVLW 0xB7
0C87  1903     BTFSC STATUS, 0x2
0C88  023D     SUBWF 0xEBD, W
0C89  1C03     BTFSS STATUS, 0x0
0C8A  2C8C     GOTO 0x48C
0C8B  2C8D     GOTO 0x48D
0C8C  2C9C     GOTO 0x49C
0C8D  2C69     GOTO 0x469
91:                        {
92:                            ledCount = 0;
93:                        }
94:                        break;
95:                }
0C8E  0021     MOVLB 0x1
0C8F  0854     MOVF USBDeviceState, W
0C90  00F3     MOVWF 0xF3
0C91  01F4     CLRF 0xF4
0C92  0874     MOVF 0xF4, W
0C93  3A00     XORLW 0x0
0C94  1903     BTFSC STATUS, 0x2
0C95  2C97     GOTO 0x497
0C96  2C6D     GOTO 0x46D
0C97  0873     MOVF 0xF3, W
0C98  3A20     XORLW 0x20
0C99  1903     BTFSC STATUS, 0x2
0C9A  2C49     GOTO 0x449
0C9B  2C6D     GOTO 0x46D
96:            
97:                /* Increment the millisecond counter. */
98:                ledCount++;
0C9C  3001     MOVLW 0x1
0C9D  0021     MOVLB 0x1
0C9E  07BD     ADDWF ledCount, F
0C9F  3000     MOVLW 0x0
0CA0  3DBE     ADDWFC 0xBE, F
99:            }
0CA1  0008     RETURN
100:           
101:           /*******************************************************************************
102:            End of File
103:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_device_joystick.c  ---------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #ifndef USBJOYSTICK_C
21:            #define USBJOYSTICK_C
22:            
23:            /** INCLUDES *******************************************************/
24:            #include "include/app_device_joystick.h"
25:            
26:            #include "include/system.h"
27:            
28:            #include "include/app_led_usb_status.h"
29:            #include "include/spi.h"
30:            
31:            #include "stdint.h"
32:            
33:            /** DECLARATIONS ***************************************************/
34:            
35:            USB_VOLATILE USB_HANDLE last_HAP_IN = 0;
36:            USB_VOLATILE USB_HANDLE last_HAP_OUT = 0;
37:            USB_VOLATILE USB_HANDLE last_LED_OUT = 0;
38:            USB_VOLATILE USB_HANDLE last_DSP_OUT = 0;
39:            
40:            
41:            /*********************************************************************
42:            * Function: void APP_DeviceJoystickInitialize(void);
43:            *
44:            * Overview: Initializes the demo code
45:            *
46:            * PreCondition: None
47:            *
48:            * Input: None
49:            *
50:            * Output: None
51:            *
52:            ********************************************************************/
53:            
54:            uint8_t display_pkt_ready,LED_pkt_ready,hap_IN_pkt_sent,hap_OUT_pkt_ready;
55:            
56:            void APP_DeviceJoystickInitialize(void)
57:            {  
58:                //initialize the variable holding the handle for the last
59:                // transmission
60:                last_HAP_IN = 0;
09BF  0021     MOVLB 0x1
09C0  01BF     CLRF last_HAP_IN
09C1  01C0     CLRF 0xC0
61:                last_HAP_OUT = 0;
09C2  0023     MOVLB 0x3
09C3  01BA     CLRF last_HAP_OUT
09C4  01BB     CLRF 0x1BB
62:                last_LED_OUT = 0;
09C5  01B8     CLRF last_LED_OUT
09C6  01B9     CLRF 0x1B9
63:                last_DSP_OUT = 0;
09C7  01B6     CLRF last_DSP_OUT
09C8  01B7     CLRF 0x1B7
64:            
65:                
66:                display_pkt_ready=0;
09C9  0021     MOVLB 0x1
09CA  01C4     CLRF display_pkt_ready
67:                LED_pkt_ready=0;
09CB  01C3     CLRF LED_pkt_ready
68:                hap_IN_pkt_sent=1;
09CC  0022     MOVLB 0x2
09CD  01AD     CLRF hap_IN_pkt_sent
09CE  0AAD     INCF hap_IN_pkt_sent, F
69:                hap_OUT_pkt_ready=0;
09CF  01AC     CLRF hap_OUT_pkt_ready
70:            
71:                //enable the HID endpoint
72:                USBEnableEndpoint(HAPTIC_EP,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
09D0  301E     MOVLW 0x1E
09D1  00FD     MOVWF 0x17D
09D2  087D     MOVF 0x17D, W
09D3  00F7     MOVWF 0x177
09D4  3001     MOVLW 0x1
09D5  3189     MOVLP 0x9
09D6  2171     CALL 0x171
09D7  3189     MOVLP 0x9
73:                USBEnableEndpoint(LEDS_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
09D8  301E     MOVLW 0x1E
09D9  00FD     MOVWF 0x17D
09DA  087D     MOVF 0x17D, W
09DB  00F7     MOVWF 0x177
09DC  3002     MOVLW 0x2
09DD  3189     MOVLP 0x9
09DE  2171     CALL 0x171
09DF  3189     MOVLP 0x9
74:                USBEnableEndpoint(DISPLAY_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
09E0  301E     MOVLW 0x1E
09E1  00FD     MOVWF 0x17D
09E2  087D     MOVF 0x17D, W
09E3  00F7     MOVWF 0x177
09E4  3003     MOVLW 0x3
09E5  3189     MOVLP 0x9
09E6  2171     CALL 0x171
09E7  3189     MOVLP 0x9
75:            }//end UserInit
09E8  0008     RETURN
76:            
77:            /*********************************************************************
78:            * Function: void APP_DeviceJoystickTasks(void);
79:            *
80:            * Overview: Keeps the demo running.
81:            *
82:            * PreCondition: The demo should have been initialized and started via
83:            *   the APP_DeviceJoystickInitialize() and APP_DeviceJoystickStart() demos
84:            *   respectively.
85:            *
86:            * Input: None
87:            *
88:            * Output: None
89:            *
90:            ********************************************************************/
91:            
92:            uint8_t cntr=0;
93:            
94:            void APP_DeviceJoystickTasks(void)
95:            {  
96:                /* If the USB device isn't configured yet, we can't really do anything
97:                 * else since we don't have a host to talk to.  So jump back to the
98:                 * top of the while loop. */
99:                if( USBGetDeviceState() < CONFIGURED_STATE )
03F1  3020     MOVLW 0x20
03F2  0021     MOVLB 0x1
03F3  0254     SUBWF USBDeviceState, W
03F4  1803     BTFSC STATUS, 0x0
03F5  2BF7     GOTO 0x3F7
03F6  2BF8     GOTO 0x3F8
03F7  2BF9     GOTO 0x3F9
03F8  2CC9     GOTO 0x4C9
100:               {
101:                   /* Jump back to the top of the while loop. */
102:                   return;
103:               }
104:           
105:               /* If we are currently suspended, then we need to see if we need to
106:                * issue a remote wakeup.  In either case, we shouldn't process any
107:                * keyboard commands since we aren't currently communicating to the host
108:                * thus just continue back to the start of the while loop. */
109:               if( USBIsDeviceSuspended() == true )
03F9  003D     MOVLB 0x1D
03FA  1C8E     BTFSS UCON, 0x1
03FB  2BFD     GOTO 0x3FD
03FC  2BFE     GOTO 0x3FE
03FD  2BFF     GOTO 0x3FF
03FE  2CC9     GOTO 0x4C9
110:               {
111:                   /* Jump back to the top of the while loop. */
112:                   return;
113:               }
114:           
115:               //If the last transmission is complete
116:               if(!HIDTxHandleBusy(last_HAP_IN) && (hap_IN_pkt_sent == 0))
03FF  0021     MOVLB 0x1
0400  083F     MOVF last_HAP_IN, W
0401  0440     IORWF 0xC0, W
0402  1903     BTFSC STATUS, 0x2
0403  2C05     GOTO 0x405
0404  2C06     GOTO 0x406
0405  2C0E     GOTO 0x40E
0406  083F     MOVF last_HAP_IN, W
0407  0086     MOVWF FSR1L
0408  0840     MOVF 0xC0, W
0409  0087     MOVWF FSR1H
040A  1B81     BTFSC INDF1, 0x7
040B  2C0D     GOTO 0x40D
040C  2C0E     GOTO 0x40E
040D  2C51     GOTO 0x451
040E  0022     MOVLB 0x2
040F  082D     MOVF hap_IN_pkt_sent, W
0410  1D03     BTFSS STATUS, 0x2
0411  2C13     GOTO 0x413
0412  2C14     GOTO 0x414
0413  2C51     GOTO 0x451
117:               {
118:                   
119:                       
120:                   haptic_in[0] = display_output[0];
0414  30B0     MOVLW 0xB0
0415  0086     MOVWF FSR1L
0416  3021     MOVLW 0x21
0417  0087     MOVWF FSR1H
0418  0801     MOVF INDF1, W
0419  00FB     MOVWF 0x17B
041A  087B     MOVF 0x17B, W
041B  0021     MOVLB 0x1
041C  00A0     MOVWF haptic_in
121:                   haptic_in[1] = display_output[1];
041D  30B0     MOVLW 0xB0
041E  0086     MOVWF FSR1L
041F  3021     MOVLW 0x21
0420  0087     MOVWF FSR1H
0421  3141     ADDFSR 1, 1
0422  0801     MOVF INDF1, W
0423  00FB     MOVWF 0xFB
0424  087B     MOVF 0xFB, W
0425  00A1     MOVWF 0xA1
122:                   haptic_in[2] = TESTB;
0426  01A2     CLRF 0xA2
123:                   haptic_in[3] = SSPCON1;
0427  0024     MOVLB 0x4
0428  0815     MOVF SSP1CON1, W
0429  00FB     MOVWF 0x27B
042A  087B     MOVF 0x27B, W
042B  0021     MOVLB 0x1
042C  00A3     MOVWF 0xA3
124:                   haptic_in[4] = SSPSTAT;
042D  0024     MOVLB 0x4
042E  0814     MOVF SSP1STAT, W
042F  00FB     MOVWF 0x27B
0430  087B     MOVF 0x27B, W
0431  0021     MOVLB 0x1
0432  00A4     MOVWF 0xA4
125:                   haptic_in[5] = display_output[63];
0433  30EF     MOVLW 0xEF
0434  0086     MOVWF FSR1L
0435  3021     MOVLW 0x21
0436  0087     MOVWF FSR1H
0437  0801     MOVF INDF1, W
0438  00FB     MOVWF 0xFB
0439  087B     MOVF 0xFB, W
043A  00A5     MOVWF 0xA5
126:                   hap_IN_pkt_sent = 1;
043B  0022     MOVLB 0x2
043C  01AD     CLRF hap_IN_pkt_sent
043D  0AAD     INCF hap_IN_pkt_sent, F
127:                       //Send the 8 byte packet over USB to the host.
128:                   last_HAP_IN = HIDTxPacket(HAPTIC_EP, (uint8_t*)&haptic_in, sizeof(haptic_in));
043E  01F0     CLRF 0x170
043F  0AF0     INCF 0x170, F
0440  30A0     MOVLW 0xA0
0441  00F1     MOVWF 0x171
0442  3000     MOVLW 0x0
0443  00F2     MOVWF 0x172
0444  3010     MOVLW 0x10
0445  00FB     MOVWF 0x17B
0446  087B     MOVF 0x17B, W
0447  00F3     MOVWF 0x173
0448  3001     MOVLW 0x1
0449  318F     MOVLP 0xF
044A  2779     CALL 0x779
044B  3183     MOVLP 0x3
044C  0871     MOVF 0x171, W
044D  0021     MOVLB 0x1
044E  00C0     MOVWF 0xC0
044F  0870     MOVF 0xF0, W
0450  00BF     MOVWF last_HAP_IN
129:                   
130:               }
131:               
132:               if(!HIDRxHandleBusy(last_HAP_OUT) && hap_OUT_pkt_ready){
0451  0023     MOVLB 0x3
0452  083A     MOVF last_HAP_OUT, W
0453  043B     IORWF 0x1BB, W
0454  1903     BTFSC STATUS, 0x2
0455  2C57     GOTO 0x457
0456  2C58     GOTO 0x458
0457  2C60     GOTO 0x460
0458  083A     MOVF last_HAP_OUT, W
0459  0086     MOVWF FSR1L
045A  083B     MOVF 0x1BB, W
045B  0087     MOVWF FSR1H
045C  1B81     BTFSC INDF1, 0x7
045D  2C5F     GOTO 0x45F
045E  2C60     GOTO 0x460
045F  2C79     GOTO 0x479
0460  0022     MOVLB 0x2
0461  082C     MOVF hap_OUT_pkt_ready, W
0462  1903     BTFSC STATUS, 0x2
0463  2C65     GOTO 0x465
0464  2C66     GOTO 0x466
0465  2C79     GOTO 0x479
133:                   hap_OUT_pkt_ready = 0;
0466  01AC     CLRF hap_OUT_pkt_ready
134:                   last_HAP_OUT = HIDRxPacket(HAPTIC_EP, (uint8_t*)&haptic_out, sizeof(haptic_out));
0467  01F0     CLRF 0x170
0468  3030     MOVLW 0x30
0469  00F1     MOVWF 0x171
046A  3001     MOVLW 0x1
046B  00F2     MOVWF 0x172
046C  3040     MOVLW 0x40
046D  00FB     MOVWF 0x17B
046E  087B     MOVF 0x17B, W
046F  00F3     MOVWF 0x173
0470  3001     MOVLW 0x1
0471  318F     MOVLP 0xF
0472  2779     CALL 0x779
0473  3183     MOVLP 0x3
0474  0871     MOVF 0x171, W
0475  0023     MOVLB 0x3
0476  00BB     MOVWF 0x1BB
0477  0870     MOVF 0x1F0, W
0478  00BA     MOVWF last_HAP_OUT
135:               }
136:               if(!HIDRxHandleBusy(last_DSP_OUT) && display_pkt_ready){
0479  0023     MOVLB 0x3
047A  0836     MOVF last_DSP_OUT, W
047B  0437     IORWF 0x1B7, W
047C  1903     BTFSC STATUS, 0x2
047D  2C7F     GOTO 0x47F
047E  2C80     GOTO 0x480
047F  2C88     GOTO 0x488
0480  0836     MOVF last_DSP_OUT, W
0481  0086     MOVWF FSR1L
0482  0837     MOVF 0x1B7, W
0483  0087     MOVWF FSR1H
0484  1B81     BTFSC INDF1, 0x7
0485  2C87     GOTO 0x487
0486  2C88     GOTO 0x488
0487  2CA1     GOTO 0x4A1
0488  0021     MOVLB 0x1
0489  0844     MOVF display_pkt_ready, W
048A  1903     BTFSC STATUS, 0x2
048B  2C8D     GOTO 0x48D
048C  2C8E     GOTO 0x48E
048D  2CA1     GOTO 0x4A1
137:                   display_pkt_ready = 0;
048E  01C4     CLRF display_pkt_ready
138:                   last_DSP_OUT = HIDRxPacket(DISPLAY_EP, (uint8_t*)&display_output, sizeof(display_output));
048F  01F0     CLRF 0xF0
0490  30B0     MOVLW 0xB0
0491  00F1     MOVWF 0xF1
0492  3021     MOVLW 0x21
0493  00F2     MOVWF 0xF2
0494  3040     MOVLW 0x40
0495  00FB     MOVWF 0xFB
0496  087B     MOVF 0xFB, W
0497  00F3     MOVWF 0xF3
0498  3003     MOVLW 0x3
0499  318F     MOVLP 0xF
049A  2779     CALL 0x779
049B  3183     MOVLP 0x3
049C  0871     MOVF 0xF1, W
049D  0023     MOVLB 0x3
049E  00B7     MOVWF 0x1B7
049F  0870     MOVF 0x1F0, W
04A0  00B6     MOVWF last_DSP_OUT
139:               }
140:               if(!HIDRxHandleBusy(last_LED_OUT) && LED_pkt_ready){
04A1  0023     MOVLB 0x3
04A2  0838     MOVF last_LED_OUT, W
04A3  0439     IORWF 0x1B9, W
04A4  1903     BTFSC STATUS, 0x2
04A5  2CA7     GOTO 0x4A7
04A6  2CA8     GOTO 0x4A8
04A7  2CB0     GOTO 0x4B0
04A8  0838     MOVF last_LED_OUT, W
04A9  0086     MOVWF FSR1L
04AA  0839     MOVF 0x1B9, W
04AB  0087     MOVWF FSR1H
04AC  1B81     BTFSC INDF1, 0x7
04AD  2CAF     GOTO 0x4AF
04AE  2CB0     GOTO 0x4B0
04AF  2CC9     GOTO 0x4C9
04B0  0021     MOVLB 0x1
04B1  0843     MOVF LED_pkt_ready, W
04B2  1903     BTFSC STATUS, 0x2
04B3  2CB5     GOTO 0x4B5
04B4  2CB6     GOTO 0x4B6
04B5  2CC9     GOTO 0x4C9
141:                   LED_pkt_ready = 0;
04B6  01C3     CLRF LED_pkt_ready
142:                   last_LED_OUT = HIDRxPacket(LEDS_EP, (uint8_t*)&leds_output, sizeof(leds_output));
04B7  01F0     CLRF 0xF0
04B8  3030     MOVLW 0x30
04B9  00F1     MOVWF 0xF1
04BA  3021     MOVLW 0x21
04BB  00F2     MOVWF 0xF2
04BC  3031     MOVLW 0x31
04BD  00FB     MOVWF 0xFB
04BE  087B     MOVF 0xFB, W
04BF  00F3     MOVWF 0xF3
04C0  3002     MOVLW 0x2
04C1  318F     MOVLP 0xF
04C2  2779     CALL 0x779
04C3  3183     MOVLP 0x3
04C4  0871     MOVF 0xF1, W
04C5  0023     MOVLB 0x3
04C6  00B9     MOVWF 0x1B9
04C7  0870     MOVF 0x1F0, W
04C8  00B8     MOVWF last_LED_OUT
143:               }
144:               
145:           }//end ProcessIO
04C9  0008     RETURN
146:           
147:           #endif
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memset.c  ---------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
04CA  0871     MOVF 0x1F1, W
04CB  00FD     MOVWF 0x1FD
04CC  0870     MOVF 0x1F0, W
04CD  00FC     MOVWF 0x1FC
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
04CE  0874     MOVF 0x1F4, W
04CF  0475     IORWF 0x1F5, W
04D0  1D03     BTFSS STATUS, 0x2
04D1  2CD3     GOTO 0x4D3
04D2  2CD4     GOTO 0x4D4
04D3  2CD5     GOTO 0x4D5
04D4  2D93     GOTO 0x593
14:            	s[0] = (unsigned char)c;
04D5  087C     MOVF 0x1FC, W
04D6  0086     MOVWF FSR1L
04D7  087D     MOVF 0x1FD, W
04D8  0087     MOVWF FSR1H
04D9  0872     MOVF 0x1F2, W
04DA  0081     MOVWF INDF1
15:            	s[n-1] = (unsigned char)c;
04DB  0874     MOVF 0x1F4, W
04DC  077C     ADDWF 0x1FC, W
04DD  00F6     MOVWF 0x1F6
04DE  0875     MOVF 0x1F5, W
04DF  3D7D     ADDWFC 0x1FD, W
04E0  00F7     MOVWF 0x1F7
04E1  0876     MOVF 0x1F6, W
04E2  3EFF     ADDLW 0xFF
04E3  00F8     MOVWF 0x1F8
04E4  30FF     MOVLW 0xFF
04E5  3D77     ADDWFC 0x1F7, W
04E6  00F9     MOVWF 0x1F9
04E7  0878     MOVF 0x1F8, W
04E8  0086     MOVWF FSR1L
04E9  0879     MOVF 0x1F9, W
04EA  0087     MOVWF FSR1H
04EB  0872     MOVF 0x1F2, W
04EC  0081     MOVWF INDF1
16:            	if (n <= 2) return dest;
04ED  3000     MOVLW 0x0
04EE  0275     SUBWF 0x1F5, W
04EF  3003     MOVLW 0x3
04F0  1903     BTFSC STATUS, 0x2
04F1  0274     SUBWF 0x1F4, W
04F2  1803     BTFSC STATUS, 0x0
04F3  2CF5     GOTO 0x4F5
04F4  2CF6     GOTO 0x4F6
04F5  2CF7     GOTO 0x4F7
04F6  2D93     GOTO 0x593
17:            	s[1] = (unsigned char)c;
04F7  087C     MOVF 0x1FC, W
04F8  3E01     ADDLW 0x1
04F9  00F6     MOVWF 0x1F6
04FA  3000     MOVLW 0x0
04FB  3D7D     ADDWFC 0x1FD, W
04FC  00F7     MOVWF 0x1F7
04FD  0876     MOVF 0x1F6, W
04FE  0086     MOVWF FSR1L
04FF  0877     MOVF 0x1F7, W
0500  0087     MOVWF FSR1H
0501  0872     MOVF 0x1F2, W
0502  0081     MOVWF INDF1
18:            	s[2] = (unsigned char)c;
0503  087C     MOVF 0x1FC, W
0504  3E02     ADDLW 0x2
0505  00F6     MOVWF 0x1F6
0506  3000     MOVLW 0x0
0507  3D7D     ADDWFC 0x1FD, W
0508  00F7     MOVWF 0x1F7
0509  0876     MOVF 0x1F6, W
050A  0086     MOVWF FSR1L
050B  0877     MOVF 0x1F7, W
050C  0087     MOVWF FSR1H
050D  0872     MOVF 0x1F2, W
050E  0081     MOVWF INDF1
19:            	s[n-2] = (unsigned char)c;
050F  0874     MOVF 0x1F4, W
0510  077C     ADDWF 0x1FC, W
0511  00F6     MOVWF 0x1F6
0512  0875     MOVF 0x1F5, W
0513  3D7D     ADDWFC 0x1FD, W
0514  00F7     MOVWF 0x1F7
0515  0876     MOVF 0x1F6, W
0516  3EFE     ADDLW 0xFE
0517  00F8     MOVWF 0x1F8
0518  30FF     MOVLW 0xFF
0519  3D77     ADDWFC 0x1F7, W
051A  00F9     MOVWF 0x1F9
051B  0878     MOVF 0x1F8, W
051C  0086     MOVWF FSR1L
051D  0879     MOVF 0x1F9, W
051E  0087     MOVWF FSR1H
051F  0872     MOVF 0x1F2, W
0520  0081     MOVWF INDF1
20:            	s[n-3] = (unsigned char)c;
0521  0874     MOVF 0x1F4, W
0522  077C     ADDWF 0x1FC, W
0523  00F6     MOVWF 0x1F6
0524  0875     MOVF 0x1F5, W
0525  3D7D     ADDWFC 0x1FD, W
0526  00F7     MOVWF 0x1F7
0527  0876     MOVF 0x1F6, W
0528  3EFD     ADDLW 0xFD
0529  00F8     MOVWF 0x1F8
052A  30FF     MOVLW 0xFF
052B  3D77     ADDWFC 0x1F7, W
052C  00F9     MOVWF 0x1F9
052D  0878     MOVF 0x1F8, W
052E  0086     MOVWF FSR1L
052F  0879     MOVF 0x1F9, W
0530  0087     MOVWF FSR1H
0531  0872     MOVF 0x1F2, W
0532  0081     MOVWF INDF1
21:            	if (n <= 6) return dest;
0533  3000     MOVLW 0x0
0534  0275     SUBWF 0x1F5, W
0535  3007     MOVLW 0x7
0536  1903     BTFSC STATUS, 0x2
0537  0274     SUBWF 0x1F4, W
0538  1803     BTFSC STATUS, 0x0
0539  2D3B     GOTO 0x53B
053A  2D3C     GOTO 0x53C
053B  2D3D     GOTO 0x53D
053C  2D93     GOTO 0x593
22:            	s[3] = (unsigned char)c;
053D  087C     MOVF 0x1FC, W
053E  3E03     ADDLW 0x3
053F  00F6     MOVWF 0x1F6
0540  3000     MOVLW 0x0
0541  3D7D     ADDWFC 0x1FD, W
0542  00F7     MOVWF 0x1F7
0543  0876     MOVF 0x1F6, W
0544  0086     MOVWF FSR1L
0545  0877     MOVF 0x1F7, W
0546  0087     MOVWF FSR1H
0547  0872     MOVF 0x1F2, W
0548  0081     MOVWF INDF1
23:            	s[n-4] = (unsigned char)c;
0549  0874     MOVF 0x1F4, W
054A  077C     ADDWF 0x1FC, W
054B  00F6     MOVWF 0x1F6
054C  0875     MOVF 0x1F5, W
054D  3D7D     ADDWFC 0x1FD, W
054E  00F7     MOVWF 0x1F7
054F  0876     MOVF 0x1F6, W
0550  3EFC     ADDLW 0xFC
0551  00F8     MOVWF 0x1F8
0552  30FF     MOVLW 0xFF
0553  3D77     ADDWFC 0x1F7, W
0554  00F9     MOVWF 0x1F9
0555  0878     MOVF 0x1F8, W
0556  0086     MOVWF FSR1L
0557  0879     MOVF 0x1F9, W
0558  0087     MOVWF FSR1H
0559  0872     MOVF 0x1F2, W
055A  0081     MOVWF INDF1
24:            	if (n <= 8) return dest;
055B  3000     MOVLW 0x0
055C  0275     SUBWF 0x1F5, W
055D  3009     MOVLW 0x9
055E  1903     BTFSC STATUS, 0x2
055F  0274     SUBWF 0x1F4, W
0560  1803     BTFSC STATUS, 0x0
0561  2D63     GOTO 0x563
0562  2D64     GOTO 0x564
0563  2D65     GOTO 0x565
0564  2D93     GOTO 0x593
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
0565  097C     COMF 0x1FC, W
0566  00F6     MOVWF 0x1F6
0567  097D     COMF 0x1FD, W
0568  00F7     MOVWF 0x1F7
0569  0AF6     INCF 0x1F6, F
056A  1903     BTFSC STATUS, 0x2
056B  0AF7     INCF 0x1F7, F
056C  3003     MOVLW 0x3
056D  0576     ANDWF 0x1F6, W
056E  00FA     MOVWF 0x1FA
056F  3000     MOVLW 0x0
0570  0577     ANDWF 0x1F7, W
0571  00FB     MOVWF 0x1FB
32:            	s += k;
0572  087A     MOVF 0x1FA, W
0573  07FC     ADDWF 0x1FC, F
0574  087B     MOVF 0x1FB, W
0575  3DFD     ADDWFC 0x1FD, F
33:            	n -= k;
0576  087A     MOVF 0x1FA, W
0577  02F4     SUBWF 0x1F4, F
0578  087B     MOVF 0x1FB, W
0579  3BF5     SUBWFB 0x1F5, F
34:            	n &= (size_t)-4;
057A  30FC     MOVLW 0xFC
057B  05F4     ANDWF 0x1F4, F
057C  30FF     MOVLW 0xFF
057D  05F5     ANDWF 0x1F5, F
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
057E  2D8D     GOTO 0x58D
057F  087C     MOVF 0x1FC, W
0580  0086     MOVWF FSR1L
0581  087D     MOVF 0x1FD, W
0582  0087     MOVWF FSR1H
0583  0872     MOVF 0x1F2, W
0584  0081     MOVWF INDF1
0585  3001     MOVLW 0x1
0586  02F4     SUBWF 0x1F4, F
0587  3000     MOVLW 0x0
0588  3BF5     SUBWFB 0x1F5, F
0589  3001     MOVLW 0x1
058A  07FC     ADDWF 0x1FC, F
058B  3000     MOVLW 0x0
058C  3DFD     ADDWFC 0x1FD, F
058D  0874     MOVF 0x1F4, W
058E  0475     IORWF 0x1F5, W
058F  1D03     BTFSS STATUS, 0x2
0590  2D92     GOTO 0x592
0591  2D93     GOTO 0x593
0592  2D7F     GOTO 0x57F
87:            #endif
88:            
89:            	return dest;
90:            }
0593  0008     RETURN
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memcpy.c  ---------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
0A14  00F8     MOVWF 0x1F8
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
0A15  0871     MOVF 0x1F1, W
0A16  00F6     MOVWF 0x1F6
0A17  0870     MOVF 0x1F0, W
0A18  00F5     MOVWF 0x1F5
12:            	d = d1;
0A19  0878     MOVF 0x1F8, W
0A1A  00F4     MOVWF 0x1F4
0A1B  0874     MOVF 0x1F4, W
0A1C  00F9     MOVWF 0x1F9
13:            	while(n--) {
0A1D  2A35     GOTO 0x235
0A35  3001     MOVLW 0x1
0A36  02F2     SUBWF 0x1F2, F
0A37  3000     MOVLW 0x0
0A38  3BF3     SUBWFB 0x1F3, F
0A39  0A72     INCF 0x1F2, W
0A3A  1D03     BTFSS STATUS, 0x2
0A3B  2A40     GOTO 0x240
0A3C  0A73     INCF 0x1F3, W
0A3D  1D03     BTFSS STATUS, 0x2
0A3E  2A40     GOTO 0x240
0A3F  2A41     GOTO 0x241
0A40  2A1E     GOTO 0x21E
14:            		tmp = *s++;
0A1E  0875     MOVF 0x1F5, W
0A1F  0086     MOVWF FSR1L
0A20  0876     MOVF 0x1F6, W
0A21  0087     MOVWF FSR1H
0A22  0801     MOVF INDF1, W
0A23  00F4     MOVWF 0x1F4
0A24  0874     MOVF 0x1F4, W
0A25  00F7     MOVWF 0x1F7
0A26  3001     MOVLW 0x1
0A27  07F5     ADDWF 0x1F5, F
0A28  3000     MOVLW 0x0
0A29  3DF6     ADDWFC 0x1F6, F
15:            		*d++ = tmp;
0A2A  0877     MOVF 0x1F7, W
0A2B  00F4     MOVWF 0x1F4
0A2C  0879     MOVF 0x1F9, W
0A2D  0086     MOVWF FSR1L
0A2E  0187     CLRF FSR1H
0A2F  0874     MOVF 0x1F4, W
0A30  0081     MOVWF INDF1
0A31  3001     MOVLW 0x1
0A32  00F4     MOVWF 0x1F4
0A33  0874     MOVF 0x1F4, W
0A34  07F9     ADDWF 0x1F9, F
0A35  3001     MOVLW 0x1
0A36  02F2     SUBWF 0x1F2, F
0A37  3000     MOVLW 0x0
0A38  3BF3     SUBWFB 0x1F3, F
0A39  0A72     INCF 0x1F2, W
0A3A  1D03     BTFSS STATUS, 0x2
0A3B  2A40     GOTO 0x240
0A3C  0A73     INCF 0x1F3, W
0A3D  1D03     BTFSS STATUS, 0x2
0A3E  2A40     GOTO 0x240
0A3F  2A41     GOTO 0x241
0A40  2A1E     GOTO 0x21E
16:            	}
17:            	return d1;
18:            }
0A41  0008     RETURN
19:            
---  C:/Users/Dutu/AppData/Local/Temp/xcAs1huo.s  -------------------------------------------------------
000A  3061     MOVLW 0x61
000B  0084     MOVWF FSR0L
000C  3088     MOVLW 0x88
000D  0085     MOVWF FSR0H
000E  0023     MOVLB 0x3
000F  0012     MOVIW FSR0++
0010  00C0     MOVWF __pdataBANK3
0011  0012     MOVIW FSR0++
0012  00C1     MOVWF 0x1C1
0013  0012     MOVIW FSR0++
0014  00C2     MOVWF 0x1C2
0015  0012     MOVIW FSR0++
0016  00C3     MOVWF 0x1C3
0017  0012     MOVIW FSR0++
0018  00C4     MOVWF 0x1C4
0019  0012     MOVIW FSR0++
001A  00C5     MOVWF 0x1C5
001B  0012     MOVIW FSR0++
001C  00C6     MOVWF 0x1C6
001D  0012     MOVIW FSR0++
001E  00C7     MOVWF 0x1C7
0872  0064     CLRWDT
0873  0180     CLRF INDF0
0874  3101     ADDFSR 0, 1
0875  3001     MOVLW 0x1
0876  02FE     SUBWF 0x1FE, F
0877  3000     MOVLW 0x0
0878  3BFF     SUBWFB 0x1FF, F
0879  087F     MOVF 0x1FF, W
087A  047E     IORWF 0x1FE, W
087B  1D03     BTFSS STATUS, 0x2
087C  2873     GOTO 0x73
087D  3400     RETLW 0x0
001F  30B0     MOVLW 0xB0
0020  0084     MOVWF FSR0L
0021  3000     MOVLW 0x0
0022  0085     MOVWF FSR0H
0023  3029     MOVLW 0x29
0024  00FE     MOVWF 0x1FE
0025  3000     MOVLW 0x0
0026  00FF     MOVWF 0x1FF
0027  3188     MOVLP 0x8
002A  3020     MOVLW 0x20
002B  0084     MOVWF FSR0L
002C  3001     MOVLW 0x1
002D  0085     MOVWF FSR0H
002E  3010     MOVLW 0x10
002F  00FE     MOVWF 0x1FE
0030  3000     MOVLW 0x0
0031  00FF     MOVWF 0x1FF
0032  3188     MOVLP 0x8
0035  30A0     MOVLW 0xA0
0036  0084     MOVWF FSR0L
0037  3001     MOVLW 0x1
0038  0085     MOVWF FSR0H
0039  3020     MOVLW 0x20
003A  00FE     MOVWF 0x1FE
003B  3000     MOVLW 0x0
003C  00FF     MOVWF 0x1FF
003D  3188     MOVLP 0x8
0040  107E     BCF 0x1FE, 0x0
0041  0020     MOVLB 0x0
0042  318A     MOVLP 0xA
