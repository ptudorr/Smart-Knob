Disassembly Listing for USB_Device_-_HID_-_Joystick
Generated From:
E:/Smart-Knob/pic16f1455_firmware/dist/LPCUSBDK_16F1455/production/pic16f1455_firmware.production.elf
Oct 25, 2022 9:50:43 PM

---  E:/Smart-Knob/pic16f1455_firmware/main.c  ----------------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #define _XTAL_FREQ 48000000
22:            #include "include/system.h"
23:            
24:            #include "include/usb/usb.h"
25:            #include "include/usb/usb_device_hid.h"
26:            
27:            #include "include/app_device_joystick.h"
28:            #include "include/app_led_usb_status.h"
29:            
30:            #include "include/spi.h"
31:            
32:            MAIN_RETURN main(void)
33:            {
34:                
35:                TRIS_MOSI_SDI_PIN = 1;TRIS_MISO_SDO_PIN = 0;
0918  0021     MOVLB 0x1
0919  148E     BSF TRISC, 0x1
091A  110E     BCF TRISC, 0x2
36:                //SYSTEM_Initialize(SYSTEM_STATE_USB_START);
37:                __delay_ms(200);
091B  300D     MOVLW 0xD
091C  0021     MOVLB 0x1
091D  00EE     MOVWF 0xEE
091E  302D     MOVLW 0x2D
091F  00ED     MOVWF 0xED
0920  30D7     MOVLW 0xD7
0921  0B89     DECFSZ WREG, F
0922  2921     GOTO 0x121
0923  0BED     DECFSZ 0xED, F
0924  2921     GOTO 0x121
0925  0BEE     DECFSZ 0xEE, F
0926  2921     GOTO 0x121
0927  3200     BRA 0x928
38:                
39:                MasterinitSPI();
0928  3197     MOVLP 0x17
0929  2758     CALL 0x758
092A  3189     MOVLP 0x9
40:                
41:                USBDeviceInit();
092B  3186     MOVLP 0x6
092C  26BC     CALL 0x6BC
092D  3189     MOVLP 0x9
42:                USBDeviceAttach();
43:            
44:                
45:                while(1)
46:                {
47:                    spiWrite();
092E  3188     MOVLP 0x8
092F  2099     CALL 0x99
0930  3189     MOVLP 0x9
48:                    SYSTEM_Tasks();
49:            
50:                    #if defined(USB_POLLING)
51:                        // Interrupt or polling method.  If using polling, must call
52:                        // this function periodically.  This function will take care
53:                        // of processing and responding to SETUP transactions
54:                        // (such as during the enumeration process when you first
55:                        // plug in).  USB hosts require that USB devices should accept
56:                        // and process SETUP packets in a timely fashion.  Therefore,
57:                        // when using polling, this function should be called
58:                        // regularly (such as once every 1.8ms or faster** [see
59:                        // inline code comments in usb_device.c for explanation when
60:                        // "or faster" applies])  In most cases, the USBDeviceTasks()
61:                        // function does not take very long to execute (ex: <100
62:                        // instruction cycles) before it returns.
63:                        USBDeviceTasks();
0931  3182     MOVLP 0x2
0932  22F1     CALL 0x2F1
0933  3189     MOVLP 0x9
64:                    #endif
65:            
66:                    // If the USB device isn't configured yet, we can't really do anything
67:                    // else since we don't have a host to talk to.  So jump back to the
68:                    // top of the while loop. 
69:                    if( USBGetDeviceState() < CONFIGURED_STATE )
0934  3020     MOVLW 0x20
0935  0021     MOVLB 0x1
0936  0253     SUBWF USBDeviceState, W
0937  1803     BTFSC STATUS, 0x0
0938  293A     GOTO 0x13A
0939  293B     GOTO 0x13B
093A  293C     GOTO 0x13C
093B  292E     GOTO 0x12E
70:                    {
71:                        // Jump back to the top of the while loop. 
72:                        continue;
73:                    }
74:            
75:                    // If we are currently suspended, then we need to see if we need to
76:                    // issue a remote wakeup.  In either case, we shouldn't process any
77:                    // keyboard commands since we aren't currently communicating to the host
78:                    // thus just continue back to the start of the while loop. 
79:                    if( USBIsDeviceSuspended() == true )
093C  003D     MOVLB 0x1D
093D  1C8E     BTFSS UCON, 0x1
093E  2940     GOTO 0x140
093F  2941     GOTO 0x141
0940  2942     GOTO 0x142
0941  292E     GOTO 0x12E
80:                    {
81:                        // Jump back to the top of the while loop. 
82:                        continue;
83:                    }
84:            
85:                    //Application specific tasks
86:                    APP_DeviceJoystickTasks();
0942  3186     MOVLP 0x6
0943  2601     CALL 0x601
0944  3189     MOVLP 0x9
0945  292E     GOTO 0x12E
0946  3180     MOVLP 0x0
87:                    
88:                    
89:                    //endfor
90:            
91:                }//end while
92:            }//end main
93:            
94:            /*******************************************************************************
95:             End of File
96:            */
97:            
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_events.c  --------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #include "include/system.h"
22:            
23:            #include "include/usb/usb.h"
24:            #include "include/usb/usb_device_hid.h"
25:            
26:            #include "include/app_device_joystick.h"
27:            #include "include/app_led_usb_status.h"
28:            
29:            /*******************************************************************
30:             * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
31:             *                        USB_EVENT event, void *pdata, uint16_t size)
32:             *
33:             * PreCondition:    None
34:             *
35:             * Input:           USB_EVENT event - the type of event
36:             *                  void *pdata - pointer to the event data
37:             *                  uint16_t size - size of the event data
38:             *
39:             * Output:          None
40:             *
41:             * Side Effects:    None
42:             *
43:             * Overview:        This function is called from the USB stack to
44:             *                  notify a user application that a USB event
45:             *                  occured.  This callback is in interrupt context
46:             *                  when the USB_INTERRUPT option is selected.
47:             *
48:             * Note:            None
49:             *******************************************************************/
50:            bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
51:            {
52:                switch( (int) event )
09C3  29E0     GOTO 0x1E0
53:                {
54:                    case EVENT_TRANSFER:
55:                        break;
56:            
57:                    case EVENT_SOF:
58:                        /* We are using the SOF as a timer to time the LED indicator.  Call
59:                         * the LED update function here. */
60:                        APP_LEDUpdateUSBStatus();
09C4  318B     MOVLP 0xB
09C5  2304     CALL 0x304
09C6  3189     MOVLP 0x9
61:                        break;
09C7  2A08     GOTO 0x208
62:            
63:                    case EVENT_SUSPEND:
64:                        /* Update the LED status for the suspend event. */
65:                        APP_LEDUpdateUSBStatus();
09C8  318B     MOVLP 0xB
09C9  2304     CALL 0x304
09CA  3189     MOVLP 0x9
66:            
67:                        //Call the hardware platform specific handler for suspend events for
68:                        //possible further action (like optionally going reconfiguring the application
69:                        //for lower power states and going to sleep during the suspend event).  This
70:                        //would normally be done in USB compliant bus powered applications, although
71:                        //no further processing is needed for purely self powered applications that
72:                        //don't consume power from the host.
73:                        SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND);
09CB  3001     MOVLW 0x1
09CC  3197     MOVLP 0x17
09CD  279C     CALL 0x79C
09CE  3189     MOVLP 0x9
74:                        break;
09CF  2A08     GOTO 0x208
75:            
76:                    case EVENT_RESUME:
77:                        /* Update the LED status for the resume event. */
78:                        APP_LEDUpdateUSBStatus();
09D0  318B     MOVLP 0xB
09D1  2304     CALL 0x304
09D2  3189     MOVLP 0x9
79:            
80:                        //Call the hardware platform specific resume from suspend handler (ex: to
81:                        //restore I/O pins to higher power states if they were changed during the 
82:                        //preceding SYSTEM_Initialize(SYSTEM_STATE_USB_SUSPEND) call at the start
83:                        //of the suspend condition.
84:                        SYSTEM_Initialize(SYSTEM_STATE_USB_RESUME);
09D3  3002     MOVLW 0x2
09D4  3197     MOVLP 0x17
09D5  279C     CALL 0x79C
09D6  3189     MOVLP 0x9
85:                        break;
09D7  2A08     GOTO 0x208
86:            
87:                    case EVENT_CONFIGURED:
88:                        /* When the device is configured, we can (re)initialize the demo
89:                         * code. */
90:                        APP_DeviceJoystickInitialize();
09D8  3197     MOVLP 0x17
09D9  27DE     CALL 0x7DE
09DA  3189     MOVLP 0x9
91:                        break;
09DB  2A08     GOTO 0x208
92:            
93:                    case EVENT_SET_DESCRIPTOR:
94:                        break;
95:            
96:                    case EVENT_EP0_REQUEST:
97:                        /* We have received a non-standard USB request.  The HID driver
98:                         * needs to check to see if the request was for it. */
99:                        USBCheckHIDRequest();
09DC  3184     MOVLP 0x4
09DD  2420     CALL 0x420
09DE  3189     MOVLP 0x9
100:                       break;
09DF  2A08     GOTO 0x208
101:           
102:                   case EVENT_BUS_ERROR:
103:                       break;
104:           
105:                   case EVENT_TRANSFER_TERMINATED:
106:                       break;
107:           
108:                   default:
109:                       break;
110:               }
09E0  0021     MOVLB 0x1
09E1  0859     MOVF 0xD9, W
09E2  3A00     XORLW 0x0
09E3  1903     BTFSC STATUS, 0x2
09E4  29E9     GOTO 0x1E9
09E5  3A7F     XORLW 0x7F
09E6  1903     BTFSC STATUS, 0x2
09E7  2A03     GOTO 0x203
09E8  2A08     GOTO 0x208
09E9  0858     MOVF __pcstackBANK1, W
09EA  3A01     XORLW 0x1
09EB  1903     BTFSC STATUS, 0x2
09EC  29D8     GOTO 0x1D8
09ED  3A03     XORLW 0x3
09EE  1903     BTFSC STATUS, 0x2
09EF  2A08     GOTO 0x208
09F0  3A01     XORLW 0x1
09F1  1903     BTFSC STATUS, 0x2
09F2  29DC     GOTO 0x1DC
09F3  3A06     XORLW 0x6
09F4  1903     BTFSC STATUS, 0x2
09F5  2A08     GOTO 0x208
09F6  3A77     XORLW 0x77
09F7  1903     BTFSC STATUS, 0x2
09F8  2A08     GOTO 0x208
09F9  3A01     XORLW 0x1
09FA  1903     BTFSC STATUS, 0x2
09FB  29C4     GOTO 0x1C4
09FC  3A07     XORLW 0x7
09FD  1903     BTFSC STATUS, 0x2
09FE  29D0     GOTO 0x1D0
09FF  3A01     XORLW 0x1
0A00  1903     BTFSC STATUS, 0x2
0A01  29C8     GOTO 0x1C8
0A02  2A08     GOTO 0x208
0A03  0858     MOVF __pcstackBANK1, W
0A04  3AFF     XORLW 0xFF
0A05  1903     BTFSC STATUS, 0x2
0A06  2A08     GOTO 0x208
0A07  2A08     GOTO 0x208
111:               return true;
112:           }
0A08  0008     RETURN
113:           
114:           
115:           /*******************************************************************************
116:            End of File
117:           */
118:           
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device_hid.c  ----------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Human Interface Device (HID) Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device_hid.c
30:            
31:              Summary:
32:                USB Device Human Interface Device (HID) Layer interface API.
33:            
34:              Description:
35:                USB Device Human Interface Device (HID) Layer interface API.
36:            *******************************************************************************/
37:            
38:            
39:            // *****************************************************************************
40:            // *****************************************************************************
41:            // Section: Included Files
42:            // *****************************************************************************
43:            // *****************************************************************************
44:            #include "include/usb/usb_config.h"
45:            #include "include/usb/usb.h"
46:            #include "include/usb/usb_device_hid.h"
47:            
48:            #if defined(__XC8)
49:                #define PACKED
50:                #define ALIGNED
51:            #else
52:                #define PACKED __attribute__((packed))
53:                #define ALIGNED __attribute__((aligned))
54:            #endif
55:            
56:            // *****************************************************************************
57:            // *****************************************************************************
58:            // Section: File Scope or Global Constants
59:            // *****************************************************************************
60:            // *****************************************************************************
61:            
62:            // *****************************************************************************
63:            // *****************************************************************************
64:            // Section: File Scope Data Types
65:            // *****************************************************************************
66:            // *****************************************************************************
67:            typedef struct PACKED
68:            {
69:                unsigned :8;
70:                unsigned :8;
71:                uint8_t reportId;
72:                uint8_t duration;
73:            } USB_SETUP_SET_IDLE_RATE;
74:            
75:            typedef struct PACKED
76:            {
77:                unsigned :8;
78:                unsigned :8;
79:                uint8_t protocol;
80:            } USB_SETUP_SET_PROTOCOL;
81:            
82:            // *****************************************************************************
83:            // *****************************************************************************
84:            // Section: Variables
85:            // *****************************************************************************
86:            // *****************************************************************************
87:            static uint8_t idle_rate;
88:            static uint8_t active_protocol;   // [0] Boot Protocol [1] Report Protocol
89:            
90:            extern const struct{uint8_t report[HAPTIC_RPT_SIZE];}HAPTIC_rpt;
91:            extern const struct{uint8_t report[LED_RPT_SIZE];}LED_rpt;
92:            extern const struct{uint8_t report[DISPLAY_RPT_SIZE];}DISPLAY_rpt;
93:            
94:            // *****************************************************************************
95:            // *****************************************************************************
96:            // Section: Prototypes
97:            // *****************************************************************************
98:            // *****************************************************************************
99:            #if defined USER_GET_REPORT_HANDLER
100:               void USER_GET_REPORT_HANDLER(void);
101:           #endif
102:           
103:           #if defined USER_SET_REPORT_HANDLER
104:               extern void USER_SET_REPORT_HANDLER(void);
105:           #endif
106:           
107:           // *****************************************************************************
108:           // *****************************************************************************
109:           // Section: Macros or Functions
110:           // *****************************************************************************
111:           // *****************************************************************************
112:           
113:           //To implement a set idle rate callback function in the application,
114:           //Make sure "#define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportID, newIdleRate)    USBHIDCBSetIdleRateHandler(reportID, newIdleRate)"
115:           //is placed in your usb_config.h file, and then in your application .c file,
116:           //add the void USBHIDCBSetIdleRateHandler(reportID, newIdleRate) function
117:           //implementation that saves the new idle rate and report ID info, so that it
118:           //gets used later when sending subsequent HID input report packets to the host.
119:           #ifndef USB_DEVICE_HID_IDLE_RATE_CALLBACK
120:               #define USB_DEVICE_HID_IDLE_RATE_CALLBACK(reportId, idleRate)
121:           #else
122:               extern void USB_DEVICE_HID_IDLE_RATE_CALLBACK(uint8_t reportId, uint8_t idleRate);
123:           #endif
124:           
125:           /********************************************************************
126:           	Function:
127:           		void USBCheckHIDRequest(void)
128:           
129:            	Summary:
130:            		This routine handles HID specific request that happen on EP0.
131:                   This function should be called from the USBCBCheckOtherReq() call back
132:                   function whenever implementing a HID device.
133:           
134:            	Description:
135:            		This routine handles HID specific request that happen on EP0.  These
136:                   include, but are not limited to, requests for the HID report
137:                   descriptors.  This function should be called from the
138:                   USBCBCheckOtherReq() call back function whenever using an HID device.
139:           
140:                   Typical Usage:
141:                   <code>
142:                   void USBCBCheckOtherReq(void)
143:                   {
144:                       //Since the stack didn't handle the request I need to check
145:                       //  my class drivers to see if it is for them
146:                       USBCheckHIDRequest();
147:                   }
148:                   </code>
149:           
150:           	PreCondition:
151:           		None
152:           
153:           	Parameters:
154:           		None
155:           
156:           	Return Values:
157:           		None
158:           
159:           	Remarks:
160:           		None
161:           
162:            *******************************************************************/
163:           void USBCheckHIDRequest(void)
164:           {
165:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD) return;
0420  0020     MOVLB 0x0
0421  0860     MOVF SetupPkt, W
0422  391F     ANDLW 0x1F
0423  3A01     XORLW 0x1
0424  1903     BTFSC STATUS, 0x2
0425  2C27     GOTO 0x427
0426  2C28     GOTO 0x428
0427  2C29     GOTO 0x429
0428  2D36     GOTO 0x536
166:               if(SetupPkt.bIntfID != HID_INTF_HAP_ID && SetupPkt.bIntfID != HID_INTF_LED_ID && SetupPkt.bIntfID != HID_INTF_DSP_ID ) return;
0429  0864     MOVF 0x64, W
042A  1903     BTFSC STATUS, 0x2
042B  2C2D     GOTO 0x42D
042C  2C2E     GOTO 0x42E
042D  2C3A     GOTO 0x43A
042E  0364     DECF 0x64, W
042F  1903     BTFSC STATUS, 0x2
0430  2C32     GOTO 0x432
0431  2C33     GOTO 0x433
0432  2C3A     GOTO 0x43A
0433  3002     MOVLW 0x2
0434  0664     XORWF 0x64, W
0435  1903     BTFSC STATUS, 0x2
0436  2C38     GOTO 0x438
0437  2C39     GOTO 0x439
0438  2C3A     GOTO 0x43A
0439  2D36     GOTO 0x536
167:           
168:               /*
169:                * There are two standard requests that hid.c may support.
170:                * 1. GET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
171:                * 2. SET_DSC(DSC_HID,DSC_RPT,DSC_PHY);
172:                */
173:               if(SetupPkt.bRequest == USB_REQUEST_GET_DESCRIPTOR)
043A  3006     MOVLW 0x6
043B  0661     XORWF 0x61, W
043C  1D03     BTFSS STATUS, 0x2
043D  2C3F     GOTO 0x43F
043E  2C40     GOTO 0x440
043F  2CDC     GOTO 0x4DC
0440  2CC9     GOTO 0x4C9
174:               {
175:                   switch(SetupPkt.bDescriptorType)
176:                   {
177:                       case DSC_HID: //HID Descriptor
178:                           if(USBActiveConfiguration == 1)
0441  0021     MOVLB 0x1
0442  0357     DECF USBActiveConfiguration, W
0443  1D03     BTFSS STATUS, 0x2
0444  2C46     GOTO 0x446
0445  2C47     GOTO 0x447
0446  2CDC     GOTO 0x4DC
179:                           {
180:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
0447  0020     MOVLB 0x0
0448  0864     MOVF 0x64, W
0449  0465     IORWF 0x65, W
044A  1D03     BTFSS STATUS, 0x2
044B  2C4D     GOTO 0x44D
044C  2C4E     GOTO 0x44E
044D  2C5B     GOTO 0x45B
181:                                   USBEP0SendROMPtr(
044E  3012     MOVLW 0x12
044F  0021     MOVLB 0x1
0450  00B8     MOVWF inPipes
0451  3090     MOVLW 0x90
0452  00B9     MOVWF 0xB9
0453  3009     MOVLW 0x9
0454  00BB     MOVWF 0xBB
0455  3000     MOVLW 0x0
0456  00BC     MOVWF 0xBC
0457  30C0     MOVLW 0xC0
0458  00F0     MOVWF 0xF0
0459  0870     MOVF 0xF0, W
045A  00BA     MOVWF 0xBA
182:                                       (const uint8_t*)&configDescriptor1 + 18,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
183:                                       sizeof(USB_HID_DSC)+3,
184:                                       USB_EP0_INCLUDE_ZERO);
185:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
045B  0020     MOVLB 0x0
045C  0364     DECF 0x64, W
045D  0465     IORWF 0x65, W
045E  1D03     BTFSS STATUS, 0x2
045F  2C61     GOTO 0x461
0460  2C62     GOTO 0x462
0461  2C6F     GOTO 0x46F
186:                                   USBEP0SendROMPtr(
0462  3032     MOVLW 0x32
0463  0021     MOVLB 0x1
0464  00B8     MOVWF inPipes
0465  3090     MOVLW 0x90
0466  00B9     MOVWF 0xB9
0467  3009     MOVLW 0x9
0468  00BB     MOVWF 0xBB
0469  3000     MOVLW 0x0
046A  00BC     MOVWF 0xBC
046B  30C0     MOVLW 0xC0
046C  00F0     MOVWF 0xF0
046D  0870     MOVF 0xF0, W
046E  00BA     MOVWF 0xBA
187:                                       (const uint8_t*)&configDescriptor1 + 50,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
188:                                       sizeof(USB_HID_DSC)+3,
189:                                       USB_EP0_INCLUDE_ZERO);
190:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
046F  3002     MOVLW 0x2
0470  0020     MOVLB 0x0
0471  0664     XORWF 0x64, W
0472  0465     IORWF 0x65, W
0473  1D03     BTFSS STATUS, 0x2
0474  2C76     GOTO 0x476
0475  2C77     GOTO 0x477
0476  2CDC     GOTO 0x4DC
191:                                   USBEP0SendROMPtr(
0477  3052     MOVLW 0x52
0478  0021     MOVLB 0x1
0479  00B8     MOVWF inPipes
047A  3090     MOVLW 0x90
047B  00B9     MOVWF 0xB9
047C  3009     MOVLW 0x9
047D  00BB     MOVWF 0xBB
047E  3000     MOVLW 0x0
047F  00BC     MOVWF 0xBC
0480  30C0     MOVLW 0xC0
0481  00F0     MOVWF 0xF0
0482  0870     MOVF 0xF0, W
0483  00BA     MOVWF 0xBA
0484  2CDC     GOTO 0x4DC
192:                                       (const uint8_t*)&configDescriptor1 + 82,		//18 is a magic number.  It is the offset from start of the configuration descriptor to the start of the HID descriptor.
193:                                       sizeof(USB_HID_DSC)+3,
194:                                       USB_EP0_INCLUDE_ZERO);
195:                           }
196:                           break;
197:                       case DSC_RPT:  //Report Descriptor
198:                           if(USBActiveConfiguration == 1)
0485  0021     MOVLB 0x1
0486  0357     DECF USBActiveConfiguration, W
0487  1D03     BTFSS STATUS, 0x2
0488  2C8A     GOTO 0x48A
0489  2C8B     GOTO 0x48B
048A  2CDC     GOTO 0x4DC
199:                           {
200:                               if(SetupPkt.wIndex == HID_INTF_HAP_ID)
048B  0020     MOVLB 0x0
048C  0864     MOVF 0x64, W
048D  0465     IORWF 0x65, W
048E  1D03     BTFSS STATUS, 0x2
048F  2C91     GOTO 0x491
0490  2C92     GOTO 0x492
0491  2C9F     GOTO 0x49F
201:                                   USBEP0SendROMPtr(
0492  3069     MOVLW 0x69
0493  0021     MOVLB 0x1
0494  00B8     MOVWF inPipes
0495  3090     MOVLW 0x90
0496  00B9     MOVWF 0xB9
0497  3057     MOVLW 0x57
0498  00BB     MOVWF 0xBB
0499  3000     MOVLW 0x0
049A  00BC     MOVWF 0xBC
049B  30C0     MOVLW 0xC0
049C  00F0     MOVWF 0xF0
049D  0870     MOVF 0xF0, W
049E  00BA     MOVWF 0xBA
202:                                       (const uint8_t*)&HAPTIC_rpt,
203:                                       HAPTIC_RPT_SIZE,     //See usbcfg.h
204:                                       USB_EP0_INCLUDE_ZERO);
205:                               
206:                               if(SetupPkt.wIndex == HID_INTF_LED_ID)
049F  0020     MOVLB 0x0
04A0  0364     DECF 0x64, W
04A1  0465     IORWF 0x65, W
04A2  1D03     BTFSS STATUS, 0x2
04A3  2CA5     GOTO 0x4A5
04A4  2CA6     GOTO 0x4A6
04A5  2CB3     GOTO 0x4B3
207:                                   USBEP0SendROMPtr(
04A6  3000     MOVLW 0x0
04A7  0021     MOVLB 0x1
04A8  00B8     MOVWF inPipes
04A9  3098     MOVLW 0x98
04AA  00B9     MOVWF 0xB9
04AB  301C     MOVLW 0x1C
04AC  00BB     MOVWF 0xBB
04AD  3000     MOVLW 0x0
04AE  00BC     MOVWF 0xBC
04AF  30C0     MOVLW 0xC0
04B0  00F0     MOVWF 0xF0
04B1  0870     MOVF 0xF0, W
04B2  00BA     MOVWF 0xBA
208:                                       (const uint8_t*)&LED_rpt,
209:                                       LED_RPT_SIZE,     //See usbcfg.h
210:                                       USB_EP0_INCLUDE_ZERO);
211:                               
212:                               if(SetupPkt.wIndex == HID_INTF_DSP_ID)
04B3  3002     MOVLW 0x2
04B4  0020     MOVLB 0x0
04B5  0664     XORWF 0x64, W
04B6  0465     IORWF 0x65, W
04B7  1D03     BTFSS STATUS, 0x2
04B8  2CBA     GOTO 0x4BA
04B9  2CBB     GOTO 0x4BB
04BA  2CDC     GOTO 0x4DC
213:                                   USBEP0SendROMPtr(
04BB  3038     MOVLW 0x38
04BC  0021     MOVLB 0x1
04BD  00B8     MOVWF inPipes
04BE  3098     MOVLW 0x98
04BF  00B9     MOVWF 0xB9
04C0  301C     MOVLW 0x1C
04C1  00BB     MOVWF 0xBB
04C2  3000     MOVLW 0x0
04C3  00BC     MOVWF 0xBC
04C4  30C0     MOVLW 0xC0
04C5  00F0     MOVWF 0xF0
04C6  0870     MOVF 0xF0, W
04C7  00BA     MOVWF 0xBA
04C8  2CDC     GOTO 0x4DC
214:                                       (const uint8_t*)&DISPLAY_rpt,
215:                                       LED_RPT_SIZE,     //See usbcfg.h
216:                                       USB_EP0_INCLUDE_ZERO);
217:                           }
218:                           break;
219:                       case DSC_PHY:  //Physical Descriptor
220:           				//Note: The below placeholder code is commented out.  HID Physical Descriptors are optional and are not used
221:           				//in many types of HID applications.  If an application does not have a physical descriptor,
222:           				//then the device should return STALL in response to this request (stack will do this automatically
223:           				//if no-one claims ownership of the control transfer).
224:           				//If an application does implement a physical descriptor, then make sure to declare
225:           				//hid_phy01 (rom structure containing the descriptor data), and hid_phy01 (the size of the descriptors in uint8_ts),
226:           				//and then uncomment the below code.
227:                           //if(USBActiveConfiguration == 1)
228:                           //{
229:                           //    USBEP0SendROMPtr((const uint8_t*)&hid_phy01, sizeof(hid_phy01), USB_EP0_INCLUDE_ZERO);
230:                           //}
231:                           break;
232:                   }//end switch(SetupPkt.bDescriptorType)
04C9  0863     MOVF p, W
04CA  00F0     MOVWF 0xF0
04CB  01F1     CLRF 0xF1
04CC  0871     MOVF 0xF1, W
04CD  3A00     XORLW 0x0
04CE  1903     BTFSC STATUS, 0x2
04CF  2CD1     GOTO 0x4D1
04D0  2CDC     GOTO 0x4DC
04D1  0870     MOVF 0xF0, W
04D2  3A21     XORLW 0x21
04D3  1903     BTFSC STATUS, 0x2
04D4  2C41     GOTO 0x441
04D5  3A03     XORLW 0x3
04D6  1903     BTFSC STATUS, 0x2
04D7  2C85     GOTO 0x485
04D8  3A01     XORLW 0x1
04D9  1903     BTFSC STATUS, 0x2
04DA  2CDC     GOTO 0x4DC
04DB  2CDC     GOTO 0x4DC
233:               }//end if(SetupPkt.bRequest == GET_DSC)
234:           
235:               if(SetupPkt.RequestType != USB_SETUP_TYPE_CLASS_BITFIELD)
04DC  0020     MOVLB 0x0
04DD  0E60     SWAPF SetupPkt, W
04DE  0C89     RRF WREG, F
04DF  3903     ANDLW 0x3
04E0  3A01     XORLW 0x1
04E1  1903     BTFSC STATUS, 0x2
04E2  2CE4     GOTO 0x4E4
04E3  2CE5     GOTO 0x4E5
04E4  2D1A     GOTO 0x51A
04E5  2D36     GOTO 0x536
236:               {
237:                   return;
238:               }
239:           
240:               switch(SetupPkt.bRequest)
241:               {
242:                   case GET_REPORT:
243:                       #if defined USER_GET_REPORT_HANDLER
244:                           USER_GET_REPORT_HANDLER();
245:                       #endif
246:                       break;
247:                   case SET_REPORT:
248:                       #if defined USER_SET_REPORT_HANDLER
249:                           USER_SET_REPORT_HANDLER();
250:                       #endif
251:                       break;
252:                   case GET_IDLE:
253:                       USBEP0SendRAMPtr(
04E6  30D5     MOVLW 0xD5
04E7  0021     MOVLB 0x1
04E8  00B8     MOVWF inPipes
04E9  3000     MOVLW 0x0
04EA  00B9     MOVWF 0xB9
04EB  3001     MOVLW 0x1
04EC  00BB     MOVWF 0xBB
04ED  3000     MOVLW 0x0
04EE  00BC     MOVWF 0xBC
04EF  30C1     MOVLW 0xC1
04F0  00F0     MOVWF 0xF0
04F1  0870     MOVF 0xF0, W
04F2  00BA     MOVWF 0xBA
254:                           (uint8_t*)&idle_rate,
255:                           1,
256:                           USB_EP0_INCLUDE_ZERO);
257:                       break;
04F3  2D36     GOTO 0x536
258:                   case SET_IDLE:
259:                       USBEP0Transmit(USB_EP0_NO_DATA);
04F4  3080     MOVLW 0x80
04F5  00F0     MOVWF 0xF0
04F6  0870     MOVF 0xF0, W
04F7  0021     MOVLB 0x1
04F8  00BA     MOVWF 0xBA
260:                       idle_rate = SetupPkt.W_Value.byte.HB;
04F9  0020     MOVLB 0x0
04FA  0863     MOVF 0x63, W
04FB  00F0     MOVWF __pcstackCOMMON
04FC  0870     MOVF __pcstackCOMMON, W
04FD  0021     MOVLB 0x1
04FE  00D5     MOVWF idle_rate
261:                       USB_DEVICE_HID_IDLE_RATE_CALLBACK(SetupPkt.W_Value.byte.LB, idle_rate);
262:                       break;
04FF  2D36     GOTO 0x536
263:                   case GET_PROTOCOL:
264:                       USBEP0SendRAMPtr(
0500  30D4     MOVLW 0xD4
0501  0021     MOVLB 0x1
0502  00B8     MOVWF inPipes
0503  3000     MOVLW 0x0
0504  00B9     MOVWF 0xB9
0505  3001     MOVLW 0x1
0506  00BB     MOVWF 0xBB
0507  3000     MOVLW 0x0
0508  00BC     MOVWF 0xBC
0509  3081     MOVLW 0x81
050A  00F0     MOVWF 0xF0
050B  0870     MOVF 0xF0, W
050C  00BA     MOVWF 0xBA
265:                           (uint8_t*)&active_protocol,
266:                           1,
267:                           USB_EP0_NO_OPTIONS);
268:                       break;
050D  2D36     GOTO 0x536
269:                   case SET_PROTOCOL:
270:                       USBEP0Transmit(USB_EP0_NO_DATA);
050E  3080     MOVLW 0x80
050F  00F0     MOVWF 0xF0
0510  0870     MOVF 0xF0, W
0511  0021     MOVLB 0x1
0512  00BA     MOVWF 0xBA
271:                       active_protocol = SetupPkt.W_Value.byte.LB;
0513  0020     MOVLB 0x0
0514  0862     MOVF 0x62, W
0515  00F0     MOVWF __pcstackCOMMON
0516  0870     MOVF __pcstackCOMMON, W
0517  0021     MOVLB 0x1
0518  00D4     MOVWF active_protocol
272:                       break;
0519  2D36     GOTO 0x536
273:               }//end switch(SetupPkt.bRequest)
051A  0861     MOVF i, W
051B  00F0     MOVWF 0xF0
051C  01F1     CLRF 0xF1
051D  0871     MOVF 0xF1, W
051E  3A00     XORLW 0x0
051F  1903     BTFSC STATUS, 0x2
0520  2D22     GOTO 0x522
0521  2D36     GOTO 0x536
0522  0870     MOVF 0xF0, W
0523  3A01     XORLW 0x1
0524  1903     BTFSC STATUS, 0x2
0525  2D36     GOTO 0x536
0526  3A03     XORLW 0x3
0527  1903     BTFSC STATUS, 0x2
0528  2CE6     GOTO 0x4E6
0529  3A01     XORLW 0x1
052A  1903     BTFSC STATUS, 0x2
052B  2D00     GOTO 0x500
052C  3A0A     XORLW 0xA
052D  1903     BTFSC STATUS, 0x2
052E  2D36     GOTO 0x536
052F  3A03     XORLW 0x3
0530  1903     BTFSC STATUS, 0x2
0531  2CF4     GOTO 0x4F4
0532  3A01     XORLW 0x1
0533  1903     BTFSC STATUS, 0x2
0534  2D0E     GOTO 0x50E
0535  2D36     GOTO 0x536
274:           
275:           }//end USBCheckHIDRequest
0536  0008     RETURN
276:           
277:           /********************************************************************
278:               Function:
279:                   USB_HANDLE HIDTxPacket(uint8_t ep, uint8_t* data, uint16_t len)
280:           
281:               Summary:
282:                   Sends the specified data out the specified endpoint
283:           
284:               Description:
285:                   This function sends the specified data out the specified
286:                   endpoint and returns a handle to the transfer information.
287:           
288:                   Typical Usage:
289:                   <code>
290:                   //make sure that the last transfer isn't busy by checking the handle
291:                   if(!HIDTxHandleBusy(USBInHandle))
292:                   {
293:                       //Send the data contained in the ToSendDataBuffer[] array out on
294:                       //  endpoint HID_EP
295:                       USBInHandle = HIDTxPacket(HID_EP,(uint8_t*)&ToSendDataBuffer[0],sizeof(ToSendDataBuffer));
296:                   }
297:                   </code>
298:           
299:               PreCondition:
300:                   None
301:           
302:               Parameters:
303:                   uint8_t ep    - the endpoint you want to send the data out of
304:                   uint8_t* data - pointer to the data that you wish to send
305:                   uint16_t len   - the length of the data that you wish to send
306:           
307:               Return Values:
308:                   USB_HANDLE - a handle for the transfer.  This information
309:                   should be kept to track the status of the transfer
310:           
311:               Remarks:
312:                   None
313:           
314:            *******************************************************************/
315:            // Implemented as a macro. See usb_function_hid.h
316:           
317:           /********************************************************************
318:               Function:
319:                   USB_HANDLE HIDRxPacket(uint8_t ep, uint8_t* data, uint16_t len)
320:           
321:               Summary:
322:                   Receives the specified data out the specified endpoint
323:           
324:               Description:
325:                   Receives the specified data out the specified endpoint.
326:           
327:                   Typical Usage:
328:                   <code>
329:                   //Read 64-uint8_ts from endpoint HID_EP, into the ReceivedDataBuffer array.
330:                   //  Make sure to save the return handle so that we can check it later
331:                   //  to determine when the transfer is complete.
332:                   USBOutHandle = HIDRxPacket(HID_EP,(uint8_t*)&ReceivedDataBuffer,64);
333:                   </code>
334:           
335:               PreCondition:
336:                   None
337:           
338:               Parameters:
339:                   uint8_t ep    - the endpoint you want to receive the data into
340:                   uint8_t* data - pointer to where the data will go when it arrives
341:                   uint16_t len   - the length of the data that you wish to receive
342:           
343:               Return Values:
344:                   USB_HANDLE - a handle for the transfer.  This information
345:                   should be kept to track the status of the transfer
346:           
347:               Remarks:
348:                   None
349:           
350:            *******************************************************************/
351:             // Implemented as a macro. See usb_function_hid.h
352:           
353:           /*******************************************************************************
354:            End of File
355:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/usb/usb_device.c  --------------------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license),
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <xc.h>
46:            
47:            #include <stdint.h>
48:            #include <stddef.h>
49:            #include <string.h>
50:            
51:            #include "include/usb/usb_config.h"
52:            
53:            #include "include/usb/usb.h"
54:            #include "include/usb/usb_ch9.h"
55:            #include "include/usb/usb_device.h"
56:            #include "include/usb/usb_device_local.h"
57:            
58:            #ifndef uintptr_t
59:                #if  defined(__XC8__) || defined(__XC16__)
60:                    #define uintptr_t uint16_t
61:                #elif defined (__XC32__)
62:                    #define uintptr_t uint32_t
63:                #endif
64:            #endif
65:            
66:            #if defined(USB_USE_MSD)
67:                #include "usb_device_msd.h"
68:            #endif
69:            
70:            // *****************************************************************************
71:            // *****************************************************************************
72:            // Section: File Scope or Global Constants
73:            // *****************************************************************************
74:            // *****************************************************************************
75:            #if !defined(USE_USB_BUS_SENSE_IO)
76:                //Assume the +5V VBUS is always present (like it would be in a bus powered
77:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
78:                //been properly defined elsewhere in the project.
79:                #undef USB_BUS_SENSE
80:                #define USB_BUS_SENSE 1
81:            #endif
82:            
83:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
84:                #define _DTS_CHECKING_ENABLED 0
85:            #else
86:                #define _DTS_CHECKING_ENABLED _DTSEN
87:            #endif
88:            
89:            #if !defined(self_power)
90:                //Assume the application is always bus powered, unless self_power has been
91:                //defined elsewhere in the project
92:                #define self_power 0    //0 = bus powered
93:            #endif
94:            
95:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
96:                //Assume the application only implements one configuration descriptor,
97:                //unless otherwise specified elsewhere in the project
98:                #define USB_MAX_NUM_CONFIG_DSC      1
99:            #endif
100:           
101:           #if defined(__XC8)
102:               //Suppress expected/harmless compiler warning message about unused RAM variables
103:               //and certain function pointer usage.
104:               //Certain variables and function pointers are not used if you don't use all
105:               //of the USB stack APIs.  However, these variables should not be
106:               //removed (since they are still used/needed in some applications, and this
107:               //is a common file shared by many projects, some of which rely on the "unused"
108:               //variables/function pointers).
109:               #pragma warning disable 1090
110:               #if __XC8_VERSION > 1300
111:                   #pragma warning disable 1471
112:               #endif
113:           #endif
114:           
115:           // *****************************************************************************
116:           // *****************************************************************************
117:           // Section: File Scope Data Types
118:           // *****************************************************************************
119:           // *****************************************************************************
120:           typedef union
121:           {
122:               uint8_t Val;
123:               struct __PACKED
124:               {
125:                   unsigned b0:1;
126:                   unsigned b1:1;
127:                   unsigned b2:1;
128:                   unsigned b3:1;
129:                   unsigned b4:1;
130:                   unsigned b5:1;
131:                   unsigned b6:1;
132:                   unsigned b7:1;
133:               } bits;
134:           } uint8_t_VAL, uint8_t_BITS;
135:           
136:           // *****************************************************************************
137:           // *****************************************************************************
138:           // Section: Variables
139:           // *****************************************************************************
140:           // *****************************************************************************
141:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
142:           USB_VOLATILE uint8_t USBActiveConfiguration;
143:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
144:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
145:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
146:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
147:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
148:           USB_VOLATILE uint8_t shortPacketStatus;
149:           USB_VOLATILE uint8_t controlTransferState;
150:           USB_VOLATILE IN_PIPE inPipes[1];
151:           USB_VOLATILE OUT_PIPE outPipes[1];
152:           USB_VOLATILE uint8_t *pDst;
153:           USB_VOLATILE bool RemoteWakeup;
154:           USB_VOLATILE bool USBBusIsSuspended;
155:           USB_VOLATILE USTAT_FIELDS USTATcopy;
156:           USB_VOLATILE uint8_t endpoint_number;
157:           USB_VOLATILE bool BothEP0OutUOWNsSet;
158:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
159:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
160:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
161:           volatile bool USBDeferStatusStagePacket;
162:           volatile bool USBStatusStageEnabledFlag1;
163:           volatile bool USBStatusStageEnabledFlag2;
164:           volatile bool USBDeferINDataStagePackets;
165:           volatile bool USBDeferOUTDataStagePackets;
166:           USB_VOLATILE uint32_t USB1msTickCount;
167:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
168:           
169:           /** USB FIXED LOCATION VARIABLES ***********************************/
170:           #if defined(COMPILER_MPLAB_C18)
171:               #pragma udata USB_BDT=USB_BDT_ADDRESS
172:           #endif
173:           
174:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
175:           
176:           /********************************************************************
177:            * EP0 Buffer Space
178:            *******************************************************************/
179:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
180:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
181:           
182:           /********************************************************************
183:            * non-EP0 Buffer Space
184:            *******************************************************************/
185:           #if defined(USB_USE_MSD)
186:               //Check if the MSD application specific USB endpoint buffer placement address
187:               //macros have already been defined or not (ex: in a processor specific header)
188:               //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
189:               //must be at a certain address range on certain microcontrollers).
190:               #if !defined(MSD_CBW_ADDR_TAG)
191:                   //Not previously defined.  Assume in this case all microcontroller RAM is
192:                   //USB module accessible, and therefore, no specific address tag value is needed.
193:                   #define MSD_CBW_ADDR_TAG
194:                   #define MSD_CSW_ADDR_TAG
195:               #endif
196:           	volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
197:           	volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
198:           
199:               #if defined(__18CXX) || defined(__XC8)
200:                   #if(__XC8_VERSION < 2000)
201:                   volatile char msd_buffer[512] @ MSD_BUFFER_ADDRESS;
202:                   #else
203:                       volatile char msd_buffer[512] __at(MSD_BUFFER_ADDRESS);
204:                   #endif
205:               #else
206:                   volatile char msd_buffer[512];
207:           	#endif
208:           #endif
209:           
210:           //Depricated in v2.2 - will be removed in a future revision
211:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
212:               //Device descriptor
213:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
214:           #else
215:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
216:           #endif
217:           
218:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
219:               //Array of configuration descriptors
220:               extern const uint8_t *const USB_CD_Ptr[];
221:           #else
222:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
223:           #endif
224:           
225:           extern const uint8_t *const USB_SD_Ptr[];
226:           
227:           
228:           // *****************************************************************************
229:           // *****************************************************************************
230:           // Section: Private and External Prototypes
231:           // *****************************************************************************
232:           // *****************************************************************************
233:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
234:           
235:           static void USBCtrlEPService(void);
236:           static void USBCtrlTrfSetupHandler(void);
237:           static void USBCtrlTrfInHandler(void);
238:           static void USBCheckStdRequest(void);
239:           static void USBStdGetDscHandler(void);
240:           static void USBCtrlEPServiceComplete(void);
241:           static void USBCtrlTrfTxService(void);
242:           static void USBCtrlTrfRxService(void);
243:           static void USBStdSetCfgHandler(void);
244:           static void USBStdGetStatusHandler(void);
245:           static void USBStdFeatureReqHandler(void);
246:           static void USBCtrlTrfOutHandler(void);
247:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
248:           static void USBWakeFromSuspend(void);
249:           static void USBSuspend(void);
250:           static void USBStallHandler(void);
251:           
252:           // *****************************************************************************
253:           // *****************************************************************************
254:           // Section: Macros or Functions
255:           // *****************************************************************************
256:           // *****************************************************************************
257:           
258:           /**************************************************************************
259:               Function:
260:                   void USBDeviceInit(void)
261:           
262:               Description:
263:                   This function initializes the device stack it in the default state. The
264:                   USB module will be completely reset including all of the internal
265:                   variables, registers, and interrupt flags.
266:           
267:               Precondition:
268:                   This function must be called before any of the other USB Device
269:                   functions can be called, including USBDeviceTasks().
270:           
271:               Parameters:
272:                   None
273:           
274:               Return Values:
275:                   None
276:           
277:               Remarks:
278:                   None
279:           
280:             ***************************************************************************/
281:           void USBDeviceInit(void)
282:           {
283:               uint8_t i;
284:           
285:               USBDisableInterrupts();
06BC  0021     MOVLB 0x1
06BD  1112     BCF PIE2, 0x2
286:           
287:               //Make sure that if a GPIO output driver exists on VBUS, that it is
288:               //tri-stated to avoid potential contention with the host
289:               USB_HAL_VBUSTristate();
290:           
291:               // Clear all USB error flags
292:               USBClearInterruptRegister(U1EIR);
06BE  003D     MOVLB 0x1D
06BF  0193     CLRF UEIR
293:           
294:               // Clears all USB interrupts
295:               USBClearInterruptRegister(U1IR);
06C0  0190     CLRF UIR
296:           
297:               //Clear all of the endpoint control registers
298:               U1EP0 = 0;
06C1  0198     CLRF UEP0
299:           
300:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
06C2  300E     MOVLW 0xE
06C3  00F2     MOVWF 0xEF2
06C4  3099     MOVLW 0x99
06C5  00F1     MOVWF 0xEF1
06C6  01F3     CLRF 0xEF3
06C7  0871     MOVF 0xEF1, W
06C8  0086     MOVWF FSR1L
06C9  0872     MOVF 0xEF2, W
06CA  0087     MOVWF FSR1H
06CB  0181     CLRF INDF1
06CC  3001     MOVLW 0x1
06CD  07F1     ADDWF 0xEF1, F
06CE  3000     MOVLW 0x0
06CF  3DF2     ADDWFC 0xEF2, F
06D0  3001     MOVLW 0x1
06D1  00F0     MOVWF 0xEF0
06D2  0870     MOVF 0xEF0, W
06D3  07F3     ADDWF 0xEF3, F
06D4  3003     MOVLW 0x3
06D5  0273     SUBWF 0xEF3, W
06D6  1C03     BTFSS STATUS, 0x0
06D7  2ED9     GOTO 0x6D9
06D8  2EDA     GOTO 0x6DA
06D9  2EC7     GOTO 0x6C7
301:           
302:               SetConfigurationOptions();
06DA  3016     MOVLW 0x16
06DB  003D     MOVLB 0x1D
06DC  0091     MOVWF UCFG
06DD  309F     MOVLW 0x9F
06DE  0097     MOVWF UEIE
06DF  307B     MOVLW 0x7B
06E0  0092     MOVWF UIE
303:           
304:               //power up the module (if not already powered)
305:               USBPowerModule();
306:           
307:               //set the address of the BDT (if applicable)
308:               USBSetBDTAddress(BDT);
309:           
310:               //Clear all of the BDT entries
311:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
06E1  01F4     CLRF 0xEF4
312:               {
313:                   BDT[i].Val = 0x00;
06E2  0874     MOVF 0xEF4, W
06E3  00F0     MOVWF 0xEF0
06E4  3001     MOVLW 0x1
06E5  35F0     LSLF 0xEF0, F
06E6  3EFF     ADDLW 0xFF
06E7  1D03     BTFSS STATUS, 0x2
06E8  2EE5     GOTO 0x6E5
06E9  3570     LSLF 0xEF0, W
06EA  3E20     ADDLW 0x20
06EB  0086     MOVWF FSR1L
06EC  0187     CLRF FSR1H
06ED  3000     MOVLW 0x0
06EE  3FC0     MOVWI 0[FSR1]
06EF  3000     MOVLW 0x0
06F0  3FC1     MOVWI 1[FSR1]
06F1  3FC2     MOVWI 2[FSR1]
06F2  3FC3     MOVWI 3[FSR1]
314:               }
06F3  3001     MOVLW 0x1
06F4  00F0     MOVWF 0xEF0
06F5  0870     MOVF 0xEF0, W
06F6  07F4     ADDWF 0xEF4, F
06F7  3010     MOVLW 0x10
06F8  0274     SUBWF 0xEF4, W
06F9  1C03     BTFSS STATUS, 0x0
06FA  2EFC     GOTO 0x6FC
06FB  2EFD     GOTO 0x6FD
06FC  2EE2     GOTO 0x6E2
315:           
316:               // Assert reset request to all of the Ping Pong buffer pointers
317:               USBPingPongBufferReset = 1;
06FD  003D     MOVLB 0x1D
06FE  170E     BSF UCON, 0x6
318:           
319:               // Reset to default address
320:               U1ADDR = 0x00;
06FF  0196     CLRF UADDR
321:           
322:               // Make sure packet processing is enabled
323:               USBPacketDisable = 0;
0700  120E     BCF UCON, 0x4
324:           
325:               //Stop trying to reset ping pong buffer pointers
326:               USBPingPongBufferReset = 0;
0701  130E     BCF UCON, 0x6
327:           
328:               // Flush any pending transactions
329:               do
330:               {
331:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0702  30F7     MOVLW 0xF7
0703  00F0     MOVWF 0xEF0
0704  0870     MOVF 0xEF0, W
0705  0590     ANDWF UIR, F
332:                   //Initialize USB stack software state variables
333:                   inPipes[0].info.Val = 0;
0706  0021     MOVLB 0x1
0707  01BA     CLRF 0xBA
334:                   outPipes[0].info.Val = 0;
0708  0022     MOVLB 0x2
0709  01A2     CLRF 0x122
335:                   outPipes[0].wCount.Val = 0;
070A  01A3     CLRF 0x123
070B  01A4     CLRF 0x124
336:               }while(USBTransactionCompleteIF == 1);
070C  003D     MOVLB 0x1D
070D  1990     BTFSC UIR, 0x3
070E  2F10     GOTO 0x710
070F  2F11     GOTO 0x711
0710  2F02     GOTO 0x702
337:           
338:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
339:               //try and arm a status stage, even before the first control transfer starts.
340:               USBStatusStageEnabledFlag1 = true;
0711  3001     MOVLW 0x1
0712  00F0     MOVWF 0xEF0
0713  0870     MOVF 0xEF0, W
0714  0021     MOVLB 0x1
0715  00C8     MOVWF USBStatusStageEnabledFlag1
341:               USBStatusStageEnabledFlag2 = true;
0716  3001     MOVLW 0x1
0717  00F0     MOVWF 0xF0
0718  0870     MOVF 0xF0, W
0719  00C7     MOVWF USBStatusStageEnabledFlag2
342:               //Initialize other flags
343:               USBDeferINDataStagePackets = false;
071A  01C6     CLRF USBDeferINDataStagePackets
344:               USBDeferOUTDataStagePackets = false;
071B  01C5     CLRF USBDeferOUTDataStagePackets
345:               USBBusIsSuspended = false;
071C  01CD     CLRF USBBusIsSuspended
346:           
347:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
348:               //pointers to NULL, so they don't get used inadvertently.
349:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
071D  01F4     CLRF 0xF4
350:               {
351:                   pBDTEntryIn[i] = 0u;
071E  3574     LSLF 0xF4, W
071F  3EB0     ADDLW 0xB0
0720  0086     MOVWF FSR1L
0721  0187     CLRF FSR1H
0722  3000     MOVLW 0x0
0723  3FC0     MOVWI 0[FSR1]
0724  3FC1     MOVWI 1[FSR1]
352:                   pBDTEntryOut[i] = 0u;
0725  3574     LSLF 0xF4, W
0726  3EA0     ADDLW 0xA0
0727  0086     MOVWF FSR1L
0728  3001     MOVLW 0x1
0729  0087     MOVWF FSR1H
072A  3000     MOVLW 0x0
072B  3FC0     MOVWI 0[FSR1]
072C  3FC1     MOVWI 1[FSR1]
353:                   ep_data_in[i].Val = 0u;
072D  0874     MOVF 0xF4, W
072E  3EB0     ADDLW 0xB0
072F  0086     MOVWF FSR1L
0730  3001     MOVLW 0x1
0731  0087     MOVWF FSR1H
0732  0181     CLRF INDF1
354:                   ep_data_out[i].Val = 0u;
0733  0874     MOVF 0xF4, W
0734  3EAC     ADDLW 0xAC
0735  0086     MOVWF FSR1L
0736  3001     MOVLW 0x1
0737  0087     MOVWF FSR1H
0738  0181     CLRF INDF1
355:               }
0739  3001     MOVLW 0x1
073A  00F0     MOVWF 0xF0
073B  0870     MOVF 0xF0, W
073C  07F4     ADDWF 0xF4, F
073D  3004     MOVLW 0x4
073E  0274     SUBWF 0xF4, W
073F  1C03     BTFSS STATUS, 0x0
0740  2F42     GOTO 0x742
0741  2F43     GOTO 0x743
0742  2F1E     GOTO 0x71E
356:           
357:               //Get ready for the first packet
358:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0743  3028     MOVLW 0x28
0744  0021     MOVLB 0x1
0745  00B0     MOVWF pBDTEntryIn
0746  3000     MOVLW 0x0
0747  00B1     MOVWF 0xB1
359:               // Initialize EP0 as a Ctrl EP
360:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;
0748  3016     MOVLW 0x16
0749  003D     MOVLB 0x1D
074A  0098     MOVWF UEP0
361:           	//Prepare for the first SETUP on EP0 OUT
362:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
074B  3000     MOVLW 0x0
074C  0020     MOVLB 0x0
074D  00A3     MOVWF 0x23
074E  3060     MOVLW 0x60
074F  00A2     MOVWF 0x22
363:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0750  3008     MOVLW 0x8
0751  00A1     MOVWF 0x21
364:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
0752  3004     MOVLW 0x4
0753  00F0     MOVWF __pcstackCOMMON
0754  0870     MOVF __pcstackCOMMON, W
0755  00A0     MOVWF BDT
365:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
0756  17A0     BSF BDT, 0x7
366:           
367:               // Clear active configuration
368:               USBActiveConfiguration = 0;
0757  0021     MOVLB 0x1
0758  01D7     CLRF USBActiveConfiguration
369:           
370:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
0759  3000     MOVLW 0x0
075A  0023     MOVLB 0x3
075B  00AB     MOVWF _spwrh
075C  3000     MOVLW 0x0
075D  00AA     MOVWF 0x1AA
075E  3000     MOVLW 0x0
075F  00A9     MOVWF 0x1A9
0760  3000     MOVLW 0x0
0761  00A8     MOVWF USB1msTickCount
371:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
0762  0021     MOVLB 0x1
0763  01C4     CLRF USBTicksSinceSuspendEnd
372:           
373:               //Indicate that we are now in the detached state
374:               USBDeviceState = DETACHED_STATE;
0764  01D3     CLRF USBDeviceState
375:           }
0765  0008     RETURN
376:           
377:           
378:           
379:           /**************************************************************************
380:             Function:
381:                   void USBDeviceTasks(void)
382:           
383:             Summary:
384:               This function is the main state machine/transaction handler of the USB
385:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
386:               (usb_config.h user option) the USBDeviceTasks() function should be called
387:               periodically to receive and transmit packets through the stack. This
388:               function also takes care of control transfers associated with the USB
389:               enumeration process, and detecting various USB events (such as suspend).
390:               This function should be called at least once every 1.8ms during the USB
391:               enumeration process. After the enumeration process is complete (which can
392:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
393:               USBDeviceTasks() handler may be called the faster of: either once
394:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
395:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
396:               a minimum rate of either the frequency that USBTransferOnePacket() gets
397:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
398:               near the top of usb_device.c for more details about minimum timing
399:               requirements when calling USBDeviceTasks().
400:           
401:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
402:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
403:               mode, the USBDeviceTasks() handler only needs to execute when a USB
404:               interrupt occurs, and therefore only needs to be called from the interrupt
405:               context.
406:           
407:             Description:
408:               This function is the main state machine/transaction handler of the USB
409:               device side stack.  When the USB stack is operated in "USB_POLLING" mode
410:               (usb_config.h user option) the USBDeviceTasks() function should be called
411:               periodically to receive and transmit packets through the stack. This
412:               function also takes care of control transfers associated with the USB
413:               enumeration process, and detecting various USB events (such as suspend).
414:               This function should be called at least once every 1.8ms during the USB
415:               enumeration process. After the enumeration process is complete (which can
416:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the
417:               USBDeviceTasks() handler may be called the faster of: either once
418:               every 9.8ms, or as often as needed to make sure that the hardware USTAT
419:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
420:               a minimum rate of either the frequency that USBTransferOnePacket() gets
421:               called, or, once/1.8ms, whichever is faster.  See the inline code comments
422:               near the top of usb_device.c for more details about minimum timing
423:               requirements when calling USBDeviceTasks().
424:           
425:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
426:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
427:               mode, the USBDeviceTasks() handler only needs to execute when a USB
428:               interrupt occurs, and therefore only needs to be called from the interrupt
429:               context.
430:           
431:               Typical usage:
432:               <code>
433:               void main(void)
434:               {
435:                   USBDeviceInit();
436:                   while(1)
437:                   {
438:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
439:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
440:                          (USBIsDeviceSuspended() == true))
441:                       {
442:                           //Either the device is not configured or we are suspended,
443:                           // so we don't want to execute any USB related application code
444:                           continue;   //go back to the top of the while loop
445:                       }
446:                       else
447:                       {
448:                           //Otherwise we are free to run USB and non-USB related user
449:                           //application code.
450:                           UserApplication();
451:                       }
452:                   }
453:               }
454:               </code>
455:           
456:             Precondition:
457:               Make sure the USBDeviceInit() function has been called prior to calling
458:               USBDeviceTasks() for the first time.
459:             Remarks:
460:               USBDeviceTasks() does not need to be called while in the USB suspend mode,
461:               if the user application firmware in the USBCBSuspend() callback function
462:               enables the ACTVIF USB interrupt source and put the microcontroller into
463:               sleep mode.  If the application firmware decides not to sleep the
464:               microcontroller core during USB suspend (ex: continues running at full
465:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
466:               function must still be called periodically, at a rate frequent enough to
467:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
468:               a worst case primary oscillator and PLL start up time of less than 5ms, then
469:               USBDeviceTasks() should be called once every 5ms in this scenario.
470:           
471:               When the USB cable is detached, or the USB host is not actively powering
472:               the VBUS line to +5V nominal, the application firmware does not always have
473:               to call USBDeviceTasks() frequently, as no USB activity will be taking
474:               place.  However, if USBDeviceTasks() is not called regularly, some
475:               alternative means of promptly detecting when VBUS is powered (indicating
476:               host attachment), or not powered (host powered down or USB cable unplugged)
477:               is still needed.  For self or dual self/bus powered USB applications, see
478:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional
479:               considerations.
480:               ***************************************************************************/
481:           void USBDeviceTasks(void)
482:           {
483:               uint8_t i;
484:           
485:               #ifdef USB_SUPPORT_OTG
486:                   //SRP Time Out Check
487:                   if (USBOTGSRPIsReady())
488:                   {
489:                       if (USBT1MSECIF && USBT1MSECIE)
490:                       {
491:                           if (USBOTGGetSRPTimeOutFlag())
492:                           {
493:                               if (USBOTGIsSRPTimeOutExpired())
494:                               {
495:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
496:                               }
497:                           }
498:           
499:                           //Clear Interrupt Flag
500:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
501:                       }
502:                   }
503:               #endif
504:           
505:               #if defined(USB_POLLING)
506:               //If the interrupt option is selected then the customer is required
507:               //  to notify the stack when the device is attached or removed from the
508:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
509:               if (USB_BUS_SENSE != 1)
510:               {
511:                    // Disable module & detach from bus
512:                    U1CON = 0;
513:           
514:                    // Mask all USB interrupts
515:                    U1IE = 0;
516:           
517:                    //Move to the detached state
518:                    USBDeviceState = DETACHED_STATE;
519:           
520:                    #ifdef  USB_SUPPORT_OTG
521:                        //Disable D+ Pullup
522:                        U1OTGCONbits.DPPULUP = 0;
523:           
524:                        //Disable HNP
525:                        USBOTGDisableHnp();
526:           
527:                        //Deactivate HNP
528:                        USBOTGDeactivateHnp();
529:           
530:                        //If ID Pin Changed State
531:                        if (USBIDIF && USBIDIE)
532:                        {
533:                            //Re-detect & Initialize
534:                             USBOTGInitialize();
535:           
536:                             //Clear ID Interrupt Flag
537:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
538:                        }
539:                    #endif
540:           
541:                    #if defined __C30__ || defined __XC16__
542:                        //USBClearInterruptFlag(U1OTGIR, 3);
543:                    #endif
544:                       //return so that we don't go through the rest of
545:                       //the state machine
546:                    USBClearUSBInterrupt();
547:                    return;
548:               }
549:           
550:           	#ifdef USB_SUPPORT_OTG
551:               //If Session Is Started Then
552:               else
553:           	{
554:                   //If SRP Is Ready
555:                   if (USBOTGSRPIsReady())
556:                   {
557:                       //Clear SRPReady
558:                       USBOTGClearSRPReady();
559:           
560:                       //Clear SRP Timeout Flag
561:                       USBOTGClearSRPTimeOutFlag();
562:           
563:                       //Indicate Session Started
564:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
565:                   }
566:               }
567:           	#endif	//#ifdef USB_SUPPORT_OTG
568:           
569:               //if we are in the detached state
570:               if(USBDeviceState == DETACHED_STATE)
02F1  0021     MOVLB 0x1
02F2  0853     MOVF USBDeviceState, W
02F3  1D03     BTFSS STATUS, 0x2
02F4  2AF6     GOTO 0x2F6
02F5  2AF7     GOTO 0x2F7
02F6  2B09     GOTO 0x309
571:               {
572:           	    //Initialize register to known value
573:                   U1CON = 0;
02F7  003D     MOVLB 0x1D
02F8  018E     CLRF UCON
574:           
575:                   // Mask all USB interrupts
576:                   U1IE = 0;
02F9  0192     CLRF UIE
577:           
578:                   //Enable/set things like: pull ups, full/low-speed mode,
579:                   //set the ping pong mode, and set internal transceiver
580:                   SetConfigurationOptions();
02FA  3016     MOVLW 0x16
02FB  0091     MOVWF UCFG
02FC  309F     MOVLW 0x9F
02FD  0097     MOVWF UEIE
02FE  307B     MOVLW 0x7B
02FF  0092     MOVWF UIE
581:           
582:                   // Enable module & attach to bus
583:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
0300  2B02     GOTO 0x302
0301  158E     BSF UCON, 0x3
0302  1D8E     BTFSS UCON, 0x3
0303  2B05     GOTO 0x305
0304  2B06     GOTO 0x306
0305  2B01     GOTO 0x301
584:           
585:                   //moved to the attached state
586:                   USBDeviceState = ATTACHED_STATE;
0306  0021     MOVLB 0x1
0307  01D3     CLRF USBDeviceState
0308  0AD3     INCF USBDeviceState, F
587:           
588:                   #ifdef  USB_SUPPORT_OTG
589:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
590:                   #endif
591:               }
592:           	#endif  //#if defined(USB_POLLING)
593:           
594:               if(USBDeviceState == ATTACHED_STATE)
0309  0353     DECF USBDeviceState, W
030A  1D03     BTFSS STATUS, 0x2
030B  2B0D     GOTO 0x30D
030C  2B0E     GOTO 0x30E
030D  2B1C     GOTO 0x31C
595:               {
596:                   /*
597:                    * After enabling the USB module, it takes some time for the
598:                    * voltage on the D+ or D- line to rise high enough to get out
599:                    * of the SE0 condition. The USB Reset interrupt should not be
600:                    * unmasked until the SE0 condition is cleared. This helps
601:                    * prevent the firmware from misinterpreting this unique event
602:                    * as a USB bus reset from the USB host.
603:                    */
604:           
605:                   if(!USBSE0Event)
030E  003D     MOVLB 0x1D
030F  1A8E     BTFSC UCON, 0x5
0310  2B12     GOTO 0x312
0311  2B13     GOTO 0x313
0312  2B1C     GOTO 0x31C
606:                   {
607:                       //We recently attached, make sure we are in a clean state
608:                       #if defined(__dsPIC33E__) || defined(_PIC24E__) || defined(__PIC32MM__)
609:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
610:                                           //during attach de-bounce interval
611:                       #else
612:                           USBClearInterruptRegister(U1IR);
0313  0190     CLRF UIR
613:                       #endif
614:           
615:                       #if defined(USB_POLLING)
616:                           U1IE=0;                        // Mask all USB interrupts
0314  0192     CLRF UIE
617:                       #endif
618:                       USBResetIE = 1;             // Unmask RESET interrupt
0315  1412     BSF UIE, 0x0
619:                       USBIdleIE = 1;             // Unmask IDLE interrupt
0316  1612     BSF UIE, 0x4
620:                       USBDeviceState = POWERED_STATE;
0317  3002     MOVLW 0x2
0318  0021     MOVLB 0x1
0319  00EA     MOVWF 0xEA
031A  086A     MOVF 0xEA, W
031B  00D3     MOVWF USBDeviceState
621:                   }
622:               }
623:           
624:               #ifdef  USB_SUPPORT_OTG
625:                   //If ID Pin Changed State
626:                   if (USBIDIF && USBIDIE)
627:                   {
628:                       //Re-detect & Initialize
629:                       USBOTGInitialize();
630:           
631:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
632:                   }
633:               #endif
634:           
635:               /*
636:                * Task A: Service USB Activity Interrupt
637:                */
638:               if(USBActivityIF && USBActivityIE)
031C  003D     MOVLB 0x1D
031D  1D10     BTFSS UIR, 0x2
031E  2B20     GOTO 0x320
031F  2B21     GOTO 0x321
0320  2B2E     GOTO 0x32E
0321  1D12     BTFSS UIE, 0x2
0322  2B24     GOTO 0x324
0323  2B25     GOTO 0x325
0324  2B2E     GOTO 0x32E
639:               {
640:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0325  30FB     MOVLW 0xFB
0326  0021     MOVLB 0x1
0327  00EA     MOVWF 0xEA
0328  086A     MOVF 0xEA, W
0329  003D     MOVLB 0x1D
032A  0590     ANDWF UIR, F
641:                   #if defined(USB_SUPPORT_OTG)
642:                       U1OTGIR = 0x10;
643:                   #else
644:                       USBWakeFromSuspend();
032B  3197     MOVLP 0x17
032C  27BD     CALL 0x7BD
032D  3182     MOVLP 0x2
645:                   #endif
646:               }
647:           
648:               /*
649:                * Pointless to continue servicing if the device is in suspend mode.
650:                */
651:               if(USBSuspendControl==1)
032E  003D     MOVLB 0x1D
032F  1C8E     BTFSS UCON, 0x1
0330  2B32     GOTO 0x332
0331  2B33     GOTO 0x333
0332  2B36     GOTO 0x336
652:               {
653:                   USBClearUSBInterrupt();
0333  0020     MOVLB 0x0
0334  1112     BCF PIR2, 0x2
654:                   return;
0335  2C1F     GOTO 0x41F
655:               }
656:           
657:               /*
658:                * Task B: Service USB Bus Reset Interrupt.
659:                * When bus reset is received during suspend, ACTVIF will be set first,
660:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
661:                * This is why URSTIF is checked after ACTVIF.
662:                *
663:                * The USB reset flag is masked when the USB state is in
664:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
665:                * cause a USB reset event during these two states.
666:                */
667:               if(USBResetIF && USBResetIE)
0336  1C10     BTFSS start, 0x0
0337  2B39     GOTO 0x339
0338  2B3A     GOTO 0x33A
0339  2B4B     GOTO 0x34B
033A  1C12     BTFSS PIR2, 0x0
033B  2B3D     GOTO 0x33D
033C  2B3E     GOTO 0x33E
033D  2B4B     GOTO 0x34B
668:               {
669:                   USBDeviceInit();
033E  3186     MOVLP 0x6
033F  26BC     CALL 0x6BC
0340  3182     MOVLP 0x2
670:           
671:                   //Re-enable the interrupts since the USBDeviceInit() function will
672:                   //  disable them.  This will do nothing in a polling setup
673:                   USBUnmaskInterrupts();
674:           
675:                   USBDeviceState = DEFAULT_STATE;
0341  3004     MOVLW 0x4
0342  0021     MOVLB 0x1
0343  00EA     MOVWF 0xEA
0344  086A     MOVF 0xEA, W
0345  00D3     MOVWF USBDeviceState
676:           
677:                   #ifdef USB_SUPPORT_OTG
678:                        //Disable HNP
679:                        USBOTGDisableHnp();
680:           
681:                        //Deactivate HNP
682:                        USBOTGDeactivateHnp();
683:                   #endif
684:           
685:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
0346  30FE     MOVLW 0xFE
0347  00EA     MOVWF 0xEA
0348  086A     MOVF 0xEA, W
0349  003D     MOVLB 0x1D
034A  0590     ANDWF UIR, F
686:               }
687:           
688:               /*
689:                * Task C: Service other USB interrupts
690:                */
691:               if(USBIdleIF && USBIdleIE)
034B  1E10     BTFSS UIR, 0x4
034C  2B4E     GOTO 0x34E
034D  2B4F     GOTO 0x34F
034E  2B56     GOTO 0x356
034F  1E12     BTFSS UIE, 0x4
0350  2B52     GOTO 0x352
0351  2B53     GOTO 0x353
0352  2B56     GOTO 0x356
692:               {
693:                   #ifdef  USB_SUPPORT_OTG
694:                       //If Suspended, Try to switch to Host
695:                       USBOTGSelectRole(ROLE_HOST);
696:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
697:                   #else
698:                       USBSuspend();
0353  3197     MOVLP 0x17
0354  2763     CALL 0x763
0355  3182     MOVLP 0x2
699:                   #endif
700:               }
701:           
702:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
703:                   //Check if a 1ms interval has elapsed.
704:                   if(USBT1MSECIF)
705:                   {
706:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
707:                       USBIncrement1msInternalTimers();
708:                   }
709:               #endif
710:           
711:               //Start-of-Frame Interrupt
712:               if(USBSOFIF)
0356  003D     MOVLB 0x1D
0357  1F10     BTFSS UIR, 0x6
0358  2B5A     GOTO 0x35A
0359  2B5B     GOTO 0x35B
035A  2B88     GOTO 0x388
713:               {
714:                   //Call the user SOF event callback if enabled.
715:                   if(USBSOFIE)
035B  1F12     BTFSS UIE, 0x6
035C  2B5E     GOTO 0x35E
035D  2B5F     GOTO 0x35F
035E  2B6F     GOTO 0x36F
716:                   {
717:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
035F  3073     MOVLW 0x73
0360  0021     MOVLB 0x1
0361  00D8     MOVWF __pcstackBANK1
0362  3000     MOVLW 0x0
0363  00D9     MOVWF 0xD9
0364  3000     MOVLW 0x0
0365  00DA     MOVWF pdata
0366  3000     MOVLW 0x0
0367  00DB     MOVWF 0xDB
0368  3001     MOVLW 0x1
0369  00DC     MOVWF size
036A  3000     MOVLW 0x0
036B  00DD     MOVWF 0xDD
036C  3189     MOVLP 0x9
036D  21C3     CALL 0x1C3
036E  3182     MOVLP 0x2
718:                   }
719:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
036F  30BF     MOVLW 0xBF
0370  0021     MOVLB 0x1
0371  00EA     MOVWF 0xEA
0372  086A     MOVF 0xEA, W
0373  003D     MOVLB 0x1D
0374  0590     ANDWF UIR, F
720:           
721:                   #if defined(__XC8__) || defined(__C18__)
722:                       USBIncrement1msInternalTimers();
0375  3197     MOVLP 0x17
0376  277F     CALL 0x77F
0377  3182     MOVLP 0x2
723:                   #endif
724:           
725:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
726:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
727:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
728:                           #warning "Double click this message.  See inline code comments."
729:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
730:                           //not strictly needed in all applications (ex: those that never call
731:                           //USBDeferStatusStage() and don't use host to device (OUT) control
732:                           //transfers with data stage).
733:                           //However, if this feature is enabled and used in a low speed application,
734:                           //it is required for the application code to periodically call the
735:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
736:                       #endif
737:           
738:                       //Decrement our status stage counter.
739:                       if(USBStatusStageTimeoutCounter != 0u)
0378  0021     MOVLB 0x1
0379  084A     MOVF USBStatusStageTimeoutCounter, W
037A  1903     BTFSC STATUS, 0x2
037B  2B7D     GOTO 0x37D
037C  2B7E     GOTO 0x37E
037D  2B80     GOTO 0x380
740:                       {
741:                           USBStatusStageTimeoutCounter--;
037E  3001     MOVLW 0x1
037F  02CA     SUBWF USBStatusStageTimeoutCounter, F
742:                       }
743:                       //Check if too much time has elapsed since progress was made in
744:                       //processing the control transfer, without arming the status stage.
745:                       //If so, auto-arm the status stage to ensure that the control
746:                       //transfer can [eventually] complete, within the timing limits
747:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
748:                       if(USBStatusStageTimeoutCounter == 0)
0380  084A     MOVF USBStatusStageTimeoutCounter, W
0381  1D03     BTFSS STATUS, 0x2
0382  2B84     GOTO 0x384
0383  2B85     GOTO 0x385
0384  2B88     GOTO 0x388
749:                       {
750:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
0385  318B     MOVLP 0xB
0386  23D4     CALL 0x3D4
0387  3182     MOVLP 0x2
751:                       }
752:                   #endif
753:               }
754:           
755:               if(USBStallIF && USBStallIE)
0388  003D     MOVLB 0x1D
0389  1E90     BTFSS UIR, 0x5
038A  2B8C     GOTO 0x38C
038B  2B8D     GOTO 0x38D
038C  2B94     GOTO 0x394
038D  1E92     BTFSS UIE, 0x5
038E  2B90     GOTO 0x390
038F  2B91     GOTO 0x391
0390  2B94     GOTO 0x394
756:               {
757:                   USBStallHandler();
0391  3188     MOVLP 0x8
0392  20BF     CALL 0xBF
0393  3182     MOVLP 0x2
758:               }
759:           
760:               if(USBErrorIF && USBErrorIE)
0394  003D     MOVLB 0x1D
0395  1C90     BTFSS UIR, 0x1
0396  2B98     GOTO 0x398
0397  2B99     GOTO 0x399
0398  2BAF     GOTO 0x3AF
0399  1C92     BTFSS UIE, 0x1
039A  2B9C     GOTO 0x39C
039B  2B9D     GOTO 0x39D
039C  2BAF     GOTO 0x3AF
761:               {
762:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
039D  30FF     MOVLW 0xFF
039E  0021     MOVLB 0x1
039F  00D8     MOVWF __pcstackBANK1
03A0  307F     MOVLW 0x7F
03A1  00D9     MOVWF 0xD9
03A2  3000     MOVLW 0x0
03A3  00DA     MOVWF pdata
03A4  3000     MOVLW 0x0
03A5  00DB     MOVWF 0xDB
03A6  3001     MOVLW 0x1
03A7  00DC     MOVWF size
03A8  3000     MOVLW 0x0
03A9  00DD     MOVWF 0xDD
03AA  3189     MOVLP 0x9
03AB  21C3     CALL 0x1C3
03AC  3182     MOVLP 0x2
763:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
03AD  003D     MOVLB 0x1D
03AE  0193     CLRF UEIR
764:           
765:                   //On PIC18, clearing the source of the error will automatically clear
766:                   //  the interrupt flag.  On other devices the interrupt flag must be
767:                   //  manually cleared.
768:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
769:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
770:                   #endif
771:               }
772:           
773:               /*
774:                * Pointless to continue servicing if the host has not sent a bus reset.
775:                * Once bus reset is received, the device transitions into the DEFAULT
776:                * state and is ready for communication.
777:                */
778:               if(USBDeviceState < DEFAULT_STATE)
03AF  3004     MOVLW 0x4
03B0  0021     MOVLB 0x1
03B1  0253     SUBWF USBDeviceState, W
03B2  1803     BTFSC STATUS, 0x0
03B3  2BB5     GOTO 0x3B5
03B4  2BB6     GOTO 0x3B6
03B5  2BB9     GOTO 0x3B9
779:               {
780:                   USBClearUSBInterrupt();
03B6  0020     MOVLB 0x0
03B7  1112     BCF PIR2, 0x2
781:                   return;
03B8  2C1F     GOTO 0x41F
782:               }
783:           
784:               /*
785:                * Task D: Servicing USB Transaction Complete Interrupt
786:                */
787:               if(USBTransactionCompleteIE)
03B9  003D     MOVLB 0x1D
03BA  1D92     BTFSS UIE, 0x3
03BB  2BBD     GOTO 0x3BD
03BC  2BBE     GOTO 0x3BE
03BD  2C1D     GOTO 0x41D
788:               {
789:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
03BE  0021     MOVLB 0x1
03BF  01EC     CLRF i
790:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
791:                       if(USBTransactionCompleteIF)
03C0  003D     MOVLB 0x1D
03C1  1D90     BTFSS UIR, 0x3
03C2  2BC4     GOTO 0x3C4
03C3  2BC5     GOTO 0x3C5
03C4  2C1D     GOTO 0x41D
792:                       {
793:                           //Save and extract USTAT register info.  Will use this info later.
794:                           USTATcopy.Val = U1STAT;
03C5  080F     MOVF USTAT, W
03C6  0021     MOVLB 0x1
03C7  00EA     MOVWF 0xEA
03C8  086A     MOVF 0xEA, W
03C9  00D6     MOVWF USTATcopy
795:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
03CA  0C56     RRF USTATcopy, W
03CB  00EA     MOVWF 0xEA
03CC  0CEA     RRF 0xEA, F
03CD  0C6A     RRF 0xEA, W
03CE  390F     ANDLW 0xF
03CF  00EB     MOVWF 0xEB
03D0  086B     MOVF 0xEB, W
03D1  00CC     MOVWF endpoint_number
796:           
797:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
03D2  30F7     MOVLW 0xF7
03D3  00EA     MOVWF 0xEA
03D4  086A     MOVF 0xEA, W
03D5  003D     MOVLB 0x1D
03D6  0590     ANDWF UIR, F
798:           
799:                           //Keep track of the hardware ping pong state for endpoints other
800:                           //than EP0, if ping pong buffering is enabled.
801:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
802:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
03D7  0021     MOVLB 0x1
03D8  1956     BTFSC USTATcopy, 0x2
03D9  2BDB     GOTO 0x3DB
03DA  2BDC     GOTO 0x3DC
03DB  2BEC     GOTO 0x3EC
803:                           {
804:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
03DC  084C     MOVF endpoint_number, W
03DD  3EAC     ADDLW 0xAC
03DE  0086     MOVWF FSR1L
03DF  3001     MOVLW 0x1
03E0  0087     MOVWF FSR1H
03E1  0801     MOVF INDF1, W
03E2  3901     ANDLW 0x1
03E3  00EA     MOVWF 0xEA
03E4  3001     MOVLW 0x1
03E5  06EA     XORWF 0xEA, F
03E6  0801     MOVF INDF1, W
03E7  066A     XORWF 0xEA, W
03E8  39FE     ANDLW 0xFE
03E9  066A     XORWF 0xEA, W
03EA  0081     MOVWF INDF1
805:                           }
03EB  2BFB     GOTO 0x3FB
806:                           else
807:                           {
808:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
03EC  084C     MOVF endpoint_number, W
03ED  3EB0     ADDLW 0xB0
03EE  0086     MOVWF FSR1L
03EF  3001     MOVLW 0x1
03F0  0087     MOVWF FSR1H
03F1  0801     MOVF INDF1, W
03F2  3901     ANDLW 0x1
03F3  00EA     MOVWF 0xEA
03F4  3001     MOVLW 0x1
03F5  06EA     XORWF 0xEA, F
03F6  0801     MOVF INDF1, W
03F7  066A     XORWF 0xEA, W
03F8  39FE     ANDLW 0xFE
03F9  066A     XORWF 0xEA, W
03FA  0081     MOVWF INDF1
809:                           }
810:                           #endif
811:           
812:                           //USBCtrlEPService only services transactions over EP0.
813:                           //It ignores all other EP transactions.
814:                           if(endpoint_number == 0)
03FB  084C     MOVF endpoint_number, W
03FC  1D03     BTFSS STATUS, 0x2
03FD  2BFF     GOTO 0x3FF
03FE  2C00     GOTO 0x400
03FF  2C04     GOTO 0x404
815:                           {
816:                               USBCtrlEPService();
0400  318A     MOVLP 0xA
0401  2251     CALL 0x251
0402  3182     MOVLP 0x2
817:                           }
0403  2C12     GOTO 0x412
818:                           else
819:                           {
820:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
0404  3072     MOVLW 0x72
0405  00D8     MOVWF __pcstackBANK1
0406  3000     MOVLW 0x0
0407  00D9     MOVWF 0xD9
0408  30D6     MOVLW 0xD6
0409  00DA     MOVWF pdata
040A  3000     MOVLW 0x0
040B  00DB     MOVWF 0xDB
040C  3000     MOVLW 0x0
040D  00DC     MOVWF size
040E  00DD     MOVWF 0xDD
040F  3189     MOVLP 0x9
0410  21C3     CALL 0x1C3
0411  3182     MOVLP 0x2
821:                           }
822:                       }//end if(USBTransactionCompleteIF)
823:                       else
824:                       {
825:                           break;	//USTAT FIFO must be empty.
826:                       }
827:                   }//end for()
0412  3001     MOVLW 0x1
0413  0021     MOVLB 0x1
0414  00EA     MOVWF 0xEA
0415  086A     MOVF 0xEA, W
0416  07EC     ADDWF i, F
0417  3004     MOVLW 0x4
0418  026C     SUBWF i, W
0419  1C03     BTFSS STATUS, 0x0
041A  2C1C     GOTO 0x41C
041B  2C1D     GOTO 0x41D
041C  2BC0     GOTO 0x3C0
828:               }//end if(USBTransactionCompleteIE)
829:           
830:               USBClearUSBInterrupt();
041D  0020     MOVLB 0x0
041E  1112     BCF PIR2, 0x2
831:           }//end of USBDeviceTasks()
041F  0008     RETURN
832:           
833:           /*******************************************************************************
834:             Function:
835:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
836:           
837:             Summary:
838:               This function will enable the specified endpoint with the specified
839:               options
840:             Description:
841:               This function will enable the specified endpoint with the specified
842:               options.
843:           
844:               Typical Usage:
845:               <code>
846:               void USBCBInitEP(void)
847:               {
848:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
849:                   USBMSDInit();
850:               }
851:               </code>
852:           
853:               In the above example endpoint number MSD_DATA_IN_EP is being configured
854:               for both IN and OUT traffic with handshaking enabled. Also since
855:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
856:               explicitly disable SETUP packets on this endpoint.
857:             Conditions:
858:               None
859:             Input:
860:               uint8_t ep -       the endpoint to be configured
861:               uint8_t options -  optional settings for the endpoint. The options should
862:                               be ORed together to form a single options string. The
863:                               available optional settings for the endpoint. The
864:                               options should be ORed together to form a single options
865:                               string. The available options are the following\:
866:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
867:                                 NAK)
868:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
869:                                 NAK)
870:                               * USB_OUT_ENABLED enables the out direction
871:                               * USB_OUT_DISABLED disables the out direction
872:                               * USB_IN_ENABLED enables the in direction
873:                               * USB_IN_DISABLED disables the in direction
874:                               * USB_ALLOW_SETUP enables control transfers
875:                               * USB_DISALLOW_SETUP disables control transfers
876:                               * USB_STALL_ENDPOINT STALLs this endpoint
877:             Return:
878:               None
879:             Remarks:
880:               None
881:             *****************************************************************************/
882:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
0874  00FC     MOVWF s
883:           {
884:               unsigned char* p;
885:           
886:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and
887:               //starting DTS state in the BDT entry.
888:               if(options & USB_OUT_ENABLED)
0875  1D77     BTFSS options, 0x2
0876  2878     GOTO 0x78
0877  2879     GOTO 0x79
0878  287E     GOTO 0x7E
889:               {
890:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
0879  01F0     CLRF __pcstackCOMMON
087A  087C     MOVF s, W
087B  3189     MOVLP 0x9
087C  2180     CALL 0x180
087D  3188     MOVLP 0x8
891:               }
892:               if(options & USB_IN_ENABLED)
087E  1CF7     BTFSS options, 0x1
087F  2881     GOTO 0x81
0880  2882     GOTO 0x82
0881  2888     GOTO 0x88
893:               {
894:                   USBConfigureEndpoint(ep, IN_TO_HOST);
0882  01F0     CLRF __pcstackCOMMON
0883  0AF0     INCF __pcstackCOMMON, F
0884  087C     MOVF s, W
0885  3189     MOVLP 0x9
0886  2180     CALL 0x180
0887  3188     MOVLP 0x8
895:               }
896:           
897:               //Update the relevant UEPx register to actually enable the endpoint with
898:               //the specified options (ex: handshaking enabled, control transfers allowed,
899:               //etc.)
900:               #if defined(__C32__)
901:                   p = (unsigned char*)(&U1EP0+(4*ep));
902:               #else
903:                   p = (unsigned char*)(&U1EP0+ep);
0888  087C     MOVF s, W
0889  3E98     ADDLW 0x98
088A  00F8     MOVWF ep
088B  01F9     CLRF handle
088C  300E     MOVLW 0xE
088D  3DF9     ADDWFC handle, F
088E  0878     MOVF ep, W
088F  00FA     MOVWF k
0890  0879     MOVF handle, W
0891  00FB     MOVWF 0x7B
904:               #endif
905:               *p = options;
0892  087A     MOVF k, W
0893  0086     MOVWF FSR1
0894  087B     MOVF 0x7B, W
0895  0087     MOVWF FSR1H
0896  0877     MOVF options, W
0897  0081     MOVWF INDF1
906:           }
0898  0008     RETURN
907:           
908:           
909:           /*************************************************************************
910:             Function:
911:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
912:           
913:             Summary:
914:               Transfers a single packet (one transaction) of data on the USB bus.
915:           
916:             Description:
917:               The USBTransferOnePacket() function prepares a USB endpoint
918:               so that it may send data to the host (an IN transaction), or
919:               receive data from the host (an OUT transaction).  The
920:               USBTransferOnePacket() function can be used both to receive	and
921:               send data to the host.  This function is the primary API function
922:               provided by the USB stack firmware for sending or receiving application
923:               data over the USB port.
924:           
925:               The USBTransferOnePacket() is intended for use with all application
926:               endpoints.  It is not used for sending or receiving application data
927:               through endpoint 0 by using control transfers.  Separate API
928:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
929:               USBEP0SendROMPtr() are provided for this purpose.
930:           
931:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
932:               entry associated with an endpoint buffer, and sets the UOWN bit, which
933:               prepares the USB hardware to allow the transaction to complete.  The
934:               application firmware can use the USBHandleBusy() macro to check the
935:               status of the transaction, to see if the data has been successfully
936:               transmitted yet.
937:           
938:           
939:               Typical Usage
940:               <code>
941:               //make sure that the we are in the configured state
942:               if(USBGetDeviceState() == CONFIGURED_STATE)
943:               {
944:                   //make sure that the last transaction isn't busy by checking the handle
945:                   if(!USBHandleBusy(USBInHandle))
946:                   {
947:           	        //Write the new data that we wish to send to the host to the INPacket[] array
948:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
949:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
950:           	        //INPacket[2] = ... (fill in the rest of the packet data)
951:           
952:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
953:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
954:                   }
955:               }
956:               </code>
957:           
958:             Conditions:
959:               Before calling USBTransferOnePacket(), the following should be true.
960:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
961:               2.  A transaction is not already pending on the specified endpoint.  This
962:                   is done by checking the previous request using the USBHandleBusy()
963:                   macro (see the typical usage example).
964:               3.  The host has already sent a set configuration request and the
965:                   enumeration process is complete.
966:                   This can be checked by verifying that the USBGetDeviceState()
967:                   macro returns "CONFIGURED_STATE", prior to calling
968:                   USBTransferOnePacket().
969:           
970:             Input:
971:               uint8_t ep - The endpoint number that the data will be transmitted or
972:           	          received on
973:               uint8_t dir - The direction of the transfer
974:                          This value is either OUT_FROM_HOST or IN_TO_HOST
975:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
976:                            the data to be sent to the host.  For OUT transactions: pointer
977:                            to the RAM buffer that the received data should get written to.
978:              uint8_t len - Length of the data needing to be sent (for IN transactions).
979:                         For OUT transactions, the len parameter should normally be set
980:                         to the endpoint size specified in the endpoint descriptor.
981:           
982:             Return Values:
983:               USB_HANDLE - handle to the transfer.  The handle is a pointer to
984:                            the BDT entry associated with this transaction.  The
985:                            status of the transaction (ex: if it is complete or still
986:                            pending) can be checked using the USBHandleBusy() macro
987:                            and supplying the USB_HANDLE provided by
988:                            USBTransferOnePacket().
989:           
990:             Remarks:
991:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
992:               callback function, the set configuration is still being processed and the
993:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case,
994:               the USBTransferOnePacket() may still be called, but make sure that the
995:               endpoint has been enabled and initialized by the USBEnableEndpoint()
996:               function first.
997:           
998:             *************************************************************************/
999:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
0766  00F8     MOVWF ep
1000:          {
1001:              volatile BDT_ENTRY* handle;
1002:          
1003:              //If the direction is IN
1004:              if(dir != 0)
0767  0870     MOVF __pcstackCOMMON, W
0768  1903     BTFSC STATUS, 0x2
0769  2F6B     GOTO 0x76B
076A  2F6C     GOTO 0x76C
076B  2F75     GOTO 0x775
1005:              {
1006:                  //point to the IN BDT of the specified endpoint
1007:                  handle = pBDTEntryIn[ep];
076C  3578     LSLF ep, W
076D  3EB0     ADDLW 0xB0
076E  0086     MOVWF FSR1
076F  0187     CLRF FSR1H
0770  3F40     MOVIW 0[FSR1]
0771  00F9     MOVWF handle
0772  3F41     MOVIW 1[FSR1]
0773  00FA     MOVWF k
1008:              }
0774  2F7E     GOTO 0x77E
1009:              else
1010:              {
1011:                  //else point to the OUT BDT of the specified endpoint
1012:                  handle = pBDTEntryOut[ep];
0775  3578     LSLF ep, W
0776  3EA0     ADDLW 0xA0
0777  0086     MOVWF FSR1
0778  3001     MOVLW 0x1
0779  0087     MOVWF FSR1H
077A  3F40     MOVIW 0[FSR1]
077B  00F9     MOVWF handle
077C  3F41     MOVIW 1[FSR1]
077D  00FA     MOVWF k
1013:              }
1014:          
1015:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1016:              //pBDTEntryOut[ep]) is initialized before using it.
1017:              if(handle == 0)
077E  0879     MOVF handle, W
077F  047A     IORWF k, W
0780  1D03     BTFSS STATUS, 0x2
0781  2F83     GOTO 0x783
0782  2F84     GOTO 0x784
0783  2F87     GOTO 0x787
1018:              {
1019:                  return 0;
0784  01F0     CLRF __pcstackCOMMON
0785  01F1     CLRF p
0786  2FEC     GOTO 0x7EC
1020:              }
1021:          
1022:              //Toggle the DTS bit if required
1023:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1024:                  handle->STAT.Val ^= _DTSMASK;
1025:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1026:                  if(ep != 0)
1027:                  {
1028:                      handle->STAT.Val ^= _DTSMASK;
1029:                  }
1030:              #endif
1031:          
1032:              //Set the data pointer, data length, and enable the endpoint
1033:              handle->ADR = ConvertToPhysicalAddress(data);
0787  30FF     MOVLW 0xFF
0788  0571     ANDWF p, W
0789  00F4     MOVWF n
078A  307F     MOVLW 0x7F
078B  0572     ANDWF c, W
078C  00F5     MOVWF EPNum
078D  0879     MOVF handle, W
078E  0086     MOVWF FSR1
078F  087A     MOVF k, W
0790  0087     MOVWF FSR1H
0791  3142     ADDFSR 1, 2
0792  0874     MOVF n, W
0793  3FC0     MOVWI 0[FSR1]
0794  0875     MOVF EPNum, W
0795  3FC1     MOVWI 1[FSR1]
1034:              handle->CNT = len;
0796  0879     MOVF handle, W
0797  3E01     ADDLW 0x1
0798  00F4     MOVWF n
0799  3000     MOVLW 0x0
079A  3D7A     ADDWFC k, W
079B  00F5     MOVWF EPNum
079C  0874     MOVF n, W
079D  0086     MOVWF FSR1
079E  0875     MOVF EPNum, W
079F  0087     MOVWF FSR1H
07A0  0873     MOVF i, W
07A1  0081     MOVWF INDF1
1035:              handle->STAT.Val &= _DTSMASK;
07A2  3040     MOVLW 0x40
07A3  00F4     MOVWF n
07A4  0879     MOVF handle, W
07A5  0086     MOVWF FSR1
07A6  087A     MOVF k, W
07A7  0087     MOVWF FSR1H
07A8  0874     MOVF n, W
07A9  0581     ANDWF INDF1, F
1036:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
07AA  0879     MOVF handle, W
07AB  0086     MOVWF FSR1
07AC  087A     MOVF k, W
07AD  0087     MOVWF FSR1H
07AE  1581     BSF INDF1, 0x3
1037:              handle->STAT.Val |= _USIE;
07AF  0879     MOVF handle, W
07B0  0086     MOVWF FSR1
07B1  087A     MOVF k, W
07B2  0087     MOVWF FSR1H
07B3  1781     BSF INDF1, 0x7
1038:          
1039:              //Point to the next buffer for ping pong purposes.
1040:              if(dir != OUT_FROM_HOST)
07B4  0870     MOVF __pcstackCOMMON, W
07B5  1903     BTFSC STATUS, 0x2
07B6  2FB8     GOTO 0x7B8
07B7  2FB9     GOTO 0x7B9
07B8  2FD0     GOTO 0x7D0
1041:              {
1042:                  //toggle over the to the next buffer for an IN endpoint
1043:                  pBDTEntryIn[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[ep]) ^ USB_NEXT_PING_PONG);
07B9  3578     LSLF ep, W
07BA  3EB0     ADDLW 0xB0
07BB  0086     MOVWF FSR1
07BC  0187     CLRF FSR1H
07BD  3F40     MOVIW 0[FSR1]
07BE  00F4     MOVWF n
07BF  3F41     MOVIW 1[FSR1]
07C0  00F5     MOVWF EPNum
07C1  3004     MOVLW 0x4
07C2  0674     XORWF n, W
07C3  00F6     MOVWF handle
07C4  3000     MOVLW 0x0
07C5  0675     XORWF EPNum, W
07C6  00F7     MOVWF options
07C7  3578     LSLF ep, W
07C8  3EB0     ADDLW 0xB0
07C9  0086     MOVWF FSR1
07CA  0187     CLRF FSR1H
07CB  0876     MOVF handle, W
07CC  3FC0     MOVWI 0[FSR1]
07CD  0877     MOVF options, W
07CE  3FC1     MOVWI 1[FSR1]
1044:              }
07CF  2FE8     GOTO 0x7E8
1045:              else
1046:              {
1047:                  //toggle over the to the next buffer for an OUT endpoint
1048:                  pBDTEntryOut[ep] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryOut[ep]) ^ USB_NEXT_PING_PONG);
07D0  3578     LSLF ep, W
07D1  3EA0     ADDLW 0xA0
07D2  0086     MOVWF FSR1
07D3  3001     MOVLW 0x1
07D4  0087     MOVWF FSR1H
07D5  3F40     MOVIW 0[FSR1]
07D6  00F4     MOVWF n
07D7  3F41     MOVIW 1[FSR1]
07D8  00F5     MOVWF EPNum
07D9  3004     MOVLW 0x4
07DA  0674     XORWF n, W
07DB  00F6     MOVWF handle
07DC  3000     MOVLW 0x0
07DD  0675     XORWF EPNum, W
07DE  00F7     MOVWF options
07DF  3578     LSLF ep, W
07E0  3EA0     ADDLW 0xA0
07E1  0086     MOVWF FSR1
07E2  3001     MOVLW 0x1
07E3  0087     MOVWF FSR1H
07E4  0876     MOVF handle, W
07E5  3FC0     MOVWI 0[FSR1]
07E6  0877     MOVF options, W
07E7  3FC1     MOVWI 1[FSR1]
1049:              }
1050:              return (USB_HANDLE)handle;
07E8  087A     MOVF k, W
07E9  00F1     MOVWF p
07EA  0879     MOVF handle, W
07EB  00F0     MOVWF __pcstackCOMMON
1051:          }
07EC  0008     RETURN
1052:          
1053:          
1054:          /********************************************************************
1055:              Function:
1056:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1057:          
1058:              Summary:
1059:                   Configures the specified endpoint to send STALL to the host, the next
1060:                   time the host tries to access the endpoint.
1061:          
1062:              PreCondition:
1063:                  None
1064:          
1065:              Parameters:
1066:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1067:                  uint8_t dir - The direction of the endpoint to STALL, either
1068:                             IN_TO_HOST or OUT_FROM_HOST.
1069:          
1070:              Return Values:
1071:                  None
1072:          
1073:              Remarks:
1074:                  None
1075:          
1076:           *******************************************************************/
1077:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
1078:          {
1079:              BDT_ENTRY *p;
1080:          
1081:              if(ep == 0)
1082:              {
1083:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1084:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP
1085:                  //packet that will arrive.
1086:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1087:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1088:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1089:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1090:                  pBDTEntryIn[0]->STAT.Val = _BSTALL;
1091:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1092:          
1093:              }
1094:              else
1095:              {
1096:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
1097:                  p->STAT.Val |= _BSTALL;
1098:                  p->STAT.Val |= _USIE;
1099:          
1100:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1101:                  //then stall that entry as well
1102:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1103:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
1104:                  p->STAT.Val |= _BSTALL;
1105:                  p->STAT.Val |= _USIE;
1106:                  #endif
1107:              }
1108:          }
1109:          
1110:          /**************************************************************************
1111:              Function:
1112:                  void USBCancelIO(uint8_t endpoint)
1113:          
1114:              Description:
1115:                  This function cancels the transfers pending on the specified endpoint.
1116:                  This function can only be used after a SETUP packet is received and
1117:                  before that setup packet is handled.  This is the time period in which
1118:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1119:                  returns to the stack.
1120:          
1121:              Precondition:
1122:          
1123:              Parameters:
1124:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1125:          
1126:              Return Values:
1127:                  None
1128:          
1129:              Remarks:
1130:                  None
1131:          
1132:            **************************************************************************/
1133:          void USBCancelIO(uint8_t endpoint)
1134:          {
1135:              if(USBPacketDisable == 1)
1136:              {
1137:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1138:              	//to mess with the BDT right now.
1139:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1140:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1141:          
1142:              	//Need to do additional handling if ping-pong buffering is being used
1143:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1144:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1145:                  //(either due to SIE clearing it after a transaction, or the firmware
1146:                  //clearing it) makes hardware ping pong pointer advance.
1147:                  pBDTEntryIn[endpoint] = (BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[endpoint]) ^ USB_NEXT_PING_PONG);
1148:          
1149:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1150:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1151:                  #endif
1152:              }
1153:          }
1154:          
1155:          /**************************************************************************
1156:              Function:
1157:                  void USBDeviceDetach(void)
1158:          
1159:              Summary:
1160:                  This function configures the USB module to "soft detach" itself from
1161:                  the USB host.
1162:          
1163:              Description:
1164:                  This function configures the USB module to perform a "soft detach"
1165:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1166:                  lets the host know the device is present and attached.  This will make
1167:                  the host think that the device has been unplugged.  This is potentially
1168:                  useful, as it allows the USB device to force the host to re-enumerate
1169:                  the device (on the firmware has re-enabled the USB module/pull up, by
1170:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1171:          
1172:              Precondition:
1173:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1174:                  section if USB_POLLING mode option is being used (usb_config.h option).
1175:          
1176:                  Additionally, this function should only be called from the main() loop
1177:                  context.  Do not call this function from within an interrupt handler, as
1178:                  this function may modify global interrupt enable bits and settings.
1179:          
1180:              Parameters:
1181:                  None
1182:          
1183:              Return Values:
1184:                  None
1185:          
1186:              Remarks:
1187:                  If the application firmware calls USBDeviceDetach(), it is strongly
1188:                  recommended that the firmware wait at least >= 80ms before calling
1189:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1190:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1191:                  hosts may interpret this as an unexpected "glitch" rather than as a
1192:                  physical removal/re-attachment of the USB device.  In this case the host
1193:                  may simply ignore the event without re-enumerating the device.  To
1194:                  ensure that the host properly detects and processes the device soft
1195:                  detach/re-attach, it is recommended to make sure the device remains
1196:                  detached long enough to mimic a real human controlled USB
1197:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1198:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1199:          
1200:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1201:                  or take long to execute.  It is the application firmwares
1202:                  responsibility for adding the 80+ms delay, when using these API
1203:                  functions.
1204:          
1205:                  Note: The Windows plug and play event handler processing is fairly
1206:                  slow, especially in certain versions of Windows, and for certain USB
1207:                  device classes.  It has been observed that some device classes need to
1208:                  provide even more USB detach dwell interval (before calling
1209:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1210:                  If the USB device is a CDC class device, it is recommended to wait
1211:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1212:                  to provide the plug and play event handler enough time to finish
1213:                  processing the removal event, before the re-attach occurs.
1214:          
1215:                  If the application is using the USB_POLLING mode option, then the
1216:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.
1217:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO"
1218:                  and "#define USB_BUS_SENSE" options in the
1219:                  HardwareProfile  [platform name].h file.
1220:          
1221:                  When using the USB_POLLING mode option, and the
1222:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then
1223:                  the USB stack assumes that it should always enable the USB module at
1224:                  pretty much all times.  Basically, anytime the application firmware
1225:                  calls USBDeviceTasks(), the firmware will automatically enable the USB
1226:                  module.  This mode would typically be selected if the application was
1227:                  designed to be a purely bus powered device.  In this case, the
1228:                  application is powered from the +5V VBUS supply from the USB port, so
1229:                  it is correct and sensible in this type of application to power up and
1230:                  turn on the USB module, at anytime that the microcontroller is
1231:                  powered (which implies the USB cable is attached and the host is also
1232:                  powered).
1233:          
1234:                  In a self powered application, the USB stack is designed with the
1235:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO"
1236:                  option in the HardwareProfile  [platform name].h file.  When this
1237:                  option is defined, then the USBDeviceTasks() function will automatically
1238:                  check the I/O pin port value of the designated pin (based on the
1239:                  #define USB_BUS_SENSE option in the HardwareProfile  [platform name].h
1240:                  file), every time the application calls USBDeviceTasks().  If the
1241:                  USBDeviceTasks() function is executed and finds that the pin defined by
1242:                  the #define USB_BUS_SENSE is in a logic low state, then it will
1243:                  automatically disable the USB module and tri-state the D+ and D- pins.
1244:                  If however the USBDeviceTasks() function is executed and finds the pin
1245:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it
1246:                  will automatically enable the USB module, if it has not already been
1247:                  enabled.
1248:          
1249:            **************************************************************************/
1250:          #if defined(USB_INTERRUPT)
1251:          void USBDeviceDetach(void)
1252:          {
1253:              //If the interrupt option is selected then the customer is required
1254:              //  to notify the stack when the device is attached or removed from the
1255:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1256:          #ifdef USB_SUPPORT_OTG
1257:              if (USB_BUS_SENSE != 1)
1258:          #endif
1259:              {
1260:                   // Disable module & detach from bus
1261:                   U1CON = 0;
1262:          
1263:                   // Mask all USB interrupts
1264:                   U1IE = 0;
1265:          
1266:                   //Move to the detached state
1267:                   USBDeviceState = DETACHED_STATE;
1268:          
1269:                   #ifdef  USB_SUPPORT_OTG
1270:                       //Disable D+ Pull-up
1271:                       U1OTGCONbits.DPPULUP = 0;
1272:          
1273:                       //Disable HNP
1274:                       USBOTGDisableHnp();
1275:          
1276:                       //Deactivate HNP
1277:                       USBOTGDeactivateHnp();
1278:          
1279:                       //If ID Pin Changed State
1280:                       if (USBIDIF && USBIDIE)
1281:                       {
1282:                           //Re-detect & Initialize
1283:                            USBOTGInitialize();
1284:          
1285:                            //Clear ID Interrupt Flag
1286:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1287:                       }
1288:                   #endif
1289:          
1290:                   #if defined __C30__ || defined __XC16__
1291:                       //USBClearInterruptFlag(U1OTGIR, 3);
1292:                   #endif
1293:                      //return so that we don't go through the rest of
1294:                      //the state machine
1295:                    return;
1296:              }
1297:          
1298:          #ifdef USB_SUPPORT_OTG
1299:              //If Session Is Started Then
1300:             else
1301:             {
1302:                  //If SRP Is Ready
1303:                  if (USBOTGSRPIsReady())
1304:                  {
1305:                      //Clear SRPReady
1306:                      USBOTGClearSRPReady();
1307:          
1308:                      //Clear SRP Timeout Flag
1309:                      USBOTGClearSRPTimeOutFlag();
1310:          
1311:                      //Indicate Session Started
1312:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1313:                  }
1314:              }
1315:          #endif
1316:          }
1317:          #endif  //#if defined(USB_INTERRUPT)
1318:          /**************************************************************************
1319:              Function:
1320:                  void USBDeviceAttach(void)
1321:          
1322:              Summary:
1323:                  Checks if VBUS is present, and that the USB module is not already
1324:                  initialized, and if so, enables the USB module so as to signal device
1325:                  attachment to the USB host.
1326:          
1327:              Description:
1328:                  This function indicates to the USB host that the USB device has been
1329:                  attached to the bus.  This function needs to be called in order for the
1330:                  device to start to enumerate on the bus.
1331:          
1332:              Precondition:
1333:                  Should only be called when USB_INTERRUPT is defined.  Also, should only
1334:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1335:                  from within an interrupt handler, as the USBDeviceAttach() function
1336:                  may modify global interrupt enable bits and settings.
1337:          
1338:                  For normal USB devices:
1339:                  Make sure that if the module was previously on, that it has been turned off
1340:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1341:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1342:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes
1343:                  reject this event, since no human could ever unplug and re-attach a USB device in a
1344:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind
1345:                  of glitch and ignore the event altogether.
1346:              Parameters:
1347:                  None
1348:          
1349:              Return Values:
1350:                  None
1351:          
1352:              Remarks:
1353:          		See also the USBDeviceDetach() API function documentation.
1354:          ****************************************************************************/
1355:          #if defined(USB_INTERRUPT)
1356:          void USBDeviceAttach(void)
1357:          {
1358:              //if we are in the detached state
1359:              if(USBDeviceState == DETACHED_STATE)
1360:              {
1361:                  if(USB_BUS_SENSE == 1)
1362:                  {
1363:              	    //Initialize registers to known states.
1364:                      U1CON = 0;
1365:          
1366:                      // Mask all USB interrupts
1367:                      U1IE = 0;
1368:          
1369:                      //Configure things like: pull ups, full/low-speed mode,
1370:                      //set the ping pong mode, and set internal transceiver
1371:                      SetConfigurationOptions();
1372:          
1373:                      USBEnableInterrupts();  //Modifies global interrupt settings
1374:          
1375:                      // Enable module & attach to bus
1376:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1377:          
1378:                      //moved to the attached state
1379:                      USBDeviceState = ATTACHED_STATE;
1380:          
1381:                      #ifdef  USB_SUPPORT_OTG
1382:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;
1383:                      #endif
1384:                  }
1385:              }
1386:          }
1387:          #endif  //#if defined(USB_INTERRUPT)
1388:          
1389:          
1390:          /*******************************************************************************
1391:            Function: void USBCtrlEPAllowStatusStage(void);
1392:          
1393:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1394:                      (based on the controlTransferState) to allow the status stage packet
1395:                      of a control transfer to complete.  This function gets used
1396:                      internally by the USB stack itself, but it may also be called from
1397:                      the application firmware, IF the application firmware called
1398:                      the USBDeferStatusStage() function during the initial processing
1399:                      of the control transfer request.  In this case, the application
1400:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1401:                      completed processing and handling the data stage portion of the
1402:                      request.
1403:          
1404:                      If the application firmware has no need for delaying control
1405:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1406:                      application firmware should not call USBCtrlEPAllowStatusStage().
1407:          
1408:            Description:
1409:          
1410:            Conditions:
1411:              None
1412:          
1413:            Input:
1414:          
1415:            Return:
1416:          
1417:            Remarks:
1418:              None
1419:            *****************************************************************************/
1420:          void USBCtrlEPAllowStatusStage(void)
1421:          {
1422:              //Check and set two flags, prior to actually modifying any BDT entries.
1423:              //This double checking is necessary to make certain that
1424:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once
1425:              //in main loop context, while simultaneously getting an interrupt which
1426:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1427:              if(USBStatusStageEnabledFlag1 == false)
0BD4  0021     MOVLB 0x1
0BD5  0848     MOVF USBStatusStageEnabledFlag1, W
0BD6  1D03     BTFSS STATUS, 0x2
0BD7  2BD9     GOTO 0x3D9
0BD8  2BDA     GOTO 0x3DA
0BD9  2C45     GOTO 0x445
1428:              {
1429:                  USBStatusStageEnabledFlag1 = true;
0BDA  3001     MOVLW 0x1
0BDB  00F0     MOVWF 0xF0
0BDC  0870     MOVF 0xF0, W
0BDD  00C8     MOVWF USBStatusStageEnabledFlag1
1430:                  if(USBStatusStageEnabledFlag2 == false)
0BDE  0847     MOVF USBStatusStageEnabledFlag2, W
0BDF  1D03     BTFSS STATUS, 0x2
0BE0  2BE2     GOTO 0x3E2
0BE1  2BE3     GOTO 0x3E3
0BE2  2C45     GOTO 0x445
1431:                  {
1432:                      USBStatusStageEnabledFlag2 = true;
0BE3  3001     MOVLW 0x1
0BE4  00F0     MOVWF 0xF0
0BE5  0870     MOVF 0xF0, W
0BE6  00C7     MOVWF USBStatusStageEnabledFlag2
1433:          
1434:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1435:                      //stage), based on the type of control transfer currently pending.
1436:                      if(controlTransferState == CTRL_TRF_RX)
0BE7  3002     MOVLW 0x2
0BE8  0650     XORWF controlTransferState, W
0BE9  1D03     BTFSS STATUS, 0x2
0BEA  2BEC     GOTO 0x3EC
0BEB  2BED     GOTO 0x3ED
0BEC  2BFF     GOTO 0x3FF
1437:                      {
1438:                          pBDTEntryIn[0]->CNT = 0;
0BED  0830     MOVF pBDTEntryIn, W
0BEE  0086     MOVWF FSR1L
0BEF  0831     MOVF 0xB1, W
0BF0  0087     MOVWF FSR1H
0BF1  3141     ADDFSR 1, 1
0BF2  0181     CLRF INDF1
1439:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0BF3  0830     MOVF pBDTEntryIn, W
0BF4  0086     MOVWF FSR1L
0BF5  0831     MOVF 0xB1, W
0BF6  0087     MOVWF FSR1H
0BF7  3048     MOVLW 0x48
0BF8  0081     MOVWF INDF1
1440:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0BF9  0830     MOVF pBDTEntryIn, W
0BFA  0086     MOVWF FSR1L
0BFB  0831     MOVF 0xB1, W
0BFC  0087     MOVWF FSR1H
0BFD  1781     BSF INDF1, 0x7
1441:                      }
0BFE  2C45     GOTO 0x445
1442:                      else if(controlTransferState == CTRL_TRF_TX)
0BFF  0350     DECF controlTransferState, W
0C00  1D03     BTFSS STATUS, 0x2
0C01  2C03     GOTO 0x403
0C02  2C04     GOTO 0x404
0C03  2C45     GOTO 0x445
1443:                      {
1444:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
0C04  01CB     CLRF BothEP0OutUOWNsSet
1445:          
1446:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1447:                          //next SETUP packet.
1448:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1449:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
0C05  3008     MOVLW 0x8
0C06  00F0     MOVWF 0xF0
0C07  0A52     INCF pBDTEntryEP0OutCurrent, W
0C08  0086     MOVWF FSR1L
0C09  0187     CLRF FSR1H
0C0A  0870     MOVF 0xF0, W
0C0B  0081     MOVWF INDF1
1450:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
0C0C  3060     MOVLW 0x60
0C0D  00F0     MOVWF 0xF0
0C0E  3000     MOVLW 0x0
0C0F  00F1     MOVWF 0xF1
0C10  0852     MOVF pBDTEntryEP0OutCurrent, W
0C11  3E02     ADDLW 0x2
0C12  0086     MOVWF FSR1L
0C13  0187     CLRF FSR1H
0C14  0870     MOVF 0xF0, W
0C15  3FC0     MOVWI 0[FSR1]
0C16  0871     MOVF 0xF1, W
0C17  3FC1     MOVWI 1[FSR1]
1451:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
0C18  3004     MOVLW 0x4
0C19  00F0     MOVWF 0xF0
0C1A  0852     MOVF pBDTEntryEP0OutCurrent, W
0C1B  0086     MOVWF FSR1L
0C1C  0187     CLRF FSR1H
0C1D  0870     MOVF 0xF0, W
0C1E  0081     MOVWF INDF1
1452:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
0C1F  0852     MOVF pBDTEntryEP0OutCurrent, W
0C20  0086     MOVWF FSR1L
0C21  0187     CLRF FSR1H
0C22  1781     BSF INDF1, 0x7
1453:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
0C23  01CB     CLRF BothEP0OutUOWNsSet
0C24  0ACB     INCF BothEP0OutUOWNsSet, F
1454:                          #endif
1455:          
1456:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1457:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0C25  083F     MOVF pBDTEntryEP0OutNext, W
0C26  3E01     ADDLW 0x1
0C27  00F0     MOVWF 0xF0
0C28  3000     MOVLW 0x0
0C29  3D40     ADDWFC 0xC0, W
0C2A  00F1     MOVWF 0xF1
0C2B  0870     MOVF 0xF0, W
0C2C  0086     MOVWF FSR1L
0C2D  0871     MOVF 0xF1, W
0C2E  0087     MOVWF FSR1H
0C2F  3008     MOVLW 0x8
0C30  0081     MOVWF INDF1
1458:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0C31  3060     MOVLW 0x60
0C32  00F0     MOVWF 0xF0
0C33  3000     MOVLW 0x0
0C34  00F1     MOVWF 0xF1
0C35  083F     MOVF pBDTEntryEP0OutNext, W
0C36  0086     MOVWF FSR1L
0C37  0840     MOVF 0xC0, W
0C38  0087     MOVWF FSR1H
0C39  3142     ADDFSR 1, 2
0C3A  0870     MOVF 0xF0, W
0C3B  3FC0     MOVWI 0[FSR1]
0C3C  0871     MOVF 0xF1, W
0C3D  3FC1     MOVWI 1[FSR1]
1459:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
0C3E  083F     MOVF pBDTEntryEP0OutNext, W
0C3F  0086     MOVWF FSR1L
0C40  0840     MOVF 0xC0, W
0C41  0087     MOVWF FSR1H
0C42  3080     MOVLW 0x80
0C43  0081     MOVWF INDF1
0C44  2C45     GOTO 0x445
1460:                      }
1461:                  }
1462:              }
1463:          }
0C45  0008     RETURN
1464:          
1465:          
1466:          /*******************************************************************************
1467:            Function: void USBCtrlEPAllowDataStage(void);
1468:          
1469:            Summary: This function allows the data stage of either a host-to-device or
1470:                      device-to-host control transfer (with data stage) to complete.
1471:                      This function is meant to be used in conjunction with either the
1472:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1473:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1474:                      then the firmware does not need to manually call
1475:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1476:                      instead.
1477:          
1478:            Description:
1479:          
1480:            Conditions: A control transfer (with data stage) should already be pending,
1481:                          if the firmware calls this function.  Additionally, the firmware
1482:                          should have called either USBDeferOUTDataStage() or
1483:                          USBDeferINDataStage() at the start of the control transfer, if
1484:                          the firmware will be calling this function manually.
1485:          
1486:            Input:
1487:          
1488:            Return:
1489:          
1490:            Remarks:
1491:            *****************************************************************************/
1492:          void USBCtrlEPAllowDataStage(void)
1493:          {
1494:              USBDeferINDataStagePackets = false;
0AA5  0021     MOVLB 0x1
0AA6  01C6     CLRF USBDeferINDataStagePackets
1495:              USBDeferOUTDataStagePackets = false;
0AA7  01C5     CLRF USBDeferOUTDataStagePackets
1496:          
1497:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
0AA8  3002     MOVLW 0x2
0AA9  0650     XORWF controlTransferState, W
0AAA  1D03     BTFSS STATUS, 0x2
0AAB  2AAD     GOTO 0x2AD
0AAC  2AAE     GOTO 0x2AE
0AAD  2AD3     GOTO 0x2D3
1498:              {
1499:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1500:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0AAE  083F     MOVF pBDTEntryEP0OutNext, W
0AAF  3E01     ADDLW 0x1
0AB0  00F3     MOVWF 0xF3
0AB1  3000     MOVLW 0x0
0AB2  3D40     ADDWFC 0xC0, W
0AB3  00F4     MOVWF 0xF4
0AB4  0873     MOVF 0xF3, W
0AB5  0086     MOVWF FSR1L
0AB6  0874     MOVF 0xF4, W
0AB7  0087     MOVWF FSR1H
0AB8  3008     MOVLW 0x8
0AB9  0081     MOVWF INDF1
1501:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0ABA  3068     MOVLW 0x68
0ABB  00F3     MOVWF 0xF3
0ABC  3000     MOVLW 0x0
0ABD  00F4     MOVWF 0xF4
0ABE  083F     MOVF pBDTEntryEP0OutNext, W
0ABF  0086     MOVWF FSR1L
0AC0  0840     MOVF 0xC0, W
0AC1  0087     MOVWF FSR1H
0AC2  3142     ADDFSR 1, 2
0AC3  0873     MOVF 0xF3, W
0AC4  3FC0     MOVWI 0[FSR1]
0AC5  0874     MOVF 0xF4, W
0AC6  3FC1     MOVWI 1[FSR1]
1502:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0AC7  083F     MOVF pBDTEntryEP0OutNext, W
0AC8  0086     MOVWF FSR1L
0AC9  0840     MOVF 0xC0, W
0ACA  0087     MOVWF FSR1H
0ACB  3048     MOVLW 0x48
0ACC  0081     MOVWF INDF1
1503:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0ACD  083F     MOVF pBDTEntryEP0OutNext, W
0ACE  0086     MOVWF FSR1L
0ACF  0840     MOVF 0xC0, W
0AD0  0087     MOVWF FSR1H
0AD1  1781     BSF INDF1, 0x7
1504:              }
0AD2  2B03     GOTO 0x303
1505:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1506:              {
1507:                  //Error check the data stage byte count.  Make sure the user specified
1508:                  //value was no greater than the number of bytes the host requested.
1509:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
0AD3  083C     MOVF 0xBC, W
0AD4  0020     MOVLB 0x0
0AD5  0267     SUBWF 0x67, W
0AD6  1D03     BTFSS STATUS, 0x2
0AD7  2ADC     GOTO 0x2DC
0AD8  0021     MOVLB 0x1
0AD9  083B     MOVF 0xBB, W
0ADA  0020     MOVLB 0x0
0ADB  0266     SUBWF 0x66, W
0ADC  1803     BTFSC STATUS, 0x0
0ADD  2ADF     GOTO 0x2DF
0ADE  2AE0     GOTO 0x2E0
0ADF  2AE7     GOTO 0x2E7
1510:          		{
1511:          			inPipes[0].wCount.Val = SetupPkt.wLength;
0AE0  0867     MOVF 0x67, W
0AE1  0021     MOVLB 0x1
0AE2  00BC     MOVWF 0xBC
0AE3  0020     MOVLB 0x0
0AE4  0866     MOVF 0x66, W
0AE5  0021     MOVLB 0x1
0AE6  00BB     MOVWF 0xBB
1512:          		}
1513:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
0AE7  318C     MOVLP 0xC
0AE8  2446     CALL 0x446
0AE9  318A     MOVLP 0xA
1514:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1515:          
1516:          	    //Cnt should have been initialized by responsible request owner (ex: by
1517:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1518:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0AEA  3068     MOVLW 0x68
0AEB  00F3     MOVWF 0xF3
0AEC  3000     MOVLW 0x0
0AED  00F4     MOVWF 0xF4
0AEE  0021     MOVLB 0x1
0AEF  0830     MOVF pBDTEntryIn, W
0AF0  0086     MOVWF FSR1L
0AF1  0831     MOVF 0xB1, W
0AF2  0087     MOVWF FSR1H
0AF3  3142     ADDFSR 1, 2
0AF4  0873     MOVF 0xF3, W
0AF5  3FC0     MOVWI 0[FSR1]
0AF6  0874     MOVF 0xF4, W
0AF7  3FC1     MOVWI 1[FSR1]
1519:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0AF8  0830     MOVF pBDTEntryIn, W
0AF9  0086     MOVWF FSR1L
0AFA  0831     MOVF 0xB1, W
0AFB  0087     MOVWF FSR1H
0AFC  3048     MOVLW 0x48
0AFD  0081     MOVWF INDF1
1520:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
0AFE  0830     MOVF pBDTEntryIn, W
0AFF  0086     MOVWF FSR1L
0B00  0831     MOVF 0xB1, W
0B01  0087     MOVWF FSR1H
0B02  1781     BSF INDF1, 0x7
1521:              }
1522:          }
0B03  0008     RETURN
1523:          
1524:          
1525:          /******************************************************************************/
1526:          /** Internal Functions *********************************************************/
1527:          /******************************************************************************/
1528:          
1529:          /********************************************************************
1530:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1531:           *
1532:           * PreCondition:    None
1533:           *
1534:           * Input:           uint8_t EPNum - the endpoint to be configured
1535:           *                  uint8_t direction - the direction to be configured
1536:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1537:           *
1538:           * Output:          None
1539:           *
1540:           * Side Effects:    None
1541:           *
1542:           * Overview:        This function will configure the specified
1543:           *                  endpoint
1544:           *
1545:           * Note:            None
1546:           *******************************************************************/
1547:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
0980  00F5     MOVWF 0xF5
1548:          {
1549:              volatile BDT_ENTRY* handle;
1550:          
1551:              //Compute a pointer to the even BDT entry corresponding to the
1552:              //EPNum and direction values passed to this function.
1553:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
0981  3020     MOVLW 0x20
0982  00F1     MOVWF 0xF1
0983  0871     MOVF 0xF1, W
0984  00F6     MOVWF 0xF6
1554:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
0985  0870     MOVF 0xF0, W
0986  00F1     MOVWF 0xF1
0987  3001     MOVLW 0x1
0988  35F1     LSLF 0xF1, F
0989  0B89     DECFSZ WREG, F
098A  2988     GOTO 0x188
098B  0875     MOVF 0xF5, W
098C  00F2     MOVWF 0xF2
098D  3001     MOVLW 0x1
098E  35F2     LSLF 0xF2, F
098F  3EFF     ADDLW 0xFF
0990  1D03     BTFSS STATUS, 0x2
0991  298E     GOTO 0x18E
0992  3572     LSLF 0xF2, W
0993  0771     ADDWF 0xF1, W
0994  00F3     MOVWF 0xF3
0995  3001     MOVLW 0x1
0996  35F3     LSLF 0xF3, F
0997  3EFF     ADDLW 0xFF
0998  1D03     BTFSS STATUS, 0x2
0999  2996     GOTO 0x196
099A  3573     LSLF 0xF3, W
099B  00F4     MOVWF 0xF4
099C  0874     MOVF 0xF4, W
099D  07F6     ADDWF 0xF6, F
1555:          
1556:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler()
099E  0876     MOVF 0xF6, W
099F  0086     MOVWF FSR1L
09A0  0187     CLRF FSR1H
09A1  1381     BCF INDF1, 0x7
1557:              //already cleared the entire BDT table
1558:          
1559:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1560:              //for USBTransferOnePacket() API calls.
1561:              if(direction == OUT_FROM_HOST)
09A2  0870     MOVF 0xF0, W
09A3  1D03     BTFSS STATUS, 0x2
09A4  29A6     GOTO 0x1A6
09A5  29A7     GOTO 0x1A7
09A6  29B1     GOTO 0x1B1
1562:              {
1563:                  pBDTEntryOut[EPNum] = handle;
09A7  3575     LSLF 0xF5, W
09A8  3EA0     ADDLW 0xA0
09A9  0086     MOVWF FSR1L
09AA  3001     MOVLW 0x1
09AB  0087     MOVWF FSR1H
09AC  0876     MOVF 0xF6, W
09AD  3FC0     MOVWI 0[FSR1]
09AE  3000     MOVLW 0x0
09AF  3FC1     MOVWI 1[FSR1]
1564:              }
09B0  29B9     GOTO 0x1B9
1565:              else
1566:              {
1567:                  pBDTEntryIn[EPNum] = handle;
09B1  3575     LSLF 0xF5, W
09B2  3EB0     ADDLW 0xB0
09B3  0086     MOVWF FSR1L
09B4  0187     CLRF FSR1H
09B5  0876     MOVF 0xF6, W
09B6  3FC0     MOVWI 0[FSR1]
09B7  3000     MOVLW 0x0
09B8  3FC1     MOVWI 1[FSR1]
1568:              }
1569:          
1570:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1571:                  handle->STAT.DTS = 0;
09B9  0876     MOVF 0xF6, W
09BA  0086     MOVWF FSR1L
09BB  0187     CLRF FSR1H
09BC  1301     BCF INDF1, 0x6
1572:                  (handle+1)->STAT.DTS = 1;
09BD  0876     MOVF 0xF6, W
09BE  3E04     ADDLW 0x4
09BF  0086     MOVWF FSR1L
09C0  0187     CLRF FSR1H
09C1  1701     BSF INDF1, 0x6
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1574:                  //Set DTS to one because the first thing we will do
1575:                  //when transmitting is toggle the bit
1576:                  handle->STAT.DTS = 1;
1577:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1578:                  if(EPNum != 0)
1579:                  {
1580:                      handle->STAT.DTS = 1;
1581:                  }
1582:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1583:                  if(EPNum != 0)
1584:                  {
1585:                      handle->STAT.DTS = 0;
1586:                      (handle+1)->STAT.DTS = 1;
1587:                  }
1588:              #endif
1589:          }
09C2  0008     RETURN
1590:          
1591:          
1592:          /******************************************************************************
1593:           * Function:        void USBCtrlEPServiceComplete(void)
1594:           *
1595:           * PreCondition:    None
1596:           *
1597:           * Input:           None
1598:           *
1599:           * Output:          None
1600:           *
1601:           * Side Effects:    None
1602:           *
1603:           * Overview:        This routine wrap up the remaining tasks in servicing
1604:           *                  a Setup Request. Its main task is to set the endpoint
1605:           *                  controls appropriately for a given situation. See code
1606:           *                  below.
1607:           *                  There are three main scenarios:
1608:           *                  a) There was no handler for the Request, in this case
1609:           *                     a STALL should be sent out.
1610:           *                  b) The host has requested a read control transfer,
1611:           *                     endpoints are required to be setup in a specific way.
1612:           *                  c) The host has requested a write control transfer, or
1613:           *                     a control data stage is not required, endpoints are
1614:           *                     required to be setup in a specific way.
1615:           *
1616:           *                  Packet processing is resumed by clearing PKTDIS bit.
1617:           *
1618:           * Note:            None
1619:           *****************************************************************************/
1620:          static void USBCtrlEPServiceComplete(void)
1621:          {
1622:              /*
1623:               * PKTDIS bit is set when a Setup Transaction is received.
1624:               * Clear to resume packet processing.
1625:               */
1626:              USBPacketDisable = 0;
0EBA  003D     MOVLB 0x1D
0EBB  120E     BCF UCON, 0x4
1627:          
1628:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1629:          	//control transfer is currently in progress.  We need to know the type of control
1630:          	//transfer that is currently pending, in order to know how to properly arm the
1631:          	//EP0 IN and EP0 OUT endpoints.
1632:              if(inPipes[0].info.bits.busy == 0)
0EBC  0021     MOVLB 0x1
0EBD  1BBA     BTFSC 0xBA, 0x7
0EBE  2EC0     GOTO 0x6C0
0EBF  2EC1     GOTO 0x6C1
0EC0  2F08     GOTO 0x708
1633:              {
1634:                  if(outPipes[0].info.bits.busy == 1)
0EC1  0022     MOVLB 0x2
0EC2  1FA2     BTFSS 0x122, 0x7
0EC3  2EC5     GOTO 0x6C5
0EC4  2EC6     GOTO 0x6C6
0EC5  2ED7     GOTO 0x6D7
1635:                  {
1636:                      controlTransferState = CTRL_TRF_RX;
0EC6  3002     MOVLW 0x2
0EC7  00F5     MOVWF 0x175
0EC8  0875     MOVF 0x175, W
0EC9  0021     MOVLB 0x1
0ECA  00D0     MOVWF controlTransferState
1637:                      /*
1638:                       * Control Write:
1639:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1640:                       */
1641:          
1642:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1643:                      //   function decided to defer the data stage (ex: because the intended
1644:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1645:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1646:                      //   once it is ready to begin receiving the data.
1647:                      if(USBDeferOUTDataStagePackets == false)
0ECB  0845     MOVF USBDeferOUTDataStagePackets, W
0ECC  1D03     BTFSS STATUS, 0x2
0ECD  2ECF     GOTO 0x6CF
0ECE  2ED0     GOTO 0x6D0
0ECF  2ED3     GOTO 0x6D3
1648:                      {
1649:                          USBCtrlEPAllowDataStage();
0ED0  318A     MOVLP 0xA
0ED1  22A5     CALL 0x2A5
0ED2  318E     MOVLP 0xE
1650:                      }
1651:          
1652:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage()
1653:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1654:                      USBStatusStageEnabledFlag2 = false;
0ED3  0021     MOVLB 0x1
0ED4  01C7     CLRF USBStatusStageEnabledFlag2
1655:                      USBStatusStageEnabledFlag1 = false;
0ED5  01C8     CLRF USBStatusStageEnabledFlag1
1656:                  }
0ED6  2F55     GOTO 0x755
1657:                  else
1658:                  {
1659:                      /*
1660:                       * If no one knows how to service this request then stall.
1661:                       * Must also prepare EP0 to receive the next SETUP transaction.
1662:                       */
1663:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0ED7  0021     MOVLB 0x1
0ED8  083F     MOVF pBDTEntryEP0OutNext, W
0ED9  3E01     ADDLW 0x1
0EDA  00F5     MOVWF 0xF5
0EDB  3000     MOVLW 0x0
0EDC  3D40     ADDWFC 0xC0, W
0EDD  00F6     MOVWF 0xF6
0EDE  0875     MOVF 0xF5, W
0EDF  0086     MOVWF FSR1L
0EE0  0876     MOVF 0xF6, W
0EE1  0087     MOVWF FSR1H
0EE2  3008     MOVLW 0x8
0EE3  0081     MOVWF INDF1
1664:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0EE4  3060     MOVLW 0x60
0EE5  00F5     MOVWF 0xF5
0EE6  3000     MOVLW 0x0
0EE7  00F6     MOVWF 0xF6
0EE8  083F     MOVF pBDTEntryEP0OutNext, W
0EE9  0086     MOVWF FSR1L
0EEA  0840     MOVF 0xC0, W
0EEB  0087     MOVWF FSR1H
0EEC  3142     ADDFSR 1, 2
0EED  0875     MOVF 0xF5, W
0EEE  3FC0     MOVWI 0[FSR1]
0EEF  0876     MOVF 0xF6, W
0EF0  3FC1     MOVWI 1[FSR1]
1665:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0EF1  083F     MOVF pBDTEntryEP0OutNext, W
0EF2  0086     MOVWF FSR1L
0EF3  0840     MOVF 0xC0, W
0EF4  0087     MOVWF FSR1H
0EF5  300C     MOVLW 0xC
0EF6  0081     MOVWF INDF1
1666:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0EF7  083F     MOVF pBDTEntryEP0OutNext, W
0EF8  0086     MOVWF FSR1L
0EF9  0840     MOVF 0xC0, W
0EFA  0087     MOVWF FSR1H
0EFB  1781     BSF INDF1, 0x7
1667:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0EFC  0830     MOVF pBDTEntryIn, W
0EFD  0086     MOVWF FSR1L
0EFE  0831     MOVF 0xB1, W
0EFF  0087     MOVWF FSR1H
0F00  3004     MOVLW 0x4
0F01  0081     MOVWF INDF1
1668:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0F02  0830     MOVF pBDTEntryIn, W
0F03  0086     MOVWF FSR1L
0F04  0831     MOVF 0xB1, W
0F05  0087     MOVWF FSR1H
0F06  1781     BSF INDF1, 0x7
0F07  2F55     GOTO 0x755
1669:                  }
1670:              }
1671:              else    // A module has claimed ownership of the control transfer session.
1672:              {
1673:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
0F08  0020     MOVLB 0x0
0F09  1FE0     BTFSS SetupPkt, 0x7
0F0A  2F0C     GOTO 0x70C
0F0B  2F0D     GOTO 0x70D
0F0C  2F24     GOTO 0x724
1674:          		{
1675:          			controlTransferState = CTRL_TRF_TX;
0F0D  0021     MOVLB 0x1
0F0E  01D0     CLRF controlTransferState
0F0F  0AD0     INCF controlTransferState, F
1676:          			/*
1677:          			 * Control Read:
1678:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1679:          			 *
1680:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1681:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1682:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1683:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1684:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1685:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1686:          			 *    is ready to begin sending the data, it should then call the
1687:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1688:          			 */
1689:          			if(USBDeferINDataStagePackets == false)
0F10  0846     MOVF USBDeferINDataStagePackets, W
0F11  1D03     BTFSS STATUS, 0x2
0F12  2F14     GOTO 0x714
0F13  2F15     GOTO 0x715
0F14  2F18     GOTO 0x718
1690:                      {
1691:                          USBCtrlEPAllowDataStage();
0F15  318A     MOVLP 0xA
0F16  22A5     CALL 0x2A5
0F17  318E     MOVLP 0xE
1692:          			}
1693:          
1694:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1695:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1696:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1697:                      //    is ready.  If the class request handler does this, it needs to be careful to
1698:                      //    be written so that it can handle the early termination scenario.
1699:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1700:                      //    1.  The desired total number of bytes were sent to the host.
1701:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that
1702:                      //        started the control transfer) has been reached.
1703:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless
1704:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1705:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1706:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1707:                      //        option can take care of this for you.
1708:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1709:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1710:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1711:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this
1712:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1713:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1714:                      USBStatusStageEnabledFlag2 = false;
0F18  0021     MOVLB 0x1
0F19  01C7     CLRF USBStatusStageEnabledFlag2
1715:                      USBStatusStageEnabledFlag1 = false;
0F1A  01C8     CLRF USBStatusStageEnabledFlag1
1716:                      if(USBDeferStatusStagePacket == false)
0F1B  0849     MOVF USBDeferStatusStagePacket, W
0F1C  1D03     BTFSS STATUS, 0x2
0F1D  2F1F     GOTO 0x71F
0F1E  2F20     GOTO 0x720
0F1F  2F55     GOTO 0x755
1717:                      {
1718:                          USBCtrlEPAllowStatusStage();
0F20  318B     MOVLP 0xB
0F21  23D4     CALL 0x3D4
0F22  318E     MOVLP 0xE
0F23  2F55     GOTO 0x755
1719:                      }
1720:          		}
1721:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1722:          		{
1723:          			//This situation occurs for special types of control transfers,
1724:          			//such as that which occurs when the host sends a SET_ADDRESS
1725:          			//control transfer.  Ex:
1726:          			//
1727:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1728:          
1729:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1730:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1731:          			//an IN status stage.
1732:          
1733:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
0F24  3002     MOVLW 0x2
0F25  00F5     MOVWF 0xF5
0F26  0875     MOVF 0xF5, W
0F27  0021     MOVLB 0x1
0F28  00D0     MOVWF controlTransferState
1734:          
1735:          			//1. Prepare OUT EP to receive the next SETUP packet.
1736:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0F29  083F     MOVF pBDTEntryEP0OutNext, W
0F2A  3E01     ADDLW 0x1
0F2B  00F5     MOVWF 0xF5
0F2C  3000     MOVLW 0x0
0F2D  3D40     ADDWFC 0xC0, W
0F2E  00F6     MOVWF 0xF6
0F2F  0875     MOVF 0xF5, W
0F30  0086     MOVWF FSR1L
0F31  0876     MOVF 0xF6, W
0F32  0087     MOVWF FSR1H
0F33  3008     MOVLW 0x8
0F34  0081     MOVWF INDF1
1737:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0F35  3060     MOVLW 0x60
0F36  00F5     MOVWF 0xF5
0F37  3000     MOVLW 0x0
0F38  00F6     MOVWF 0xF6
0F39  083F     MOVF pBDTEntryEP0OutNext, W
0F3A  0086     MOVWF FSR1L
0F3B  0840     MOVF 0xC0, W
0F3C  0087     MOVWF FSR1H
0F3D  3142     ADDFSR 1, 2
0F3E  0875     MOVF 0xF5, W
0F3F  3FC0     MOVWI 0[FSR1]
0F40  0876     MOVF 0xF6, W
0F41  3FC1     MOVWI 1[FSR1]
1738:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0F42  083F     MOVF pBDTEntryEP0OutNext, W
0F43  0086     MOVWF FSR1L
0F44  0840     MOVF 0xC0, W
0F45  0087     MOVWF FSR1H
0F46  3004     MOVLW 0x4
0F47  0081     MOVWF INDF1
1739:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0F48  083F     MOVF pBDTEntryEP0OutNext, W
0F49  0086     MOVWF FSR1L
0F4A  0840     MOVF 0xC0, W
0F4B  0087     MOVWF FSR1H
0F4C  1781     BSF INDF1, 0x7
1740:          
1741:          			//2. Prepare for IN status stage of the control transfer
1742:                      USBStatusStageEnabledFlag2 = false;
0F4D  01C7     CLRF USBStatusStageEnabledFlag2
1743:                      USBStatusStageEnabledFlag1 = false;
0F4E  01C8     CLRF USBStatusStageEnabledFlag1
1744:          			if(USBDeferStatusStagePacket == false)
0F4F  0849     MOVF USBDeferStatusStagePacket, W
0F50  1D03     BTFSS STATUS, 0x2
0F51  2F53     GOTO 0x753
0F52  2F54     GOTO 0x754
0F53  2F55     GOTO 0x755
0F54  2F20     GOTO 0x720
1745:                      {
1746:                          USBCtrlEPAllowStatusStage();
1747:                      }
1748:          		}
1749:          
1750:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1751:          
1752:          }//end USBCtrlEPServiceComplete
0F55  0008     RETURN
1753:          
1754:          
1755:          /******************************************************************************
1756:           * Function:        void USBCtrlTrfTxService(void)
1757:           *
1758:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1759:           *
1760:           * Input:           None
1761:           *
1762:           * Output:          None
1763:           *
1764:           * Side Effects:    None
1765:           *
1766:           * Overview:        This routine is used for device to host control transfers
1767:           *					(IN transactions).  This function takes care of managing a
1768:           *                  transfer over multiple USB transactions.
1769:           *					This routine should be called from only two places.
1770:           *                  One from USBCtrlEPServiceComplete() and one from
1771:           *                  USBCtrlTrfInHandler().
1772:           *
1773:           * Note:
1774:           *****************************************************************************/
1775:          static void USBCtrlTrfTxService(void)
1776:          {
1777:              uint8_t byteToSend;
1778:          
1779:              //Figure out how many bytes of data to send in the next IN transaction.
1780:              //Assume a full size packet, unless otherwise determined below.
1781:              byteToSend = USB_EP0_BUFF_SIZE;
0C46  3008     MOVLW 0x8
0C47  00F0     MOVWF 0xF0
0C48  0870     MOVF 0xF0, W
0C49  00F2     MOVWF 0xF2
1782:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
0C4A  3000     MOVLW 0x0
0C4B  0021     MOVLB 0x1
0C4C  023C     SUBWF 0xBC, W
0C4D  3008     MOVLW 0x8
0C4E  1903     BTFSC STATUS, 0x2
0C4F  023B     SUBWF 0xBB, W
0C50  1803     BTFSC STATUS, 0x0
0C51  2C53     GOTO 0x453
0C52  2C54     GOTO 0x454
0C53  2C69     GOTO 0x469
1783:              {
1784:                  byteToSend = (uint8_t)(inPipes[0].wCount.Val);
0C54  083B     MOVF 0xBB, W
0C55  00F0     MOVWF 0xF0
0C56  0870     MOVF 0xF0, W
0C57  00F2     MOVWF 0xF2
1785:          
1786:                  //Keep track of whether or not we have sent a "short packet" yet.
1787:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1788:                  //after we have sent all of the intended data.  This makes sure the
1789:                  //hardware STALLs if the host erroneously tries to send more IN token
1790:                  //packets, requesting more data than intended in the control transfer.
1791:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
0C58  0851     MOVF shortPacketStatus, W
0C59  1D03     BTFSS STATUS, 0x2
0C5A  2C5C     GOTO 0x45C
0C5B  2C5D     GOTO 0x45D
0C5C  2C60     GOTO 0x460
1792:                  {
1793:                      shortPacketStatus = SHORT_PKT_PENDING;
0C5D  01D1     CLRF shortPacketStatus
0C5E  0AD1     INCF shortPacketStatus, F
1794:                  }
0C5F  2C69     GOTO 0x469
1795:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
0C60  0351     DECF shortPacketStatus, W
0C61  1D03     BTFSS STATUS, 0x2
0C62  2C64     GOTO 0x464
0C63  2C65     GOTO 0x465
0C64  2C69     GOTO 0x469
1796:                  {
1797:                      shortPacketStatus = SHORT_PKT_SENT;
0C65  3002     MOVLW 0x2
0C66  00F0     MOVWF 0xF0
0C67  0870     MOVF 0xF0, W
0C68  00D1     MOVWF shortPacketStatus
1798:                  }
1799:              }
1800:          
1801:              //Keep track of how many bytes remain to be sent in the transfer, by
1802:              //subtracting the number of bytes about to be sent from the total.
1803:              inPipes[0].wCount.Val -= byteToSend;
0C69  0872     MOVF 0xF2, W
0C6A  00F0     MOVWF 0xF0
0C6B  01F1     CLRF 0xF1
0C6C  0870     MOVF 0xF0, W
0C6D  02BB     SUBWF 0xBB, F
0C6E  0871     MOVF 0xF1, W
0C6F  3BBC     SUBWFB 0xBC, F
1804:          
1805:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1806:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1807:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1808:              pBDTEntryIn[0]->CNT = byteToSend;
0C70  0830     MOVF pBDTEntryIn, W
0C71  3E01     ADDLW 0x1
0C72  00F0     MOVWF 0xF0
0C73  3000     MOVLW 0x0
0C74  3D31     ADDWFC 0xB1, W
0C75  00F1     MOVWF 0xF1
0C76  0870     MOVF 0xF0, W
0C77  0086     MOVWF FSR1L
0C78  0871     MOVF 0xF1, W
0C79  0087     MOVWF FSR1H
0C7A  0872     MOVF 0xF2, W
0C7B  0081     MOVWF INDF1
1809:          
1810:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1811:              //which we will send to the host.
1812:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
0C7C  3068     MOVLW 0x68
0C7D  00F0     MOVWF 0xF0
0C7E  0870     MOVF 0xF0, W
0C7F  00CF     MOVWF pDst
1813:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
0C80  183A     BTFSC 0xBA, 0x0
0C81  2C83     GOTO 0x483
0C82  2C84     GOTO 0x484
0C83  2CB5     GOTO 0x4B5
0C84  2C9A     GOTO 0x49A
1814:              {
1815:                  while(byteToSend)
0C9A  0872     MOVF 0xF2, W
0C9B  1D03     BTFSS STATUS, 0x2
0C9C  2C9E     GOTO 0x49E
0C9D  2C9F     GOTO 0x49F
0C9E  2C85     GOTO 0x485
0C9F  2CBA     GOTO 0x4BA
1816:                  {
1817:                      *pDst++ = *inPipes[0].pSrc.bRom++;
0C85  0838     MOVF inPipes, W
0C86  0084     MOVWF FSR0L
0C87  0839     MOVF 0xB9, W
0C88  0085     MOVWF FSR0H
0C89  0800     MOVF INDF0, W
0C8A  00F0     MOVWF 0xF0
0C8B  084F     MOVF pDst, W
0C8C  0086     MOVWF FSR1L
0C8D  0187     CLRF FSR1H
0C8E  0870     MOVF 0xF0, W
0C8F  0081     MOVWF INDF1
0C90  3001     MOVLW 0x1
0C91  07B8     ADDWF inPipes, F
0C92  3000     MOVLW 0x0
0C93  3DB9     ADDWFC 0xB9, F
0C94  3001     MOVLW 0x1
0C95  00F0     MOVWF 0xF0
0C96  0870     MOVF 0xF0, W
0C97  07CF     ADDWF pDst, F
1818:                      byteToSend--;
0C98  3001     MOVLW 0x1
0C99  02F2     SUBWF 0xF2, F
1819:                  }//end while(byte_to_send.Val)
1820:              }
1821:              else  // RAM
1822:              {
1823:                  while(byteToSend)
0CB5  0872     MOVF 0xF2, W
0CB6  1D03     BTFSS STATUS, 0x2
0CB7  2CB9     GOTO 0x4B9
0CB8  2CBA     GOTO 0x4BA
0CB9  2CA0     GOTO 0x4A0
1824:                  {
1825:                      *pDst++ = *inPipes[0].pSrc.bRam++;
0CA0  0838     MOVF inPipes, W
0CA1  0084     MOVWF FSR0L
0CA2  0839     MOVF 0xB9, W
0CA3  0085     MOVWF FSR0H
0CA4  0800     MOVF INDF0, W
0CA5  00F0     MOVWF 0xF0
0CA6  084F     MOVF pDst, W
0CA7  0086     MOVWF FSR1L
0CA8  0187     CLRF FSR1H
0CA9  0870     MOVF 0xF0, W
0CAA  0081     MOVWF INDF1
0CAB  3001     MOVLW 0x1
0CAC  07B8     ADDWF inPipes, F
0CAD  3000     MOVLW 0x0
0CAE  3DB9     ADDWFC 0xB9, F
0CAF  3001     MOVLW 0x1
0CB0  00F0     MOVWF 0xF0
0CB1  0870     MOVF 0xF0, W
0CB2  07CF     ADDWF pDst, F
1826:                      byteToSend--;
0CB3  3001     MOVLW 0x1
0CB4  02F2     SUBWF 0xF2, F
0CB5  0872     MOVF 0xF2, W
0CB6  1D03     BTFSS STATUS, 0x2
0CB7  2CB9     GOTO 0x4B9
0CB8  2CBA     GOTO 0x4BA
0CB9  2CA0     GOTO 0x4A0
1827:                  }//end while(byte_to_send.Val)
1828:              }//end if(usb_stat.ctrl_trf_mem == _const)
1829:          }//end USBCtrlTrfTxService
0CBA  0008     RETURN
1830:          
1831:          /******************************************************************************
1832:           * Function:        void USBCtrlTrfRxService(void)
1833:           *
1834:           * PreCondition:    pDst and wCount are setup properly.
1835:           *                  pSrc is always &CtrlTrfData
1836:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1837:           *                  wCount should be set to 0 at the start of each control
1838:           *                  transfer.
1839:           *
1840:           * Input:           None
1841:           *
1842:           * Output:          None
1843:           *
1844:           * Side Effects:    None
1845:           *
1846:           * Overview:        This routine is used for host to device control transfers
1847:           *					(uses OUT transactions).  This function receives the data that arrives
1848:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1849:           *					buffer.  Once the host has sent all the data it was intending
1850:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1851:           *					handler (unless it is NULL), so that it can be used by the
1852:           *					intended target firmware.
1853:           *
1854:           * Note:            None
1855:           *****************************************************************************/
1856:          static void USBCtrlTrfRxService(void)
1857:          {
1858:              uint8_t byteToRead;
1859:              uint8_t i;
1860:          
1861:              //Load byteToRead with the number of bytes the host just sent us in the
1862:              //last OUT transaction.
1863:              byteToRead = pBDTEntryEP0OutCurrent->CNT;
0F56  0021     MOVLB 0x1
0F57  0852     MOVF pBDTEntryEP0OutCurrent, W
0F58  0086     MOVWF FSR1L
0F59  0187     CLRF FSR1H
0F5A  3F41     MOVIW 1[FSR1]
0F5B  00F5     MOVWF 0xF5
1864:          
1865:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1866:              //of remaining bytes expected to be received from the host, in the control
1867:              //transfer.  First check to see if the host sent us more bytes than the
1868:              //application firmware was expecting to receive.
1869:              if(byteToRead > outPipes[0].wCount.Val)
0F5C  0875     MOVF 0xF5, W
0F5D  00F2     MOVWF 0xF2
0F5E  01F3     CLRF 0xF3
0F5F  0873     MOVF 0xF3, W
0F60  0022     MOVLB 0x2
0F61  0224     SUBWF 0x124, W
0F62  1D03     BTFSS STATUS, 0x2
0F63  2F66     GOTO 0x766
0F64  0872     MOVF 0x172, W
0F65  0223     SUBWF 0x123, W
0F66  1803     BTFSC STATUS, 0x0
0F67  2F69     GOTO 0x769
0F68  2F6A     GOTO 0x76A
0F69  2F6E     GOTO 0x76E
1870:              {
1871:                  byteToRead = (uint8_t)(outPipes[0].wCount.Val);
0F6A  0823     MOVF 0x123, W
0F6B  00F2     MOVWF 0x172
0F6C  0872     MOVF 0x172, W
0F6D  00F5     MOVWF 0x175
1872:              }
1873:              //Reduce the number of remaining bytes by the number we just received.
1874:              outPipes[0].wCount.Val -= byteToRead;
0F6E  0875     MOVF 0x175, W
0F6F  00F2     MOVWF 0x172
0F70  01F3     CLRF 0x173
0F71  0872     MOVF 0x172, W
0F72  02A3     SUBWF 0x123, F
0F73  0873     MOVF 0x173, W
0F74  3BA4     SUBWFB 0x124, F
1875:          
1876:              //Copy the OUT DATAx packet bytes that we just received from the host,
1877:              //into the user application buffer space.
1878:              for(i=0;i<byteToRead;i++)
0F75  01F4     CLRF 0x174
0F76  2F8A     GOTO 0x78A
1879:              {
1880:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
0F77  0874     MOVF 0x174, W
0F78  3E68     ADDLW 0x68
0F79  0086     MOVWF FSR1L
0F7A  0187     CLRF FSR1H
0F7B  0801     MOVF INDF1, W
0F7C  00F2     MOVWF 0x172
0F7D  0820     MOVF outPipes, W
0F7E  0086     MOVWF FSR1L
0F7F  0187     CLRF FSR1H
0F80  0872     MOVF 0x172, W
0F81  0081     MOVWF INDF1
0F82  3001     MOVLW 0x1
0F83  00F2     MOVWF 0x172
0F84  0872     MOVF 0x172, W
0F85  07A0     ADDWF outPipes, F
1881:              }//end while(byteToRead.Val)
0F86  3001     MOVLW 0x1
0F87  00F2     MOVWF 0x172
0F88  0872     MOVF 0x172, W
0F89  07F4     ADDWF 0x174, F
0F8A  0875     MOVF 0x175, W
0F8B  0274     SUBWF 0x174, W
0F8C  1C03     BTFSS STATUS, 0x0
0F8D  2F8F     GOTO 0x78F
0F8E  2F90     GOTO 0x790
0F8F  2F77     GOTO 0x777
1882:          
1883:              //If there is more data to receive, prepare EP0 OUT so that it can receive
1884:          	//the next packet in the sequence.
1885:              if(outPipes[0].wCount.Val > 0)
0F90  0823     MOVF 0x123, W
0F91  0424     IORWF 0x124, W
0F92  1903     BTFSC STATUS, 0x2
0F93  2F95     GOTO 0x795
0F94  2F96     GOTO 0x796
0F95  2FCF     GOTO 0x7CF
1886:              {
1887:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0F96  0021     MOVLB 0x1
0F97  083F     MOVF pBDTEntryEP0OutNext, W
0F98  3E01     ADDLW 0x1
0F99  00F2     MOVWF 0xF2
0F9A  3000     MOVLW 0x0
0F9B  3D40     ADDWFC 0xC0, W
0F9C  00F3     MOVWF 0xF3
0F9D  0872     MOVF 0xF2, W
0F9E  0086     MOVWF FSR1L
0F9F  0873     MOVF 0xF3, W
0FA0  0087     MOVWF FSR1H
0FA1  3008     MOVLW 0x8
0FA2  0081     MOVWF INDF1
1888:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
0FA3  3068     MOVLW 0x68
0FA4  00F2     MOVWF 0xF2
0FA5  3000     MOVLW 0x0
0FA6  00F3     MOVWF 0xF3
0FA7  083F     MOVF pBDTEntryEP0OutNext, W
0FA8  0086     MOVWF FSR1L
0FA9  0840     MOVF 0xC0, W
0FAA  0087     MOVWF FSR1H
0FAB  3142     ADDFSR 1, 2
0FAC  0872     MOVF 0xF2, W
0FAD  3FC0     MOVWI 0[FSR1]
0FAE  0873     MOVF 0xF3, W
0FAF  3FC1     MOVWI 1[FSR1]
1889:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
0FB0  0852     MOVF pBDTEntryEP0OutCurrent, W
0FB1  0086     MOVWF FSR1L
0FB2  0187     CLRF FSR1H
0FB3  1B01     BTFSC INDF1, 0x6
0FB4  2FB6     GOTO 0x7B6
0FB5  2FB7     GOTO 0x7B7
0FB6  2FC3     GOTO 0x7C3
1890:                  {
1891:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0FB7  083F     MOVF pBDTEntryEP0OutNext, W
0FB8  0086     MOVWF FSR1L
0FB9  0840     MOVF 0xC0, W
0FBA  0087     MOVWF FSR1H
0FBB  3048     MOVLW 0x48
0FBC  0081     MOVWF INDF1
1892:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FBD  083F     MOVF pBDTEntryEP0OutNext, W
0FBE  0086     MOVWF FSR1L
0FBF  0840     MOVF 0xC0, W
0FC0  0087     MOVWF FSR1H
0FC1  1781     BSF INDF1, 0x7
1893:                  }
0FC2  2FFF     GOTO 0x7FF
1894:                  else
1895:                  {
1896:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0FC3  083F     MOVF pBDTEntryEP0OutNext, W
0FC4  0086     MOVWF FSR1L
0FC5  0840     MOVF 0xC0, W
0FC6  0087     MOVWF FSR1H
0FC7  3008     MOVLW 0x8
0FC8  0081     MOVWF INDF1
1897:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FC9  083F     MOVF pBDTEntryEP0OutNext, W
0FCA  0086     MOVWF FSR1L
0FCB  0840     MOVF 0xC0, W
0FCC  0087     MOVWF FSR1H
0FCD  1781     BSF INDF1, 0x7
0FCE  2FFF     GOTO 0x7FF
1898:                  }
1899:              }
1900:              else
1901:              {
1902:          	    //We have received all OUT packets that we were expecting to
1903:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1904:          		//the next SETUP transaction that may arrive.
1905:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0FCF  0021     MOVLB 0x1
0FD0  083F     MOVF pBDTEntryEP0OutNext, W
0FD1  3E01     ADDLW 0x1
0FD2  00F2     MOVWF 0xF2
0FD3  3000     MOVLW 0x0
0FD4  3D40     ADDWFC 0xC0, W
0FD5  00F3     MOVWF 0xF3
0FD6  0872     MOVF 0xF2, W
0FD7  0086     MOVWF FSR1L
0FD8  0873     MOVF 0xF3, W
0FD9  0087     MOVWF FSR1H
0FDA  3008     MOVLW 0x8
0FDB  0081     MOVWF INDF1
1906:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0FDC  3060     MOVLW 0x60
0FDD  00F2     MOVWF 0xF2
0FDE  3000     MOVLW 0x0
0FDF  00F3     MOVWF 0xF3
0FE0  083F     MOVF pBDTEntryEP0OutNext, W
0FE1  0086     MOVWF FSR1L
0FE2  0840     MOVF 0xC0, W
0FE3  0087     MOVWF FSR1H
0FE4  3142     ADDFSR 1, 2
0FE5  0872     MOVF 0xF2, W
0FE6  3FC0     MOVWI 0[FSR1]
0FE7  0873     MOVF 0xF3, W
0FE8  3FC1     MOVWI 1[FSR1]
1907:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1908:                  //control transfers.  However, set BSTALL in case the host tries to send
1909:                  //more data than it claims it was going to send.
1910:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
0FE9  083F     MOVF pBDTEntryEP0OutNext, W
0FEA  0086     MOVWF FSR1L
0FEB  0840     MOVF 0xC0, W
0FEC  0087     MOVWF FSR1H
0FED  3004     MOVLW 0x4
0FEE  0081     MOVWF INDF1
1911:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0FEF  083F     MOVF pBDTEntryEP0OutNext, W
0FF0  0086     MOVWF FSR1L
0FF1  0840     MOVF 0xC0, W
0FF2  0087     MOVWF FSR1H
0FF3  1781     BSF INDF1, 0x7
1912:          
1913:          		//All data bytes for the host to device control write (OUT) have now been
1914:          		//received successfully.
1915:          		//Go ahead and call the user specified callback function, to use/consume
1916:          		//the control transfer data (ex: if the "void (*function)" parameter
1917:          		//was non-NULL when USBEP0Receive() was called).
1918:                  if(outPipes[0].pFunc != NULL)
1919:                  {
1920:                      #if defined(__XC8)
1921:                          //Special pragmas to suppress an expected/harmless warning
1922:                          //message when building with the XC8 compiler
1923:                          #pragma warning push
1924:                          #pragma warning disable 1088
1925:                          outPipes[0].pFunc();    //Call the user's callback function
1926:                          #pragma warning pop
1927:                      #else
1928:                          outPipes[0].pFunc();    //Call the user's callback function
1929:                      #endif
1930:                  }
1931:                  outPipes[0].info.bits.busy = 0;
0FF4  0022     MOVLB 0x2
0FF5  13A2     BCF 0x122, 0x7
1932:          
1933:                  //Ready to arm status stage IN transaction now, if the application
1934:                  //firmware has completed processing the request.  If it is still busy
1935:                  //and needs more time to finish handling the request, then the user
1936:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1937:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1938:                  //this case, it is the application's firmware responsibility to call
1939:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1940:                  //Note: The application firmware must process the request and call
1941:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1942:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1943:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1944:                  //more details.
1945:                  if(USBDeferStatusStagePacket == false)
0FF6  0021     MOVLB 0x1
0FF7  0849     MOVF USBDeferStatusStagePacket, W
0FF8  1D03     BTFSS STATUS, 0x2
0FF9  2FFB     GOTO 0x7FB
0FFA  2FFC     GOTO 0x7FC
0FFB  2FFF     GOTO 0x7FF
1946:                  {
1947:                      USBCtrlEPAllowStatusStage();
0FFC  318B     MOVLP 0xB
0FFD  23D4     CALL 0x3D4
0FFE  318F     MOVLP 0xF
1948:                  }
1949:              }
1950:          
1951:          }//end USBCtrlTrfRxService
0FFF  0008     RETURN
1952:          
1953:          
1954:          /********************************************************************
1955:           * Function:        void USBStdSetCfgHandler(void)
1956:           *
1957:           * PreCondition:    None
1958:           *
1959:           * Input:           None
1960:           *
1961:           * Output:          None
1962:           *
1963:           * Side Effects:    None
1964:           *
1965:           * Overview:        This routine first disables all endpoints by
1966:           *                  clearing UEP registers. It then configures
1967:           *                  (initializes) endpoints by calling the callback
1968:           *                  function USBCBInitEP().
1969:           *
1970:           * Note:            None
1971:           *******************************************************************/
1972:          static void USBStdSetCfgHandler(void)
1973:          {
1974:              uint8_t i;
1975:          
1976:              // This will generate a zero length packet
1977:              inPipes[0].info.bits.busy = 1;
0E34  0021     MOVLB 0x1
0E35  17BA     BSF 0xBA, 0x7
1978:          
1979:              //Clear all of the endpoint control registers
1980:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0E36  300E     MOVLW 0xE
0E37  00E0     MOVWF pUEP
0E38  3099     MOVLW 0x99
0E39  00DF     MOVWF p
0E3A  01E1     CLRF i
0E3B  085F     MOVF p, W
0E3C  0086     MOVWF FSR1L
0E3D  0860     MOVF pUEP, W
0E3E  0087     MOVWF FSR1H
0E3F  0181     CLRF INDF1
0E40  3001     MOVLW 0x1
0E41  07DF     ADDWF p, F
0E42  3000     MOVLW 0x0
0E43  3DE0     ADDWFC pUEP, F
0E44  3001     MOVLW 0x1
0E45  00DE     MOVWF 0xDE
0E46  085E     MOVF 0xDE, W
0E47  07E1     ADDWF i, F
0E48  3003     MOVLW 0x3
0E49  0261     SUBWF i, W
0E4A  1C03     BTFSS STATUS, 0x0
0E4B  2E4D     GOTO 0x64D
0E4C  2E4E     GOTO 0x64E
0E4D  2E3B     GOTO 0x63B
1981:          
1982:              //Clear all of the BDT entries
1983:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
0E4E  3020     MOVLW 0x20
0E4F  00F0     MOVWF 0xF0
0E50  3000     MOVLW 0x0
0E51  00F1     MOVWF 0xF1
0E52  3000     MOVLW 0x0
0E53  00F2     MOVWF 0xF2
0E54  00F3     MOVWF 0xF3
0E55  3040     MOVLW 0x40
0E56  00F4     MOVWF 0xF4
0E57  3000     MOVLW 0x0
0E58  00F5     MOVWF 0xF5
0E59  3185     MOVLP 0x5
0E5A  2537     CALL 0x537
0E5B  318E     MOVLP 0xE
1984:          
1985:              // Assert reset request to all of the Ping Pong buffer pointers
1986:              USBPingPongBufferReset = 1;
0E5C  003D     MOVLB 0x1D
0E5D  170E     BSF UCON, 0x6
1987:          
1988:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1989:          	//the EVEN buffer being the next one that will be used), since we are also
1990:          	//doing a hardware ping pong pointer reset above.
1991:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0E5E  0021     MOVLB 0x1
0E5F  01E2     CLRF i
1992:          	{
1993:          		ep_data_in[i].Val = 0u;
0E60  0862     MOVF i, W
0E61  3EB0     ADDLW 0xB0
0E62  0086     MOVWF FSR1L
0E63  3001     MOVLW 0x1
0E64  0087     MOVWF FSR1H
0E65  0181     CLRF INDF1
1994:                  ep_data_out[i].Val = 0u;
0E66  0862     MOVF i, W
0E67  3EAC     ADDLW 0xAC
0E68  0086     MOVWF FSR1L
0E69  3001     MOVLW 0x1
0E6A  0087     MOVWF FSR1H
0E6B  0181     CLRF INDF1
1995:          	}
0E6C  3001     MOVLW 0x1
0E6D  00DE     MOVWF 0xDE
0E6E  085E     MOVF 0xDE, W
0E6F  07E2     ADDWF i, F
0E70  3004     MOVLW 0x4
0E71  0262     SUBWF i, W
0E72  1C03     BTFSS STATUS, 0x0
0E73  2E75     GOTO 0x675
0E74  2E76     GOTO 0x676
0E75  2E60     GOTO 0x660
1996:          
1997:              //clear the alternate interface settings
1998:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0E76  30B6     MOVLW 0xB6
0E77  00F0     MOVWF 0xF0
0E78  3001     MOVLW 0x1
0E79  00F1     MOVWF 0xF1
0E7A  3000     MOVLW 0x0
0E7B  00F2     MOVWF 0xF2
0E7C  00F3     MOVWF 0xF3
0E7D  3003     MOVLW 0x3
0E7E  00F4     MOVWF 0xF4
0E7F  3000     MOVLW 0x0
0E80  00F5     MOVWF 0xF5
0E81  3185     MOVLP 0x5
0E82  2537     CALL 0x537
0E83  318E     MOVLP 0xE
1999:          
2000:              //Stop trying to reset ping pong buffer pointers
2001:              USBPingPongBufferReset = 0;
0E84  003D     MOVLB 0x1D
0E85  130E     BCF UCON, 0x6
2002:          
2003:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0E86  3028     MOVLW 0x28
0E87  0021     MOVLB 0x1
0E88  00B0     MOVWF pBDTEntryIn
0E89  3000     MOVLW 0x0
0E8A  00B1     MOVWF 0xB1
2004:          
2005:          	//Set the next out to the current out packet
2006:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0E8B  3020     MOVLW 0x20
0E8C  00DE     MOVWF 0xDE
0E8D  085E     MOVF 0xDE, W
0E8E  00D2     MOVWF pBDTEntryEP0OutCurrent
2007:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0E8F  0852     MOVF pBDTEntryEP0OutCurrent, W
0E90  00BF     MOVWF pBDTEntryEP0OutNext
0E91  39FF     ANDLW 0xFF
0E92  1D03     BTFSS STATUS, 0x2
0E93  3000     MOVLW 0x0
0E94  00C0     MOVWF 0xC0
2008:          
2009:              //set the current configuration
2010:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0E95  0020     MOVLB 0x0
0E96  0862     MOVF 0x62, W
0E97  0021     MOVLB 0x1
0E98  00DE     MOVWF 0xDE
0E99  085E     MOVF 0xDE, W
0E9A  00D7     MOVWF USBActiveConfiguration
2011:          
2012:              //if the configuration value == 0
2013:              if(USBActiveConfiguration == 0)
0E9B  0857     MOVF USBActiveConfiguration, W
0E9C  1D03     BTFSS STATUS, 0x2
0E9D  2E9F     GOTO 0x69F
0E9E  2EA0     GOTO 0x6A0
0E9F  2EA5     GOTO 0x6A5
2014:              {
2015:                  //Go back to the addressed state
2016:                  USBDeviceState = ADDRESS_STATE;
0EA0  3010     MOVLW 0x10
0EA1  00DE     MOVWF 0xDE
0EA2  085E     MOVF 0xDE, W
0EA3  00D3     MOVWF USBDeviceState
2017:              }
0EA4  2EB9     GOTO 0x6B9
2018:              else
2019:              {
2020:                  //initialize the required endpoints
2021:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0EA5  3001     MOVLW 0x1
0EA6  00D8     MOVWF __pcstackBANK1
0EA7  3000     MOVLW 0x0
0EA8  00D9     MOVWF 0xD9
0EA9  30D7     MOVLW 0xD7
0EAA  00DA     MOVWF pdata
0EAB  3000     MOVLW 0x0
0EAC  00DB     MOVWF 0xDB
0EAD  3001     MOVLW 0x1
0EAE  00DC     MOVWF size
0EAF  3000     MOVLW 0x0
0EB0  00DD     MOVWF 0xDD
0EB1  3189     MOVLP 0x9
0EB2  21C3     CALL 0x1C3
0EB3  318E     MOVLP 0xE
2022:          
2023:                  //Otherwise go to the configured state.  Update the state variable last,
2024:                  //after performing all of the set configuration related initialization
2025:                  //tasks.
2026:                  USBDeviceState = CONFIGURED_STATE;
0EB4  3020     MOVLW 0x20
0EB5  0021     MOVLB 0x1
0EB6  00DE     MOVWF 0xDE
0EB7  085E     MOVF 0xDE, W
0EB8  00D3     MOVWF USBDeviceState
2027:              }//end if(SetupPkt.bConfigurationValue == 0)
2028:          }//end USBStdSetCfgHandler
0EB9  0008     RETURN
2029:          
2030:          
2031:          /********************************************************************
2032:           * Function:        void USBStdGetDscHandler(void)
2033:           *
2034:           * PreCondition:    None
2035:           *
2036:           * Input:           None
2037:           *
2038:           * Output:          None
2039:           *
2040:           * Side Effects:    None
2041:           *
2042:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2043:           *                  request.
2044:           *
2045:           * Note:            None
2046:           *******************************************************************/
2047:          static void USBStdGetDscHandler(void)
2048:          {
2049:              if(SetupPkt.bmRequestType == 0x80)
0DAF  3080     MOVLW 0x80
0DB0  0020     MOVLB 0x0
0DB1  0660     XORWF SetupPkt, W
0DB2  1D03     BTFSS STATUS, 0x2
0DB3  2DB5     GOTO 0x5B5
0DB4  2DB6     GOTO 0x5B6
0DB5  2E33     GOTO 0x633
2050:              {
2051:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0DB6  30C0     MOVLW 0xC0
0DB7  00F0     MOVWF __pcstackCOMMON
0DB8  0870     MOVF __pcstackCOMMON, W
0DB9  0021     MOVLB 0x1
0DBA  00BA     MOVWF 0xBA
2052:          
2053:                  switch(SetupPkt.bDescriptorType)
0DBB  2E1F     GOTO 0x61F
2054:                  {
2055:                      case USB_DESCRIPTOR_DEVICE:
2056:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2057:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2058:                          #else
2059:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0DBC  304E     MOVLW 0x4E
0DBD  0021     MOVLB 0x1
0DBE  00B8     MOVWF inPipes
0DBF  3098     MOVLW 0x98
0DC0  00B9     MOVWF 0xB9
2060:                          #endif
2061:                          inPipes[0].wCount.Val = sizeof(device_dsc);
0DC1  3012     MOVLW 0x12
0DC2  00BB     MOVWF 0xBB
0DC3  3000     MOVLW 0x0
0DC4  00BC     MOVWF 0xBC
2062:                          break;
0DC5  2E33     GOTO 0x633
2063:                      case USB_DESCRIPTOR_CONFIGURATION:
2064:                          //First perform error case check, to make sure the host is requesting a
2065:                          //legal descriptor index.  If the request index is illegal, don't do
2066:                          //anything (so that the default STALL response will be sent).
2067:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0DC6  0862     MOVF i, W
0DC7  1D03     BTFSS STATUS, 0x2
0DC8  2DCA     GOTO 0x5CA
0DC9  2DCB     GOTO 0x5CB
0DCA  2DFA     GOTO 0x5FA
2068:                          {
2069:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2070:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2071:                              #else
2072:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0DCB  0862     MOVF i, W
0DCC  00F0     MOVWF 0xF0
0DCD  01F1     CLRF 0xF1
0DCE  35F0     LSLF 0xF0, F
0DCF  0DF1     RLF 0xF1, F
0DD0  306A     MOVLW 0x6A
0DD1  0770     ADDWF 0xF0, W
0DD2  0084     MOVWF FSR0L
0DD3  3098     MOVLW 0x98
0DD4  3D71     ADDWFC 0xF1, W
0DD5  0085     MOVWF FSR0H
0DD6  3F00     MOVIW 0[FSR0]
0DD7  0021     MOVLB 0x1
0DD8  00B8     MOVWF inPipes
0DD9  3F01     MOVIW 1[FSR0]
0DDA  00B9     MOVWF 0xB9
2073:                              #endif
2074:          
2075:                              //This must be loaded using byte addressing.  The source pointer
2076:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2077:                              //  in an address error on the dereference.
2078:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0DDB  0839     MOVF 0xB9, W
0DDC  00F1     MOVWF 0xF1
0DDD  0838     MOVF inPipes, W
0DDE  00F0     MOVWF 0xF0
0DDF  3002     MOVLW 0x2
0DE0  0770     ADDWF 0xF0, W
0DE1  0084     MOVWF FSR0L
0DE2  0871     MOVF 0xF1, W
0DE3  1803     BTFSC STATUS, 0x0
0DE4  0A71     INCF 0xF1, W
0DE5  0085     MOVWF FSR0H
0DE6  0800     MOVF INDF0, W
0DE7  00F2     MOVWF 0xF2
0DE8  0872     MOVF 0xF2, W
0DE9  00BB     MOVWF 0xBB
2079:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0DEA  0839     MOVF 0xB9, W
0DEB  00F1     MOVWF 0xF1
0DEC  0838     MOVF inPipes, W
0DED  00F0     MOVWF 0xF0
0DEE  3003     MOVLW 0x3
0DEF  0770     ADDWF 0xF0, W
0DF0  0084     MOVWF FSR0L
0DF1  0871     MOVF 0xF1, W
0DF2  1803     BTFSC STATUS, 0x0
0DF3  0A71     INCF 0xF1, W
0DF4  0085     MOVWF FSR0H
0DF5  0800     MOVF INDF0, W
0DF6  00F2     MOVWF 0xF2
0DF7  0872     MOVF 0xF2, W
0DF8  00BC     MOVWF 0xBC
2080:                          }
0DF9  2E33     GOTO 0x633
2081:          				else
2082:          				{
2083:          					inPipes[0].info.Val = 0;
0DFA  0021     MOVLB 0x1
0DFB  01BA     CLRF 0xBA
0DFC  2E33     GOTO 0x633
2084:          				}
2085:                          break;
2086:                      case USB_DESCRIPTOR_STRING:
2087:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2088:                          //  later it is now mandatory.  This should be defined in usb_config.h and should
2089:                          //  indicate the number of string descriptors.
2090:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0DFD  3003     MOVLW 0x3
0DFE  0262     SUBWF i, W
0DFF  1803     BTFSC STATUS, 0x0
0E00  2E02     GOTO 0x602
0E01  2E03     GOTO 0x603
0E02  2DFA     GOTO 0x5FA
2091:                          {
2092:                              //Get a pointer to the String descriptor requested
2093:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0E03  0862     MOVF i, W
0E04  00F0     MOVWF 0xF0
0E05  01F1     CLRF 0xF1
0E06  35F0     LSLF 0xF0, F
0E07  0DF1     RLF 0xF1, F
0E08  3060     MOVLW 0x60
0E09  0770     ADDWF 0xF0, W
0E0A  0084     MOVWF FSR0L
0E0B  3098     MOVLW 0x98
0E0C  3D71     ADDWFC 0xF1, W
0E0D  0085     MOVWF FSR0H
0E0E  3F00     MOVIW 0[FSR0]
0E0F  0021     MOVLB 0x1
0E10  00B8     MOVWF inPipes
0E11  3F01     MOVIW 1[FSR0]
0E12  00B9     MOVWF 0xB9
2094:                              // Set data count
2095:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
0E13  0838     MOVF inPipes, W
0E14  0084     MOVWF FSR0L
0E15  0839     MOVF 0xB9, W
0E16  0085     MOVWF FSR0H
0E17  0800     MOVF INDF0, W
0E18  00F0     MOVWF 0xF0
0E19  01F1     CLRF 0xF1
0E1A  0870     MOVF 0xF0, W
0E1B  00BB     MOVWF 0xBB
0E1C  0871     MOVF 0xF1, W
0E1D  00BC     MOVWF 0xBC
2096:                          }
0E1E  2E33     GOTO 0x633
2097:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2098:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2099:                          {
2100:                              //Get a pointer to the special MS OS string descriptor requested
2101:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2102:                              // Set data count
2103:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;
2104:                          }
2105:                          #endif
2106:                          else
2107:                          {
2108:                              inPipes[0].info.Val = 0;
2109:                          }
2110:                          break;
2111:                      default:
2112:                          inPipes[0].info.Val = 0;
2113:                          break;
2114:                  }//end switch
0E1F  0020     MOVLB 0x0
0E20  0863     MOVF 0x63, W
0E21  00F0     MOVWF __pcstackCOMMON
0E22  01F1     CLRF p
0E23  0871     MOVF p, W
0E24  3A00     XORLW 0x0
0E25  1903     BTFSC STATUS, 0x2
0E26  2E28     GOTO 0x628
0E27  2DFA     GOTO 0x5FA
0E28  0870     MOVF __pcstackCOMMON, W
0E29  3A01     XORLW 0x1
0E2A  1903     BTFSC STATUS, 0x2
0E2B  2DBC     GOTO 0x5BC
0E2C  3A03     XORLW 0x3
0E2D  1903     BTFSC STATUS, 0x2
0E2E  2DC6     GOTO 0x5C6
0E2F  3A01     XORLW 0x1
0E30  1903     BTFSC STATUS, 0x2
0E31  2DFD     GOTO 0x5FD
0E32  2DFA     GOTO 0x5FA
2115:              }//end if
2116:          }//end USBStdGetDscHandler
0E33  0008     RETURN
2117:          
2118:          /********************************************************************
2119:           * Function:        void USBStdGetStatusHandler(void)
2120:           *
2121:           * PreCondition:    None
2122:           *
2123:           * Input:           None
2124:           *
2125:           * Output:          None
2126:           *
2127:           * Side Effects:    None
2128:           *
2129:           * Overview:        This routine handles the standard GET_STATUS request
2130:           *
2131:           * Note:            None
2132:           *******************************************************************/
2133:          static void USBStdGetStatusHandler(void)
2134:          {
2135:              CtrlTrfData[0] = 0;                 // Initialize content
0B67  0020     MOVLB 0x0
0B68  01E8     CLRF CtrlTrfData
2136:              CtrlTrfData[1] = 0;
0B69  01E9     CLRF 0x69
2137:          
2138:              switch(SetupPkt.Recipient)
0B6A  2BB1     GOTO 0x3B1
2139:              {
2140:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2141:                      inPipes[0].info.bits.busy = 1;
0B6B  0021     MOVLB 0x1
0B6C  17BA     BSF 0xBA, 0x7
2142:                      /*
2143:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2144:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2145:                       */
2146:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2147:                      {
2148:                          CtrlTrfData[0]|=0x01;
2149:                      }
2150:          
2151:                      if(RemoteWakeup == true)
0B6D  034E     DECF RemoteWakeup, W
0B6E  1D03     BTFSS STATUS, 0x2
0B6F  2B71     GOTO 0x371
0B70  2B72     GOTO 0x372
0B71  2BC5     GOTO 0x3C5
2152:                      {
2153:                          CtrlTrfData[0]|=0x02;
0B72  0020     MOVLB 0x0
0B73  14E8     BSF CtrlTrfData, 0x1
0B74  2BC5     GOTO 0x3C5
2154:                      }
2155:                      break;
2156:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2157:                      inPipes[0].info.bits.busy = 1;     // No data to update
0B75  0021     MOVLB 0x1
0B76  17BA     BSF 0xBA, 0x7
2158:                      break;
0B77  2BC5     GOTO 0x3C5
2159:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2160:                      inPipes[0].info.bits.busy = 1;
0B78  0021     MOVLB 0x1
0B79  17BA     BSF 0xBA, 0x7
2161:                      /*
2162:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2163:                       */
2164:                      if(SetupPkt.EPNum != 0)
0B7A  0020     MOVLB 0x0
0B7B  0864     MOVF 0x64, W
0B7C  390F     ANDLW 0xF
0B7D  3A00     XORLW 0x0
0B7E  1903     BTFSC STATUS, 0x2
0B7F  2B81     GOTO 0x381
0B80  2B82     GOTO 0x382
0B81  2BC5     GOTO 0x3C5
2165:                      {
2166:                          BDT_ENTRY *p;
2167:          
2168:                          if(SetupPkt.EPDir == 0)
0B82  1BE4     BTFSC 0x64, 0x7
0B83  2B85     GOTO 0x385
0B84  2B86     GOTO 0x386
0B85  2B92     GOTO 0x392
2169:                          {
2170:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0B86  0864     MOVF 0x64, W
0B87  390F     ANDLW 0xF
0B88  0709     ADDWF WREG, W
0B89  3EA0     ADDLW 0xA0
0B8A  0086     MOVWF FSR1
0B8B  3001     MOVLW 0x1
0B8C  0087     MOVWF FSR1H
0B8D  3F40     MOVIW 0[FSR1]
0B8E  00F2     MOVWF c
0B8F  3F41     MOVIW 1[FSR1]
0B90  00F3     MOVWF i
2171:                          }
0B91  2B9C     GOTO 0x39C
2172:                          else
2173:                          {
2174:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0B92  0864     MOVF 0x64, W
0B93  390F     ANDLW 0xF
0B94  0709     ADDWF WREG, W
0B95  3EB0     ADDLW 0xB0
0B96  0086     MOVWF FSR1
0B97  0187     CLRF FSR1H
0B98  3F40     MOVIW 0[FSR1]
0B99  00F2     MOVWF c
0B9A  3F41     MOVIW 1[FSR1]
0B9B  00F3     MOVWF i
2175:                          }
2176:          
2177:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
0B9C  0872     MOVF c, W
0B9D  0086     MOVWF FSR1
0B9E  0873     MOVF i, W
0B9F  0087     MOVWF FSR1H
0BA0  1F81     BTFSS INDF1, 0x7
0BA1  2BA3     GOTO 0x3A3
0BA2  2BA4     GOTO 0x3A4
0BA3  2BC5     GOTO 0x3C5
0BA4  0872     MOVF c, W
0BA5  0086     MOVWF FSR1
0BA6  0873     MOVF i, W
0BA7  0087     MOVWF FSR1H
0BA8  1D01     BTFSS INDF1, 0x2
0BA9  2BAB     GOTO 0x3AB
0BAA  2BAC     GOTO 0x3AC
0BAB  2BC5     GOTO 0x3C5
2178:                          {
2179:                              CtrlTrfData[0]=0x01;    // Set bit0
0BAC  3001     MOVLW 0x1
0BAD  00F0     MOVWF __pcstackCOMMON
0BAE  0870     MOVF __pcstackCOMMON, W
0BAF  00E8     MOVWF CtrlTrfData
0BB0  2BC5     GOTO 0x3C5
2180:                          }
2181:                      }
2182:                      break;
2183:              }//end switch
0BB1  0860     MOVF SetupPkt, W
0BB2  391F     ANDLW 0x1F
0BB3  00F0     MOVWF __pcstackCOMMON
0BB4  01F1     CLRF p
0BB5  0871     MOVF p, W
0BB6  3A00     XORLW 0x0
0BB7  1903     BTFSC STATUS, 0x2
0BB8  2BBA     GOTO 0x3BA
0BB9  2BC5     GOTO 0x3C5
0BBA  0870     MOVF __pcstackCOMMON, W
0BBB  3A00     XORLW 0x0
0BBC  1903     BTFSC STATUS, 0x2
0BBD  2B6B     GOTO 0x36B
0BBE  3A01     XORLW 0x1
0BBF  1903     BTFSC STATUS, 0x2
0BC0  2B75     GOTO 0x375
0BC1  3A03     XORLW 0x3
0BC2  1903     BTFSC STATUS, 0x2
0BC3  2B78     GOTO 0x378
0BC4  2BC5     GOTO 0x3C5
2184:          
2185:              if(inPipes[0].info.bits.busy == 1)
0BC5  0021     MOVLB 0x1
0BC6  1FBA     BTFSS 0xBA, 0x7
0BC7  2BC9     GOTO 0x3C9
0BC8  2BCA     GOTO 0x3CA
0BC9  2BD3     GOTO 0x3D3
2186:              {
2187:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
0BCA  3068     MOVLW 0x68
0BCB  00B8     MOVWF inPipes
0BCC  3000     MOVLW 0x0
0BCD  00B9     MOVWF 0xB9
2188:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
0BCE  143A     BSF 0xBA, 0x0
2189:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
0BCF  3002     MOVLW 0x2
0BD0  00F0     MOVWF 0xF0
0BD1  0870     MOVF 0xF0, W
0BD2  00BB     MOVWF 0xBB
2190:              }//end if(...)
2191:          }//end USBStdGetStatusHandler
0BD3  0008     RETURN
2192:          
2193:          /********************************************************************
2194:           * Function:        void USBStallHandler(void)
2195:           *
2196:           * PreCondition:    None
2197:           *
2198:           * Input:           None
2199:           *
2200:           * Output:          None
2201:           *
2202:           * Side Effects:
2203:           *
2204:           * Overview:        This function handles the event of a STALL
2205:           *                  occurring on the bus
2206:           *
2207:           * Note:            None
2208:           *******************************************************************/
2209:          static void USBStallHandler(void)
2210:          {
2211:              /*
2212:               * Does not really have to do anything here,
2213:               * even for the control endpoint.
2214:               * All BDs of Endpoint 0 are owned by SIE right now,
2215:               * but once a Setup Transaction is received, the ownership
2216:               * for EP0_OUT will be returned to CPU.
2217:               * When the Setup Transaction is serviced, the ownership
2218:               * for EP0_IN will then be forced back to CPU by firmware.
2219:               */
2220:          
2221:              if(U1EP0bits.EPSTALL == 1)
08BF  003D     MOVLB 0x1D
08C0  1C18     BTFSS UEP0, 0x0
08C1  28C3     GOTO 0xC3
08C2  28C4     GOTO 0xC4
08C3  28E5     GOTO 0xE5
2222:              {
2223:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2224:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
08C4  0021     MOVLB 0x1
08C5  0852     MOVF pBDTEntryEP0OutCurrent, W
08C6  0086     MOVWF FSR1L
08C7  0187     CLRF FSR1H
08C8  3080     MOVLW 0x80
08C9  0601     XORWF INDF1, W
08CA  1D03     BTFSS STATUS, 0x2
08CB  28CD     GOTO 0xCD
08CC  28CE     GOTO 0xCE
08CD  28E3     GOTO 0xE3
08CE  0830     MOVF pBDTEntryIn, W
08CF  0086     MOVWF FSR1L
08D0  0831     MOVF 0xB1, W
08D1  0087     MOVWF FSR1H
08D2  3084     MOVLW 0x84
08D3  0601     XORWF INDF1, W
08D4  1D03     BTFSS STATUS, 0x2
08D5  28D7     GOTO 0xD7
08D6  28D8     GOTO 0xD8
08D7  28E3     GOTO 0xE3
2225:                  {
2226:                      // Set ep0Bo to stall also
2227:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
08D8  300C     MOVLW 0xC
08D9  00F0     MOVWF 0xF0
08DA  0852     MOVF pBDTEntryEP0OutCurrent, W
08DB  0086     MOVWF FSR1L
08DC  0187     CLRF FSR1H
08DD  0870     MOVF 0xF0, W
08DE  0081     MOVWF INDF1
2228:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
08DF  0852     MOVF pBDTEntryEP0OutCurrent, W
08E0  0086     MOVWF FSR1L
08E1  0187     CLRF FSR1H
08E2  1781     BSF INDF1, 0x7
2229:                  }//end if
2230:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
08E3  003D     MOVLB 0x1D
08E4  1018     BCF UEP0, 0x0
2231:              }//end if
2232:          
2233:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
08E5  30DF     MOVLW 0xDF
08E6  00F0     MOVWF 0xEF0
08E7  0870     MOVF 0xEF0, W
08E8  0590     ANDWF UIR, F
2234:          }
08E9  0008     RETURN
2235:          
2236:          /********************************************************************
2237:           * Function:        void USBSuspend(void)
2238:           *
2239:           * PreCondition:    None
2240:           *
2241:           * Input:           None
2242:           *
2243:           * Output:          None
2244:           *
2245:           * Side Effects:
2246:           *
2247:           * Overview:        This function handles if the host tries to
2248:           *                  suspend the device
2249:           *
2250:           * Note:            None
2251:           *******************************************************************/
2252:          static void USBSuspend(void)
2253:          {
2254:              /*
2255:               * NOTE: Do not clear UIRbits.ACTVIF here!
2256:               * Reason:
2257:               * ACTVIF is only generated once an IDLEIF has been generated.
2258:               * This is a 1:1 ratio interrupt generation.
2259:               * For every IDLEIF, there will be only one ACTVIF regardless of
2260:               * the number of subsequent bus transitions.
2261:               *
2262:               * If the ACTIF is cleared here, a problem could occur when:
2263:               * [       IDLE       ][bus activity ->
2264:               * <--- 3 ms ----->     ^
2265:               *                ^     ACTVIF=1
2266:               *                IDLEIF=1
2267:               *  #           #           #           #   (#=Program polling flags)
2268:               *                          ^
2269:               *                          This polling loop will see both
2270:               *                          IDLEIF=1 and ACTVIF=1.
2271:               *                          However, the program services IDLEIF first
2272:               *                          because ACTIVIE=0.
2273:               *                          If this routine clears the only ACTIVIF,
2274:               *                          then it can never get out of the suspend
2275:               *                          mode.
2276:               */
2277:              USBActivityIE = 1;                     // Enable bus activity interrupt
1763  003D     MOVLB 0x1D
1764  1512     BSF UIE, 0x2
2278:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
1765  30EF     MOVLW 0xEF
1766  0021     MOVLB 0x1
1767  00DE     MOVWF 0xDE
1768  085E     MOVF 0xDE, W
1769  003D     MOVLB 0x1D
176A  0590     ANDWF UIR, F
2279:          
2280:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2281:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
176B  148E     BSF UCON, 0x1
2282:                                                          // mode, SIE clock inactive
2283:              #endif
2284:              USBBusIsSuspended = true;
176C  0021     MOVLB 0x1
176D  01CD     CLRF USBBusIsSuspended
176E  0ACD     INCF USBBusIsSuspended, F
2285:              USBTicksSinceSuspendEnd = 0;
176F  01C4     CLRF USBTicksSinceSuspendEnd
2286:          
2287:              /*
2288:               * At this point the PIC can go into sleep,idle, or
2289:               * switch to a slower clock, etc.  This should be done in the
2290:               * USBCBSuspend() if necessary.
2291:               */
2292:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
1770  3075     MOVLW 0x75
1771  00D8     MOVWF __pcstackBANK1
1772  3000     MOVLW 0x0
1773  00D9     MOVWF 0xD9
1774  3000     MOVLW 0x0
1775  00DA     MOVWF pdata
1776  3000     MOVLW 0x0
1777  00DB     MOVWF 0xDB
1778  3000     MOVLW 0x0
1779  00DC     MOVWF size
177A  00DD     MOVWF 0xDD
177B  3189     MOVLP 0x9
177C  21C3     CALL 0x1C3
177D  3197     MOVLP 0x17
2293:          }
177E  0008     RETURN
2294:          
2295:          /********************************************************************
2296:           * Function:        void USBWakeFromSuspend(void)
2297:           *
2298:           * PreCondition:    None
2299:           *
2300:           * Input:           None
2301:           *
2302:           * Output:          None
2303:           *
2304:           * Side Effects:    None
2305:           *
2306:           * Overview:
2307:           *
2308:           * Note:            None
2309:           *******************************************************************/
2310:          static void USBWakeFromSuspend(void)
2311:          {
2312:              USBBusIsSuspended = false;
17BD  0021     MOVLB 0x1
17BE  01CD     CLRF USBBusIsSuspended
2313:          
2314:              /*
2315:               * If using clock switching, the place to restore the original
2316:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2317:               */
2318:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
17BF  3074     MOVLW 0x74
17C0  00D8     MOVWF __pcstackBANK1
17C1  3000     MOVLW 0x0
17C2  00D9     MOVWF 0xD9
17C3  3000     MOVLW 0x0
17C4  00DA     MOVWF pdata
17C5  3000     MOVLW 0x0
17C6  00DB     MOVWF 0xDB
17C7  3000     MOVLW 0x0
17C8  00DC     MOVWF size
17C9  00DD     MOVWF 0xDD
17CA  3189     MOVLP 0x9
17CB  21C3     CALL 0x1C3
17CC  3197     MOVLP 0x17
2319:          
2320:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2321:                  //To avoid improperly clocking the USB module, make sure the oscillator
2322:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2323:                  //Make sure the correct oscillator settings are selected in the
2324:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2325:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
17CD  003D     MOVLB 0x1D
17CE  108E     BCF UCON, 0x1
2326:                                          // mode.
2327:              #endif
2328:          
2329:          
2330:              USBActivityIE = 0;
17CF  1112     BCF UIE, 0x2
2331:          
2332:              /********************************************************************
2333:              Bug Fix: Feb 26, 2007 v2.1
2334:              *********************************************************************
2335:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2336:              up from Suspend or while the USB module is suspended. A few clock cycles
2337:              are required to synchronize the internal hardware state machine before
2338:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2339:              before the internal hardware is synchronized may not have an effect on
2340:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2341:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2342:              module may not be immediately operational while waiting for the 96 MHz
2343:              PLL to lock.
2344:              ********************************************************************/
2345:          
2346:              // UIRbits.ACTVIF = 0;                      // Removed
2347:              #if defined(__18CXX) || defined(__XC8)
2348:              while(USBActivityIF)
17D0  2FD7     GOTO 0x7D7
17D7  1910     BTFSC UIR, 0x2
17D8  2FDA     GOTO 0x7DA
17D9  2FDB     GOTO 0x7DB
17DA  2FD1     GOTO 0x7D1
2349:              #endif
2350:              {
2351:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
17D1  30FB     MOVLW 0xFB
17D2  0021     MOVLB 0x1
17D3  00DE     MOVWF 0xDE
17D4  085E     MOVF 0xDE, W
17D5  003D     MOVLB 0x1D
17D6  0590     ANDWF UIR, F
2352:              }  // Added
2353:          
2354:              USBTicksSinceSuspendEnd = 0;
17DB  0021     MOVLB 0x1
17DC  01C4     CLRF USBTicksSinceSuspendEnd
2355:          
2356:          }//end USBWakeFromSuspend
17DD  0008     RETURN
2357:          
2358:          /********************************************************************
2359:           * Function:        void USBCtrlEPService(void)
2360:           *
2361:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2362:           *
2363:           * Input:           None
2364:           *
2365:           * Output:          None
2366:           *
2367:           * Side Effects:    None
2368:           *
2369:           * Overview:        USBCtrlEPService checks for three transaction
2370:           *                  types that it knows how to service and services
2371:           *                  them:
2372:           *                  1. EP0 SETUP
2373:           *                  2. EP0 OUT
2374:           *                  3. EP0 IN
2375:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2376:           *
2377:           * Note:            None
2378:           *******************************************************************/
2379:          static void USBCtrlEPService(void)
2380:          {
2381:              //If we get to here, that means a successful transaction has just occurred
2382:              //on EP0.  This means "progress" has occurred in the currently pending
2383:              //control transfer, so we should re-initialize our timeout counter.
2384:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2385:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
0A51  302D     MOVLW 0x2D
0A52  0021     MOVLB 0x1
0A53  00E8     MOVWF 0xE8
0A54  0868     MOVF 0xE8, W
0A55  00CA     MOVWF USBStatusStageTimeoutCounter
2386:              #endif
2387:          
2388:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2389:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
0A56  0856     MOVF USTATcopy, W
0A57  39FD     ANDLW 0xFD
0A58  1D03     BTFSS STATUS, 0x2
0A59  2A5B     GOTO 0x25B
0A5A  2A5C     GOTO 0x25C
0A5B  2A98     GOTO 0x298
2390:              {
2391:          		//Point to the EP0 OUT buffer of the buffer that arrived
2392:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2393:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
0A5C  3656     LSRF USTATcopy, W
0A5D  393F     ANDLW 0x3F
0A5E  00E8     MOVWF 0xE8
0A5F  3001     MOVLW 0x1
0A60  35E8     LSLF 0xE8, F
0A61  3EFF     ADDLW 0xFF
0A62  1D03     BTFSS STATUS, 0x2
0A63  2A60     GOTO 0x260
0A64  3568     LSLF 0xE8, W
0A65  3E20     ADDLW 0x20
0A66  00E9     MOVWF 0xE9
0A67  0869     MOVF 0xE9, W
0A68  00D2     MOVWF pBDTEntryEP0OutCurrent
2394:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2395:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2396:                  #else
2397:                      #error "unimplemented"
2398:                  #endif
2399:          
2400:          		//Set the next out to the current out packet
2401:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0A69  0852     MOVF pBDTEntryEP0OutCurrent, W
0A6A  00BF     MOVWF pBDTEntryEP0OutNext
0A6B  39FF     ANDLW 0xFF
0A6C  1D03     BTFSS STATUS, 0x2
0A6D  3000     MOVLW 0x0
0A6E  00C0     MOVWF 0xC0
2402:          		//Toggle it to the next ping pong buffer (if applicable)
2403:                  pBDTEntryEP0OutNext = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryEP0OutNext) ^ USB_NEXT_EP0_OUT_PING_PONG);
0A6F  3004     MOVLW 0x4
0A70  063F     XORWF pBDTEntryEP0OutNext, W
0A71  00BF     MOVWF pBDTEntryEP0OutNext
0A72  3000     MOVLW 0x0
0A73  0640     XORWF 0xC0, W
0A74  00C0     MOVWF 0xC0
2404:          
2405:          		//If the current EP0 OUT buffer has a SETUP packet
2406:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
0A75  0852     MOVF pBDTEntryEP0OutCurrent, W
0A76  0086     MOVWF FSR1L
0A77  0187     CLRF FSR1H
0A78  0C01     RRF INDF1, W
0A79  0C89     RRF WREG, F
0A7A  390F     ANDLW 0xF
0A7B  3A0D     XORLW 0xD
0A7C  1D03     BTFSS STATUS, 0x2
0A7D  2A7F     GOTO 0x27F
0A7E  2A80     GOTO 0x280
0A7F  2A94     GOTO 0x294
2407:                  {
2408:          	        //The SETUP transaction data may have gone into the the CtrlTrfData
2409:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2410:          	        //before the transaction.  Therefore, we should copy the data to the
2411:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().
2412:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
0A80  0852     MOVF pBDTEntryEP0OutCurrent, W
0A81  3E02     ADDLW 0x2
0A82  0086     MOVWF FSR1L
0A83  0187     CLRF FSR1H
0A84  3F40     MOVIW 0[FSR1]
0A85  00F0     MOVWF 0xF0
0A86  3F41     MOVIW 1[FSR1]
0A87  00F1     MOVWF 0xF1
0A88  3008     MOVLW 0x8
0A89  00F2     MOVWF 0xF2
0A8A  3000     MOVLW 0x0
0A8B  00F3     MOVWF 0xF3
0A8C  3060     MOVLW 0x60
0A8D  3188     MOVLP 0x8
0A8E  20EA     CALL 0xEA
0A8F  318A     MOVLP 0xA
2413:          
2414:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2415:                      USBCtrlTrfSetupHandler();
0A90  318A     MOVLP 0xA
0A91  2209     CALL 0x209
0A92  318A     MOVLP 0xA
2416:                  }
0A93  2AA4     GOTO 0x2A4
2417:                  else
2418:                  {
2419:          			//Handle the DATA transfer
2420:                      USBCtrlTrfOutHandler();
0A94  3189     MOVLP 0x9
0A95  2148     CALL 0x148
0A96  318A     MOVLP 0xA
0A97  2AA4     GOTO 0x2A4
2421:                  }
2422:              }
2423:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
0A98  30FD     MOVLW 0xFD
0A99  0556     ANDWF USTATcopy, W
0A9A  00E8     MOVWF 0xE8
0A9B  3004     MOVLW 0x4
0A9C  0668     XORWF 0xE8, W
0A9D  1D03     BTFSS STATUS, 0x2
0A9E  2AA0     GOTO 0x2A0
0A9F  2AA1     GOTO 0x2A1
0AA0  2AA4     GOTO 0x2A4
2424:              {
2425:          		//Otherwise the transmission was and EP0 IN
2426:          		//  so take care of the IN transfer
2427:                  USBCtrlTrfInHandler();
0AA1  318C     MOVLP 0xC
0AA2  24BB     CALL 0x4BB
0AA3  318A     MOVLP 0xA
2428:              }
2429:          
2430:          }//end USBCtrlEPService
0AA4  0008     RETURN
2431:          
2432:          /********************************************************************
2433:           * Function:        void USBCtrlTrfSetupHandler(void)
2434:           *
2435:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2436:           *
2437:           * Input:           None
2438:           *
2439:           * Output:          None
2440:           *
2441:           * Side Effects:    None
2442:           *
2443:           * Overview:        This routine is a task dispatcher and has 3 stages.
2444:           *                  1. It initializes the control transfer state machine.
2445:           *                  2. It calls on each of the module that may know how to
2446:           *                     service the Setup Request from the host.
2447:           *                     Module Example: USBD, HID, CDC, MSD, ...
2448:           *                     A callback function, USBCBCheckOtherReq(),
2449:           *                     is required to call other module handlers.
2450:           *                  3. Once each of the modules has had a chance to check if
2451:           *                     it is responsible for servicing the request, stage 3
2452:           *                     then checks direction of the transfer to determine how
2453:           *                     to prepare EP0 for the control transfer.
2454:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2455:           *
2456:           * Note:            Microchip USB Firmware has three different states for
2457:           *                  the control transfer state machine:
2458:           *                  1. WAIT_SETUP
2459:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2460:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2461:           *                  Refer to firmware manual to find out how one state
2462:           *                  is transitioned to another.
2463:           *
2464:           *                  A Control Transfer is composed of many USB transactions.
2465:           *                  When transferring data over multiple transactions,
2466:           *                  it is important to keep track of data source, data
2467:           *                  destination, and data count. These three parameters are
2468:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2469:           *                  note if the data source is from const or RAM.
2470:           *
2471:           *******************************************************************/
2472:          static void USBCtrlTrfSetupHandler(void)
2473:          {
2474:              //--------------------------------------------------------------------------
2475:              //1. Re-initialize state tracking variables related to control transfers.
2476:              //--------------------------------------------------------------------------
2477:              shortPacketStatus = SHORT_PKT_NOT_USED;
0A09  0021     MOVLB 0x1
0A0A  01D1     CLRF shortPacketStatus
2478:              USBDeferStatusStagePacket = false;
0A0B  01C9     CLRF USBDeferStatusStagePacket
2479:              USBDeferINDataStagePackets = false;
0A0C  01C6     CLRF USBDeferINDataStagePackets
2480:              USBDeferOUTDataStagePackets = false;
0A0D  01C5     CLRF USBDeferOUTDataStagePackets
2481:              BothEP0OutUOWNsSet = false;
0A0E  01CB     CLRF BothEP0OutUOWNsSet
2482:              controlTransferState = WAIT_SETUP;
0A0F  01D0     CLRF controlTransferState
2483:          
2484:              //Abandon any previous control transfers that might have been using EP0.
2485:              //Ordinarily, nothing actually needs abandoning, since the previous control
2486:              //transfer would have completed successfully prior to the host sending the next
2487:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2488:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2489:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2490:              //by the class request handler that will be called next.
2491:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
0A10  307F     MOVLW 0x7F
0A11  00E7     MOVWF 0xE7
0A12  0830     MOVF pBDTEntryIn, W
0A13  0086     MOVWF FSR1L
0A14  0831     MOVF 0xB1, W
0A15  0087     MOVWF FSR1H
0A16  0867     MOVF 0xE7, W
0A17  0581     ANDWF INDF1, F
2492:          
2493:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0A18  3004     MOVLW 0x4
0A19  0630     XORWF pBDTEntryIn, W
0A1A  00B0     MOVWF pBDTEntryIn
0A1B  3000     MOVLW 0x0
0A1C  0631     XORWF 0xB1, W
0A1D  00B1     MOVWF 0xB1
2494:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);
0A1E  307F     MOVLW 0x7F
0A1F  00E7     MOVWF 0xE7
0A20  0830     MOVF pBDTEntryIn, W
0A21  0086     MOVWF FSR1L
0A22  0831     MOVF 0xB1, W
0A23  0087     MOVWF FSR1H
0A24  0867     MOVF 0xE7, W
0A25  0581     ANDWF INDF1, F
2495:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0A26  3004     MOVLW 0x4
0A27  0630     XORWF pBDTEntryIn, W
0A28  00B0     MOVWF pBDTEntryIn
0A29  3000     MOVLW 0x0
0A2A  0631     XORWF 0xB1, W
0A2B  00B1     MOVWF 0xB1
2496:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);
0A2C  307F     MOVLW 0x7F
0A2D  00E7     MOVWF 0xE7
0A2E  083F     MOVF pBDTEntryEP0OutNext, W
0A2F  0086     MOVWF FSR1L
0A30  0840     MOVF 0xC0, W
0A31  0087     MOVWF FSR1H
0A32  0867     MOVF 0xE7, W
0A33  0581     ANDWF INDF1, F
2497:          
2498:              inPipes[0].info.Val = 0;
0A34  01BA     CLRF 0xBA
2499:              inPipes[0].wCount.Val = 0;
0A35  01BB     CLRF 0xBB
0A36  01BC     CLRF 0xBC
2500:              outPipes[0].info.Val = 0;
0A37  0022     MOVLB 0x2
0A38  01A2     CLRF 0x122
2501:              outPipes[0].wCount.Val = 0;
0A39  01A3     CLRF 0x123
0A3A  01A4     CLRF 0x124
2502:          
2503:          
2504:              //--------------------------------------------------------------------------
2505:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2506:              //--------------------------------------------------------------------------
2507:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
0A3B  318D     MOVLP 0xD
0A3C  2533     CALL 0x533
0A3D  318A     MOVLP 0xA
2508:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
0A3E  3003     MOVLW 0x3
0A3F  0021     MOVLB 0x1
0A40  00D8     MOVWF __pcstackBANK1
0A41  3000     MOVLW 0x0
0A42  00D9     MOVWF 0xD9
0A43  3000     MOVLW 0x0
0A44  00DA     MOVWF pdata
0A45  3000     MOVLW 0x0
0A46  00DB     MOVWF 0xDB
0A47  3000     MOVLW 0x0
0A48  00DC     MOVWF size
0A49  00DD     MOVWF 0xDD
0A4A  3189     MOVLP 0x9
0A4B  21C3     CALL 0x1C3
0A4C  318A     MOVLP 0xA
2509:          
2510:          
2511:              //--------------------------------------------------------------------------
2512:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in
2513:              //   progress.  If one of the above handlers (in step 2) knew how to process
2514:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2515:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2516:              //   USBCtrlEPServiceComplete() function know how and which endpoints to
2517:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2518:              //   process the request.  In this case, the default behavior will be to
2519:              //   perform protocol STALL on EP0.
2520:              //--------------------------------------------------------------------------
2521:              USBCtrlEPServiceComplete();
0A4D  318E     MOVLP 0xE
0A4E  26BA     CALL 0x6BA
0A4F  318A     MOVLP 0xA
2522:          }//end USBCtrlTrfSetupHandler
0A50  0008     RETURN
2523:          
2524:          
2525:          /******************************************************************************
2526:           * Function:        void USBCtrlTrfOutHandler(void)
2527:           *
2528:           * PreCondition:    None
2529:           *
2530:           * Input:           None
2531:           *
2532:           * Output:          None
2533:           *
2534:           * Side Effects:    None
2535:           *
2536:           * Overview:        This routine handles an OUT transaction according to
2537:           *                  which control transfer state is currently active.
2538:           *
2539:           * Note:            Note that if the the control transfer was from
2540:           *                  host to device, the session owner should be notified
2541:           *                  at the end of each OUT transaction to service the
2542:           *                  received data.
2543:           *
2544:           *****************************************************************************/
2545:          static void USBCtrlTrfOutHandler(void)
2546:          {
2547:              if(controlTransferState == CTRL_TRF_RX)
0948  3002     MOVLW 0x2
0949  0021     MOVLB 0x1
094A  0650     XORWF controlTransferState, W
094B  1D03     BTFSS STATUS, 0x2
094C  294E     GOTO 0x14E
094D  294F     GOTO 0x14F
094E  2953     GOTO 0x153
2548:              {
2549:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
094F  318F     MOVLP 0xF
0950  2756     CALL 0x756
0951  3189     MOVLP 0x9
2550:              }
0952  297F     GOTO 0x17F
2551:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2552:              {
2553:                  //If the status stage is complete, this means we are done with the
2554:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2555:                  controlTransferState = WAIT_SETUP;
0953  01D0     CLRF controlTransferState
2556:          
2557:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2558:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2559:                  //and the last control transfer was of direction: device to host, see
2560:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2561:                  //to do anything to the BDT.
2562:                  if(BothEP0OutUOWNsSet == false)
0954  084B     MOVF BothEP0OutUOWNsSet, W
0955  1D03     BTFSS STATUS, 0x2
0956  2958     GOTO 0x158
0957  2959     GOTO 0x159
0958  297E     GOTO 0x17E
2563:                  {
2564:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
0959  083F     MOVF pBDTEntryEP0OutNext, W
095A  3E01     ADDLW 0x1
095B  00F6     MOVWF 0xF6
095C  3000     MOVLW 0x0
095D  3D40     ADDWFC 0xC0, W
095E  00F7     MOVWF 0xF7
095F  0876     MOVF 0xF6, W
0960  0086     MOVWF FSR1L
0961  0877     MOVF 0xF7, W
0962  0087     MOVWF FSR1H
0963  3008     MOVLW 0x8
0964  0081     MOVWF INDF1
2565:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0965  3060     MOVLW 0x60
0966  00F6     MOVWF 0xF6
0967  3000     MOVLW 0x0
0968  00F7     MOVWF 0xF7
0969  083F     MOVF pBDTEntryEP0OutNext, W
096A  0086     MOVWF FSR1L
096B  0840     MOVF 0xC0, W
096C  0087     MOVWF FSR1H
096D  3142     ADDFSR 1, 2
096E  0876     MOVF 0xF6, W
096F  3FC0     MOVWI 0[FSR1]
0970  0877     MOVF 0xF7, W
0971  3FC1     MOVWI 1[FSR1]
2566:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
0972  083F     MOVF pBDTEntryEP0OutNext, W
0973  0086     MOVWF FSR1L
0974  0840     MOVF 0xC0, W
0975  0087     MOVWF FSR1H
0976  300C     MOVLW 0xC
0977  0081     MOVWF INDF1
2567:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
0978  083F     MOVF pBDTEntryEP0OutNext, W
0979  0086     MOVWF FSR1L
097A  0840     MOVF 0xC0, W
097B  0087     MOVWF FSR1H
097C  1781     BSF INDF1, 0x7
2568:                  }
097D  297F     GOTO 0x17F
2569:                  else
2570:                  {
2571:                      BothEP0OutUOWNsSet = false;
097E  01CB     CLRF BothEP0OutUOWNsSet
2572:                  }
2573:              }
2574:          }
097F  0008     RETURN
2575:          
2576:          /******************************************************************************
2577:           * Function:        void USBCtrlTrfInHandler(void)
2578:           *
2579:           * PreCondition:    None
2580:           *
2581:           * Input:           None
2582:           *
2583:           * Output:          None
2584:           *
2585:           * Side Effects:    None
2586:           *
2587:           * Overview:        This routine handles an IN transaction according to
2588:           *                  which control transfer state is currently active.
2589:           *
2590:           * Note:            A Set Address Request must not change the actual address
2591:           *                  of the device until the completion of the control
2592:           *                  transfer. The end of the control transfer for Set Address
2593:           *                  Request is an IN transaction. Therefore it is necessary
2594:           *                  to service this unique situation when the condition is
2595:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2596:           *                  usb9.h and its function is to specifically service this
2597:           *                  event.
2598:           *****************************************************************************/
2599:          static void USBCtrlTrfInHandler(void)
2600:          {
2601:              uint8_t lastDTS;
2602:          
2603:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
0CBB  0021     MOVLB 0x1
0CBC  0830     MOVF pBDTEntryIn, W
0CBD  0086     MOVWF FSR1L
0CBE  0831     MOVF 0xB1, W
0CBF  0087     MOVWF FSR1H
0CC0  3000     MOVLW 0x0
0CC1  1B01     BTFSC INDF1, 0x6
0CC2  3001     MOVLW 0x1
0CC3  00F5     MOVWF 0xF5
2604:          
2605:              //switch to the next ping pong buffer
2606:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)(((uintptr_t)pBDTEntryIn[0]) ^ USB_NEXT_EP0_IN_PING_PONG);
0CC4  3004     MOVLW 0x4
0CC5  0630     XORWF pBDTEntryIn, W
0CC6  00B0     MOVWF pBDTEntryIn
0CC7  3000     MOVLW 0x0
0CC8  0631     XORWF 0xB1, W
0CC9  00B1     MOVWF 0xB1
2607:          
2608:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2609:              //now, since the IN status stage of the (set address) control transfer has
2610:              //evidently completed successfully.
2611:              if(USBDeviceState == ADR_PENDING_STATE)
0CCA  3008     MOVLW 0x8
0CCB  0653     XORWF USBDeviceState, W
0CCC  1D03     BTFSS STATUS, 0x2
0CCD  2CCF     GOTO 0x4CF
0CCE  2CD0     GOTO 0x4D0
0CCF  2CE5     GOTO 0x4E5
2612:              {
2613:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
0CD0  0020     MOVLB 0x0
0CD1  0862     MOVF 0x62, W
0CD2  397F     ANDLW 0x7F
0CD3  003D     MOVLB 0x1D
0CD4  0096     MOVWF UADDR
2614:                  if(U1ADDR != 0u)
0CD5  0816     MOVF UADDR, W
0CD6  1903     BTFSC STATUS, 0x2
0CD7  2CD9     GOTO 0x4D9
0CD8  2CDA     GOTO 0x4DA
0CD9  2CE0     GOTO 0x4E0
2615:                  {
2616:                      USBDeviceState=ADDRESS_STATE;
0CDA  3010     MOVLW 0x10
0CDB  00F3     MOVWF 0xEF3
0CDC  0873     MOVF 0xEF3, W
0CDD  0021     MOVLB 0x1
0CDE  00D3     MOVWF USBDeviceState
2617:                  }
0CDF  2CE5     GOTO 0x4E5
2618:                  else
2619:                  {
2620:                      USBDeviceState=DEFAULT_STATE;
0CE0  3004     MOVLW 0x4
0CE1  00F3     MOVWF 0xF3
0CE2  0873     MOVF 0xF3, W
0CE3  0021     MOVLB 0x1
0CE4  00D3     MOVWF USBDeviceState
2621:                  }
2622:              }//end if
2623:          
2624:          
2625:              if(controlTransferState == CTRL_TRF_TX)
0CE5  0350     DECF controlTransferState, W
0CE6  1D03     BTFSS STATUS, 0x2
0CE7  2CE9     GOTO 0x4E9
0CE8  2CEA     GOTO 0x4EA
0CE9  2D2A     GOTO 0x52A
2626:              {
2627:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
0CEA  3068     MOVLW 0x68
0CEB  00F3     MOVWF 0xF3
0CEC  3000     MOVLW 0x0
0CED  00F4     MOVWF 0xF4
0CEE  0830     MOVF pBDTEntryIn, W
0CEF  0086     MOVWF FSR1L
0CF0  0831     MOVF 0xB1, W
0CF1  0087     MOVWF FSR1H
0CF2  3142     ADDFSR 1, 2
0CF3  0873     MOVF 0xF3, W
0CF4  3FC0     MOVWI 0[FSR1]
0CF5  0874     MOVF 0xF4, W
0CF6  3FC1     MOVWI 1[FSR1]
2628:                  USBCtrlTrfTxService();
0CF7  318C     MOVLP 0xC
0CF8  2446     CALL 0x446
0CF9  318C     MOVLP 0xC
2629:          
2630:                  //Check if we have already sent a short packet.  If so, configure
2631:                  //the endpoint to STALL in response to any further IN tokens (in the
2632:                  //case that the host erroneously tries to receive more data than it
2633:                  //should).
2634:                  if(shortPacketStatus == SHORT_PKT_SENT)
0CFA  3002     MOVLW 0x2
0CFB  0021     MOVLB 0x1
0CFC  0651     XORWF shortPacketStatus, W
0CFD  1D03     BTFSS STATUS, 0x2
0CFE  2D00     GOTO 0x500
0CFF  2D01     GOTO 0x501
0D00  2D0D     GOTO 0x50D
2635:                  {
2636:                      // If a short packet has been sent, don't want to send any more,
2637:                      // stall next time if host is still trying to read.
2638:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
0D01  0830     MOVF pBDTEntryIn, W
0D02  0086     MOVWF FSR1L
0D03  0831     MOVF 0xB1, W
0D04  0087     MOVWF FSR1H
0D05  3004     MOVLW 0x4
0D06  0081     MOVWF INDF1
2639:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
0D07  0830     MOVF pBDTEntryIn, W
0D08  0086     MOVWF FSR1L
0D09  0831     MOVF 0xB1, W
0D0A  0087     MOVWF FSR1H
0D0B  1781     BSF INDF1, 0x7
2640:                  }
0D0C  2D32     GOTO 0x532
2641:                  else
2642:                  {
2643:                      if(lastDTS == 0)
0D0D  0875     MOVF 0xF5, W
0D0E  1D03     BTFSS STATUS, 0x2
0D0F  2D11     GOTO 0x511
0D10  2D12     GOTO 0x512
0D11  2D1E     GOTO 0x51E
2644:                      {
2645:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
0D12  0830     MOVF pBDTEntryIn, W
0D13  0086     MOVWF FSR1L
0D14  0831     MOVF 0xB1, W
0D15  0087     MOVWF FSR1H
0D16  3048     MOVLW 0x48
0D17  0081     MOVWF INDF1
2646:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0D18  0830     MOVF pBDTEntryIn, W
0D19  0086     MOVWF FSR1L
0D1A  0831     MOVF 0xB1, W
0D1B  0087     MOVWF FSR1H
0D1C  1781     BSF INDF1, 0x7
2647:                      }
0D1D  2D32     GOTO 0x532
2648:                      else
2649:                      {
2650:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
0D1E  0830     MOVF pBDTEntryIn, W
0D1F  0086     MOVWF FSR1L
0D20  0831     MOVF 0xB1, W
0D21  0087     MOVWF FSR1H
0D22  3008     MOVLW 0x8
0D23  0081     MOVWF INDF1
2651:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
0D24  0830     MOVF pBDTEntryIn, W
0D25  0086     MOVWF FSR1L
0D26  0831     MOVF 0xB1, W
0D27  0087     MOVWF FSR1H
0D28  1781     BSF INDF1, 0x7
0D29  2D32     GOTO 0x532
2652:                      }
2653:                  }//end if(...)else
2654:              }
2655:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2656:          	{
2657:                  //if someone is still expecting data from the control transfer
2658:                  //  then make sure to terminate that request and let them know that
2659:                  //  they are done
2660:                  if(outPipes[0].info.bits.busy == 1)
0D2A  0022     MOVLB 0x2
0D2B  1FA2     BTFSS 0x122, 0x7
0D2C  2D2E     GOTO 0x52E
0D2D  2D2F     GOTO 0x52F
0D2E  2D30     GOTO 0x530
2661:                  {
2662:                      if(outPipes[0].pFunc != NULL)
2663:                      {
2664:                          outPipes[0].pFunc();
2665:                      }
2666:                      outPipes[0].info.bits.busy = 0;
0D2F  13A2     BCF 0x122, 0x7
2667:                  }
2668:          
2669:                  controlTransferState = WAIT_SETUP;
0D30  0021     MOVLB 0x1
0D31  01D0     CLRF controlTransferState
2670:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2671:                  //got processed by the USBCtrlTrfRxService() handler.
2672:          	}
2673:          
2674:          }
0D32  0008     RETURN
2675:          
2676:          
2677:          /********************************************************************
2678:           * Function:        void USBCheckStdRequest(void)
2679:           *
2680:           * PreCondition:    None
2681:           *
2682:           * Input:           None
2683:           *
2684:           * Output:          None
2685:           *
2686:           * Side Effects:    None
2687:           *
2688:           * Overview:        This routine checks the setup data packet to see
2689:           *                  if it knows how to handle it
2690:           *
2691:           * Note:            None
2692:           *******************************************************************/
2693:          static void USBCheckStdRequest(void)
2694:          {
2695:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0D33  0020     MOVLB 0x0
0D34  0E60     SWAPF SetupPkt, W
0D35  0C89     RRF WREG, F
0D36  3903     ANDLW 0x3
0D37  3A00     XORLW 0x0
0D38  1903     BTFSC STATUS, 0x2
0D39  2D3B     GOTO 0x53B
0D3A  2D3C     GOTO 0x53C
0D3B  2D82     GOTO 0x582
0D3C  2DAE     GOTO 0x5AE
2696:          
2697:              switch(SetupPkt.bRequest)
2698:              {
2699:                  case USB_REQUEST_SET_ADDRESS:
2700:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
0D3D  17BA     BSF 0x3A, 0x7
2701:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
0D3E  3008     MOVLW 0x8
0D3F  00E5     MOVWF 0x65
0D40  0865     MOVF 0x65, W
0D41  00D3     MOVWF 0x53
2702:                      /* See USBCtrlTrfInHandler() for the next step */
2703:                      break;
0D42  2DAE     GOTO 0x5AE
2704:                  case USB_REQUEST_GET_DESCRIPTOR:
2705:                      USBStdGetDscHandler();
0D43  318D     MOVLP 0xD
0D44  25AF     CALL 0x5AF
0D45  318D     MOVLP 0xD
2706:                      break;
0D46  2DAE     GOTO 0x5AE
2707:                  case USB_REQUEST_SET_CONFIGURATION:
2708:                      USBStdSetCfgHandler();
0D47  318E     MOVLP 0xE
0D48  2634     CALL 0x634
0D49  318D     MOVLP 0xD
2709:                      break;
0D4A  2DAE     GOTO 0x5AE
2710:                  case USB_REQUEST_GET_CONFIGURATION:
2711:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
0D4B  30D7     MOVLW 0xD7
0D4C  00B8     MOVWF 0x38
0D4D  3000     MOVLW 0x0
0D4E  00B9     MOVWF 0x39
2712:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
0D4F  143A     BSF 0x3A, 0x0
2713:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0D50  01BB     CLRF 0x3B
0D51  0ABB     INCF 0x3B, F
2714:                      inPipes[0].info.bits.busy = 1;
0D52  17BA     BSF 0x3A, 0x7
2715:                      break;
0D53  2DAE     GOTO 0x5AE
2716:                  case USB_REQUEST_GET_STATUS:
2717:                      USBStdGetStatusHandler();
0D54  318B     MOVLP 0xB
0D55  2367     CALL 0x367
0D56  318D     MOVLP 0xD
2718:                      break;
0D57  2DAE     GOTO 0x5AE
2719:                  case USB_REQUEST_CLEAR_FEATURE:
2720:                  case USB_REQUEST_SET_FEATURE:
2721:                      USBStdFeatureReqHandler();
0D58  3180     MOVLP 0x0
0D59  2044     CALL 0x44
0D5A  318D     MOVLP 0xD
2722:                      break;
0D5B  2DAE     GOTO 0x5AE
2723:                  case USB_REQUEST_GET_INTERFACE:
2724:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
0D5C  0020     MOVLB 0x0
0D5D  0864     MOVF 0x64, W
0D5E  3EB6     ADDLW 0xB6
0D5F  0021     MOVLB 0x1
0D60  00B8     MOVWF inPipes
0D61  3001     MOVLW 0x1
0D62  00B9     MOVWF 0xB9
0D63  2D4F     GOTO 0x54F
2725:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2726:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2727:                      inPipes[0].info.bits.busy = 1;
2728:                      break;
2729:                  case USB_REQUEST_SET_INTERFACE:
2730:                      inPipes[0].info.bits.busy = 1;
0D64  17BA     BSF 0xBA, 0x7
2731:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
0D65  0020     MOVLB 0x0
0D66  0862     MOVF 0x62, W
0D67  0021     MOVLB 0x1
0D68  00E5     MOVWF 0xE5
0D69  0020     MOVLB 0x0
0D6A  0864     MOVF 0x64, W
0D6B  3EB6     ADDLW 0xB6
0D6C  0086     MOVWF FSR1
0D6D  3001     MOVLW 0x1
0D6E  0087     MOVWF FSR1H
0D6F  0021     MOVLB 0x1
0D70  0865     MOVF 0xE5, W
0D71  0081     MOVWF INDF1
2732:                      break;
0D72  2DAE     GOTO 0x5AE
2733:                  case USB_REQUEST_SET_DESCRIPTOR:
2734:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
0D73  3002     MOVLW 0x2
0D74  00D8     MOVWF __pcstackBANK1
0D75  3000     MOVLW 0x0
0D76  00D9     MOVWF 0xD9
0D77  3000     MOVLW 0x0
0D78  00DA     MOVWF pdata
0D79  3000     MOVLW 0x0
0D7A  00DB     MOVWF 0xDB
0D7B  3000     MOVLW 0x0
0D7C  00DC     MOVWF size
0D7D  00DD     MOVWF 0xDD
0D7E  3189     MOVLP 0x9
0D7F  21C3     CALL 0x1C3
0D80  318D     MOVLP 0xD
2735:                      break;
0D81  2DAE     GOTO 0x5AE
2736:                  case USB_REQUEST_SYNCH_FRAME:
2737:                  default:
2738:                      break;
2739:              }//end switch
0D82  0861     MOVF i, W
0D83  0021     MOVLB 0x1
0D84  00E5     MOVWF 0xE5
0D85  01E6     CLRF 0xE6
0D86  0866     MOVF 0xE6, W
0D87  3A00     XORLW 0x0
0D88  1903     BTFSC STATUS, 0x2
0D89  2D8B     GOTO 0x58B
0D8A  2DAE     GOTO 0x5AE
0D8B  0865     MOVF 0xE5, W
0D8C  3A00     XORLW 0x0
0D8D  1903     BTFSC STATUS, 0x2
0D8E  2D54     GOTO 0x554
0D8F  3A01     XORLW 0x1
0D90  1903     BTFSC STATUS, 0x2
0D91  2D58     GOTO 0x558
0D92  3A02     XORLW 0x2
0D93  1903     BTFSC STATUS, 0x2
0D94  2D58     GOTO 0x558
0D95  3A06     XORLW 0x6
0D96  1903     BTFSC STATUS, 0x2
0D97  2D3D     GOTO 0x53D
0D98  3A03     XORLW 0x3
0D99  1903     BTFSC STATUS, 0x2
0D9A  2D43     GOTO 0x543
0D9B  3A01     XORLW 0x1
0D9C  1903     BTFSC STATUS, 0x2
0D9D  2D73     GOTO 0x573
0D9E  3A0F     XORLW 0xF
0D9F  1903     BTFSC STATUS, 0x2
0DA0  2D4B     GOTO 0x54B
0DA1  3A01     XORLW 0x1
0DA2  1903     BTFSC STATUS, 0x2
0DA3  2D47     GOTO 0x547
0DA4  3A03     XORLW 0x3
0DA5  1903     BTFSC STATUS, 0x2
0DA6  2D5C     GOTO 0x55C
0DA7  3A01     XORLW 0x1
0DA8  1903     BTFSC STATUS, 0x2
0DA9  2D64     GOTO 0x564
0DAA  3A07     XORLW 0x7
0DAB  1903     BTFSC STATUS, 0x2
0DAC  2DAE     GOTO 0x5AE
0DAD  2DAE     GOTO 0x5AE
2740:          }//end USBCheckStdRequest
0DAE  0008     RETURN
2741:          
2742:          /********************************************************************
2743:           * Function:        void USBStdFeatureReqHandler(void)
2744:           *
2745:           * PreCondition:    None
2746:           *
2747:           * Input:           None
2748:           *
2749:           * Output:          Can alter BDT entries.  Can also modify USB stack
2750:           *                  Maintained variables.
2751:           *
2752:           * Side Effects:    None
2753:           *
2754:           * Overview:        This routine handles the standard SET & CLEAR
2755:           *                  FEATURES requests
2756:           *
2757:           * Note:            This is a private function, intended for internal
2758:           *                  use by the USB stack, when processing SET/CLEAR
2759:           *                  feature requests.
2760:           *******************************************************************/
2761:          static void USBStdFeatureReqHandler(void)
2762:          {
2763:              BDT_ENTRY *p;
2764:              EP_STATUS current_ep_data;
2765:              #if defined(__C32__)
2766:                  uint32_t* pUEP;
2767:              #else
2768:                  unsigned char* pUEP;
2769:              #endif
2770:          
2771:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2772:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
0044  0020     MOVLB 0x0
0045  0362     DECF 0x62, W
0046  1D03     BTFSS STATUS, 0x2
0047  2849     GOTO 0x49
0048  284A     GOTO 0x4A
0049  2860     GOTO 0x60
004A  0860     MOVF SetupPkt, W
004B  391F     ANDLW 0x1F
004C  3A00     XORLW 0x0
004D  1D03     BTFSS STATUS, 0x2
004E  2850     GOTO 0x50
004F  2851     GOTO 0x51
0050  2860     GOTO 0x60
2773:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2774:              {
2775:                  inPipes[0].info.bits.busy = 1;
0051  0021     MOVLB 0x1
0052  17BA     BSF 0xBA, 0x7
2776:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0053  3003     MOVLW 0x3
0054  0020     MOVLB 0x0
0055  0661     XORWF 0x61, W
0056  1D03     BTFSS STATUS, 0x2
0057  2859     GOTO 0x59
0058  285A     GOTO 0x5A
0059  285E     GOTO 0x5E
2777:                      RemoteWakeup = true;
005A  0021     MOVLB 0x1
005B  01CE     CLRF RemoteWakeup
005C  0ACE     INCF RemoteWakeup, F
005D  2860     GOTO 0x60
2778:                  else
2779:                      RemoteWakeup = false;
005E  0021     MOVLB 0x1
005F  01CE     CLRF RemoteWakeup
2780:              }//end if
2781:          
2782:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2783:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
0060  0020     MOVLB 0x0
0061  0862     MOVF 0x62, W
0062  1D03     BTFSS STATUS, 0x2
0063  2865     GOTO 0x65
0064  2866     GOTO 0x66
0065  29AA     GOTO 0x1AA
0066  0860     MOVF SetupPkt, W
0067  391F     ANDLW 0x1F
0068  3A02     XORLW 0x2
0069  1D03     BTFSS STATUS, 0x2
006A  286C     GOTO 0x6C
006B  286D     GOTO 0x6D
006C  29AA     GOTO 0x1AA
006D  0864     MOVF 0x64, W
006E  390F     ANDLW 0xF
006F  3A00     XORLW 0x0
0070  1903     BTFSC STATUS, 0x2
0071  2873     GOTO 0x73
0072  2874     GOTO 0x74
0073  29AA     GOTO 0x1AA
0074  0864     MOVF 0x64, W
0075  390F     ANDLW 0xF
0076  0021     MOVLB 0x1
0077  00DE     MOVWF 0xDE
0078  3004     MOVLW 0x4
0079  025E     SUBWF 0xDE, W
007A  1803     BTFSC STATUS, 0x0
007B  287D     GOTO 0x7D
007C  287E     GOTO 0x7E
007D  29AA     GOTO 0x1AA
007E  3020     MOVLW 0x20
007F  0653     XORWF USBDeviceState, W
0080  1D03     BTFSS STATUS, 0x2
0081  2883     GOTO 0x83
0082  2884     GOTO 0x84
0083  29AA     GOTO 0x1AA
2784:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2785:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2786:                 (USBDeviceState == CONFIGURED_STATE))
2787:              {
2788:          		//The request was valid.  Take control of the control transfer and
2789:          		//perform the host requested action.
2790:          		inPipes[0].info.bits.busy = 1;
0084  17BA     BSF 0xBA, 0x7
2791:          
2792:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2793:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
0085  0020     MOVLB 0x0
0086  1BE4     BTFSC 0x64, 0x7
0087  2889     GOTO 0x89
0088  288A     GOTO 0x8A
0089  28A3     GOTO 0xA3
2794:                  {
2795:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
008A  0864     MOVF 0x64, W
008B  390F     ANDLW 0xF
008C  0709     ADDWF WREG, W
008D  3EA0     ADDLW 0xA0
008E  0086     MOVWF FSR1
008F  3001     MOVLW 0x1
0090  0087     MOVWF FSR1H
0091  3F40     MOVIW 0[FSR1]
0092  0021     MOVLB 0x1
0093  00E3     MOVWF p
0094  3F41     MOVIW 1[FSR1]
0095  00E4     MOVWF 0xE4
2796:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
0096  0020     MOVLB 0x0
0097  0864     MOVF 0x64, W
0098  390F     ANDLW 0xF
0099  3EAC     ADDLW 0xAC
009A  0086     MOVWF FSR1
009B  3001     MOVLW 0x1
009C  0087     MOVWF FSR1H
009D  0801     MOVF INDF1, W
009E  0021     MOVLB 0x1
009F  00DE     MOVWF 0xDE
00A0  085E     MOVF 0xDE, W
00A1  00E2     MOVWF i
2797:                  }
00A2  28BA     GOTO 0xBA
2798:                  else
2799:                  {
2800:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
00A3  0864     MOVF 0xE4, W
00A4  390F     ANDLW 0xF
00A5  0709     ADDWF WREG, W
00A6  3EB0     ADDLW 0xB0
00A7  0086     MOVWF FSR1L
00A8  0187     CLRF FSR1H
00A9  3F40     MOVIW 0[FSR1]
00AA  0021     MOVLB 0x1
00AB  00E3     MOVWF p
00AC  3F41     MOVIW 1[FSR1]
00AD  00E4     MOVWF 0xE4
2801:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
00AE  0020     MOVLB 0x0
00AF  0864     MOVF 0x64, W
00B0  390F     ANDLW 0xF
00B1  3EB0     ADDLW 0xB0
00B2  0086     MOVWF FSR1
00B3  3001     MOVLW 0x1
00B4  0087     MOVWF FSR1H
00B5  0801     MOVF INDF1, W
00B6  0021     MOVLB 0x1
00B7  00DE     MOVWF 0xDE
00B8  085E     MOVF 0xDE, W
00B9  00E2     MOVWF i
2802:                  }
2803:          
2804:                  //If ping pong buffering is enabled on the requested endpoint, need
2805:                  //to point to the one that is the active BDT entry which the SIE will
2806:                  //use for the next attempted transaction on that EP number.
2807:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2808:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
00BA  1862     BTFSC i, 0x0
00BB  28BD     GOTO 0xBD
00BC  28BE     GOTO 0xBE
00BD  28C9     GOTO 0xC9
2809:                      {
2810:                          p = (BDT_ENTRY*)(((uintptr_t)(p)) & (~USB_NEXT_PING_PONG));
00BE  30FB     MOVLW 0xFB
00BF  00DE     MOVWF 0xDE
00C0  30FF     MOVLW 0xFF
00C1  00DF     MOVWF p
00C2  0863     MOVF p, W
00C3  055E     ANDWF 0xDE, W
00C4  00E3     MOVWF p
00C5  0864     MOVF 0xE4, W
00C6  055F     ANDWF p, W
00C7  00E4     MOVWF 0xE4
2811:                      }
00C8  28CF     GOTO 0xCF
2812:                      else //else must have been odd
2813:                      {
2814:                          p = (BDT_ENTRY*)(((uintptr_t)p) | USB_NEXT_PING_PONG);
00C9  3004     MOVLW 0x4
00CA  0463     IORWF p, W
00CB  00E3     MOVWF p
00CC  3000     MOVLW 0x0
00CD  0464     IORWF 0xE4, W
00CE  00E4     MOVWF 0xE4
2815:                      }
2816:                  #endif
2817:          
2818:                  //Update the BDT pointers with the new, next entry based on the feature
2819:                  //  request
2820:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
00CF  0020     MOVLB 0x0
00D0  1BE4     BTFSC 0x64, 0x7
00D1  28D3     GOTO 0xD3
00D2  28D4     GOTO 0xD4
00D3  28E1     GOTO 0xE1
2821:                  {
2822:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00D4  0864     MOVF 0x64, W
00D5  390F     ANDLW 0xF
00D6  0709     ADDWF WREG, W
00D7  3EA0     ADDLW 0xA0
00D8  0086     MOVWF FSR1
00D9  3001     MOVLW 0x1
00DA  0087     MOVWF FSR1H
00DB  0021     MOVLB 0x1
00DC  0863     MOVF p, W
00DD  3FC0     MOVWI 0[FSR1]
00DE  0864     MOVF 0xE4, W
00DF  3FC1     MOVWI 1[FSR1]
2823:                  }
00E0  28EC     GOTO 0xEC
2824:                  else
2825:                  {
2826:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
00E1  0864     MOVF 0xE4, W
00E2  390F     ANDLW 0xF
00E3  0709     ADDWF WREG, W
00E4  3EB0     ADDLW 0xB0
00E5  0086     MOVWF FSR1L
00E6  0187     CLRF FSR1H
00E7  0021     MOVLB 0x1
00E8  0863     MOVF p, W
00E9  3FC0     MOVWI 0[FSR1]
00EA  0864     MOVF 0xE4, W
00EB  3FC1     MOVWI 1[FSR1]
2827:                  }
2828:          
2829:          		//Check if it was a SET_FEATURE endpoint halt request
2830:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
00EC  3003     MOVLW 0x3
00ED  0020     MOVLB 0x0
00EE  0661     XORWF 0x61, W
00EF  1D03     BTFSS STATUS, 0x2
00F0  28F2     GOTO 0xF2
00F1  28F3     GOTO 0xF3
00F2  291C     GOTO 0x11C
2831:                  {
2832:                      if(p->STAT.UOWN == 1)
00F3  0021     MOVLB 0x1
00F4  0863     MOVF p, W
00F5  0086     MOVWF FSR1L
00F6  0864     MOVF 0xE4, W
00F7  0087     MOVWF FSR1H
00F8  1F81     BTFSS INDF1, 0x7
00F9  28FB     GOTO 0xFB
00FA  28FC     GOTO 0xFC
00FB  2910     GOTO 0x110
2833:                      {
2834:                          //Mark that we are terminating this transfer and that the user
2835:                          //  needs to be notified later
2836:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
00FC  0020     MOVLB 0x0
00FD  1BE4     BTFSC 0x64, 0x7
00FE  2900     GOTO 0x100
00FF  2901     GOTO 0x101
0100  2909     GOTO 0x109
2837:                          {
2838:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
0101  0864     MOVF 0x64, W
0102  390F     ANDLW 0xF
0103  3EAC     ADDLW 0xAC
0104  0086     MOVWF FSR1
0105  3001     MOVLW 0x1
0106  0087     MOVWF FSR1H
0107  1481     BSF INDF1, 0x1
2839:                          }
0108  2910     GOTO 0x110
2840:                          else
2841:                          {
2842:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
0109  0864     MOVF 0x64, W
010A  390F     ANDLW 0xF
010B  3EB0     ADDLW 0xB0
010C  0086     MOVWF FSR1
010D  3001     MOVLW 0x1
010E  0087     MOVWF FSR1H
010F  1481     BSF INDF1, 0x1
2843:                          }
2844:                      }
2845:          
2846:          			//Then STALL the endpoint
2847:                      p->STAT.Val |= _BSTALL;
0110  0021     MOVLB 0x1
0111  0863     MOVF p, W
0112  0086     MOVWF FSR1L
0113  0864     MOVF 0xE4, W
0114  0087     MOVWF FSR1H
0115  1501     BSF INDF1, 0x2
2848:                      p->STAT.Val |= _USIE;
0116  0863     MOVF p, W
0117  0086     MOVWF FSR1L
0118  0864     MOVF 0xE4, W
0119  0087     MOVWF FSR1H
011A  1781     BSF INDF1, 0x7
2849:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
011B  29AA     GOTO 0x1AA
2850:                  else
2851:                  {
2852:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2853:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2854:                          //toggle over the to the non-active BDT
2855:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
011C  3004     MOVLW 0x4
011D  0021     MOVLB 0x1
011E  0663     XORWF p, W
011F  00E3     MOVWF p
0120  3000     MOVLW 0x0
0121  0664     XORWF 0xE4, W
0122  00E4     MOVWF 0xE4
2856:          
2857:                          if(p->STAT.UOWN == 1)
0123  0863     MOVF p, W
0124  0086     MOVWF FSR1L
0125  0864     MOVF 0xE4, W
0126  0087     MOVWF FSR1H
0127  1F81     BTFSS INDF1, 0x7
0128  292A     GOTO 0x12A
0129  292B     GOTO 0x12B
012A  2948     GOTO 0x148
2858:                          {
2859:                              //Clear UOWN and set DTS state so it will be correct the next time
2860:                              //the application firmware uses USBTransferOnePacket() on the EP.
2861:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
012B  307F     MOVLW 0x7F
012C  00DE     MOVWF 0xDE
012D  0863     MOVF p, W
012E  0086     MOVWF FSR1L
012F  0864     MOVF 0xE4, W
0130  0087     MOVWF FSR1H
0131  085E     MOVF 0xDE, W
0132  0581     ANDWF INDF1, F
2862:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
0133  0863     MOVF p, W
0134  0086     MOVWF FSR1L
0135  0864     MOVF 0xE4, W
0136  0087     MOVWF FSR1H
0137  1701     BSF INDF1, 0x6
2863:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0138  3005     MOVLW 0x5
0139  00D8     MOVWF __pcstackBANK1
013A  3000     MOVLW 0x0
013B  00D9     MOVWF 0xD9
013C  0864     MOVF 0xE4, W
013D  00DB     MOVWF 0xDB
013E  0863     MOVF p, W
013F  00DA     MOVWF pdata
0140  3002     MOVLW 0x2
0141  00DC     MOVWF size
0142  3000     MOVLW 0x0
0143  00DD     MOVWF 0xDD
0144  3189     MOVLP 0x9
0145  21C3     CALL 0x1C3
0146  3180     MOVLP 0x0
2864:                          }
0147  294D     GOTO 0x14D
2865:                          else
2866:                          {
2867:                              //UOWN already clear, but still need to set DTS to DATA1
2868:          					p->STAT.Val |= _DAT1;
0148  0863     MOVF p, W
0149  0086     MOVWF FSR1L
014A  0864     MOVF 0xE4, W
014B  0087     MOVWF FSR1H
014C  1701     BSF INDF1, 0x6
2869:                          }
2870:          
2871:                          //toggle back to the active BDT (the one the SIE is currently looking at
2872:                          //and will use for the next successful transaction to take place on the EP
2873:                          p = (BDT_ENTRY*)(((uintptr_t)p) ^ USB_NEXT_PING_PONG);
014D  3004     MOVLW 0x4
014E  0021     MOVLB 0x1
014F  0663     XORWF p, W
0150  00E3     MOVWF p
0151  3000     MOVLW 0x0
0152  0664     XORWF 0xE4, W
0153  00E4     MOVWF 0xE4
2874:          
2875:                          //Check if we are currently terminating, or have previously terminated
2876:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2877:                          //set DTS to the proper state, and call the application callback
2878:                          //function.
2879:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
0154  18E2     BTFSC i, 0x1
0155  2957     GOTO 0x157
0156  2958     GOTO 0x158
0157  2960     GOTO 0x160
0158  0863     MOVF p, W
0159  0086     MOVWF FSR1L
015A  0864     MOVF 0xE4, W
015B  0087     MOVWF FSR1H
015C  1F81     BTFSS INDF1, 0x7
015D  295F     GOTO 0x15F
015E  2960     GOTO 0x160
015F  298D     GOTO 0x18D
2880:                          {
2881:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0160  0020     MOVLB 0x0
0161  1BE4     BTFSC 0x64, 0x7
0162  2964     GOTO 0x164
0163  2965     GOTO 0x165
0164  296D     GOTO 0x16D
2882:                              {
2883:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0165  0864     MOVF 0x64, W
0166  390F     ANDLW 0xF
0167  3EAC     ADDLW 0xAC
0168  0086     MOVWF FSR1
0169  3001     MOVLW 0x1
016A  0087     MOVWF FSR1H
016B  1081     BCF INDF1, 0x1
2884:                              }
016C  2974     GOTO 0x174
2885:                              else
2886:                              {
2887:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
016D  0864     MOVF 0x64, W
016E  390F     ANDLW 0xF
016F  3EB0     ADDLW 0xB0
0170  0086     MOVWF FSR1
0171  3001     MOVLW 0x1
0172  0087     MOVWF FSR1H
0173  1081     BCF INDF1, 0x1
2888:                              }
2889:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2890:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
0174  303B     MOVLW 0x3B
0175  0021     MOVLB 0x1
0176  00DE     MOVWF 0xDE
0177  0863     MOVF p, W
0178  0086     MOVWF FSR1L
0179  0864     MOVF 0xE4, W
017A  0087     MOVWF FSR1H
017B  085E     MOVF 0xDE, W
017C  0581     ANDWF INDF1, F
2891:                              //Call the application event handler callback function, so it can
2892:          					//decide if the endpoint should get re-armed again or not.
2893:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
017D  3005     MOVLW 0x5
017E  00D8     MOVWF __pcstackBANK1
017F  3000     MOVLW 0x0
0180  00D9     MOVWF 0xD9
0181  0864     MOVF 0xE4, W
0182  00DB     MOVWF 0xDB
0183  0863     MOVF p, W
0184  00DA     MOVWF pdata
0185  3002     MOVLW 0x2
0186  00DC     MOVWF size
0187  3000     MOVLW 0x0
0188  00DD     MOVWF 0xDD
0189  3189     MOVLP 0x9
018A  21C3     CALL 0x1C3
018B  3180     MOVLP 0x0
2894:                          }
018C  2995     GOTO 0x195
2895:                          else
2896:                          {
2897:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition
2898:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);
018D  303B     MOVLW 0x3B
018E  00DE     MOVWF 0xDE
018F  0863     MOVF p, W
0190  0086     MOVWF FSR1L
0191  0864     MOVF 0xE4, W
0192  0087     MOVWF FSR1H
0193  085E     MOVF 0xDE, W
0194  0581     ANDWF INDF1, F
2899:                          }
2900:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2901:                          //Check if we need to call the user transfer terminated event callback function.
2902:                          //We should call the callback, if the endpoint was previously terminated,
2903:                          //or the endpoint is currently armed, and the host is performing clear
2904:                          //endpoint halt, even though the endpoint wasn't stalled.
2905:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2906:                          {
2907:                              //We are going to call the user transfer terminated callback.
2908:                              //Clear the flag so we know we took care of it and don't need
2909:                              //to call it again later.
2910:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2911:                              {
2912:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2913:                              }
2914:                              else
2915:                              {
2916:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2917:                              }
2918:          
2919:                              //Clear UOWN and remove the STALL condition.
2920:                              //  In this case we also need to set the DTS bit to 1 so that
2921:                              //  it toggles to DATA0 the next time the application firmware
2922:                              //  calls USBTransferOnePacket() (or equivalent macro).
2923:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2924:                              p->STAT.Val |= _DAT1;
2925:                              //Let the application firmware know a transaction just
2926:                              //got terminated by the host, and that it is now free to
2927:                              //re-arm the endpoint or do other tasks if desired.
2928:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2929:                          }
2930:                          else
2931:                          {
2932:                              //Clear UOWN and remove the STALL condition.
2933:                              //  In this case we also need to set the DTS bit to 1 so that
2934:                              //  it toggles to DATA0 the next time the application firmware
2935:                              //  calls USBTransferOnePacket() (or equivalent macro).
2936:                              p->STAT.Val &= ~(_USIE | _BSTALL);
2937:                              p->STAT.Val |= _DAT1;
2938:                          }
2939:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
2940:          
2941:          			//Get a pointer to the appropriate UEPn register
2942:                      #if defined(__C32__)
2943:                          pUEP = (uint32_t*)(&U1EP0);
2944:                          pUEP += (SetupPkt.EPNum*4);
2945:                      #else
2946:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0195  0020     MOVLB 0x0
0196  0864     MOVF 0x64, W
0197  390F     ANDLW 0xF
0198  3E98     ADDLW 0x98
0199  0021     MOVLB 0x1
019A  00DE     MOVWF 0xDE
019B  01DF     CLRF p
019C  300E     MOVLW 0xE
019D  3DDF     ADDWFC p, F
019E  085E     MOVF 0xDE, W
019F  00E0     MOVWF pUEP
01A0  085F     MOVF p, W
01A1  00E1     MOVWF i
2947:                      #endif
2948:          
2949:          			//Clear the STALL bit in the UEP register
2950:                      *pUEP &= ~UEP_STALL;
01A2  30FE     MOVLW 0xFE
01A3  00DE     MOVWF 0xDE
01A4  0860     MOVF pUEP, W
01A5  0086     MOVWF FSR1L
01A6  0861     MOVF i, W
01A7  0087     MOVWF FSR1H
01A8  085E     MOVF 0xDE, W
01A9  0581     ANDWF INDF1, F
2951:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2952:              }//end if (lots of checks for set/clear endpoint halt)
2953:          }//end USBStdFeatureReqHandler
01AA  0008     RETURN
2954:          
2955:          
2956:          
2957:          
2958:          /**************************************************************************
2959:              Function:
2960:                  void USBIncrement1msInternalTimers(void)
2961:          
2962:              Description:
2963:                  This function increments internal 1ms time base counters, which are
2964:                  useful for application code (that can use a 1ms time base/counter), and
2965:                  for certain USB event timing specific purposes.
2966:          
2967:                  In USB full speed applications, the application code does not need to (and should
2968:                  not) explicitly call this function, as the USBDeviceTasks() function will
2969:                  automatically call this function whenever a 1ms time interval has elapsed
2970:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2971:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
2972:                  in USB_INTERRUPT mode).
2973:          
2974:                  In USB low speed applications, the application firmware is responsible for
2975:                  periodically calling this function at a ~1ms rate.  This can be done using
2976:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
2977:                  If the low speed application code does not call this function, the internal timers
2978:                  will not increment, and the USBGet1msTickCount() API function will not be available.
2979:                  Additionally, certain USB stack operations (like control transfer timeouts)
2980:                  may be unavailable.
2981:          
2982:              Precondition:
2983:                  This function should be called only after USBDeviceInit() has been
2984:                  called (at least once at the start of the application).  Ordinarily,
2985:                  application code should never call this function, unless it is a low speed
2986:                  USB device.
2987:          
2988:              Parameters:
2989:                  None
2990:          
2991:              Return Values:
2992:                  None
2993:          
2994:              Remarks:
2995:                  This function does not need to be called during USB suspend conditions, when
2996:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
2997:            ***************************************************************************/
2998:          void USBIncrement1msInternalTimers(void)
2999:          {
3000:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3001:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3002:              #endif
3003:          
3004:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3005:              //that needs a 1ms time base that is active during USB non-suspended operation.
3006:              USB1msTickCount++;
177F  3001     MOVLW 0x1
1780  0023     MOVLB 0x3
1781  07A8     ADDWF USB1msTickCount, F
1782  3000     MOVLW 0x0
1783  3DA9     ADDWFC 0x1A9, F
1784  3000     MOVLW 0x0
1785  3DAA     ADDWFC 0x1AA, F
1786  3000     MOVLW 0x0
1787  3DAB     ADDWFC _spwrh, F
3007:              if(USBIsBusSuspended() == false)
1788  0021     MOVLB 0x1
1789  084D     MOVF USBBusIsSuspended, W
178A  1D03     BTFSS STATUS, 0x2
178B  2F8D     GOTO 0x78D
178C  2F8E     GOTO 0x78E
178D  2F9B     GOTO 0x79B
3008:              {
3009:                  USBTicksSinceSuspendEnd++;
178E  3001     MOVLW 0x1
178F  00F0     MOVWF 0xF0
1790  0870     MOVF 0xF0, W
1791  07C4     ADDWF USBTicksSinceSuspendEnd, F
3010:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3011:                  if(USBTicksSinceSuspendEnd == 0)
1792  0844     MOVF USBTicksSinceSuspendEnd, W
1793  1D03     BTFSS STATUS, 0x2
1794  2F96     GOTO 0x796
1795  2F97     GOTO 0x797
1796  2F9B     GOTO 0x79B
3012:                  {
3013:                      USBTicksSinceSuspendEnd = 255;
1797  30FF     MOVLW 0xFF
1798  00F0     MOVWF 0xF0
1799  0870     MOVF 0xF0, W
179A  00C4     MOVWF USBTicksSinceSuspendEnd
3014:                  }
3015:              }
3016:          }
179B  0008     RETURN
3017:          
3018:          
3019:          
3020:          
3021:          /**************************************************************************
3022:              Function:
3023:                  uint32_t USBGet1msTickCount(void)
3024:          
3025:              Description:
3026:                  This function retrieves a 32-bit unsigned integer that normally increments by
3027:                  one every one millisecond.  The count value starts from zero when the
3028:                  USBDeviceInit() function is first called.  See the remarks section for
3029:                  details on special circumstances where the tick count will not increment.
3030:          
3031:              Precondition:
3032:                  This function should be called only after USBDeviceInit() has been
3033:                  called (at least once at the start of the application).
3034:          
3035:              Parameters:
3036:                  None
3037:          
3038:              Return Values:
3039:                  uint32_t representing the approximate millisecond count, since the time the
3040:                  USBDeviceInit() function was first called.
3041:          
3042:              Remarks:
3043:                  On 8-bit USB full speed devices, the internal counter is incremented on
3044:                  every SOF packet detected.  Therefore, it will not increment during suspend
3045:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3046:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3047:                  on 16-bit devices, the count continue to increment during USB suspend or
3048:                  detach events, so long as the application code has not put the microcontroller
3049:                  to sleep during these events, and the application firmware is regularly
3050:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3051:                  USB_INTERRUPT mode operation).
3052:          
3053:                  In USB low speed applications, the host does not broadcast SOF packets to
3054:                  the device, so the application firmware becomes responsible for calling
3055:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3056:                  timer interrupt handler), or else the returned value from this function will
3057:                  not increment.
3058:          
3059:                  Prior to calling USBDeviceInit() for the first time the returned value will
3060:                  be unpredictable.
3061:          
3062:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3063:                  code without risk of retrieving a partially updated 32-bit number.
3064:          
3065:                  However, this value only increments when the USBDeviceTasks() function is allowed
3066:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3067:                  function.  If however USB_POLLING mode is used, one must not block on this
3068:                  function without also calling USBDeviceTasks() continuously for the blocking
3069:                  duration (since the USB stack must still be allowed to execute, and the USB
3070:                  stack is also responsible for updating the tick counter internally).
3071:          
3072:                  If the application is operating in USB_POLLING mode, this function should
3073:                  only be called from the main loop context, and not from an interrupt handler,
3074:                  as the returned value could be incorrect, if the main loop context code was in
3075:                  the process of updating the internal count at the moment of the interrupt event.
3076:             ***************************************************************************/
3077:          uint32_t USBGet1msTickCount(void)
3078:          {
3079:              #if defined (USB_INTERRUPT)
3080:                  uint32_t localContextValue;
3081:          
3082:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3083:                  //value.  This ensures that the complete 32-bit value got read without
3084:                  //getting interrupted in between bytes.
3085:                  do
3086:                  {
3087:                      localContextValue = USB1msTickCount;
3088:                  }while(localContextValue != USB1msTickCount);
3089:          
3090:                  return localContextValue;
3091:          
3092:              #else
3093:                  return USB1msTickCount;
3094:              #endif
3095:          }
3096:          
3097:          
3098:          
3099:          
3100:          
3101:          
3102:          /** EOF USBDevice.c *****************************************************/
---  E:/Smart-Knob/pic16f1455_firmware/lib/system.c  ----------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #include "include/system.h"
21:            
22:            /** CONFIGURATION Bits **********************************************/
23:            // PIC16F1459 configuration bit settings:
24:            #if defined (USE_INTERNAL_OSC)	    // Define this in system.h if using the HFINTOSC for USB operation
25:                // CONFIG1
26:                #pragma config FOSC = INTOSC    // Oscillator Selection Bits (INTOSC oscillator: I/O function on CLKIN pin)
27:                #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
28:                #pragma config PWRTE = OFF      // Power-up Timer Enable (PWRT disabled)
29:                #pragma config MCLRE = OFF      // MCLR Pin Function Select (MCLR/VPP pin function is digital input)
30:                #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
31:                #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
32:                #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
33:                #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
34:                #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
35:            
36:                // CONFIG2
37:                #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
38:                #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
39:                #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
40:                #pragma config PLLMULT = 3x     // PLL Multipler Selection Bit (3x Output Frequency Selected)
41:                #pragma config PLLEN = ENABLED  // PLL Enable Bit (3x or 4x PLL Enabled)
42:                #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
43:                #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
44:                #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
45:                #pragma config LVP = OFF        // Low-Voltage Programming Enable (High-voltage on MCLR/VPP must be used for programming)
46:            #else
47:                // CONFIG1
48:            #pragma config FOSC = HS        // Oscillator Selection Bits (HS Oscillator, High-speed crystal/resonator connected between OSC1 and OSC2 pins)
49:            #pragma config WDTE = OFF       // Watchdog Timer Enable (WDT disabled)
50:            #pragma config PWRTE = ON       // Power-up Timer Enable (PWRT enabled)
51:            #pragma config MCLRE = ON       // MCLR Pin Function Select (MCLR/VPP pin function is MCLR)
52:            #pragma config CP = OFF         // Flash Program Memory Code Protection (Program memory code protection is disabled)
53:            #pragma config BOREN = ON       // Brown-out Reset Enable (Brown-out Reset enabled)
54:            #pragma config CLKOUTEN = OFF   // Clock Out Enable (CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin)
55:            #pragma config IESO = OFF       // Internal/External Switchover Mode (Internal/External Switchover Mode is disabled)
56:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
57:            
58:            // CONFIG2
59:            #pragma config WRT = OFF        // Flash Memory Self-Write Protection (Write protection off)
60:            #pragma config CPUDIV = NOCLKDIV// CPU System Clock Selection Bit (NO CPU system divide)
61:            #pragma config USBLSCLK = 48MHz // USB Low SPeed Clock Selection bit (System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.)
62:            #pragma config PLLMULT = 4x     // PLL Multipler Selection Bit (4x Output Frequency Selected)
63:            #pragma config PLLEN = ENABLED/*********!!!!!!!!!!!!!!!
64:            
65:            
66:            
67:            !*/  // PLL Enable Bit (3x or 4x PLL Enabled)
68:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable (Stack Overflow or Underflow will cause a Reset)
69:            #pragma config BORV = LO        // Brown-out Reset Voltage Selection (Brown-out Reset Voltage (Vbor), low trip point selected.)
70:            #pragma config LPBOR = OFF      // Low-Power Brown Out Reset (Low-Power BOR is disabled)
71:            #pragma config LVP = ON         // Low-Voltage Programming Enable (Low-voltage programming enabled)
72:            #endif
73:            /*********************************************************************
74:            * Function: void SYSTEM_Initialize( SYSTEM_STATE state )
75:            *
76:            * Overview: Initializes the system.
77:            *
78:            * PreCondition: None
79:            *
80:            * Input:  SYSTEM_STATE - the state to initialize the system into
81:            *
82:            * Output: None
83:            *
84:            ********************************************************************/
85:            void SYSTEM_Initialize( SYSTEM_STATE state )
179C  00F5     MOVWF 0xF5
86:            {
87:                ANSELC = 0;
179D  0023     MOVLB 0x3
179E  018E     CLRF ANSELC
88:                switch(state)
179F  2FA9     GOTO 0x7A9
89:                {
90:                    case SYSTEM_STATE_USB_START:
91:                        #if defined(USE_INTERNAL_OSC)
92:                            //Make sure to turn on active clock tuning for USB full speed 
93:                            //operation from the INTOSC
94:                            OSCCON = 0xFC;  //HFINTOSC @ 16MHz, 3X PLL, PLL enabled
95:                            ACTCON = 0x90;  //Active clock tuning enabled for USB
96:                        #endif
97:                        LED_Enable(LED_USB_DEVICE_STATE);
17A0  3001     MOVLW 0x1
17A1  3188     MOVLP 0x8
17A2  2052     CALL 0x52
17A3  3197     MOVLP 0x17
98:                        //LED_Enable(LED_D3);
99:                        
100:                       BUTTON_Enable(BUTTON_USB_DEVICE_HID_JOYSTICK);
17A4  3001     MOVLW 0x1
17A5  3187     MOVLP 0x7
17A6  27ED     CALL 0x7ED
17A7  3197     MOVLP 0x17
101:                       break;
17A8  2FBC     GOTO 0x7BC
102:                       
103:                   case SYSTEM_STATE_USB_SUSPEND: 
104:                       break;
105:                       
106:                   case SYSTEM_STATE_USB_RESUME:
107:                       break;
108:               }
17A9  0875     MOVF 0x1F5, W
17AA  00F3     MOVWF 0x1F3
17AB  01F4     CLRF 0x1F4
17AC  0874     MOVF 0x1F4, W
17AD  3A00     XORLW 0x0
17AE  1903     BTFSC STATUS, 0x2
17AF  2FB1     GOTO 0x7B1
17B0  2FBC     GOTO 0x7BC
17B1  0873     MOVF 0x1F3, W
17B2  3A00     XORLW 0x0
17B3  1903     BTFSC STATUS, 0x2
17B4  2FA0     GOTO 0x7A0
17B5  3A01     XORLW 0x1
17B6  1903     BTFSC STATUS, 0x2
17B7  2FBC     GOTO 0x7BC
17B8  3A03     XORLW 0x3
17B9  1903     BTFSC STATUS, 0x2
17BA  2FBC     GOTO 0x7BC
17BB  2FBC     GOTO 0x7BC
109:           }
17BC  0008     RETURN
110:           
111:           #if(__XC8_VERSION < 2000)
112:               #define INTERRUPT interrupt
113:           #else
114:               #define INTERRUPT __interrupt()
115:           #endif			
116:           			
117:           void INTERRUPT SYS_InterruptHigh(void)
0004  147E     BSF 0x1FE, 0x0
0005  3180     MOVLP 0x0
118:           {
119:               #if defined(USB_INTERRUPT)
120:                   USBDeviceTasks();
121:               #endif
122:           }
0006  107E     BCF 0x1FE, 0x0
---  E:/Smart-Knob/pic16f1455_firmware/lib/spi.c  -------------------------------------------------------
1:             #include <xc.h>
2:             #include "include/spi.h"
3:             
4:             #include "include/app_device_joystick.h"
5:             
6:             #define SPI_FREQ 6
7:             #if SPI_FREQ == 6
8:                 #define SPI_MODE MASTER_OSC_SPADD
9:             #else
10:                #define SPI_MODE MASTER_OSC_DIV4
11:            #endif
12:            
13:            #define writeByteNOread asm("MOVIW FSR1++");/*load next byte*/   \
14:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
15:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
16:                asm("BRA -2");                         /*else go back*/         \
17:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
18:                
19:            #define writeByteRead asm("MOVIW FSR1++");/*load next byte*/   \
20:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
21:                asm("BTFSS SSP1STAT, 0x0");            /*if ready continue*/    \
22:                asm("BRA -2");                         /*else go back*/         \
23:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
24:                asm("MOVWI FSR0++");/*save received byte*/
25:                
26:            #if SPI_FREQ == 6
27:                #define WAIT_ADDITIONAL NOP();NOP();NOP();NOP();  NOP();NOP();NOP();NOP(); 
28:            #else
29:                #define WIAT_ADDITIONAL
30:            #endif
31:            
32:            
33:            
34:            #define writeByteNOreadFAST asm("MOVIW FSR1++");/*load next byte*/  \
35:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
36:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
37:                WAIT_ADDITIONAL                                                 \
38:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/
39:                
40:            #define writeByteReadFAST asm("MOVIW FSR1++");/*load next byte*/  \
41:                asm("MOVWF SSP1BUF");                      /*output to SPI*/    \
42:                NOP();NOP();NOP();NOP();   NOP();NOP();NOP();NOP();NOP();   \
43:                WAIT_ADDITIONAL                                                 \
44:                asm("MOVF SSP1BUF,W");                /*read the received byte into W*/ \
45:                asm("MOVWI FSR0++");/*save received byte*/
46:                
47:            
48:            
49:            
50:                //TO DO OUT VECTOR
51:            #define REP8(x) x x x x x x x x
52:            
53:            #define strgf(x) str_H(x)
54:            #define str_H(X) #X
55:            #define MOVLW_ADR(X) asm(strgf(M_CONC(MOVLW 0x, X)));
56:            
57:            
58:            #define _XTAL_FREQ 48000000
59:            void spiRead(void){
60:                if(BF){
61:                    TESTB=SSPBUF;
62:                    REGT=0x22;
63:                    if(TESTB == 0x55){
64:                        //service transfer
65:                        SSPBUF = 0x76;
66:                        while(WCOL){    //write the SYNC RECEIVED CODE(0x76)
67:                            WCOL=0;
68:                            SSPBUF = 0x76;
69:                        }
70:                        while(!BF);
71:                        
72:                        SSPBUF = 0x00;
73:                        while(WCOL){    //write the SYNC RECEIVED CODE(0x76)
74:                            WCOL=0;
75:                            SSPBUF = 0x00;
76:                        }
77:                        while(!BF);
78:                        REGT=0x11;
79:                    }
80:                    
81:                    //SSPBUF=0xff-TESTB;
82:                    //REGT=SSPCON1;
83:                    WCOL=0;
84:                    SSPOV=0;
85:                    
86:                }
87:            }
88:            
89:            char v[8]="ABCDEFGH";
90:            
91:            void spwrh(){
92:                /*
93:                 
94:                 * 
95:                 * 
96:                 * MOVLW 0xD0
97:            0B9E  0086     MOVWF FSR1L
98:            0B9F  3021     MOVLW 0x21
99:            0BA0  0087     MOVWF FSR1H
100:           0BA1  3141     ADDFSR 1, 1--------------
101:           0BA2  0801     MOVF INDF1, W
102:           0BA3  0091     MOVWF SSP1BUF
103:           0BA4  1C14     BTFSS SSP1STAT, 0x0
104:           0BA5  2BA7     GOTO 0x3A7
105:           0BA6  2BA8     GOTO 0x3A8
106:           0BA7  2BA4     GOTO 0x3A4
107:                */
108:               ////TESTING RECEIVE ON DISPLAY AND SEND ON HAPTIC
109:               //preload address
110:               //address for DISPLAY
111:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_LO)     //asm("MOVLW 0xD0");
01AB  30B0     MOVLW 0xB0
112:               asm("MOVWF FSR1L");
01AC  0086     MOVWF FSR1L
113:               MOVLW_ADR(DISPLAY_DATA_ADDRESS_HI)     //asm("MOVLW 0x21");
01AD  3021     MOVLW 0x21
114:               asm("MOVWF FSR1H");
01AE  0087     MOVWF FSR1H
115:               
116:               //address for HAPTIC_IN
117:               /*asm("MOVLW 0x30");
118:               asm("MOVWF FSR0L");
119:               asm("MOVLW 0x22");
120:               asm("MOVWF FSR0H");*/
121:               
122:               
123:               //go to bank 4, where the spbuf/stat is
124:               asm("MOVLB 4");
01AF  0024     MOVLB 0x4
125:               
126:               REP8(REP8(writeByteNOread))
01B0  0016     MOVIW FSR1++
01B1  0091     MOVWF SSP1BUF
01B2  1C14     BTFSS SSP1STAT, 0x0
01B3  33FE     BRA 0x1B2
01B4  0811     MOVF SSP1BUF, W
01B5  0016     MOVIW FSR1++
01B6  0091     MOVWF SSP1BUF
01B7  1C14     BTFSS SSP1STAT, 0x0
01B8  33FE     BRA 0x1B7
01B9  0811     MOVF SSP1BUF, W
01BA  0016     MOVIW FSR1++
01BB  0091     MOVWF SSP1BUF
01BC  1C14     BTFSS SSP1STAT, 0x0
01BD  33FE     BRA 0x1BC
01BE  0811     MOVF SSP1BUF, W
01BF  0016     MOVIW FSR1++
01C0  0091     MOVWF SSP1BUF
01C1  1C14     BTFSS SSP1STAT, 0x0
01C2  33FE     BRA __Hspace_1
01C3  0811     MOVF SSP1BUF, W
01C4  0016     MOVIW FSR1++
01C5  0091     MOVWF SSP1BUF
01C6  1C14     BTFSS SSP1STAT, 0x0
01C7  33FE     BRA 0x1C6
01C8  0811     MOVF SSP1BUF, W
01C9  0016     MOVIW FSR1++
01CA  0091     MOVWF SSP1BUF
01CB  1C14     BTFSS SSP1STAT, 0x0
01CC  33FE     BRA 0x1CB
01CD  0811     MOVF SSP1BUF, W
01CE  0016     MOVIW FSR1++
01CF  0091     MOVWF SSP1BUF
01D0  1C14     BTFSS SSP1STAT, 0x0
01D1  33FE     BRA 0x1D0
01D2  0811     MOVF SSP1BUF, W
01D3  0016     MOVIW FSR1++
01D4  0091     MOVWF SSP1BUF
01D5  1C14     BTFSS SSP1STAT, 0x0
01D6  33FE     BRA 0x1D5
01D7  0811     MOVF SSP1BUF, W
01D8  0016     MOVIW FSR1++
01D9  0091     MOVWF SSP1BUF
01DA  1C14     BTFSS SSP1STAT, 0x0
01DB  33FE     BRA 0x1DA
01DC  0811     MOVF SSP1BUF, W
01DD  0016     MOVIW FSR1++
01DE  0091     MOVWF SSP1BUF
01DF  1C14     BTFSS SSP1STAT, 0x0
01E0  33FE     BRA 0x1DF
01E1  0811     MOVF SSP1BUF, W
01E2  0016     MOVIW FSR1++
01E3  0091     MOVWF SSP1BUF
01E4  1C14     BTFSS SSP1STAT, 0x0
01E5  33FE     BRA 0x1E4
01E6  0811     MOVF SSP1BUF, W
01E7  0016     MOVIW FSR1++
01E8  0091     MOVWF SSP1BUF
01E9  1C14     BTFSS SSP1STAT, 0x0
01EA  33FE     BRA 0x1E9
01EB  0811     MOVF SSP1BUF, W
01EC  0016     MOVIW FSR1++
01ED  0091     MOVWF SSP1BUF
01EE  1C14     BTFSS SSP1STAT, 0x0
01EF  33FE     BRA 0x1EE
01F0  0811     MOVF SSP1BUF, W
01F1  0016     MOVIW FSR1++
01F2  0091     MOVWF SSP1BUF
01F3  1C14     BTFSS SSP1STAT, 0x0
01F4  33FE     BRA 0x1F3
01F5  0811     MOVF SSP1BUF, W
01F6  0016     MOVIW FSR1++
01F7  0091     MOVWF SSP1BUF
01F8  1C14     BTFSS SSP1STAT, 0x0
01F9  33FE     BRA 0x1F8
01FA  0811     MOVF SSP1BUF, W
01FB  0016     MOVIW FSR1++
01FC  0091     MOVWF SSP1BUF
01FD  1C14     BTFSS SSP1STAT, 0x0
01FE  33FE     BRA 0x1FD
01FF  0811     MOVF SSP1BUF, W
0200  0016     MOVIW FSR1++
0201  0091     MOVWF SSP1BUF
0202  1C14     BTFSS SSP1STAT, 0x0
0203  33FE     BRA 0x202
0204  0811     MOVF SSP1BUF, W
0205  0016     MOVIW FSR1++
0206  0091     MOVWF SSP1BUF
0207  1C14     BTFSS SSP1STAT, 0x0
0208  33FE     BRA 0x207
0209  0811     MOVF SSP1BUF, W
020A  0016     MOVIW FSR1++
020B  0091     MOVWF SSP1BUF
020C  1C14     BTFSS SSP1STAT, 0x0
020D  33FE     BRA 0x20C
020E  0811     MOVF SSP1BUF, W
020F  0016     MOVIW FSR1++
0210  0091     MOVWF SSP1BUF
0211  1C14     BTFSS SSP1STAT, 0x0
0212  33FE     BRA 0x211
0213  0811     MOVF SSP1BUF, W
0214  0016     MOVIW FSR1++
0215  0091     MOVWF SSP1BUF
0216  1C14     BTFSS SSP1STAT, 0x0
0217  33FE     BRA 0x216
0218  0811     MOVF SSP1BUF, W
0219  0016     MOVIW FSR1++
021A  0091     MOVWF SSP1BUF
021B  1C14     BTFSS SSP1STAT, 0x0
021C  33FE     BRA 0x21B
021D  0811     MOVF SSP1BUF, W
021E  0016     MOVIW FSR1++
021F  0091     MOVWF SSP1BUF
0220  1C14     BTFSS SSP1STAT, 0x0
0221  33FE     BRA 0x220
0222  0811     MOVF SSP1BUF, W
0223  0016     MOVIW FSR1++
0224  0091     MOVWF SSP1BUF
0225  1C14     BTFSS SSP1STAT, 0x0
0226  33FE     BRA 0x225
0227  0811     MOVF SSP1BUF, W
0228  0016     MOVIW FSR1++
0229  0091     MOVWF SSP1BUF
022A  1C14     BTFSS SSP1STAT, 0x0
022B  33FE     BRA 0x22A
022C  0811     MOVF SSP1BUF, W
022D  0016     MOVIW FSR1++
022E  0091     MOVWF SSP1BUF
022F  1C14     BTFSS SSP1STAT, 0x0
0230  33FE     BRA 0x22F
0231  0811     MOVF SSP1BUF, W
0232  0016     MOVIW FSR1++
0233  0091     MOVWF SSP1BUF
0234  1C14     BTFSS SSP1STAT, 0x0
0235  33FE     BRA 0x234
0236  0811     MOVF SSP1BUF, W
0237  0016     MOVIW FSR1++
0238  0091     MOVWF SSP1BUF
0239  1C14     BTFSS SSP1STAT, 0x0
023A  33FE     BRA 0x239
023B  0811     MOVF SSP1BUF, W
023C  0016     MOVIW FSR1++
023D  0091     MOVWF SSP1BUF
023E  1C14     BTFSS SSP1STAT, 0x0
023F  33FE     BRA 0x23E
0240  0811     MOVF SSP1BUF, W
0241  0016     MOVIW FSR1++
0242  0091     MOVWF SSP1BUF
0243  1C14     BTFSS SSP1STAT, 0x0
0244  33FE     BRA 0x243
0245  0811     MOVF SSP1BUF, W
0246  0016     MOVIW FSR1++
0247  0091     MOVWF SSP1BUF
0248  1C14     BTFSS SSP1STAT, 0x0
0249  33FE     BRA 0x248
024A  0811     MOVF SSP1BUF, W
024B  0016     MOVIW FSR1++
024C  0091     MOVWF SSP1BUF
024D  1C14     BTFSS SSP1STAT, 0x0
024E  33FE     BRA 0x24D
024F  0811     MOVF SSP1BUF, W
0250  0016     MOVIW FSR1++
0251  0091     MOVWF SSP1BUF
0252  1C14     BTFSS SSP1STAT, 0x0
0253  33FE     BRA 0x252
0254  0811     MOVF SSP1BUF, W
0255  0016     MOVIW FSR1++
0256  0091     MOVWF SSP1BUF
0257  1C14     BTFSS SSP1STAT, 0x0
0258  33FE     BRA 0x257
0259  0811     MOVF SSP1BUF, W
025A  0016     MOVIW FSR1++
025B  0091     MOVWF SSP1BUF
025C  1C14     BTFSS SSP1STAT, 0x0
025D  33FE     BRA 0x25C
025E  0811     MOVF SSP1BUF, W
025F  0016     MOVIW FSR1++
0260  0091     MOVWF SSP1BUF
0261  1C14     BTFSS SSP1STAT, 0x0
0262  33FE     BRA 0x261
0263  0811     MOVF SSP1BUF, W
0264  0016     MOVIW FSR1++
0265  0091     MOVWF SSP1BUF
0266  1C14     BTFSS SSP1STAT, 0x0
0267  33FE     BRA 0x266
0268  0811     MOVF SSP1BUF, W
0269  0016     MOVIW FSR1++
026A  0091     MOVWF SSP1BUF
026B  1C14     BTFSS SSP1STAT, 0x0
026C  33FE     BRA 0x26B
026D  0811     MOVF SSP1BUF, W
026E  0016     MOVIW FSR1++
026F  0091     MOVWF SSP1BUF
0270  1C14     BTFSS SSP1STAT, 0x0
0271  33FE     BRA 0x270
0272  0811     MOVF SSP1BUF, W
0273  0016     MOVIW FSR1++
0274  0091     MOVWF SSP1BUF
0275  1C14     BTFSS SSP1STAT, 0x0
0276  33FE     BRA 0x275
0277  0811     MOVF SSP1BUF, W
0278  0016     MOVIW FSR1++
0279  0091     MOVWF SSP1BUF
027A  1C14     BTFSS SSP1STAT, 0x0
027B  33FE     BRA 0x27A
027C  0811     MOVF SSP1BUF, W
027D  0016     MOVIW FSR1++
027E  0091     MOVWF SSP1BUF
027F  1C14     BTFSS SSP1STAT, 0x0
0280  33FE     BRA 0x27F
0281  0811     MOVF SSP1BUF, W
0282  0016     MOVIW FSR1++
0283  0091     MOVWF SSP1BUF
0284  1C14     BTFSS SSP1STAT, 0x0
0285  33FE     BRA 0x284
0286  0811     MOVF SSP1BUF, W
0287  0016     MOVIW FSR1++
0288  0091     MOVWF SSP1BUF
0289  1C14     BTFSS SSP1STAT, 0x0
028A  33FE     BRA 0x289
028B  0811     MOVF SSP1BUF, W
028C  0016     MOVIW FSR1++
028D  0091     MOVWF SSP1BUF
028E  1C14     BTFSS SSP1STAT, 0x0
028F  33FE     BRA 0x28E
0290  0811     MOVF SSP1BUF, W
0291  0016     MOVIW FSR1++
0292  0091     MOVWF SSP1BUF
0293  1C14     BTFSS SSP1STAT, 0x0
0294  33FE     BRA 0x293
0295  0811     MOVF SSP1BUF, W
0296  0016     MOVIW FSR1++
0297  0091     MOVWF SSP1BUF
0298  1C14     BTFSS SSP1STAT, 0x0
0299  33FE     BRA 0x298
029A  0811     MOVF SSP1BUF, W
029B  0016     MOVIW FSR1++
029C  0091     MOVWF SSP1BUF
029D  1C14     BTFSS SSP1STAT, 0x0
029E  33FE     BRA 0x29D
029F  0811     MOVF SSP1BUF, W
02A0  0016     MOVIW FSR1++
02A1  0091     MOVWF SSP1BUF
02A2  1C14     BTFSS SSP1STAT, 0x0
02A3  33FE     BRA 0x2A2
02A4  0811     MOVF SSP1BUF, W
02A5  0016     MOVIW FSR1++
02A6  0091     MOVWF SSP1BUF
02A7  1C14     BTFSS SSP1STAT, 0x0
02A8  33FE     BRA 0x2A7
02A9  0811     MOVF SSP1BUF, W
02AA  0016     MOVIW FSR1++
02AB  0091     MOVWF SSP1BUF
02AC  1C14     BTFSS SSP1STAT, 0x0
02AD  33FE     BRA 0x2AC
02AE  0811     MOVF SSP1BUF, W
02AF  0016     MOVIW FSR1++
02B0  0091     MOVWF SSP1BUF
02B1  1C14     BTFSS SSP1STAT, 0x0
02B2  33FE     BRA 0x2B1
02B3  0811     MOVF SSP1BUF, W
02B4  0016     MOVIW FSR1++
02B5  0091     MOVWF SSP1BUF
02B6  1C14     BTFSS SSP1STAT, 0x0
02B7  33FE     BRA 0x2B6
02B8  0811     MOVF SSP1BUF, W
02B9  0016     MOVIW FSR1++
02BA  0091     MOVWF SSP1BUF
02BB  1C14     BTFSS SSP1STAT, 0x0
02BC  33FE     BRA 0x2BB
02BD  0811     MOVF SSP1BUF, W
02BE  0016     MOVIW FSR1++
02BF  0091     MOVWF SSP1BUF
02C0  1C14     BTFSS SSP1STAT, 0x0
02C1  33FE     BRA 0x2C0
02C2  0811     MOVF SSP1BUF, W
02C3  0016     MOVIW FSR1++
02C4  0091     MOVWF SSP1BUF
02C5  1C14     BTFSS SSP1STAT, 0x0
02C6  33FE     BRA 0x2C5
02C7  0811     MOVF SSP1BUF, W
02C8  0016     MOVIW FSR1++
02C9  0091     MOVWF SSP1BUF
02CA  1C14     BTFSS SSP1STAT, 0x0
02CB  33FE     BRA 0x2CA
02CC  0811     MOVF SSP1BUF, W
02CD  0016     MOVIW FSR1++
02CE  0091     MOVWF SSP1BUF
02CF  1C14     BTFSS SSP1STAT, 0x0
02D0  33FE     BRA 0x2CF
02D1  0811     MOVF SSP1BUF, W
02D2  0016     MOVIW FSR1++
02D3  0091     MOVWF SSP1BUF
02D4  1C14     BTFSS SSP1STAT, 0x0
02D5  33FE     BRA 0x2D4
02D6  0811     MOVF SSP1BUF, W
02D7  0016     MOVIW FSR1++
02D8  0091     MOVWF SSP1BUF
02D9  1C14     BTFSS SSP1STAT, 0x0
02DA  33FE     BRA 0x2D9
02DB  0811     MOVF SSP1BUF, W
02DC  0016     MOVIW FSR1++
02DD  0091     MOVWF SSP1BUF
02DE  1C14     BTFSS SSP1STAT, 0x0
02DF  33FE     BRA 0x2DE
02E0  0811     MOVF SSP1BUF, W
02E1  0016     MOVIW FSR1++
02E2  0091     MOVWF SSP1BUF
02E3  1C14     BTFSS SSP1STAT, 0x0
02E4  33FE     BRA 0x2E3
02E5  0811     MOVF SSP1BUF, W
02E6  0016     MOVIW FSR1++
02E7  0091     MOVWF SSP1BUF
02E8  1C14     BTFSS SSP1STAT, 0x0
02E9  33FE     BRA 0x2E8
02EA  0811     MOVF SSP1BUF, W
02EB  0016     MOVIW FSR1++
02EC  0091     MOVWF SSP1BUF
02ED  1C14     BTFSS SSP1STAT, 0x0
02EE  33FE     BRA 0x2ED
02EF  0811     MOVF SSP1BUF, W
127:               
128:                
129:               /*SSPBUF = display_output[0];while(!BF);//7f=DEL
130:               SSPBUF = display_output[1];while(!BF);//7f=DEL
131:               SSPBUF = display_output[2];while(!BF);//7f=DEL
132:               SSPBUF = display_output[3];while(!BF);//7f=DEL
133:               SSPBUF = display_output[4];while(!BF);//7f=DEL
134:               SSPBUF = display_output[5];while(!BF);//7f=DEL
135:               SSPBUF = display_output[6];while(!BF);//7f=
136:               SSPBUF = display_output[7];while(!BF);//7f=DEL*/
137:               
138:           }
02F0  0008     RETURN
139:           int cnt_tr=0;
140:           
141:           void spiWrite(){
0899  0023     MOVLB 0x3
089A  0835     MOVF 0x1B5, W
089B  3A80     XORLW 0x80
089C  00F0     MOVWF 0x1F0
089D  3083     MOVLW 0x83
089E  0270     SUBWF 0x1F0, W
142:               if(cnt_tr<1000){ 
089F  1D03     BTFSS STATUS, 0x2
08A0  28A3     GOTO 0xA3
08A1  30E8     MOVLW 0xE8
08A2  0234     SUBWF cnt_tr, W
08A3  1803     BTFSC STATUS, 0x0
08A4  28A6     GOTO 0xA6
08A5  28A7     GOTO 0xA7
08A6  28AD     GOTO 0xAD
143:                  cnt_tr++;
08A7  3001     MOVLW 0x1
08A8  0023     MOVLB 0x3
08A9  07B4     ADDWF cnt_tr, F
08AA  3000     MOVLW 0x0
08AB  3DB5     ADDWFC 0x1B5, F
08AC  28BE     GOTO 0xBE
144:                   return;
145:               }
146:               cnt_tr=0;
08AD  0023     MOVLB 0x3
08AE  01B4     CLRF cnt_tr
08AF  01B5     CLRF 0x1B5
147:               CS_PIN = 0;
08B0  0020     MOVLB 0x0
08B1  118E     BCF PORTC, 0x3
148:               //__delay_us(100);
149:               
150:               spwrh();
08B2  3181     MOVLP 0x1
08B3  21AB     CALL 0x1AB
08B4  3188     MOVLP 0x8
151:               //spwrh("ASDFQWER");
152:               //spwrh("POIUYTRE");
153:               //spwrh("PLMNJKOI");
154:               //spwrh("GHBNVFTY");
155:               //spwrh("12398754");
156:               //spwrh(",./;'[]-");
157:               //spwrh("GHtjhv/]");
158:               //spwrh("-=6`4f;z");
159:               
160:               SSPBUF = ' ';while(!BF);
08B5  3020     MOVLW 0x20
08B6  0024     MOVLB 0x4
08B7  0091     MOVWF SSP1BUF
08B8  1C14     BTFSS SSP1STAT, 0x0
08B9  28BB     GOTO 0xBB
08BA  28BC     GOTO 0xBC
08BB  28B8     GOTO 0xB8
161:               CS_PIN = 1;
08BC  0020     MOVLB 0x0
08BD  158E     BSF PORTC, 0x3
162:           }
08BE  0008     RETURN
163:           
164:           void MasterinitSPI(){
165:               TRIS_CS_PIN = 0;TRIS_CLK_PIN = 0;
1758  0021     MOVLB 0x1
1759  118E     BCF TRISC, 0x3
175A  100E     BCF TRISC, 0x0
166:             
167:           #if SPI_FREQ == 6
168:               SSPADD = 1;
175B  3001     MOVLW 0x1
175C  0024     MOVLB 0x4
175D  0092     MOVWF SSP1ADD
169:           #endif
170:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
175E  3040     MOVLW 0x40
175F  0094     MOVWF SSP1STAT
171:               SSPCON = SPI_MODE | IDLE_LOW;//SSPM=0000:=;CKP=0
1760  302A     MOVLW 0x2A
1761  0095     MOVWF SSP1CON1
172:               
173:           }
1762  0008     RETURN
174:           void SlaveinitSPI(){
175:               TRIS_CS_PIN = 1;TRIS_CLK_PIN = 1;
176:               //BOEN = 0;
177:               //ANSC0=0;ANSC1=0;ANSC2=0;ANSC3=0; moved to system.c
178:               
179:               SSPSTAT = SAMPLE_MIDDLE |  ACTIVE_TO_IDLE;//SMP=0;CKE=1
180:               SSPCON = SLAVE_SS_EN | IDLE_LOW;//SSPM=0000:=;CKP=0
181:           }
---  E:/Smart-Knob/pic16f1455_firmware/lib/leds.c  ------------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <include/leds.h>
24:            #include <stdbool.h>
25:            #include <xc.h>
26:            
27:            #define LED_D1_LAT LATCbits.LATC4
28:            #define LED_D2_LAT LATCbits.LATC1
29:            #define LED_D3_LAT LATCbits.LATC2
30:            //#define LED_D4_LAT LATCbits.LATC3
31:            
32:            #define LED_D1_TRIS TRISCbits.TRISC4
33:            #define LED_D2_TRIS TRISCbits.TRISC1
34:            #define LED_D3_TRIS TRISCbits.TRISC2
35:            //#define LED_D4_TRIS TRISCbits.TRISC3
36:            
37:            #define LED_ON  1
38:            #define LED_OFF 0
39:            
40:            #define PIN_INPUT  1
41:            #define PIN_OUTPUT 0
42:            
43:            /*********************************************************************
44:            * Function: void LED_On(LED led);
45:            *
46:            * Overview: Turns requested LED on
47:            *
48:            * PreCondition: LED configured via LED_Configure()
49:            *
50:            * Input: LED led - enumeration of the LEDs available in this
51:            *        demo.  They should be meaningful names and not the names of
52:            *        the LEDs on the silkscreen on the board (as the demo code may
53:            *        be ported to other boards).
54:            *         i.e. - LED_On(LED_CONNECTION_DETECTED);
55:            *
56:            * Output: none
57:            *
58:            ********************************************************************/
59:            void LED_On(LED led)
0830  00F2     MOVWF 0x272
60:            {
61:                switch(led)
0831  283B     GOTO 0x3B
62:                {
63:                    case LED_D1:
64:                        LED_D1_LAT = LED_ON;
0832  0022     MOVLB 0x2
0833  160E     BSF LATC, 0x4
65:                        break;
0834  2851     GOTO 0x51
66:            
67:                    case LED_D2:
68:                        LED_D2_LAT = LED_ON;
0835  0022     MOVLB 0x2
0836  148E     BSF LATC, 0x1
69:                        break;
0837  2851     GOTO 0x51
70:            			
71:                    case LED_D3:
72:                        LED_D3_LAT = LED_ON;
0838  0022     MOVLB 0x2
0839  150E     BSF LATC, 0x2
73:                        break;
083A  2851     GOTO 0x51
74:            			
75:                    /*case LED_D4:
76:                        LED_D4_LAT = LED_ON;
77:                        break;*/
78:            
79:                    case LED_NONE:
80:                        break;
81:                }
083B  0872     MOVF 0x172, W
083C  00F0     MOVWF 0x170
083D  01F1     CLRF 0x171
083E  0871     MOVF 0x171, W
083F  3A00     XORLW 0x0
0840  1903     BTFSC STATUS, 0x2
0841  2843     GOTO 0x43
0842  2851     GOTO 0x51
0843  0870     MOVF 0x170, W
0844  3A00     XORLW 0x0
0845  1903     BTFSC STATUS, 0x2
0846  2851     GOTO 0x51
0847  3A01     XORLW 0x1
0848  1903     BTFSC STATUS, 0x2
0849  2832     GOTO 0x32
084A  3A03     XORLW 0x3
084B  1903     BTFSC STATUS, 0x2
084C  2835     GOTO 0x35
084D  3A01     XORLW 0x1
084E  1903     BTFSC STATUS, 0x2
084F  2838     GOTO 0x38
0850  2851     GOTO 0x51
82:            }
0851  0008     RETURN
83:            
84:            /*********************************************************************
85:            * Function: void LED_Off(LED led);
86:            *
87:            * Overview: Turns requested LED off
88:            *
89:            * PreCondition: LED configured via LEDConfigure()
90:            *
91:            * Input: LED led - enumeration of the LEDs available in this
92:            *        demo.  They should be meaningful names and not the names of
93:            *        the LEDs on the silkscreen on the board (as the demo code may
94:            *        be ported to other boards).
95:            *         i.e. - LED_Off(LED_CONNECTION_DETECTED);
96:            *
97:            * Output: none
98:            *
99:            ********************************************************************/
100:           void LED_Off(LED led)
080E  00F2     MOVWF 0x172
101:           {
102:               switch(led)
080F  2819     GOTO 0x19
103:               {
104:                   case LED_D1:
105:                       LED_D1_LAT = LED_OFF;
0810  0022     MOVLB 0x2
0811  120E     BCF LATC, 0x4
106:                       break;
0812  282F     GOTO 0x2F
107:           
108:                   case LED_D2:
109:                       LED_D2_LAT = LED_OFF;
0813  0022     MOVLB 0x2
0814  108E     BCF LATC, 0x1
110:                       break;
0815  282F     GOTO 0x2F
111:           			
112:                   case LED_D3:
113:                       LED_D3_LAT = LED_OFF;
0816  0022     MOVLB 0x2
0817  110E     BCF LATC, 0x2
114:                       break;
0818  282F     GOTO 0x2F
115:           			
116:                   /*case LED_D4:
117:                       LED_D4_LAT = LED_OFF;
118:                       break;*/
119:           
120:                   case LED_NONE:
121:                       break;
122:               }
0819  0872     MOVF 0x172, W
081A  00F0     MOVWF 0x170
081B  01F1     CLRF 0x171
081C  0871     MOVF 0x171, W
081D  3A00     XORLW 0x0
081E  1903     BTFSC STATUS, 0x2
081F  2821     GOTO 0x21
0820  282F     GOTO 0x2F
0821  0870     MOVF 0x170, W
0822  3A00     XORLW 0x0
0823  1903     BTFSC STATUS, 0x2
0824  282F     GOTO 0x2F
0825  3A01     XORLW 0x1
0826  1903     BTFSC STATUS, 0x2
0827  2810     GOTO 0x10
0828  3A03     XORLW 0x3
0829  1903     BTFSC STATUS, 0x2
082A  2813     GOTO 0x13
082B  3A01     XORLW 0x1
082C  1903     BTFSC STATUS, 0x2
082D  2816     GOTO 0x16
082E  282F     GOTO 0x2F
123:           }
082F  0008     RETURN
124:           
125:           /*********************************************************************
126:           * Function: void LED_Toggle(LED led);
127:           *
128:           * Overview: Toggles the state of the requested LED
129:           *
130:           * PreCondition: LED configured via LEDConfigure()
131:           *
132:           * Input: LED led - enumeration of the LEDs available in this
133:           *        demo.  They should be meaningful names and not the names of
134:           *        the LEDs on the silkscreen on the board (as the demo code may
135:           *        be ported to other boards).
136:           *         i.e. - LED_Toggle(LED_CONNECTION_DETECTED);
137:           *
138:           * Output: none
139:           *
140:           ********************************************************************/
141:           void LED_Toggle(LED led)
142:           {
143:               switch(led)
144:               {
145:                   case LED_D1:
146:                       LED_D1_LAT ^= 1;
147:                       break;
148:           
149:                   case LED_D2:
150:                       LED_D2_LAT ^= 1;
151:                       break;
152:           			
153:                   case LED_D3:
154:                       //LED_D3_LAT ^= 1;
155:                       break;
156:           			
157:                   /*case LED_D4:
158:                       LED_D4_LAT ^= 1;
159:                       break;*/
160:           
161:                   case LED_NONE:
162:                       break;
163:               }
164:           }
165:           
166:           /*********************************************************************
167:           * Function: bool LED_Get(LED led);
168:           *
169:           * Overview: Returns the current state of the requested LED
170:           *
171:           * PreCondition: LED configured via LEDConfigure()
172:           *
173:           * Input: LED led - enumeration of the LEDs available in this
174:           *        demo.  They should be meaningful names and not the names of
175:           *        the LEDs on the silkscreen on the board (as the demo code may
176:           *        be ported to other boards).
177:           *         i.e. - LED_Get(LED_CONNECTION_DETECTED);
178:           *
179:           * Output: true if on, false if off
180:           *
181:           ********************************************************************/
182:           bool LED_Get(LED led)
183:           {
184:               switch(led)
185:               {
186:                   case LED_D1:
187:                       return ( (LED_D1_LAT == LED_ON) ? true : false );
188:           
189:                   case LED_D2:
190:                       return ( (LED_D2_LAT == LED_ON) ? true : false );
191:           			
192:                   case LED_D3:
193:                       return ( (LED_D3_LAT == LED_ON) ? true : false );
194:           			
195:                   /*case LED_D4:
196:                       return ( (LED_D4_LAT == LED_ON) ? true : false );*/
197:           
198:                   case LED_NONE:
199:                       return false;
200:               }
201:               
202:               return false;
203:           }
204:           
205:           /*********************************************************************
206:           * Function: void LED_Enable(LED led);
207:           *
208:           * Overview: Configures the LED for use by the other LED API
209:           *
210:           * PreCondition: none
211:           *
212:           * Input: LED led - enumeration of the LEDs available in this
213:           *        demo.  They should be meaningful names and not the names of
214:           *        the LEDs on the silkscreen on the board (as the demo code may
215:           *        be ported to other boards).
216:           *
217:           * Output: none
218:           *
219:           ********************************************************************/
220:           void LED_Enable(LED led)
0852  00F2     MOVWF 0x172
221:           {
222:               switch(led)
0853  285D     GOTO 0x5D
223:               {
224:                   case LED_D1:
225:                       LED_D1_TRIS = PIN_OUTPUT;
0854  0021     MOVLB 0x1
0855  120E     BCF TRISC, 0x4
226:                       break;
0856  2873     GOTO 0x73
227:           
228:                   case LED_D2:
229:                       LED_D2_TRIS = PIN_OUTPUT;
0857  0021     MOVLB 0x1
0858  108E     BCF TRISC, 0x1
230:                       break;
0859  2873     GOTO 0x73
231:           			
232:                   case LED_D3:
233:                       LED_D3_TRIS = PIN_OUTPUT;
085A  0021     MOVLB 0x1
085B  110E     BCF TRISC, 0x2
234:                       break;
085C  2873     GOTO 0x73
235:           			
236:                   /*case LED_D4:
237:                       LED_D4_TRIS = PIN_OUTPUT;
238:                       break;*/
239:           
240:                   case LED_NONE:
241:                       break;
242:               }
085D  0872     MOVF 0xF2, W
085E  00F0     MOVWF 0xF0
085F  01F1     CLRF 0xF1
0860  0871     MOVF 0xF1, W
0861  3A00     XORLW 0x0
0862  1903     BTFSC STATUS, 0x2
0863  2865     GOTO 0x65
0864  2873     GOTO 0x73
0865  0870     MOVF 0xF0, W
0866  3A00     XORLW 0x0
0867  1903     BTFSC STATUS, 0x2
0868  2873     GOTO 0x73
0869  3A01     XORLW 0x1
086A  1903     BTFSC STATUS, 0x2
086B  2854     GOTO 0x54
086C  3A03     XORLW 0x3
086D  1903     BTFSC STATUS, 0x2
086E  2857     GOTO 0x57
086F  3A01     XORLW 0x1
0870  1903     BTFSC STATUS, 0x2
0871  285A     GOTO 0x5A
0872  2873     GOTO 0x73
243:           }
0873  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/buttons.c  ---------------------------------------------------
1:             /********************************************************************
2:              Software License Agreement:
3:             
4:              The software supplied herewith by Microchip Technology Incorporated
5:              (the "Company") for its PIC(R) Microcontroller is intended and
6:              supplied to you, the Company's customer, for use solely and
7:              exclusively on Microchip PIC Microcontroller products. The
8:              software is owned by the Company and/or its supplier, and is
9:              protected under applicable copyright laws. All rights are reserved.
10:             Any use in violation of the foregoing restrictions may subject the
11:             user to criminal sanctions under applicable laws, as well as to
12:             civil liability for the breach of the terms and conditions of this
13:             license.
14:            
15:             THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES,
16:             WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
17:             TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
18:             PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
19:             IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
20:             CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
21:             *******************************************************************/
22:            
23:            #include <xc.h>
24:            #include <stdbool.h>
25:            #include <include/buttons.h>
26:            
27:            /*** Button Definitions *********************************************/
28:            #define S1_PORT  PORTCbits.RC3
29:            
30:            #define BUTTON_PRESSED      0
31:            #define BUTTON_NOT_PRESSED  1
32:            
33:            #define PIN_INPUT           1
34:            #define PIN_OUTPUT          0
35:            
36:            #define PIN_DIGITAL         1
37:            #define PIN_ANALOG          0
38:            
39:            /*********************************************************************
40:            * Function: bool BUTTON_IsPressed(BUTTON button);
41:            *
42:            * Overview: Returns the current state of the requested button
43:            *
44:            * PreCondition: button configured via BUTTON_SetConfiguration()
45:            *
46:            * Input: BUTTON button - enumeration of the buttons available in
47:            *        this demo.  They should be meaningful names and not the names 
48:            *        of the buttons on the silkscreen on the board (as the demo 
49:            *        code may be ported to other boards).
50:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
51:            *
52:            * Output: TRUE if pressed; FALSE if not pressed.
53:            *
54:            ********************************************************************/
55:            bool BUTTON_IsPressed(BUTTON button)
56:            {
57:                ANSELC = 0;
58:                switch(button)
59:                {
60:                    case BUTTON_S1:
61:                        return ( (S1_PORT == BUTTON_PRESSED) ? true : false);
62:            
63:                    case BUTTON_NONE:
64:                        return false;
65:                }
66:                
67:                return false;
68:            }
69:            
70:            /*********************************************************************
71:            * Function: void BUTTON_Enable(BUTTON button);
72:            *
73:            * Overview: Returns the current state of the requested button
74:            *
75:            * PreCondition: button configured via BUTTON_SetConfiguration()
76:            *
77:            * Input: BUTTON button - enumeration of the buttons available in
78:            *        this demo.  They should be meaningful names and not the names
79:            *        of the buttons on the silkscreen on the board (as the demo
80:            *        code may be ported to other boards).
81:            *         i.e. - ButtonIsPressed(BUTTON_SEND_MESSAGE);
82:            *
83:            * Output: None
84:            *
85:            ********************************************************************/
86:            void BUTTON_Enable(BUTTON button)
07ED  00F2     MOVWF 0xF2
87:            {
88:                switch(button)
07EE  0872     MOVF 0xF2, W
07EF  00F0     MOVWF 0xF0
07F0  01F1     CLRF 0xF1
07F1  0871     MOVF 0xF1, W
07F2  3A00     XORLW 0x0
89:                {
90:                    case BUTTON_S1:
91:                        break;
92:            
93:                    case BUTTON_NONE:
94:                        break;
95:                }
07F3  1903     BTFSC STATUS, 0x2
07F4  2FF6     GOTO 0x7F6
07F5  2FFE     GOTO 0x7FE
07F6  0870     MOVF 0xF0, W
07F7  3A00     XORLW 0x0
07F8  1903     BTFSC STATUS, 0x2
07F9  2FFE     GOTO 0x7FE
07FA  3A01     XORLW 0x1
07FB  1903     BTFSC STATUS, 0x2
07FC  2FFE     GOTO 0x7FE
07FD  2FFE     GOTO 0x7FE
96:            }
07FE  0008     RETURN
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_led_usb_status.c  ----------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            // *****************************************************************************
21:            // *****************************************************************************
22:            // Section: Included Files
23:            // *****************************************************************************
24:            // *****************************************************************************
25:            #include "stdint.h"
26:            #include "include/system.h"
27:            #include "include/usb/usb_device.h"
28:            
29:            
30:            // *****************************************************************************
31:            // *****************************************************************************
32:            // Section: File Scope or Global Constants
33:            // *****************************************************************************
34:            // *****************************************************************************
35:            
36:            
37:            // *****************************************************************************
38:            // *****************************************************************************
39:            // Section: File Scope Data Types
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            
43:            
44:            // *****************************************************************************
45:            // *****************************************************************************
46:            // Section: Macros or Functions
47:            // *****************************************************************************
48:            // *****************************************************************************
49:            
50:            void APP_LEDUpdateUSBStatus(void)
51:            {
52:                static uint16_t ledCount = 0;
53:            
54:                if(USBIsDeviceSuspended() == true)
0B04  003D     MOVLB 0x1D
0B05  1C8E     BTFSS UCON, 0x1
0B06  2B08     GOTO 0x308
0B07  2B09     GOTO 0x309
0B08  2B53     GOTO 0x353
55:                {
56:                    LED_Off(LED_USB_DEVICE_STATE);
0B09  3001     MOVLW 0x1
0B0A  3188     MOVLP 0x8
0B0B  200E     CALL 0xE
0B0C  318B     MOVLP 0xB
0B0D  2B66     GOTO 0x366
57:                    return;
58:                }
59:            
60:                switch(USBGetDeviceState())
61:                {         
62:                    case CONFIGURED_STATE:
63:                        /* We are configured.  Blink fast.
64:                         * On for 75ms, off for 75ms, then reset/repeat. */
65:                        if(ledCount == 1)
0B0E  033D     DECF 0xEBD, W
0B0F  043E     IORWF 0xEBE, W
0B10  1D03     BTFSS STATUS, 0x2
0B11  2B13     GOTO 0x313
0B12  2B14     GOTO 0x314
0B13  2B19     GOTO 0x319
66:                        {
67:                            LED_On(LED_USB_DEVICE_STATE);
0B14  3001     MOVLW 0x1
0B15  3188     MOVLP 0x8
0B16  2030     CALL 0x30
0B17  318B     MOVLP 0xB
68:                        }
0B18  2B61     GOTO 0x361
69:                        else if(ledCount == 75)
0B19  304B     MOVLW 0x4B
0B1A  063D     XORWF 0xEBD, W
0B1B  043E     IORWF 0xEBE, W
0B1C  1D03     BTFSS STATUS, 0x2
0B1D  2B1F     GOTO 0x31F
0B1E  2B20     GOTO 0x320
0B1F  2B25     GOTO 0x325
70:                        {
71:                            LED_Off(LED_USB_DEVICE_STATE);
0B20  3001     MOVLW 0x1
0B21  3188     MOVLP 0x8
0B22  200E     CALL 0xE
0B23  318B     MOVLP 0xB
72:                        }
0B24  2B61     GOTO 0x361
73:                        else if(ledCount > 150)
0B25  3000     MOVLW 0x0
0B26  023E     SUBWF 0xEBE, W
0B27  3097     MOVLW 0x97
0B28  1903     BTFSC STATUS, 0x2
0B29  023D     SUBWF 0xEBD, W
0B2A  1C03     BTFSS STATUS, 0x0
0B2B  2B2D     GOTO 0x32D
0B2C  2B2E     GOTO 0x32E
0B2D  2B31     GOTO 0x331
74:                        {
75:                            ledCount = 0;
0B2E  01BD     CLRF 0xEBD
0B2F  01BE     CLRF 0xEBE
0B30  2B61     GOTO 0x361
76:                        }
77:                        break;
0B31  2B61     GOTO 0x361
78:            
79:                    default:
80:                        /* We aren't configured yet, but we aren't suspended so let's blink with
81:                         * a slow pulse. On for 50ms, then off for 950ms, then reset/repeat. */
82:                        if(ledCount == 1)
0B32  033D     DECF 0xEBD, W
0B33  043E     IORWF 0xEBE, W
0B34  1D03     BTFSS STATUS, 0x2
0B35  2B37     GOTO 0x337
0B36  2B38     GOTO 0x338
0B37  2B3D     GOTO 0x33D
83:                        {
84:                            LED_On(LED_USB_DEVICE_STATE);
0B38  3001     MOVLW 0x1
0B39  3188     MOVLP 0x8
0B3A  2030     CALL 0x30
0B3B  318B     MOVLP 0xB
85:                        }
0B3C  2B61     GOTO 0x361
86:                        else if(ledCount == 50)
0B3D  3032     MOVLW 0x32
0B3E  063D     XORWF 0xEBD, W
0B3F  043E     IORWF 0xEBE, W
0B40  1D03     BTFSS STATUS, 0x2
0B41  2B43     GOTO 0x343
0B42  2B44     GOTO 0x344
0B43  2B49     GOTO 0x349
87:                        {
88:                            LED_Off(LED_USB_DEVICE_STATE);
0B44  3001     MOVLW 0x1
0B45  3188     MOVLP 0x8
0B46  200E     CALL 0xE
0B47  318B     MOVLP 0xB
89:                        }
0B48  2B61     GOTO 0x361
90:                        else if(ledCount > 950)
0B49  3003     MOVLW 0x3
0B4A  023E     SUBWF 0xEBE, W
0B4B  30B7     MOVLW 0xB7
0B4C  1903     BTFSC STATUS, 0x2
0B4D  023D     SUBWF 0xEBD, W
0B4E  1C03     BTFSS STATUS, 0x0
0B4F  2B51     GOTO 0x351
0B50  2B52     GOTO 0x352
0B51  2B61     GOTO 0x361
0B52  2B2E     GOTO 0x32E
91:                        {
92:                            ledCount = 0;
93:                        }
94:                        break;
95:                }
0B53  0021     MOVLB 0x1
0B54  0853     MOVF USBDeviceState, W
0B55  00F3     MOVWF 0xF3
0B56  01F4     CLRF 0xF4
0B57  0874     MOVF 0xF4, W
0B58  3A00     XORLW 0x0
0B59  1903     BTFSC STATUS, 0x2
0B5A  2B5C     GOTO 0x35C
0B5B  2B32     GOTO 0x332
0B5C  0873     MOVF 0xF3, W
0B5D  3A20     XORLW 0x20
0B5E  1903     BTFSC STATUS, 0x2
0B5F  2B0E     GOTO 0x30E
0B60  2B32     GOTO 0x332
96:            
97:                /* Increment the millisecond counter. */
98:                ledCount++;
0B61  3001     MOVLW 0x1
0B62  0021     MOVLB 0x1
0B63  07BD     ADDWF ledCount, F
0B64  3000     MOVLW 0x0
0B65  3DBE     ADDWFC 0xBE, F
99:            }
0B66  0008     RETURN
100:           
101:           /*******************************************************************************
102:            End of File
103:           */
---  E:/Smart-Knob/pic16f1455_firmware/lib/app_device_joystick.c  ---------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             Licensed under the Apache License, Version 2.0 (the "License");
5:             you may not use this file except in compliance with the License.
6:             You may obtain a copy of the License at
7:             
8:                 http://www.apache.org/licenses/LICENSE-2.0
9:             
10:            Unless required by applicable law or agreed to in writing, software
11:            distributed under the License is distributed on an "AS IS" BASIS,
12:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
13:            See the License for the specific language governing permissions and
14:            limitations under the License.
15:            
16:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
17:            please contact mla_licensing@microchip.com
18:            *******************************************************************************/
19:            
20:            #ifndef USBJOYSTICK_C
21:            #define USBJOYSTICK_C
22:            
23:            /** INCLUDES *******************************************************/
24:            #include "include/usb/usb.h"
25:            #include "include/usb/usb_device_hid.h"
26:            #include "include/app_device_joystick.h"
27:            
28:            #include "include/system.h"
29:            
30:            #include "include/app_led_usb_status.h"
31:            #include "include/spi.h"
32:            
33:            #include "stdint.h"
34:            
35:            /** DECLARATIONS ***************************************************/
36:            
37:            USB_VOLATILE USB_HANDLE last_HAP_IN = 0;
38:            USB_VOLATILE USB_HANDLE last_HAP_OUT = 0;
39:            USB_VOLATILE USB_HANDLE last_LED_OUT = 0;
40:            USB_VOLATILE USB_HANDLE last_DSP_OUT = 0;
41:            
42:            
43:            /*********************************************************************
44:            * Function: void APP_DeviceJoystickInitialize(void);
45:            *
46:            * Overview: Initializes the demo code
47:            *
48:            * PreCondition: None
49:            *
50:            * Input: None
51:            *
52:            * Output: None
53:            *
54:            ********************************************************************/
55:            void APP_DeviceJoystickInitialize(void)
56:            {  
57:                //initialize the variable holding the handle for the last
58:                // transmission
59:                last_HAP_IN = 0;
17DE  0022     MOVLB 0x2
17DF  01AD     CLRF last_HAP_IN
17E0  01AE     CLRF 0x12E
60:                last_HAP_OUT = 0;
17E1  01AB     CLRF last_HAP_OUT
17E2  01AC     CLRF 0x12C
61:                last_LED_OUT = 0;
17E3  01A9     CLRF last_LED_OUT
17E4  01AA     CLRF 0x12A
62:                last_DSP_OUT = 0;
17E5  01A7     CLRF last_DSP_OUT
17E6  01A8     CLRF 0x128
63:            
64:                //enable the HID endpoint
65:                USBEnableEndpoint(HAPTIC_EP,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
17E7  301E     MOVLW 0x1E
17E8  00FD     MOVWF 0x17D
17E9  087D     MOVF 0x17D, W
17EA  00F7     MOVWF 0x177
17EB  3001     MOVLW 0x1
17EC  3188     MOVLP 0x8
17ED  2074     CALL 0x74
17EE  3197     MOVLP 0x17
66:                USBEnableEndpoint(LEDS_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
17EF  301E     MOVLW 0x1E
17F0  00FD     MOVWF 0x17D
17F1  087D     MOVF 0x17D, W
17F2  00F7     MOVWF 0x177
17F3  3002     MOVLW 0x2
17F4  3188     MOVLP 0x8
17F5  2074     CALL 0x74
17F6  3197     MOVLP 0x17
67:                USBEnableEndpoint(DISPLAY_EP  ,USB_OUT_ENABLED|USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
17F7  301E     MOVLW 0x1E
17F8  00FD     MOVWF 0x17D
17F9  087D     MOVF 0x17D, W
17FA  00F7     MOVWF 0x177
17FB  3003     MOVLW 0x3
17FC  3188     MOVLP 0x8
17FD  2074     CALL 0x74
17FE  3197     MOVLP 0x17
68:            }//end UserInit
17FF  0008     RETURN
69:            
70:            /*********************************************************************
71:            * Function: void APP_DeviceJoystickTasks(void);
72:            *
73:            * Overview: Keeps the demo running.
74:            *
75:            * PreCondition: The demo should have been initialized and started via
76:            *   the APP_DeviceJoystickInitialize() and APP_DeviceJoystickStart() demos
77:            *   respectively.
78:            *
79:            * Input: None
80:            *
81:            * Output: None
82:            *
83:            ********************************************************************/
84:            
85:            uint8_t cntr=0;
86:            
87:            void APP_DeviceJoystickTasks(void)
88:            {  
89:                /* If the USB device isn't configured yet, we can't really do anything
90:                 * else since we don't have a host to talk to.  So jump back to the
91:                 * top of the while loop. */
92:                if( USBGetDeviceState() < CONFIGURED_STATE )
0601  3020     MOVLW 0x20
0602  0021     MOVLB 0x1
0603  0253     SUBWF USBDeviceState, W
0604  1803     BTFSC STATUS, 0x0
0605  2E07     GOTO 0x607
0606  2E08     GOTO 0x608
0607  2E09     GOTO 0x609
0608  2EBB     GOTO 0x6BB
93:                {
94:                    /* Jump back to the top of the while loop. */
95:                    return;
96:                }
97:            
98:                /* If we are currently suspended, then we need to see if we need to
99:                 * issue a remote wakeup.  In either case, we shouldn't process any
100:                * keyboard commands since we aren't currently communicating to the host
101:                * thus just continue back to the start of the while loop. */
102:               if( USBIsDeviceSuspended() == true )
0609  003D     MOVLB 0x1D
060A  1C8E     BTFSS UCON, 0x1
060B  2E0D     GOTO 0x60D
060C  2E0E     GOTO 0x60E
060D  2E0F     GOTO 0x60F
060E  2EBB     GOTO 0x6BB
103:               {
104:                   /* Jump back to the top of the while loop. */
105:                   return;
106:               }
107:           
108:               //If the last transmission is complete
109:               if(!HIDTxHandleBusy(last_HAP_IN))
060F  0022     MOVLB 0x2
0610  082D     MOVF last_HAP_IN, W
0611  042E     IORWF 0x12E, W
0612  1903     BTFSC STATUS, 0x2
0613  2E15     GOTO 0x615
0614  2E16     GOTO 0x616
0615  2E1E     GOTO 0x61E
0616  082D     MOVF last_HAP_IN, W
0617  0086     MOVWF FSR1L
0618  082E     MOVF 0x12E, W
0619  0087     MOVWF FSR1H
061A  1B81     BTFSC INDF1, 0x7
061B  2E1D     GOTO 0x61D
061C  2E1E     GOTO 0x61E
061D  2E5B     GOTO 0x65B
110:               {
111:                   //If the button is pressed
112:                   if(/*BUTTON_IsPressed(BUTTON_USB_DEVICE_HID_JOYSTICK)*/false == true)
113:                   {
114:                       //Indicate that the "x" button is pressed, but none others
115:           
116:                       //Move the hat switch to the "east" position
117:                       //haptic_in.button = HAT_SWITCH_EAST;
118:           
119:                       haptic_in[1] = TESTB;
120:                       //Move the X and Y coordinates to the their extreme values (0x80 is
121:                       //  in the middle - no value).
122:                       //joystick_input.members.analog_stick.X = 0;
123:                       //joystick_input.members.analog_stick.Y = 0;
124:           
125:                       //Send the packet over USB to the host.
126:                       last_HAP_IN = HIDTxPacket(HAPTIC_EP, (uint8_t*)&haptic_in, sizeof(haptic_in));
127:           
128:                   }
129:                   else
130:                   {
131:                       //Reset values of the controller to default state
132:           
133:                       //Buttons
134:                       //haptic_in.val[0] = cntr++;
135:                       //haptic_in.val[1] = TESTB;
136:                       
137:                       haptic_in[0] = display_output[0];
061E  30B0     MOVLW 0xB0
061F  0086     MOVWF FSR1L
0620  3021     MOVLW 0x21
0621  0087     MOVWF FSR1H
0622  0801     MOVF INDF1, W
0623  00FB     MOVWF 0x17B
0624  087B     MOVF 0x17B, W
0625  0021     MOVLB 0x1
0626  00A0     MOVWF haptic_in
138:                       haptic_in[1] = display_output[1];
0627  30B0     MOVLW 0xB0
0628  0086     MOVWF FSR1L
0629  3021     MOVLW 0x21
062A  0087     MOVWF FSR1H
062B  3141     ADDFSR 1, 1
062C  0801     MOVF INDF1, W
062D  00FB     MOVWF 0xFB
062E  087B     MOVF 0xFB, W
062F  00A1     MOVWF 0xA1
139:                       haptic_in[2] = TESTB;
0630  0843     MOVF TESTB, W
0631  00FB     MOVWF 0xFB
0632  087B     MOVF 0xFB, W
0633  00A2     MOVWF 0xA2
140:                       haptic_in[3] = SSPCON1;
0634  0024     MOVLB 0x4
0635  0815     MOVF SSP1CON1, W
0636  00FB     MOVWF 0x27B
0637  087B     MOVF 0x27B, W
0638  0021     MOVLB 0x1
0639  00A3     MOVWF 0xA3
141:                       haptic_in[4] = SSPSTAT;
063A  0024     MOVLB 0x4
063B  0814     MOVF SSP1STAT, W
063C  00FB     MOVWF 0x27B
063D  087B     MOVF 0x27B, W
063E  0021     MOVLB 0x1
063F  00A4     MOVWF 0xA4
142:                       haptic_in[5] = display_output[63];
0640  30EF     MOVLW 0xEF
0641  0086     MOVWF FSR1L
0642  3021     MOVLW 0x21
0643  0087     MOVWF FSR1H
0644  0801     MOVF INDF1, W
0645  00FB     MOVWF 0xFB
0646  087B     MOVF 0xFB, W
0647  00A5     MOVWF 0xA5
143:           
144:                       //Hat switch
145:                       //haptic_in.val[2] = haptic_out.val[3];
146:           
147:                       //Analog sticks
148:                       
149:           
150:                       //Send the 8 byte packet over USB to the host.
151:                       last_HAP_IN = HIDTxPacket(HAPTIC_EP, (uint8_t*)&haptic_in, sizeof(haptic_in));
0648  01F0     CLRF 0xF0
0649  0AF0     INCF 0xF0, F
064A  30A0     MOVLW 0xA0
064B  00F1     MOVWF 0xF1
064C  3000     MOVLW 0x0
064D  00F2     MOVWF 0xF2
064E  3010     MOVLW 0x10
064F  00FB     MOVWF 0xFB
0650  087B     MOVF 0xFB, W
0651  00F3     MOVWF 0xF3
0652  3001     MOVLW 0x1
0653  3187     MOVLP 0x7
0654  2766     CALL 0x766
0655  3186     MOVLP 0x6
0656  0871     MOVF 0xF1, W
0657  0022     MOVLB 0x2
0658  00AE     MOVWF 0x12E
0659  0870     MOVF 0x170, W
065A  00AD     MOVWF last_HAP_IN
152:                   }
153:               }
154:               
155:               if(!HIDRxHandleBusy(last_HAP_OUT)){
065B  082B     MOVF last_HAP_OUT, W
065C  042C     IORWF 0x12C, W
065D  1903     BTFSC STATUS, 0x2
065E  2E60     GOTO 0x660
065F  2E61     GOTO 0x661
0660  2E69     GOTO 0x669
0661  082B     MOVF last_HAP_OUT, W
0662  0086     MOVWF FSR1L
0663  082C     MOVF 0x12C, W
0664  0087     MOVWF FSR1H
0665  1B81     BTFSC INDF1, 0x7
0666  2E68     GOTO 0x668
0667  2E69     GOTO 0x669
0668  2E7B     GOTO 0x67B
156:                   last_HAP_OUT = HIDRxPacket(HAPTIC_EP, (uint8_t*)&haptic_out, sizeof(haptic_out));
0669  01F0     CLRF 0x170
066A  3030     MOVLW 0x30
066B  00F1     MOVWF 0x171
066C  3001     MOVLW 0x1
066D  00F2     MOVWF 0x172
066E  3040     MOVLW 0x40
066F  00FB     MOVWF 0x17B
0670  087B     MOVF 0x17B, W
0671  00F3     MOVWF 0x173
0672  3001     MOVLW 0x1
0673  3187     MOVLP 0x7
0674  2766     CALL 0x766
0675  3186     MOVLP 0x6
0676  0871     MOVF 0x171, W
0677  0022     MOVLB 0x2
0678  00AC     MOVWF 0x12C
0679  0870     MOVF 0x170, W
067A  00AB     MOVWF last_HAP_OUT
157:               }
158:               if(!HIDRxHandleBusy(last_DSP_OUT)){
067B  0827     MOVF last_DSP_OUT, W
067C  0428     IORWF 0x128, W
067D  1903     BTFSC STATUS, 0x2
067E  2E80     GOTO 0x680
067F  2E81     GOTO 0x681
0680  2E89     GOTO 0x689
0681  0827     MOVF last_DSP_OUT, W
0682  0086     MOVWF FSR1L
0683  0828     MOVF 0x128, W
0684  0087     MOVWF FSR1H
0685  1B81     BTFSC INDF1, 0x7
0686  2E88     GOTO 0x688
0687  2E89     GOTO 0x689
0688  2E9B     GOTO 0x69B
159:                   last_DSP_OUT = HIDRxPacket(DISPLAY_EP, (uint8_t*)&display_output, sizeof(display_output));
0689  01F0     CLRF 0x170
068A  30B0     MOVLW 0xB0
068B  00F1     MOVWF 0x171
068C  3021     MOVLW 0x21
068D  00F2     MOVWF 0x172
068E  3040     MOVLW 0x40
068F  00FB     MOVWF 0x17B
0690  087B     MOVF 0x17B, W
0691  00F3     MOVWF 0x173
0692  3003     MOVLW 0x3
0693  3187     MOVLP 0x7
0694  2766     CALL 0x766
0695  3186     MOVLP 0x6
0696  0871     MOVF 0x171, W
0697  0022     MOVLB 0x2
0698  00A8     MOVWF 0x128
0699  0870     MOVF 0x170, W
069A  00A7     MOVWF last_DSP_OUT
160:               }
161:               if(!HIDRxHandleBusy(last_LED_OUT)){
069B  0829     MOVF last_LED_OUT, W
069C  042A     IORWF 0x12A, W
069D  1903     BTFSC STATUS, 0x2
069E  2EA0     GOTO 0x6A0
069F  2EA1     GOTO 0x6A1
06A0  2EA9     GOTO 0x6A9
06A1  0829     MOVF last_LED_OUT, W
06A2  0086     MOVWF FSR1L
06A3  082A     MOVF 0x12A, W
06A4  0087     MOVWF FSR1H
06A5  1B81     BTFSC INDF1, 0x7
06A6  2EA8     GOTO 0x6A8
06A7  2EA9     GOTO 0x6A9
06A8  2EBB     GOTO 0x6BB
162:                   /*if(leds_output.val[48] == 0x97)
163:                       LED_On(LED_D3);
164:                   else
165:                       LED_Off(LED_D3);*/
166:                   last_LED_OUT = HIDRxPacket(LEDS_EP, (uint8_t*)&leds_output, sizeof(leds_output));
06A9  01F0     CLRF 0x170
06AA  3030     MOVLW 0x30
06AB  00F1     MOVWF 0x171
06AC  3021     MOVLW 0x21
06AD  00F2     MOVWF 0x172
06AE  3031     MOVLW 0x31
06AF  00FB     MOVWF 0x17B
06B0  087B     MOVF 0x17B, W
06B1  00F3     MOVWF 0x173
06B2  3002     MOVLW 0x2
06B3  3187     MOVLP 0x7
06B4  2766     CALL 0x766
06B5  3186     MOVLP 0x6
06B6  0871     MOVF 0x171, W
06B7  0022     MOVLB 0x2
06B8  00AA     MOVWF 0x12A
06B9  0870     MOVF 0x170, W
06BA  00A9     MOVWF last_LED_OUT
167:               }
168:               
169:           }//end ProcessIO
06BB  0008     RETURN
170:           
171:           #endif
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memset.c  ---------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
5:             {
6:             	unsigned char *s = dest;
0537  0871     MOVF 0x171, W
0538  00FD     MOVWF 0x17D
0539  0870     MOVF 0x170, W
053A  00FC     MOVWF 0x17C
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
053B  0874     MOVF 0x174, W
053C  0475     IORWF 0x175, W
053D  1D03     BTFSS STATUS, 0x2
053E  2D40     GOTO 0x540
053F  2D41     GOTO 0x541
0540  2D42     GOTO 0x542
0541  2E00     GOTO 0x600
14:            	s[0] = (unsigned char)c;
0542  087C     MOVF 0x17C, W
0543  0086     MOVWF FSR1L
0544  087D     MOVF 0x17D, W
0545  0087     MOVWF FSR1H
0546  0872     MOVF 0x172, W
0547  0081     MOVWF INDF1
15:            	s[n-1] = (unsigned char)c;
0548  0874     MOVF 0x174, W
0549  077C     ADDWF 0x17C, W
054A  00F6     MOVWF 0x176
054B  0875     MOVF 0x175, W
054C  3D7D     ADDWFC 0x17D, W
054D  00F7     MOVWF 0x177
054E  0876     MOVF 0x176, W
054F  3EFF     ADDLW 0xFF
0550  00F8     MOVWF 0x178
0551  30FF     MOVLW 0xFF
0552  3D77     ADDWFC 0x177, W
0553  00F9     MOVWF 0x179
0554  0878     MOVF 0x178, W
0555  0086     MOVWF FSR1L
0556  0879     MOVF 0x179, W
0557  0087     MOVWF FSR1H
0558  0872     MOVF 0x172, W
0559  0081     MOVWF INDF1
16:            	if (n <= 2) return dest;
055A  3000     MOVLW 0x0
055B  0275     SUBWF 0x175, W
055C  3003     MOVLW 0x3
055D  1903     BTFSC STATUS, 0x2
055E  0274     SUBWF 0x174, W
055F  1803     BTFSC STATUS, 0x0
0560  2D62     GOTO 0x562
0561  2D63     GOTO 0x563
0562  2D64     GOTO 0x564
0563  2E00     GOTO 0x600
17:            	s[1] = (unsigned char)c;
0564  087C     MOVF 0x17C, W
0565  3E01     ADDLW 0x1
0566  00F6     MOVWF 0x176
0567  3000     MOVLW 0x0
0568  3D7D     ADDWFC 0x17D, W
0569  00F7     MOVWF 0x177
056A  0876     MOVF 0x176, W
056B  0086     MOVWF FSR1L
056C  0877     MOVF 0x177, W
056D  0087     MOVWF FSR1H
056E  0872     MOVF 0x172, W
056F  0081     MOVWF INDF1
18:            	s[2] = (unsigned char)c;
0570  087C     MOVF 0x17C, W
0571  3E02     ADDLW 0x2
0572  00F6     MOVWF 0x176
0573  3000     MOVLW 0x0
0574  3D7D     ADDWFC 0x17D, W
0575  00F7     MOVWF 0x177
0576  0876     MOVF 0x176, W
0577  0086     MOVWF FSR1L
0578  0877     MOVF 0x177, W
0579  0087     MOVWF FSR1H
057A  0872     MOVF 0x172, W
057B  0081     MOVWF INDF1
19:            	s[n-2] = (unsigned char)c;
057C  0874     MOVF 0x174, W
057D  077C     ADDWF 0x17C, W
057E  00F6     MOVWF 0x176
057F  0875     MOVF 0x175, W
0580  3D7D     ADDWFC 0x17D, W
0581  00F7     MOVWF 0x177
0582  0876     MOVF 0x176, W
0583  3EFE     ADDLW 0xFE
0584  00F8     MOVWF 0x178
0585  30FF     MOVLW 0xFF
0586  3D77     ADDWFC 0x177, W
0587  00F9     MOVWF 0x179
0588  0878     MOVF 0x178, W
0589  0086     MOVWF FSR1L
058A  0879     MOVF 0x179, W
058B  0087     MOVWF FSR1H
058C  0872     MOVF 0x172, W
058D  0081     MOVWF INDF1
20:            	s[n-3] = (unsigned char)c;
058E  0874     MOVF 0x174, W
058F  077C     ADDWF 0x17C, W
0590  00F6     MOVWF 0x176
0591  0875     MOVF 0x175, W
0592  3D7D     ADDWFC 0x17D, W
0593  00F7     MOVWF 0x177
0594  0876     MOVF 0x176, W
0595  3EFD     ADDLW 0xFD
0596  00F8     MOVWF 0x178
0597  30FF     MOVLW 0xFF
0598  3D77     ADDWFC 0x177, W
0599  00F9     MOVWF 0x179
059A  0878     MOVF 0x178, W
059B  0086     MOVWF FSR1L
059C  0879     MOVF 0x179, W
059D  0087     MOVWF FSR1H
059E  0872     MOVF 0x172, W
059F  0081     MOVWF INDF1
21:            	if (n <= 6) return dest;
05A0  3000     MOVLW 0x0
05A1  0275     SUBWF 0x175, W
05A2  3007     MOVLW 0x7
05A3  1903     BTFSC STATUS, 0x2
05A4  0274     SUBWF 0x174, W
05A5  1803     BTFSC STATUS, 0x0
05A6  2DA8     GOTO 0x5A8
05A7  2DA9     GOTO 0x5A9
05A8  2DAA     GOTO 0x5AA
05A9  2E00     GOTO 0x600
22:            	s[3] = (unsigned char)c;
05AA  087C     MOVF 0x17C, W
05AB  3E03     ADDLW 0x3
05AC  00F6     MOVWF 0x176
05AD  3000     MOVLW 0x0
05AE  3D7D     ADDWFC 0x17D, W
05AF  00F7     MOVWF 0x177
05B0  0876     MOVF 0x176, W
05B1  0086     MOVWF FSR1L
05B2  0877     MOVF 0x177, W
05B3  0087     MOVWF FSR1H
05B4  0872     MOVF 0x172, W
05B5  0081     MOVWF INDF1
23:            	s[n-4] = (unsigned char)c;
05B6  0874     MOVF 0x174, W
05B7  077C     ADDWF 0x17C, W
05B8  00F6     MOVWF 0x176
05B9  0875     MOVF 0x175, W
05BA  3D7D     ADDWFC 0x17D, W
05BB  00F7     MOVWF 0x177
05BC  0876     MOVF 0x176, W
05BD  3EFC     ADDLW 0xFC
05BE  00F8     MOVWF 0x178
05BF  30FF     MOVLW 0xFF
05C0  3D77     ADDWFC 0x177, W
05C1  00F9     MOVWF 0x179
05C2  0878     MOVF 0x178, W
05C3  0086     MOVWF FSR1L
05C4  0879     MOVF 0x179, W
05C5  0087     MOVWF FSR1H
05C6  0872     MOVF 0x172, W
05C7  0081     MOVWF INDF1
24:            	if (n <= 8) return dest;
05C8  3000     MOVLW 0x0
05C9  0275     SUBWF 0x175, W
05CA  3009     MOVLW 0x9
05CB  1903     BTFSC STATUS, 0x2
05CC  0274     SUBWF 0x174, W
05CD  1803     BTFSC STATUS, 0x0
05CE  2DD0     GOTO 0x5D0
05CF  2DD1     GOTO 0x5D1
05D0  2DD2     GOTO 0x5D2
05D1  2E00     GOTO 0x600
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
05D2  097C     COMF 0x17C, W
05D3  00F6     MOVWF 0x176
05D4  097D     COMF 0x17D, W
05D5  00F7     MOVWF 0x177
05D6  0AF6     INCF 0x176, F
05D7  1903     BTFSC STATUS, 0x2
05D8  0AF7     INCF 0x177, F
05D9  3003     MOVLW 0x3
05DA  0576     ANDWF 0x176, W
05DB  00FA     MOVWF 0x17A
05DC  3000     MOVLW 0x0
05DD  0577     ANDWF 0x177, W
05DE  00FB     MOVWF 0x17B
32:            	s += k;
05DF  087A     MOVF 0x17A, W
05E0  07FC     ADDWF 0x17C, F
05E1  087B     MOVF 0x17B, W
05E2  3DFD     ADDWFC 0x17D, F
33:            	n -= k;
05E3  087A     MOVF 0x17A, W
05E4  02F4     SUBWF 0x174, F
05E5  087B     MOVF 0x17B, W
05E6  3BF5     SUBWFB 0x175, F
34:            	n &= (size_t)-4;
05E7  30FC     MOVLW 0xFC
05E8  05F4     ANDWF 0x174, F
05E9  30FF     MOVLW 0xFF
05EA  05F5     ANDWF 0x175, F
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = (unsigned char)c;
05EB  2DFA     GOTO 0x5FA
05EC  087C     MOVF 0x17C, W
05ED  0086     MOVWF FSR1L
05EE  087D     MOVF 0x17D, W
05EF  0087     MOVWF FSR1H
05F0  0872     MOVF 0x172, W
05F1  0081     MOVWF INDF1
05F2  3001     MOVLW 0x1
05F3  02F4     SUBWF 0x174, F
05F4  3000     MOVLW 0x0
05F5  3BF5     SUBWFB 0x175, F
05F6  3001     MOVLW 0x1
05F7  07FC     ADDWF 0x17C, F
05F8  3000     MOVLW 0x0
05F9  3DFD     ADDWFC 0x17D, F
05FA  0874     MOVF 0x174, W
05FB  0475     IORWF 0x175, W
05FC  1D03     BTFSS STATUS, 0x2
05FD  2DFF     GOTO 0x5FF
05FE  2E00     GOTO 0x600
05FF  2DEC     GOTO 0x5EC
87:            #endif
88:            
89:            	return dest;
90:            }
0600  0008     RETURN
---  E:/Atmel Studio/Comp-istall/pic/sources/c99/common/memcpy.c  ---------------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
08EA  00F8     MOVWF 0x178
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
08EB  0871     MOVF 0x171, W
08EC  00F6     MOVWF 0x176
08ED  0870     MOVF 0x170, W
08EE  00F5     MOVWF 0x175
12:            	d = d1;
08EF  0878     MOVF 0x178, W
08F0  00F4     MOVWF 0x174
08F1  0874     MOVF 0x174, W
08F2  00F9     MOVWF 0x179
13:            	while(n--) {
08F3  290B     GOTO 0x10B
090B  3001     MOVLW 0x1
090C  02F2     SUBWF 0x172, F
090D  3000     MOVLW 0x0
090E  3BF3     SUBWFB 0x173, F
090F  0A72     INCF 0x172, W
0910  1D03     BTFSS STATUS, 0x2
0911  2916     GOTO 0x116
0912  0A73     INCF 0x173, W
0913  1D03     BTFSS STATUS, 0x2
0914  2916     GOTO 0x116
0915  2917     GOTO 0x117
0916  28F4     GOTO 0xF4
14:            		tmp = *s++;
08F4  0875     MOVF 0x175, W
08F5  0086     MOVWF FSR1L
08F6  0876     MOVF 0x176, W
08F7  0087     MOVWF FSR1H
08F8  0801     MOVF INDF1, W
08F9  00F4     MOVWF 0x174
08FA  0874     MOVF 0x174, W
08FB  00F7     MOVWF 0x177
08FC  3001     MOVLW 0x1
08FD  07F5     ADDWF 0x175, F
08FE  3000     MOVLW 0x0
08FF  3DF6     ADDWFC 0x176, F
15:            		*d++ = tmp;
0900  0877     MOVF 0x177, W
0901  00F4     MOVWF 0x174
0902  0879     MOVF 0x179, W
0903  0086     MOVWF FSR1L
0904  0187     CLRF FSR1H
0905  0874     MOVF 0x174, W
0906  0081     MOVWF INDF1
0907  3001     MOVLW 0x1
0908  00F4     MOVWF 0x174
0909  0874     MOVF 0x174, W
090A  07F9     ADDWF 0x179, F
090B  3001     MOVLW 0x1
090C  02F2     SUBWF 0x172, F
090D  3000     MOVLW 0x0
090E  3BF3     SUBWFB 0x173, F
090F  0A72     INCF 0x172, W
0910  1D03     BTFSS STATUS, 0x2
0911  2916     GOTO 0x116
0912  0A73     INCF 0x173, W
0913  1D03     BTFSS STATUS, 0x2
0914  2916     GOTO 0x116
0915  2917     GOTO 0x117
0916  28F4     GOTO 0xF4
16:            	}
17:            	return d1;
18:            }
0917  0008     RETURN
19:            
---  C:/Users/Dutu/AppData/Local/Temp/xcAs12fg.s  -------------------------------------------------------
000A  3050     MOVLW 0x50
000B  0084     MOVWF FSR0L
000C  3097     MOVLW 0x97
000D  0085     MOVWF FSR0H
000E  0023     MOVLB 0x3
000F  0012     MOVIW FSR0++
0010  00B9     MOVWF __pdataBANK3
0011  0012     MOVIW FSR0++
0012  00BA     MOVWF 0x1BA
0013  0012     MOVIW FSR0++
0014  00BB     MOVWF 0x1BB
0015  0012     MOVIW FSR0++
0016  00BC     MOVWF 0x1BC
0017  0012     MOVIW FSR0++
0018  00BD     MOVWF 0x1BD
0019  0012     MOVIW FSR0++
001A  00BE     MOVWF 0x1BE
001B  0012     MOVIW FSR0++
001C  00BF     MOVWF 0x1BF
001D  0012     MOVIW FSR0++
001E  00C0     MOVWF 0x1C0
0802  0064     CLRWDT
0803  0180     CLRF INDF0
0804  3101     ADDFSR 0, 1
0805  3001     MOVLW 0x1
0806  02FE     SUBWF 0x1FE, F
0807  3000     MOVLW 0x0
0808  3BFF     SUBWFB 0x1FF, F
0809  087F     MOVF 0x1FF, W
080A  047E     IORWF 0x1FE, W
080B  1D03     BTFSS STATUS, 0x2
080C  2803     GOTO 0x3
080D  3400     RETLW 0x0
001F  30B0     MOVLW 0xB0
0020  0084     MOVWF FSR0L
0021  3000     MOVLW 0x0
0022  0085     MOVWF FSR0H
0023  3028     MOVLW 0x28
0024  00FE     MOVWF 0x1FE
0025  3000     MOVLW 0x0
0026  00FF     MOVWF 0x1FF
0027  3188     MOVLP 0x8
002A  3020     MOVLW 0x20
002B  0084     MOVWF FSR0L
002C  3001     MOVLW 0x1
002D  0085     MOVWF FSR0H
002E  300F     MOVLW 0xF
002F  00FE     MOVWF 0x1FE
0030  3000     MOVLW 0x0
0031  00FF     MOVWF 0x1FF
0032  3188     MOVLP 0x8
0035  30A0     MOVLW 0xA0
0036  0084     MOVWF FSR0L
0037  3001     MOVLW 0x1
0038  0085     MOVWF FSR0H
0039  3019     MOVLW 0x19
003A  00FE     MOVWF 0x1FE
003B  3000     MOVLW 0x0
003C  00FF     MOVWF 0x1FF
003D  3188     MOVLP 0x8
0040  107E     BCF 0x1FE, 0x0
0041  0020     MOVLB 0x0
0042  3189     MOVLP 0x9
